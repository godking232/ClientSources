// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////


#include "Game.h"

#if DEF_LANGUAGE == 1
#include "lan_tai.h"
#elif DEF_LANGUAGE == 2
#include "lan_chi.h"
#elif DEF_LANGUAGE == 3
#include "lan_kor.h"
#elif DEF_LANGUAGE == 4
#include "lan_eng.h"
#elif DEF_LANGUAGE == 5
#include "lan_jap.h"
#endif

#ifdef DEF_HTMLCOMMOM
	#include "GlobalVal.h"
#endif

#ifdef DEF_COLOR	//	mando 030125	색상 테스트 부분.
	#include "GlobalVal.h"
#endif


#if DEF_LANGUAGE == 3
extern unsigned __stdcall ThreadProc(void *ch); 
#endif
   
extern char G_cSpriteAlphaDegree;

extern char G_cCmdLine[256], G_cCmdLineTokenA[120], G_cCmdLineTokenA_Lowercase[120], G_cCmdLineTokenB[120], G_cCmdLineTokenC[120], G_cCmdLineTokenD[120], G_cCmdLineTokenE[120];
extern class XSocket * G_pCalcSocket;
extern BOOL G_bIsCalcSocketConnected;
extern DWORD G_dwCalcSocketTime, G_dwCalcSocketSendTime;
extern HWND	G_hWnd, G_hEditWnd;

#ifdef DEF_HTMLCOMMOM	//	Html 다이얼로그 부분..
	extern HWND G_hInternetWnd;

	//	다이얼로그 커서.. (m_d;) 020909..
	POINT G_point;
	//POINT G_Oldpoint;
	//class CGame * G_pGame2;

	//	다이얼로그 생성&소멸..
	extern BOOL G_bDlg1;
	RECT G_rDlg1Rc;

#endif

extern HINSTANCE G_hInstance;

char _cDrawingOrder[]            = {0, 1, 0, 0, 0, 0, 0, 1, 1};
char _cMantleDrawingOrder[]      = {0, 1, 1, 1, 0, 0, 0, 2, 2};
char _cMantleDrawingOrderOnRun[] = {0, 1, 1, 1, 1, 1, 1, 1, 1};


// 속도저하를 방지하지 위한 부득이한 전역변수 
short _tmp_sOwnerType, _tmp_sAppr1, _tmp_sAppr2, _tmp_sAppr3, _tmp_sAppr4;//, _tmp_sStatus;
//CInt _tmp_sStatus;
short _tmp_sStatus;
char  _tmp_cAction, _tmp_cDir, _tmp_cFrame, _tmp_cName[12]; 
int   _tmp_iChatIndex, _tmp_dx, _tmp_dy, _tmp_iApprColor, _tmp_iEffectType, _tmp_iEffectFrame, _tmp_dX, _tmp_dY; // 21.171 2002-6-14
WORD  _tmp_wObjectID;
char cDynamicObjectData1, cDynamicObjectData2, cDynamicObjectData3, cDynamicObjectData4;
WORD  wFocusObjectID; 
short sFocus_dX, sFocus_dY;
char  cFocusAction, cFocusFrame, cFocusDir, cFocusName[12];
short sFocusX, sFocusY, sFocusOwnerType, sFocusAppr1, sFocusAppr2, sFocusAppr3, sFocusAppr4, sFocusStatus;
int   iFocusApprColor;


//////////////////////////////////////////////////////////////////////
// 웹 다이얼 로그 추가.. 20021207..
//////////////////////////////////////////////////////////////////////

#ifdef DEF_HTMLCOMMOM
	//	mando	020904..(HTML VIEW?)
	// Mesage handler for about box.
	LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
	{
	   HANDLE pthis =  GetProp( hDlg, THIS_PROP );

	   if ( !pthis )
	   {
		  if ( message != WM_INITDIALOG )
			 return FALSE;

		  pthis =(PHANDLE) lParam;

		  SetProp( hDlg, THIS_PROP, (HANDLE) pthis );
	   }

	   BOOL fResult = AboutDlgProc( hDlg, message, wParam, lParam );

	   if ( message == WM_DESTROY )
		  RemoveProp( hDlg, THIS_PROP );

	   return fResult;
	}

	BOOL AboutDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
	{
		//	포인터 가두기^^; (m_d)
	//	POINT m_OldDrawDataGripPnt;
	//	RECT rc;
	//	short msX, msY, msZ, sX, sY;
	//	char cLB, cRB;

		//	스킨 입히기.. (m_d;)
		HBITMAP hBtnBit;

	//	URL 얻어오기..
	//	char	cBuf[1024];
	//	HANDLE	hFile;
	//	DWORD	dwRead;

	//	HDC m_BitDC;
		HDC m_DlgDC;
		PAINTSTRUCT ps;
		HDC MemDC;
		HBITMAP Dialog, OldDialog;
		BITMAP bit;

	//	POINT pPoint;
		

		//	웹다이얼로그 부분..
		char cUrl[1000];
		char *cwdSN;
		cwdSN = G_cWorldServerName;
		cwdSN+=2;

		int	_iwdID = atoi(cwdSN);
	//	char *_cwdID = G_cWorldServerName;

		//	이름 CGI EnCoder부분..
		char	_cURLName[320];
		char	_pcCode[6];
		char	_cPlayerNameOneC[2];
	//	_cPlayerName = G_cPlayerName;
		int		i = 0;
		int		iname = 0;
		int		_iEnCode=0;
		

		switch ( uMsg )
		{
		case WM_INITDIALOG:
			
			//	스킨 초기화..
			hBtnBit = LoadBitmap(G_hInstance,MAKEINTRESOURCE(IDB_BIT_OKBN));
			SendDlgItemMessage(hdlg,IDOK,BM_SETIMAGE,(WPARAM)IMAGE_BITMAP,(LPARAM)hBtnBit);

	/////////////////////////////////
	//		//	가두기 초기화^^; (m_d)
	//		G_Oldpoint.x = 320;
	//		G_Oldpoint.y = 240;
	//		SetCursorPos(G_Oldpoint.x, G_Oldpoint.y);

			//	다이얼 로그 박스 렉트값얻어오기.. 
			GetClientRect(hdlg,&G_rDlg1Rc);

			//	생성시 보여주게될 웹페이지.. (m_d;)
	//		hFile =  CreateFile("URL.txt",GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	//		if(hFile != INVALID_HANDLE_VALUE)
	//		{
	//			memset(cBuf,0,1024);
	//			ReadFile(hFile,cBuf,1024,&dwRead,NULL);
	//			CloseHandle(hFile);
	//		}

	//		char	*cPlayerName = G_cPlayerName;

			memset(&_cURLName,0,320);
			
			while(G_cPlayerName[i])
			{
				//	문자열 하나씩 빼와서 처리..
				memset(&_cPlayerNameOneC,0,2);
				memcpy(&_cPlayerNameOneC ,&G_cPlayerName[i],1);

				//	'%'를 붙여서 10진수로 변환..
				memset(_pcCode,0,sizeof(_pcCode));
				sprintf(_pcCode,"%%%d",(int *)_cPlayerNameOneC[0]);
				

				//	URL문장에 저장..
				strcpy(_cURLName + iname, _pcCode);
				iname += strlen(_pcCode);

				i++;
			}

	//====================================================================
	//		URL Decoding
	//====================================================================
	//		char	*value;
	//		int		value_len;
	//		char	xdigit[2];
	//
	//
	//		int i = 0;
	//		for(int j=0; j < value_len ; j++)
	//		{
	//			switch(value[i])
	//			{
	//			//	공백..
	//			case '+':
	//				value[i] = 0;
	//				break;
	//
	//			//	특수문자..
	//			case '%':
	//				xdigit[0] = value[j+1];
	//				xdigit[1] = value[j+1];
	//				value[i] = (char) strtol(xdigit, (char**) NULL, 16);
	//				j += 2;
	//				break;
	//
	//			//	일반문자..
	//			default:
	//				value[i] = value[j];
	//				break;
	//			}
	//			i++;
	//		}


			memset(cUrl,0,sizeof(cUrl));
//	엔코딩부분 빼달래서..
//			wsprintf( cUrl, "211.144.8.53/login.asp?WorldID=%d&PlayerLevel=%d&PlayerName=%s&MapName=%s",
//					_iwdID, G_iLevel, _cURLName, G_cMapName );
			wsprintf( cUrl, "211.144.8.53/login.asp?WorldID=%d&PlayerLevel=%d&PlayerName=%s&MapName=%s",
					_iwdID, G_iLevel, G_cPlayerName, G_cMapName );
			
	//		wsprintf( cUrl, "www.empas.com",G_cMapName);

	//		SetDlgItemText( hdlg, IDC_WEBCTRL, cBuf );
	//		SetDlgItemText( hdlg, IDC_WEBCTRL, "http://www.fantasymasters.co.kr" );

			SetDlgItemText( hdlg, IDC_WEBCTRL, cUrl );
			
			FORWARD_WM_NEXTDLGCTL( hdlg, GetDlgItem( hdlg, IDOK ), 1, PostMessage );
			
			break;

		case WM_PAINT:
			m_DlgDC = BeginPaint(hdlg ,&ps);
			MemDC = ::CreateCompatibleDC(m_DlgDC);
			Dialog = LoadBitmap(G_hInstance,MAKEINTRESOURCE(IDB_BIT_DLG));
			OldDialog = (HBITMAP)SelectObject(MemDC,Dialog);

			::GetObject(Dialog,sizeof(BITMAP),&bit );

			BitBlt(m_DlgDC,0,0,bit.bmWidth,bit.bmHeight,MemDC,0,0,SRCCOPY);

			SelectObject(MemDC,OldDialog);
			DeleteObject(Dialog);
			DeleteDC(MemDC);
			EndPaint(hdlg,&ps);

			break;

		case WM_SETFOCUS:
			SetFocus(hdlg);
			break;

		case WM_COMMAND:
			
			switch ( GET_WM_COMMAND_ID( wParam, lParam ) )
			{
			case IDOK:
			case IDCANCEL:

	//			::GetCursorPos(&pPoint);
				G_bDlg1 = FALSE;
				EndDialog( hdlg, 0 );
	//			::SetFocus(G_hWnd);
	///			::SetCursorPos(pPoint.x, pPoint.y);
	//			::SetCursorPos(10, 10);

				
				break;
				
			default:
				
				return FALSE;
			}
			
			break;
			
			default:
				
				return FALSE;
		}
		
		return TRUE;
	}

	//============================================================================
	//	웹 다이얼 로그창을 띄운다..mando 021031
	void CGame::WebDialog()
	{
		G_bDlg1 = TRUE;	//	다이얼로그 박스가 생성되었다..
		G_hInternetWnd = CreateDialog( G_hInstance, MAKEINTRESOURCE(IDD_COMMON), G_hWnd, (DLGPROC) AboutDlgProc );		
 		SetFocus(G_hInternetWnd);
		ShowWindow( G_hInternetWnd, SW_SHOWNORMAL );
	}
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

void CGame::ReadSettings()
{
	m_sMagicShortCut = -1;
	m_sRecentShortCut = -1;
	for( int i=0 ; i<5 ; i++ ) m_sShortCut[i] = -1;

	HKEY key;
	DWORD dwDisp;
	UINT Result;
	DWORD Size = sizeof(LONG);
	if( RegCreateKeyEx( HKEY_CURRENT_USER, "Software\\Siementech\\Helbreath\\Settings", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &key, &dwDisp ) != ERROR_SUCCESS ) return;

	if( RegQueryValueEx(key, "Magic", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 101 ) m_sMagicShortCut = Result - 1;
	else m_sMagicShortCut = -1;

	if( RegQueryValueEx(key, "ShortCut0", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[0] = Result - 1;
	else m_sShortCut[0] = -1;

	if( RegQueryValueEx(key, "ShortCut1", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[1] = Result - 1;
	else m_sShortCut[1] = -1;

	if( RegQueryValueEx(key, "ShortCut2", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[2] = Result - 1;
	else m_sShortCut[2] = -1;

	if( RegQueryValueEx(key, "ShortCut3", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[3] = Result - 1;
	else m_sShortCut[3] = -1;

	if( RegQueryValueEx(key, "ShortCut4", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[4] = Result - 1;
	else m_sShortCut[4] = -1;

	RegCloseKey(key);
}

void CGame::WriteSettings()
{
	HKEY key;
	DWORD dwDisp;
	UINT nData;
	if( RegCreateKeyEx( HKEY_CURRENT_USER, "Software\\Siementech\\Helbreath\\Settings", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &key, &dwDisp ) != ERROR_SUCCESS ) return;

	if( m_sMagicShortCut >= 0 && m_sMagicShortCut < 100 ) nData = m_sMagicShortCut + 1;
	else nData = 0;
	if( RegSetValueEx(key, "Magic", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}

	if( m_sShortCut[0] >= 0 && m_sShortCut[0] < 200 ) nData = m_sShortCut[0] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut0", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}

	if( m_sShortCut[1] >= 0 && m_sShortCut[1] < 200 ) nData = m_sShortCut[1] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut1", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}

	if( m_sShortCut[2] >= 0 && m_sShortCut[2] < 200 ) nData = m_sShortCut[2] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut2", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}

	if( m_sShortCut[3] >= 0 && m_sShortCut[3] < 200 ) nData = m_sShortCut[3] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut3", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}

	if( m_sShortCut[4] >= 0 && m_sShortCut[4] < 200 ) nData = m_sShortCut[4] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut4", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{
		RegCloseKey(key);
		return;
	}
	RegCloseKey(key);
}

CGame::CGame()
{
	int i;	
	srand( (unsigned)time( NULL ) );
	ReadSettings();

#ifdef _DEBUG
	m_bToggleScreen = TRUE;
#else
	m_bToggleScreen = FALSE;
#endif
	m_bShowFPS = FALSE;
	m_cDetailLevel = 2;
	m_cLoading = 0;
	m_bZoomMap = TRUE;
	m_bIsFirstConn = TRUE;

	// 2002. 10. 29 정진광 아이템 버리기..
	m_iItemDropCnt = 0;
	m_bItemDrop = FALSE; 

	m_bIsSpecial = FALSE;

	m_cGameMode = DEF_GAMEMODE_ONLOADING;
	m_cWhisperIndex = DEF_MAXWHISPERMSG;
	m_cGameModeCount = 0;

	ZeroMemory(m_cMapName, sizeof(m_cMapName));

	m_pGSock   = NULL;
	m_pLSock   = NULL;
	m_pMapData = NULL;

	m_cCommandCount  = 0;
	m_dwCommandTime = 0; //v2.15 SpeedHack 방지용

	//2003.06.09 정진광 진정피드백용 변수.
	m_iFeedBackCardIndex = -1;

	m_sPlayerX = NULL;
	m_sPlayerY = NULL;
	
	m_sViewDX  = NULL;
	m_sViewDY  = NULL;

	m_cCommand = DEF_OBJECTSTOP;
	m_bIsObserverMode = FALSE;

	for (i = 0; i < DEF_MAXSPRITES; i++) m_pSprite[i] = NULL;
	for (i = 0; i < DEF_MAXTILES; i++) m_pTileSpr[i] = NULL;
	for (i = 0; i < DEF_MAXEFFECTSPR; i++) m_pEffectSpr[i] = NULL;

	m_pBGM = NULL;
	for (i = 0; i < DEF_MAXSOUNDEFFECTS; i++) {
		m_pCSound[i]  = NULL;
		m_pESound[i]  = NULL;
		m_pMSound[i]  = NULL;
	}
	
	for (i = 0; i < DEF_MAXCHATMSGS; i++) m_pChatMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXEFFECTS; i++) m_pEffectList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMS; i++) m_pItemList[i] = NULL;

	for (i = 0; i < DEF_MAXBANKITEMS; i++) m_pBankList[i] = NULL;

	for (i = 0; i < 4; i++) m_pCharList[i] = NULL;
 
	for (i = 0; i < 41; i++) m_cDialogBoxOrder[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) m_pMagicCfgList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) m_pSkillCfgList[i] = NULL;
	
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		m_pMsgTextList[i] = NULL;
		m_pMsgTextList2[i] = NULL;
		m_pAgreeMsgTextList[i] = NULL;
	}

	// v1.41
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pBuildItemList[i] = NULL;

	// v1.41
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pDispBuildItemList[i] = NULL;

	// v1.42
	for (i = 0; i < DEF_MAXGAMEMSGS; i++) m_pGameMsgList[i] = NULL;

	m_pExID = NULL;

	for (i = 0; i < DEF_MAXITEMNAMES; i++) m_pItemNameList[i] = NULL;
	
	m_stMCursor.cPrevStatus       = DEF_CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = NULL;

	ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));

	for (i = 0; i < DEF_MAXMENUITEMS; i++)
		m_pItemForSaleList[i] = NULL;
 
	//Character-Info Dialog(F5)
	m_stDialogBoxInfo[1].sX = 30;
	m_stDialogBoxInfo[1].sY = 30;
	m_stDialogBoxInfo[1].sSizeX = 270;
	m_stDialogBoxInfo[1].sSizeY = 376;

	//Inventory Dialog(F6)
	m_stDialogBoxInfo[2].sX = 380;
	m_stDialogBoxInfo[2].sY = 210;
	m_stDialogBoxInfo[2].sSizeX = 225;
	m_stDialogBoxInfo[2].sSizeY = 185;

	//Magic Circle Dialog(F7)
	m_stDialogBoxInfo[3].sX = 337;
	m_stDialogBoxInfo[3].sY = 57;
	m_stDialogBoxInfo[3].sSizeX = 258;//280;
	m_stDialogBoxInfo[3].sSizeY = 328;//346;

	//정진광 아이템 버리기....
	m_stDialogBoxInfo[4].sX = 0;
	m_stDialogBoxInfo[4].sY = 0;
	m_stDialogBoxInfo[4].sSizeX = 270; 
	m_stDialogBoxInfo[4].sSizeY = 105;

//일시적으로 사용할 피드백 카드용 다이얼로그..일단 이런 식으로라도..
#ifdef DEF_FEEDBACKCARD
	//2003.06.09 정진광 추가. 중국 진정피드백
	m_stDialogBoxInfo[5].sX = 0;
	m_stDialogBoxInfo[5].sY = 0;
	m_stDialogBoxInfo[5].sSizeX = 320; 
	m_stDialogBoxInfo[5].sSizeY = 320;
#else
	//정진광. 15세 관련 메세지 박스
	m_stDialogBoxInfo[5].sX = 0;
	m_stDialogBoxInfo[5].sY = 0;
	m_stDialogBoxInfo[5].sSizeX = 310; 
	m_stDialogBoxInfo[5].sSizeY = 170;
#endif

	//정진광. 심의용 경고 메세지 박스
	m_stDialogBoxInfo[6].sX = 0;
	m_stDialogBoxInfo[6].sY = 0;
	m_stDialogBoxInfo[6].sSizeX = 310; 
	m_stDialogBoxInfo[6].sSizeY = 170;

	//Guild Menu Dialog
	m_stDialogBoxInfo[7].sX = 337;
	m_stDialogBoxInfo[7].sY = 57;
	m_stDialogBoxInfo[7].sSizeX = 258;
	m_stDialogBoxInfo[7].sSizeY = 339;

	//Guild Operation Dialog
	m_stDialogBoxInfo[8].sX = 337;
	m_stDialogBoxInfo[8].sY = 57;
	m_stDialogBoxInfo[8].sSizeX = 295;
	m_stDialogBoxInfo[8].sSizeY = 346;

	//Guide Map Dialog
	m_stDialogBoxInfo[9].sX = 512;
	m_stDialogBoxInfo[9].sY = 0;
	m_stDialogBoxInfo[9].sSizeX = 128;
	m_stDialogBoxInfo[9].sSizeY = 128; 

	//Chatting History Dialog(F9)
	m_stDialogBoxInfo[10].sX = 135; 
	m_stDialogBoxInfo[10].sY = 273;
	m_stDialogBoxInfo[10].sSizeX = 364;
	m_stDialogBoxInfo[10].sSizeY = 162;

	//Sale Menu Dialog
	m_stDialogBoxInfo[11].sX = 70;
	m_stDialogBoxInfo[11].sY = 50;
	m_stDialogBoxInfo[11].sSizeX = 258;
	m_stDialogBoxInfo[11].sSizeY = 339;

	//Level-Up Setting Dialog
	m_stDialogBoxInfo[12].sX = 0;
	m_stDialogBoxInfo[12].sY = 0;
	m_stDialogBoxInfo[12].sSizeX = 258;
	m_stDialogBoxInfo[12].sSizeY = 339;

	//City Hall Menu Dialog
	m_stDialogBoxInfo[13].sX = 337;
	m_stDialogBoxInfo[13].sY = 57;
	m_stDialogBoxInfo[13].sSizeX = 258;
	m_stDialogBoxInfo[13].sSizeY = 339;

	//Bank Dialog(창고)
	m_stDialogBoxInfo[14].sX = 60; //337
	m_stDialogBoxInfo[14].sY = 50;
	m_stDialogBoxInfo[14].sSizeX = 258;
	m_stDialogBoxInfo[14].sSizeY = 339;
	m_stDialogBoxInfo[14].sV1 = 13; //한화면에 보여지는 창고아이템의 수...현재13

	//Skill Menu(F8)
	m_stDialogBoxInfo[15].sX = 337;
	m_stDialogBoxInfo[15].sY = 57;
	m_stDialogBoxInfo[15].sSizeX = 258;
	m_stDialogBoxInfo[15].sSizeY = 339;

	//Magic Shop Menu
	m_stDialogBoxInfo[16].sX = 30;
	m_stDialogBoxInfo[16].sY = 30;
	m_stDialogBoxInfo[16].sSizeX = 304;
	m_stDialogBoxInfo[16].sSizeY = 328;

	//아이템 수량 묻는 Dialog
	m_stDialogBoxInfo[17].sX = 0;
	m_stDialogBoxInfo[17].sY = 0;
	m_stDialogBoxInfo[17].sSizeX = 215;
	m_stDialogBoxInfo[17].sSizeY = 87;

	//일반 Text Dialog
	m_stDialogBoxInfo[18].sX = 5;
	m_stDialogBoxInfo[18].sY = 65;
	m_stDialogBoxInfo[18].sSizeX = 258;
	m_stDialogBoxInfo[18].sSizeY = 339;

	//System Menu Dialog(F12)
	m_stDialogBoxInfo[19].sX = 337;
	m_stDialogBoxInfo[19].sY = 107;
	m_stDialogBoxInfo[19].sSizeX = 258;//270; //v2.18
	m_stDialogBoxInfo[19].sSizeY = 268;//346;

	//NpcActionQuery Dialog
	m_stDialogBoxInfo[20].sX = 237;
	m_stDialogBoxInfo[20].sY = 57;
	m_stDialogBoxInfo[20].sSizeX = 252;
	m_stDialogBoxInfo[20].sSizeY = 87;

	//NpcTalk Dialog
	m_stDialogBoxInfo[21].sX = 337;
	m_stDialogBoxInfo[21].sY = 57;
	m_stDialogBoxInfo[21].sSizeX = 258;
	m_stDialogBoxInfo[21].sSizeY = 339;

	//Map
	m_stDialogBoxInfo[22].sX = 336;
	m_stDialogBoxInfo[22].sY = 88;
	m_stDialogBoxInfo[22].sSizeX = 270;
	m_stDialogBoxInfo[22].sSizeY = 346;

	//ItemSellorRepair Dialog
	m_stDialogBoxInfo[23].sX = 337;
	m_stDialogBoxInfo[23].sY = 57;
	m_stDialogBoxInfo[23].sSizeX = 258;
	m_stDialogBoxInfo[23].sSizeY = 339;

	//Fishing Dialog
	m_stDialogBoxInfo[24].sX = 193;
	m_stDialogBoxInfo[24].sY = 241;
	m_stDialogBoxInfo[24].sSizeX = 263;
	m_stDialogBoxInfo[24].sSizeY = 100;

	//Noticement Dialog
	m_stDialogBoxInfo[25].sX = 162;
	m_stDialogBoxInfo[25].sY = 40;
	m_stDialogBoxInfo[25].sSizeX = 315;
	m_stDialogBoxInfo[25].sSizeY = 171;

	//Manufacture Dialog
	m_stDialogBoxInfo[26].sX = 100;
	m_stDialogBoxInfo[26].sY = 60;
	m_stDialogBoxInfo[26].sSizeX = 258; 
	m_stDialogBoxInfo[26].sSizeY = 339;
 
	//Exchange Dialog
	m_stDialogBoxInfo[27].sX = 100; 
	m_stDialogBoxInfo[27].sY = 30;
	m_stDialogBoxInfo[27].sSizeX = 520;
	m_stDialogBoxInfo[27].sSizeY = 357;

	//Quest Dialog
	m_stDialogBoxInfo[28].sX = 0;  
	m_stDialogBoxInfo[28].sY = 0;
	m_stDialogBoxInfo[28].sSizeX = 258;
	m_stDialogBoxInfo[28].sSizeY = 339;

	//Gauge Pannel
	m_stDialogBoxInfo[29].sX = 0;
	m_stDialogBoxInfo[29].sY = 434;
	m_stDialogBoxInfo[29].sSizeX = 157;
	m_stDialogBoxInfo[29].sSizeY = 53;

	//Icon Pannel
	m_stDialogBoxInfo[30].sX = 0;
	m_stDialogBoxInfo[30].sY = 427;
	m_stDialogBoxInfo[30].sSizeX = 640;
	m_stDialogBoxInfo[30].sSizeY = 53;//47;

	//Sell List Dialog
	m_stDialogBoxInfo[31].sX = 170;
	m_stDialogBoxInfo[31].sY = 70;
	m_stDialogBoxInfo[31].sSizeX = 258;
	m_stDialogBoxInfo[31].sSizeY = 339; 

	//Party Dialog
	m_stDialogBoxInfo[32].sX = 0;
	m_stDialogBoxInfo[32].sY = 0;
	m_stDialogBoxInfo[32].sSizeX = 258;
	m_stDialogBoxInfo[32].sSizeY = 339;

	//Crusade Job Dialog
	m_stDialogBoxInfo[33].sX = 360;
	m_stDialogBoxInfo[33].sY = 65;
	m_stDialogBoxInfo[33].sSizeX = 258;
	m_stDialogBoxInfo[33].sSizeY = 339;

	//Item Upgrade Dialog
	m_stDialogBoxInfo[34].sX = 60;
	m_stDialogBoxInfo[34].sY = 50;
	m_stDialogBoxInfo[34].sSizeX = 258;
	m_stDialogBoxInfo[34].sSizeY = 339;

	//Help Menu Dialog(F1)
	m_stDialogBoxInfo[35].sX = 358;
	m_stDialogBoxInfo[35].sY = 65;
	m_stDialogBoxInfo[35].sSizeX = 258;
	m_stDialogBoxInfo[35].sSizeY = 339;

	//Crusade Commander Dialog
	m_stDialogBoxInfo[36].sX = 20;
	m_stDialogBoxInfo[36].sY = 20;
	m_stDialogBoxInfo[36].sSizeX = 310;
	m_stDialogBoxInfo[36].sSizeY = 386;

	//Crusade Constructor Dialog
	m_stDialogBoxInfo[37].sX = 20;
	m_stDialogBoxInfo[37].sY = 20;
	m_stDialogBoxInfo[37].sSizeX = 310;
	m_stDialogBoxInfo[37].sSizeY = 386;
 
	//Crusade Soldier Dialog
	m_stDialogBoxInfo[38].sX = 20;
	m_stDialogBoxInfo[38].sY = 20;
	m_stDialogBoxInfo[38].sSizeX = 310; 
	m_stDialogBoxInfo[38].sSizeY = 386;

	//상하.....창고 자동보관 인터페이스용
	m_stDialogBoxInfo[39].sX = 0;
	m_stDialogBoxInfo[39].sY = 0;
	m_stDialogBoxInfo[39].sSizeX = 291; 
	m_stDialogBoxInfo[39].sSizeY = 413;

	m_bCtrlPressed  = FALSE;
	m_bShiftPressed = FALSE;
	m_bEnterPressed = FALSE;
	m_bEscPressed	= FALSE;

	m_bSoundFlag = FALSE;
	m_dwDialogCloseTime = 0;

	m_iTimeLeftSecAccount = NULL;
	m_iTimeLeftSecIP      = NULL;

	//2002.10.19 정진광. 귓속말과 외치기 변수.
	// 이 값이 TRUE 이면, 들을 수 있는 상태.
	m_bWhisper = TRUE;
	m_bShout   = TRUE;
}
 

CGame::~CGame()
{


}

// 클라이언트 초기화
BOOL CGame::bInit(HWND hWnd, HINSTANCE hInst, char * pCmdLine)
{
 int iIndex;
 class CStrTok * pStrTok;
 char seps[] = "&= ,\t\n";
 char * token;

	// !!! 미디어 웹 파라미터때문에 이런 방식으로 커맨드 라인을 얻어와야 한다. 원래 CmdLine에는 없는 문자열이 있다.
	//pCmdLine = GetCommandLine();
	
	if (pCmdLine != NULL) {
		ZeroMemory(G_cCmdLine, sizeof(G_cCmdLine));
		ZeroMemory(G_cCmdLineTokenA, sizeof(G_cCmdLineTokenA));
		ZeroMemory(G_cCmdLineTokenB, sizeof(G_cCmdLineTokenB));
		ZeroMemory(G_cCmdLineTokenC, sizeof(G_cCmdLineTokenC));
		ZeroMemory(G_cCmdLineTokenD, sizeof(G_cCmdLineTokenD));
		ZeroMemory(G_cCmdLineTokenE, sizeof(G_cCmdLineTokenE));
		
		strcpy(G_cCmdLine, pCmdLine);

		iIndex = 0;
		pStrTok = new class CStrTok(pCmdLine, seps);
		token = pStrTok->pGet(); 
		while( token != NULL ) {
			switch (iIndex) {
			case 0:	strcpy(G_cCmdLineTokenA, token); break;
			case 1: strcpy(G_cCmdLineTokenB, token); break;
			case 2: strcpy(G_cCmdLineTokenC, token); break;
			case 3: strcpy(G_cCmdLineTokenD, token); break;
			case 4: strcpy(G_cCmdLineTokenE, token); break;
			}
			
			token = pStrTok->pGet();
			iIndex++;
		}	
		delete pStrTok;
	}

	ZeroMemory(G_cCmdLineTokenA_Lowercase, sizeof(G_cCmdLineTokenA_Lowercase));
	strcpy(G_cCmdLineTokenA_Lowercase, G_cCmdLineTokenA);
	_strlwr(G_cCmdLineTokenA_Lowercase);

	// v2.03 한미르 과금 
	if (memcmp(G_cCmdLineTokenA_Lowercase, "/egparam", 8) == 0) {
		ZeroMemory(G_cCmdLineTokenA, sizeof(G_cCmdLineTokenA));
		memcpy(G_cCmdLineTokenA,"dataq",5);
	}

	m_hWnd = hWnd;
	m_bCommandAvailable = TRUE;
	m_pCGameMonitor = NULL;

	// Connect 시간체크를 위해 타임값 기록 
	m_dwTime = G_dwGlobalTime;

	m_bSoundFlag = m_DSound.Create(m_hWnd);
	m_bMusicStat = m_bSoundStat = m_bSoundFlag;
	m_bIsHideLocalCursor = FALSE;

	m_cEnterCheck = m_cTabCheck = m_cLeftArrowCheck = NULL;
	
	if (bCheckImportantFile() == FALSE) {
		MessageBox(m_hWnd, "File checksum error! Get Update again please!", "ERROR1", MB_ICONEXCLAMATION | MB_OK);
		return FALSE;	
	}

	if (_bDecodeBuildItemContents() == FALSE) {
		MessageBox(m_hWnd, "File checksum error! Get Update again please!","ERROR2",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;	
	}

	if(bReadLoginConfigFile("login.cfg") == FALSE) {
		MessageBox(m_hWnd, "login.cfg file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}

	if(bReadItemNameConfigFile() == FALSE) {
		MessageBox(m_hWnd, "ItemName.cfg file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}
	
	// 마법이름 리스트를 초기화한다.
	if (bInitMagicCfgList() == FALSE) {
		MessageBox(m_hWnd, "MAGICCFG.TXT file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;	
	}
	// Skill이름 리스트를 초기화한다.
	if (bInitSkillCfgList() == FALSE) {
		MessageBox(m_hWnd, "SKILLCFG.TXT file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;	
	}

	if (m_DDraw.bInit(m_hWnd) == FALSE) {
		MessageBox(m_hWnd, "This program requires DirectX7.0a!","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}

	if (m_DInput.bInit(hWnd, hInst) == FALSE) {
		MessageBox(m_hWnd, "This program requires DirectX7.0a!","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}
	
	// @@@@
	// 초기화면 구성을 위해 필요한 스프라이트를 로딩한다.
	// 마우스 커서
    
	
	//정진광 수정..새로 만든 CSprite constructor 를 사용하기 위해...
	// 다이알로그박스 
	m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
	m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 0, FALSE);
	CloseHandle(m_hPakFile);

	//m_hPakFile = CreateFile("sprites\\interface2.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
	m_hPakFile = CreateFile("sprites\\interface2.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 0, FALSE);
	CloseHandle(m_hPakFile);
	//정진광 수정, 여기까지...

	// 마우스 커서 이미지 저장용 서페이스 
	m_stMCursor.sX = 0;
	m_stMCursor.sY = 0;

	// 맵데이터 구조를 생성한다. 초기데이터가 도착하면 해당 맵을 오픈한다. 
	m_pMapData = new class CMapData(this);
	
	ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
	ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
	ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));

#ifdef DEF_ACCOUNTLONG  //2002.09.24 for Terra
	ZeroMemory(m_cAccountLong, sizeof(m_cAccountLong));
#endif

	m_sPlayerType = 2;
	m_cPlayerTurn = 0;

	// 항상 활성화 되어있는 다이얼로그 박스 아이디 30번(아이콘 판넬)
	m_cDialogBoxOrder[40] = 29;
	m_cDialogBoxOrder[39] = 30; // 29번 GaugePannel

	m_cMenuDir    = 4;
	m_cMenuDirCnt = 0;
	m_cMenuFrame  = 0;

	m_cSoundVolume = 100;
	m_cMusicVolume = 100;

	// 무기류용 색상 세트 
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 70, 70, 80),  &m_wWR[1], &m_wWG[1], &m_wWB[1]); // Light-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 70, 70, 80),  &m_wWR[2], &m_wWG[2], &m_wWB[2]); // light-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 70, 70, 80),  &m_wWR[3], &m_wWG[3], &m_wWB[3]); // light-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 70, 100, 70), &m_wWR[4], &m_wWG[4], &m_wWB[4]); // Green 
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 130, 90, 10), &m_wWR[5], &m_wWG[5], &m_wWB[5]); // ?
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 42, 53, 111), &m_wWR[6], &m_wWG[6], &m_wWB[6]); // Heavy-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 145, 145, 145), &m_wWR[7], &m_wWG[7], &m_wWB[7]); // White
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 120, 100, 120), &m_wWR[8], &m_wWG[8], &m_wWB[8]); // Violet
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(75, 10, 10), &m_wWR[9], &m_wWG[9], &m_wWB[9]);   // Heavy-Red
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(135, 104, 30),  &m_wR[10], &m_wG[10], &m_wB[10]);	// Gold   

	// 옷, 갑옷용 색상 세트 
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 200/2,  200/2,  200/2),  &m_wR[0], &m_wG[0], &m_wB[0]);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x50/2, 0x50/2, 0xC0/2),  &m_wR[1], &m_wG[1], &m_wB[1]);	// Blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(79, 79, 62),  &m_wR[2], &m_wG[2], &m_wB[2]);				// Custom-Weapon Color
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(135, 104, 30),  &m_wR[3], &m_wG[3], &m_wB[3]);				// Gold  
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(255/2, 36/2, 0),  &m_wR[4], &m_wG[4], &m_wB[4]);			// Orange 
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(10, 60, 10),  &m_wR[5], &m_wG[5], &m_wB[5]);				// Green
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x50/2, 0x50/2, 0x50/2),  &m_wR[6], &m_wG[6], &m_wB[6]);	// Gray
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x5F/2, 0x9E/2, 0xA0/2),  &m_wR[7], &m_wG[7], &m_wB[7]);	// 
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xFF/2, 0x69/2, 0xB4/2),  &m_wR[8], &m_wG[8], &m_wB[8]);	// 
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(90, 60, 90),  &m_wR[9], &m_wG[9], &m_wB[9]);				// Violet
	
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0, 35, 60),  &m_wR[10], &m_wG[10], &m_wB[10]);				 // 
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xD2/2, 0xB4/2, 0x8C/2),  &m_wR[11], &m_wG[11], &m_wB[11]); // Tan
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xBD/2, 0xB7/2, 0x6B/2),  &m_wR[12], &m_wG[12], &m_wB[12]); // Khaki 
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(85, 85, 8), &m_wR[13], &m_wG[13], &m_wB[13]);				 // Yellow
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(75, 10, 10), &m_wR[14], &m_wG[14], &m_wB[14]);				 // Red
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x30, 0x30, 0x30), &m_wR[15], &m_wG[15], &m_wB[15]);		 // Black
	
	m_pCGameMonitor = new class CGameMonitor;
	
	// 자동 업데이트시에 계속 받게 된다. 수정 요망 
	//===============================================
	// badword.txt 보안보강.. mando..021025
	if(!m_Misc._iConvertFileXor("contents\\badword.txt", "contents\\badword.tmp", 35))
	{
		MessageBox(m_hWnd, "BADWORD.TXT file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}
	m_pCGameMonitor->iReadBadWordFileList("contents\\badword.tmp");
	DeleteFile("contents\\badword.tmp");

#if DEF_LANGUAGE > 2
	if(!m_Misc._iConvertFileXor("contents\\Curse.txt", "contents\\Curse.tmp", 35))
	{
		MessageBox(m_hWnd, "CURSE.TXT file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}
	m_curse.LoadCurse( "contents\\Curse.tmp" );
	DeleteFile("contents\\Curse.tmp");
#endif
	//==============================================mando..

	_LoadGameMsgTextContents();

	// 월드 서버 이름 
	ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));

	return TRUE;
}

// 종료 처리
void CGame::Quit()
{
 int i;

	WriteSettings();
	ChangeGameMode(DEF_GAMEMODE_NULL);

	for (i = 0; i < DEF_MAXSPRITES; i++)
	if (m_pSprite[i] != NULL) delete m_pSprite[i];	
	for (i = 0; i < DEF_MAXTILES; i++)
	if (m_pTileSpr[i] != NULL) delete m_pTileSpr[i];
	for (i = 0; i < DEF_MAXEFFECTSPR; i++)
	if (m_pEffectSpr[i] != NULL) delete m_pEffectSpr[i];

	for (i = 0; i < DEF_MAXSOUNDEFFECTS; i++) {
		if (m_pCSound[i] != NULL) delete m_pCSound[i];
		if (m_pMSound[i] != NULL) delete m_pMSound[i];
		if (m_pESound[i] != NULL) delete m_pESound[i];
	}

	if (m_pBGM != NULL) delete m_pBGM;

	for (i = 0; i < 4; i++)
	if (m_pCharList[i] != NULL) delete m_pCharList[i];

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL)	delete m_pItemList[i];

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pBankList[i] != NULL)	delete m_pBankList[i];

	for (i = 0; i < DEF_MAXEFFECTS; i++)
	if (m_pEffectList[i] != NULL) delete m_pEffectList[i];

	for (i = 0; i < DEF_MAXCHATMSGS; i++) 
		if (m_pChatMsgList[i] != NULL) delete m_pChatMsgList[i];

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++) 
		if (m_pChatScrollList[i] != NULL) delete m_pChatScrollList[i];

	for (i = 0; i < DEF_MAXWHISPERMSG; i++) 
		if (m_pWhisperMsg[i] != NULL) delete m_pWhisperMsg[i];

	for (i = 0; i < DEF_MAXMENUITEMS; i++) 
		if (m_pItemForSaleList[i] != NULL) delete m_pItemForSaleList[i];
	
	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicCfgList[i] != NULL) delete m_pMagicCfgList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillCfgList[i] != NULL) delete m_pSkillCfgList[i];

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != NULL)  delete m_pMsgTextList[i];
		if (m_pMsgTextList2[i] != NULL) delete m_pMsgTextList2[i];
		if (m_pAgreeMsgTextList[i] != NULL) delete m_pAgreeMsgTextList[i];
	} 

	if (m_pExID != NULL) delete m_pExID;

	// v1.41
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	// v1.41
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		if (m_pDispBuildItemList[i] != NULL) delete m_pDispBuildItemList[i];
	
	for (i = 0; i < DEF_MAXGAMEMSGS; i++) 
		if (m_pGameMsgList[i] != NULL) delete m_pGameMsgList[i];

	for (i = 0; i < DEF_MAXITEMNAMES; i++)
		if (m_pItemNameList[i] != NULL) delete m_pItemNameList[i];
	
	delete m_pMapData;

	if (m_pGSock != NULL) delete m_pGSock;
	if (m_pLSock != NULL) delete m_pLSock;
	if (G_pCalcSocket != NULL) delete G_pCalcSocket;
	if (m_pCGameMonitor != NULL) delete m_pCGameMonitor;
}  
  
  
void CGame::UpdateScreen() 
{ 
	G_dwGlobalTime = timeGetTime();  

	switch (m_cGameMode) {
#ifdef DEF_MAKE_ACCOUNT
	case DEF_GAMEMODE_ONAGREEMENT:
		UpdateScreen_OnAgreement(); 
		break;

	case DEF_GAMEMODE_ONCREATENEWACCOUNT:
		UpdateScreen_OnCreateNewAccount();
		break;
#endif

	case DEF_GAMEMODE_ONVERSIONNOTMATCH:
		UpdateScreen_OnVersionNotMatch();
		break;  

	case DEF_GAMEMODE_ONCONNECTING:
		UpdateScreen_OnConnecting();
		break;
	
	case DEF_GAMEMODE_ONMAINMENU:
		UpdateScreen_OnMainMenu();
		break;

	case DEF_GAMEMODE_ONLOADING:
		UpdateScreen_OnLoading(TRUE);
		break;

	case DEF_GAMEMODE_ONMAINGAME:
		UpdateScreen_OnGame();
		break;
	
	case DEF_GAMEMODE_ONWAITINGINITDATA:
		UpdateScreen_OnWaitInitData();
		break;

	case DEF_GAMEMODE_ONCONNECTIONLOST:
		UpdateScreen_OnConnectionLost();
		break;

	case DEF_GAMEMODE_ONMSG:
		UpdateScreen_OnMsg();
		break;

	case DEF_GAMEMODE_ONLOGIN:
		UpdateScreen_OnLogin();
		break;
	
	case DEF_GAMEMODE_ONSELECTSERVER:
		UpdateScreen_OnSelectServer();
		break;
	
	case DEF_GAMEMODE_ONQUIT:
		UpdateScreen_OnQuit();
		break;
	
	case DEF_GAMEMODE_ONQUERYFORCELOGIN:
		UpdateScreen_OnQueryForceLogin();
		break;

	case DEF_GAMEMODE_ONSELECTCHARACTER:
		UpdateScreen_OnSelectCharacter();
		break;

	case DEF_GAMEMODE_ONCREATENEWCHARACTER:
		UpdateScreen_OnCreateNewCharacter();
		break;

	case DEF_GAMEMODE_ONWAITINGRESPONSE:
		UpdateScreen_OnWaitingResponse();
		break;

	case DEF_GAMEMODE_ONQUERYDELETECHARACTER:
		UpdateScreen_OnQueryDeleteCharacter();
		break;

	case DEF_GAMEMODE_ONLOGRESMSG:
		UpdateScreen_OnLogResMsg();
		break;

	case DEF_GAMEMODE_ONCHANGEPASSWORD:
		UpdateScreen_OnChangePassword();
		break;
#if DEF_LANGUAGE == 2
	case DEF_GAMEMODE_ONINPUTKEYCODE:
		UpdateScreen_OnInputKeyCode();
		break;
#endif
	}

#ifdef DEF_USING_WIN_IME

	#ifdef DEF_HTMLCOMMOM	
		if(!G_bDlg1)	//	mando	다이얼로그가 떠있을때는 강제로 엔터 먹는것 취소..
	#endif			
		{
			// 키 코드를 읽어온다.
			if (GetAsyncKeyState(VK_RETURN) != NULL) m_cEnterCheck = 1;
			// v2.04 Candicate 창이 열렸을때는 Enter키를 처리하지 않는다.
			if ((m_cEnterCheck == 1) && (GetAsyncKeyState(VK_RETURN) == NULL)) {
				m_bEnterPressed = TRUE;
				m_cEnterCheck = NULL;
			}
			if (GetAsyncKeyState(VK_TAB) != NULL) m_cTabCheck = 1; 
 			if ((m_cTabCheck == 1) && (GetAsyncKeyState(VK_TAB) == NULL)) {
				m_cCurFocus++;
				if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
				if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME) bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, NULL, NULL, NULL, NULL, NULL); 
				m_cTabCheck = NULL;
			}
			if( m_bInputStatus )
			{
				if (GetAsyncKeyState(VK_LEFT) != NULL) m_cLeftArrowCheck = 1;
				if ((m_cLeftArrowCheck == 1) && (GetAsyncKeyState(VK_LEFT) == NULL)) {
					m_cLeftArrowCheck = NULL;
					if( G_hEditWnd != NULL )
					{
						int iStrLen = strlen(m_pInputBuffer);
						SendMessage( G_hEditWnd, EM_SETSEL, iStrLen, iStrLen );
					}
				}
			}
		}
	

#endif
}

// 시점 이동 포인트를 계산한다.
void CGame::CalcViewPoint()
{
 short dX, dY;

	dX = m_sViewPointX - m_sViewDstX;
	dY = m_sViewPointY - m_sViewDstY;

	if (abs(dX) < abs(m_sViewDX)) {
		m_sViewPointX = m_sViewDstX;
		m_sViewDX = 0;
	}
	else { 
		if (dX > 0) m_sViewDX--;
		if (dX < 0) m_sViewDX++;
		if (dX == 0) m_sViewDX = 0;
		if (abs(dX) < 40) {
			if (m_sViewDX > 4)  m_sViewDX = 4;
			else if (m_sViewDX < -4) m_sViewDX = -4;
		}
		m_sViewPointX += m_sViewDX;
	}  

	if (abs(dY) < abs(m_sViewDY)) {
		m_sViewPointY = m_sViewDstY;
		m_sViewDY = 0;
	} 
	else {
		if (dY > 0) m_sViewDY--;
		if (dY < 0) m_sViewDY++;
		if (dY == 0) m_sViewDY = 0;		
		if (abs(dY) < 40) {
			if (m_sViewDY > 4)  m_sViewDY = 4;
			else if (m_sViewDY < -4) m_sViewDY = -4;
		}		
		m_sViewPointY += m_sViewDY;
	}
}

// 소켓에서 발생한 이벤트에 대한 처리를 한다.
void CGame::OnGameSocketEvent(WPARAM wParam, LPARAM lParam)
{
 int iRet;
 char * pData;
 DWORD  dwMsgSize;
	
	if (m_pGSock == NULL) return;

	iRet = m_pGSock->iOnSocketEvent(wParam, lParam);	
	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// *** 소켓이 연결되었다. 해당 커넥션에 따라 처리한다.
		ConnectionEstablishHandler(DEF_SERVERTYPE_GAME);
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		// *** 메시지가 수신되었다.
		pData = m_pGSock->pGetRcvDataPointer(&dwMsgSize);
		GameRecvMsgHandler(dwMsgSize, pData);
		// 서버로부터의 응답시간 체크를 위해 타임값 기록 
		m_dwTime = G_dwGlobalTime;
		break;
	
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// *** 서버와의 연결이 끊어졌다. 
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		
		delete m_pGSock;
		m_pGSock = NULL;
		break;
	
	case DEF_XSOCKEVENT_SOCKETERROR:
		// *** 서버와의 연결상태에 에러가 발생했다.
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		
		delete m_pGSock;
		m_pGSock = NULL;
		break;
	
	case DEF_XSOCKEVENT_CRITICALERROR:
		// *** 치명적인 에러가 발생했다. 프로그램을 종료해야만 한다.
		delete m_pGSock;
		m_pGSock = NULL;

		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		break;
	}
}

// 잃어버린 스프라이트 서페이스 모두를 복구시킨다.
void CGame::RestoreSprites()
{
	for (int i = 0; i < DEF_MAXSPRITES; i++)
	if (m_pSprite[i] != NULL) m_pSprite[i]->iRestore();
}

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };
char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, BOOL bMoveCheck)
{
 char  cDir, cTmpDir;
 //int   aX, aY, aX2, aY2, dX, dY;
 int   aX, aY, dX, dY;
 int   i;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;
 
	cDir = m_Misc.cGetNextMoveDir(dX, dY, dstX, dstY);

	if (m_cPlayerTurn == 0)
	for (i = cDir; i <= cDir + 2;i++) {
		cTmpDir = i;
		if (cTmpDir > 8) cTmpDir -= 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == TRUE) && (bMoveCheck == TRUE)) {
			// v1.42
			m_bIsPrevMoveBlocked = FALSE;
		}
		else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == TRUE)
		{
			if( m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == TRUE )
			{
				if( _bCheckMoveable(dX + aX, dY + aY) == TRUE ) return cTmpDir;
				else
				{
					SetTopMsg( DEF_MSG_GETNEXTMOVEDIR, 5 );
				}
			}
			else return cTmpDir;
		}
	}

	if (m_cPlayerTurn == 1)
	for (i = cDir; i >= cDir - 2;i--) {
		cTmpDir = i;
		if (cTmpDir < 1) cTmpDir += 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == TRUE) && (bMoveCheck == TRUE)) {
			// v1.42
			m_bIsPrevMoveBlocked = FALSE;
		}
		else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == TRUE)
		{
			if( m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == TRUE )
			{
				if( _bCheckMoveable(dX + aX, dY + aY) == TRUE ) return cTmpDir;
				else
				{
					SetTopMsg( DEF_MSG_GETNEXTMOVEDIR, 5 );
				}
			}
			else return cTmpDir;
		}
	}
	return 0;
}

BOOL CGame::_bCheckMoveable( short sx, short sy )
{
	if( m_bIsCrusadeMode ) return TRUE;
	if( m_bHunter == FALSE ) return TRUE;//민간인모드가 아니면 무사통과
	if( m_bCitizen == FALSE ) return TRUE;//중립캐릭터라도 무사통과
	if( m_bAresden == TRUE && m_cMapIndex == 11 )
	{		
		if( sy == 20 )
		{
			//아레스덴에서 미들로 가는 입구 두개
			if( (sx>=39) && (sx<=47) ) return FALSE;
			if( (sx>=360) && (sx<=368) ) return FALSE;
		}
	}
	if( m_bAresden == FALSE && m_cMapIndex == 3 )
	{
		//엘바인에서 미들로 가는 입구 두개
		if( sy == 373 )
		{
			if( (sx>=27) && (sx<=32) ) return FALSE;
		}
		if( sy == 374 )
		{
			if( (sx>=298) && (sx<=305) ) return FALSE;
		}
	}
	return TRUE;
}

BOOL CGame::bSendCommand(DWORD dwMsgID, WORD wCommand, char cDir, int iV1, int iV2, int iV3, char * pString, int iV4)
{
  //v1.4334  Quiz cMsg[256] -> cMsg[300]
 char  * cp, cMsg[300], cTxt[256], cKey;
 WORD  * wp;
 DWORD * dwp, dwTime;
 short * sp; 
 int   * ip, iRet, i, * fightzonenum ;

	if ((m_pGSock == NULL) && (m_pLSock == NULL)) return FALSE;

	dwTime = timeGetTime();
 
	ZeroMemory(cMsg, sizeof(cMsg));
	cKey = (char)(rand() % 255) +1; // v1.4
	
	switch (dwMsgID) {

	case MSGID_REQUEST_TELEPORT_LIST:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		cp = (char*)(cMsg + 6);
		memset( cp, 0, 20 );
		memcpy( cp, "William", 20 );
		iRet = m_pGSock->iSendMsg(cMsg, 26, cKey);
		break;

	case MSGID_REQUEST_CHARGED_TELEPORT:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		ip  = (int *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		*ip = iV1;
		iRet = m_pGSock->iSendMsg(cMsg, 10, cKey);
		break;

	case MSGID_REQUEST_SELLITEMLIST:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		for (i = 0; i < DEF_MAXSELLLIST; i++) 
		{
			*cp = m_stSellItemList[i].iIndex;
			cp++;
			ip = (int *)cp;
			*ip = m_stSellItemList[i].iAmount;
			cp += 4;
		}

		iRet = m_pGSock->iSendMsg(cMsg, 70, cKey);
		break;

	case MSGID_REQUEST_RESTART:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		iRet = m_pGSock->iSendMsg(cMsg, 6, cKey);
		break;

	case MSGID_REQUEST_PANNING:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		*cp = cDir;
		cp++;

		iRet = m_pGSock->iSendMsg(cMsg, 7, cKey);
		break;

#if DEF_LANGUAGE == 2
	case MSGID_REQUEST_INPUTKEYCODE:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cKeyCode, 17);
		memcpy(cp, cTxt, 17); 
		cp += 10;

		iRet = m_pLSock->iSendMsg(cMsg, 43, cKey); // 6+10+10+17
		break;

	case MSGID_REQUEST_CHANGEPASSWORD:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.5 상하추가 중국은 민번도 입력
		memcpy(cTxt, m_cAccountSSN, 18);
		memcpy(cp, cTxt, 18); 
		cp += 18;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cNewPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cNewPassConfirm, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		iRet = m_pLSock->iSendMsg(cMsg, 64, cKey);
		break;
#else
	case MSGID_REQUEST_CHANGEPASSWORD:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cNewPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cNewPassConfirm, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		iRet = m_pLSock->iSendMsg(cMsg, 46, cKey);
		break;
#endif	
	case MSGID_REQUEST_CREATENEWACCOUNT:
		// to Log Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		memcpy(cp, m_cEmailAddr, 50);
		cp += 50;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		if ((rand() % 2) == 0) strcpy(cTxt, "Male");
		else strcpy(cTxt, "Female");
		memcpy(cp, cTxt, 10);
		cp += 10;

		memcpy(cp, m_cAccountAge, 10);
		cp += 10;

		memcpy(cp, "xxxx", 4);
		cp += 4;

		memcpy(cp, "xx", 2);
		cp += 2;

		memcpy(cp, "xx", 2);
		cp += 2;

		memcpy(cp, m_cAccountCountry, 17);
		cp += 17;

		memcpy(cp, m_cAccountSSN, 28);
		cp += 28;

		//v1.4334  Quiz 

 		memcpy(cp, m_cAccountQuiz, 45);
		cp += 45;

		memcpy(cp, m_cAccountAnswer, 20);
		cp += 20;

		//v1.432 2001 4 30
		memcpy(cp, G_cCmdLineTokenA_Lowercase, 50);

		iRet = m_pLSock->iSendMsg(cMsg, 214	+50, cKey);
		break;

	case MSGID_GETMINIMUMLOADGATEWAY:
	case MSGID_REQUEST_LOGIN:
		// to Log Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		// 2002-09-16 #1 for Terra
#ifdef DEF_ACCOUNTLONG
		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountLong, DEF_ACCOUNTLEN);
		memcpy(cp, cTxt, DEF_ACCOUNTLEN);
		cp += DEF_ACCOUNTLEN;
#else
		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;
#endif

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		//v1.43
		memcpy(cp, m_cWorldServerName, 30);
		cp += 30;

		// 2002-09-16 #1 for Terra
#ifdef DEF_ACCOUNTLONG
		iRet = m_pLSock->iSendMsg(cMsg, 46 + DEF_ACCOUNTLEN, cKey);
#else
		iRet = m_pLSock->iSendMsg(cMsg, 56, cKey);
#endif
		break;
	
	case MSGID_REQUEST_CREATENEWCHARACTER:
		// to Log Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = (WORD)NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_cPlayerName, 10);
		cp += 10;

		memcpy(cp, m_cAccountName, 10);
		cp += 10;

		memcpy(cp, m_cAccountPassword, 10);
		cp += 10;

		memcpy(cp, m_cWorldServerName, 30);
		cp += 30;

		// 새로 생성할 캐릭터의 초기정보를 담는다.
		*cp = m_cGender;
		cp++;

		*cp = m_cSkinCol;
		cp++;

		*cp = m_cHairStyle;
		cp++;

		*cp = m_cHairCol;
		cp++;

		*cp = m_cUnderCol;
		cp++;

		*cp = m_ccStr;
		cp++;

		*cp = m_ccVit;
		cp++;

		*cp = m_ccDex; 
		cp++;

		*cp = m_ccInt;
		cp++;

		*cp = m_ccMag;
		cp++;

		*cp = m_ccChr;
		cp++;

		iRet = m_pLSock->iSendMsg(cMsg, 77, cKey);
		break;

	case MSGID_REQUEST_ENTERGAME:
		// to Log Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = (WORD)m_wEnterGameType;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cPlayerName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.43
		memcpy(cTxt, m_cMapName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;
		
		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ip = (int *)cp;
		*ip = m_iLevel;
		cp += 4;

		memcpy(cp, m_cWorldServerName, 30);
		cp += 30;

		memcpy(cp, G_cCmdLineTokenA, 120); // !!! 과금처리용 스트링열
		cp += 120;
		
		iRet = m_pLSock->iSendMsg(cMsg, 200, cKey);
		break;

	case MSGID_REQUEST_DELETECHARACTER:
		// to Log Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = (WORD)m_wEnterGameType; // 몇번째 캐릭터를 지울것인가의 정보 

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		// 지울 캐릭터 이름 
		memcpy(cp, m_pCharList[m_wEnterGameType - 1]->m_cName, 10);
		cp += 10;

		memcpy(cp, m_cAccountName, 10);
		cp += 10;

		memcpy(cp, m_cAccountPassword, 10);
		cp += 10;

		// 지울 캐릭터가 위치한 월드서버 이름 
		memcpy(cp, m_cWorldServerName, 30);
		cp += 30;
		
		iRet = m_pLSock->iSendMsg(cMsg, 66, cKey);
		break;

	case MSGID_REQUEST_SETITEMPOS:
		// to Game Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		
		*cp = cDir;

		cp++;

		sp = (short *)cp;
		*sp = (short)iV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)iV2;
		cp += 2;

		iRet = m_pGSock->iSendMsg(cMsg, 11);
		break;

	case MSGID_COMMAND_CHECKCONNECTION:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		dwp = (DWORD *)cp;
		*dwp = dwTime;
		cp += 4;
		
		iRet = m_pGSock->iSendMsg(cMsg, 10, cKey);

		break;

	case MSGID_REQUEST_INITDATA:
	case MSGID_REQUEST_INITPLAYER:
		// to Game Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cPlayerName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;
		
		// v1.41
		*cp = (char)m_bIsObserverMode;
		cp++;

		// v2.04 Gateway
		memcpy(cp, m_cGameServerName, 20);
		cp += 20;

		iRet = m_pGSock->iSendMsg(cMsg, 37 +20, cKey);
		
		//m_bIsObserverMode = FALSE;
		break;
	
	case MSGID_LEVELUPSETTINGS:
		// 레벨 업 할당치가 토탈 3보다 클수는 없다.
		if ((m_cLU_Str + m_cLU_Vit + m_cLU_Dex + m_cLU_Int + m_cLU_Mag + m_cLU_Char) > 3) return FALSE;
		
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		
		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		*cp = m_cLU_Str;
		cp++;

		*cp = m_cLU_Vit;
		cp++;

		*cp = m_cLU_Dex;
		cp++;

		*cp = m_cLU_Int;
		cp++;

		*cp = m_cLU_Mag;
		cp++;

		*cp = m_cLU_Char;
		cp++;

		iRet = m_pGSock->iSendMsg(cMsg, 12);
		break;

	case MSGID_COMMAND_CHATMSG:
		// v1.433 텔레포트가 요청된 이후로는 동작 명령을 내릴 수 없다. 접속 종료를 방지하기 위함.
		if (m_bIsTeleportRequested == TRUE) return FALSE;
		
		// to Game Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		*sp = m_sPlayerX;
		cp += 2;

		sp = (short *)cp;
		*sp = m_sPlayerY;
		cp += 2;

		memcpy(cp, m_cPlayerName, 10);
		cp += 10;

		*cp = (char)iV1; // 채팅 메시지 형식 
		cp++;

		// 지역 채팅 커맨드라면 전송할 필요 없다. 
		if (bCheckLocalChatCommand(pString) == TRUE) return FALSE;
		memcpy((char *)cp, pString, strlen(pString) + 1);
		
		iRet = m_pGSock->iSendMsg(cMsg, 22 + strlen(pString));
		break;

	case MSGID_COMMAND_COMMON:
		// v1.433 텔레포트가 요청된 이후로는 동작 명령을 내릴 수 없다. 접속 종료를 방지하기 위함.
		if (m_bIsTeleportRequested == TRUE) return FALSE;

		// to Game Server
		// 아이템 버림, 장착, 마법 사용 등등 기타 동작과 관계가 없는 명령들을 모두  
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = wCommand;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		*sp = m_sPlayerX;
		cp += 2;

		sp = (short *)cp;
		*sp = m_sPlayerY;
		cp += 2;

		*cp = cDir;
		cp++;
		
		switch (wCommand) {
		case DEF_COMMONTYPE_BUILDITEM:
			memcpy(cp, pString, 20);
			cp += 20;
				
			*cp = (char)m_stDialogBoxInfo[26].sV1;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV2;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV3;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV4;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV5;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV6;
			cp++;

			iRet = m_pGSock->iSendMsg(cMsg, 37);
			break;

		case DEF_COMMONTYPE_REQ_CREATEPORTION:
			// 파라미터가 6개라서 따로 처리해야 한다.
			*cp = (char)m_stDialogBoxInfo[26].sV1;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV2;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV3;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV4;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV5;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV6;
			cp++;

			iRet = m_pGSock->iSendMsg(cMsg, 18);
			break;

		default:
			if (pString == NULL) {
				ip = (int *)cp;
				*ip = iV1;
				cp += 4;
				
				ip = (int *)cp;
				*ip = iV2;
				cp += 4;
				
				ip = (int *)cp;
				*ip = iV3;
				cp += 4;

				// v2.172 2002-6-21 고광현수정
				dwp = (DWORD *)cp;
				*dwp = dwTime;
				cp += 4;
				
				iRet = m_pGSock->iSendMsg(cMsg, 23 +4); // v2.172
			}
			else {
				ip = (int *)cp;
				*ip = iV1;
				cp += 4;
				
				ip = (int *)cp;
				*ip = iV2;
				cp += 4;
				
				ip = (int *)cp;
				*ip = iV3;
				cp += 4;
				
				memcpy(cp, pString, 30);
				cp += 30;
				
				ip = (int *)cp;
				*ip = iV4;
				cp += 4;
					
				iRet = m_pGSock->iSendMsg(cMsg, 23 + 34);
			}
			break;
		}
		
		// 이 메시지는 카운팅을 하지 않는다.
		break;

	case MSGID_REQUEST_CREATENEWGUILD:
	case MSGID_REQUEST_DISBANDGUILD:
		// to Game Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cPlayerName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10); 
		cp += 10;
		// 길드이름의 공백을 특수문자로 바꾼다.
		char cTemp[21];
		ZeroMemory(cTemp, sizeof(cTemp));
		memcpy(cTemp, m_cGuildName, 20);
		m_Misc.ReplaceString(cTemp, ' ', '_');
		memcpy(cp, cTemp, 20);
		cp += 20;

		iRet = m_pGSock->iSendMsg(cMsg, 56, cKey);
		break;
	
	case MSGID_REQUEST_TELEPORT:
		// 다른 맵으로의 텔레포트를 요청한다.
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;
		
		iRet = m_pGSock->iSendMsg(cMsg, 6);

		m_bIsTeleportRequested = TRUE;
		break;

	case MSGID_REQUEST_CIVILRIGHT:
		// 시민권 획득을 요청한다.
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;
		
		iRet = m_pGSock->iSendMsg(cMsg, 6);
		break;

	case MSGID_REQUEST_RETRIEVEITEM:
		// 아이템을 되찾는다는 메시지 전송.
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		*cp = (char)iV1;

		iRet = m_pGSock->iSendMsg(cMsg, 7);
		break;

	case MSGID_REQUEST_NOTICEMENT:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		*ip = iV1;
		cp += 4;

		iRet = m_pGSock->iSendMsg(cMsg, 10, cKey);
		break;

	// v1.4311-3 변경  메세지 전송   서버에 사투장 예약
	case  MSGID_REQUEST_FIGHTZONE_RESERVE:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		fightzonenum = (int *)cp;
		*fightzonenum = iV1;
		cp += 4;

		iRet = m_pGSock->iSendMsg(cMsg, 10);
		break; 

	default:
		// v1.433 텔레포트가 요청된 이후로는 동작 명령을 내릴 수 없다. 접속 종료를 방지하기 위함.
		if (m_bIsTeleportRequested == TRUE) return FALSE;
	
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = wCommand;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);	

		sp = (short *)cp;
		*sp = m_sPlayerX;
		cp += 2;

		sp = (short *)cp;
		*sp = m_sPlayerY;
		cp += 2;

		*cp = cDir;
		cp++;
		
		sp  = (short *)cp;
		*sp = (short)iV1;
		cp += 2;

		sp  = (short *)cp;
		*sp = (short)iV2;
		cp += 2;

		sp  = (short *)cp;
		*sp = (short)iV3;
		cp += 2;
		if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) { // v1.4  v2.171
			sp  = (short *)cp;
			*sp = (short)iV4;
			cp += 2;	

			//v2.171
			dwp = (DWORD *)cp;
			*dwp = dwTime;
			cp += 4;
			
			iRet = m_pGSock->iSendMsg(cMsg, 19 +4); //v2.171
		}
		else {
			//v2.171
			dwp = (DWORD *)cp;
			*dwp = dwTime;
			cp += 4;
			
			iRet = m_pGSock->iSendMsg(cMsg, 17 +4); //v2.171
		}
		m_cCommandCount++;
		break;

	}

	switch (iRet) {
	case DEF_XSOCKEVENT_SOCKETCLOSED:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_QUENEFULL:
		// 소켓에 에러가 발생했으므로 접속을 해제한다.
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		
		delete m_pGSock;
		m_pGSock = NULL;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pGSock;
		m_pGSock = NULL;

		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);

		break;
	}

#ifdef DEF_HTMLCOMMOM	//	전역으로 빼기위한..mando 
	G_iLevel			=	m_iLevel;
	strcpy(G_cWorldServerName, m_cWorldServerName);
	strcpy(G_cPlayerName,	m_cPlayerName);
	strcpy(G_cMapName	,	m_cMapName);
	strcpy(G_cMapMessage,	m_cMapMessage);
#endif

	return TRUE;
}

//
void CGame::DrawObjects(short sPivotX, short sPivotY, short sDivX, short sDivY, short sModX, short sModY, short msX, short msY)
{
	int ix, iy, indexX, indexY, dX, dY, iDvalue;
	char cItemColor;
	BOOL bIsPlayerDrawed = FALSE;
	BOOL bContact = FALSE;
	BOOL bRet = FALSE;
	short sItemSprite, sItemSpriteFrame, sObjSpr, sObjSprFrame, sDynamicObject, sDynamicObjectFrame;
	static DWORD dwMCAnimTime = G_dwGlobalTime;
	static short sMCAnimFrame = 1;

	// v2.14 텔레포트시 물건 집으면 클라이언트 죽는 에러 처리..
	if( sDivY < 0 || sDivX < 0) return ;
	m_sMCX = NULL;
	m_sMCY = NULL;
	ZeroMemory(m_cMCName, sizeof(m_cMCName));

	//dwTime = G_dwGlobalTime;
	DWORD dwTime = m_dwCurTime;
	m_stMCursor.sCursorFrame = 0;
	
	indexY = sDivY + sPivotY - 7;
	for (iy = -sModY-224; iy <= 427+352; iy += 32) {
		indexX = sDivX + sPivotX-4;
		for (ix = -sModX-128 ; ix <= 640 + 128; ix += 32)
		{
			// v1.4311
			sDynamicObject = NULL;
			bRet = FALSE;

			if ((ix >= -sModX) && (ix <= 640+16) && (iy >= -sModY) && (iy <= 427+32+16)) {
				
				_tmp_wObjectID = _tmp_sOwnerType = _tmp_sAppr1 = _tmp_sAppr2 = _tmp_sAppr3 = _tmp_sAppr4 = _tmp_sStatus = NULL;
				_tmp_cDir = _tmp_cFrame = 0;
				_tmp_iEffectType = _tmp_iEffectFrame = _tmp_iChatIndex = 0; // v2.171 2002-6-14

				ZeroMemory(_tmp_cName, sizeof(_tmp_cName));
				
				// +++ 함수 호출의 오버헤드를 막기위해 직접 억세스 한다. 
				if ((indexX < m_pMapData->m_sPivotX) || (indexX > m_pMapData->m_sPivotX + MAPDATASIZEX) || 
					(indexY < m_pMapData->m_sPivotY) || (indexY > m_pMapData->m_sPivotY + MAPDATASIZEY)) {
		
					sItemSprite = NULL;
					sItemSpriteFrame = NULL;
					bRet = FALSE;
					cItemColor = NULL;
				}
				else {
					_tmp_dX = dX = indexX - m_pMapData->m_sPivotX; // v2.171 2002-6-14
					_tmp_dY = dY = indexY - m_pMapData->m_sPivotY; // v2.171 2002-6-14
					_tmp_wObjectID  = m_pMapData->m_pData[dX][dY].m_wDeadObjectID;
					_tmp_sOwnerType = m_pMapData->m_pData[dX][dY].m_sDeadOwnerType;
					_tmp_cDir       = m_pMapData->m_pData[dX][dY].m_cDeadDir;
					_tmp_sAppr1     = m_pMapData->m_pData[dX][dY].m_sDeadAppr1;
					_tmp_sAppr2     = m_pMapData->m_pData[dX][dY].m_sDeadAppr2;
					_tmp_sAppr3     = m_pMapData->m_pData[dX][dY].m_sDeadAppr3;
					_tmp_sAppr4     = m_pMapData->m_pData[dX][dY].m_sDeadAppr4;
					_tmp_iApprColor = m_pMapData->m_pData[dX][dY].m_iDeadApprColor; // v1.4
					_tmp_cFrame     = m_pMapData->m_pData[dX][dY].m_cDeadOwnerFrame; 
					_tmp_iChatIndex = m_pMapData->m_pData[dX][dY].m_iDeadChatMsg;
					_tmp_sStatus    = m_pMapData->m_pData[dX][dY].m_sDeadStatus;
					
					strcpy(_tmp_cName, m_pMapData->m_pData[dX][dY].m_cDeadOwnerName);

					sItemSprite      = m_pMapData->m_pData[dX][dY].m_sItemSprite;
					sItemSpriteFrame = m_pMapData->m_pData[dX][dY].m_sItemSpriteFrame;
					cItemColor       = m_pMapData->m_pData[dX][dY].m_cItemColor;

					sDynamicObject      = m_pMapData->m_pData[dX][dY].m_sDynamicObjectType;
					sDynamicObjectFrame = (short)m_pMapData->m_pData[dX][dY].m_cDynamicObjectFrame;
					cDynamicObjectData1 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData1;
					cDynamicObjectData2 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData2;
					cDynamicObjectData3 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData3;
					cDynamicObjectData4 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData4;

					bRet = TRUE;
			 	}
				// +++

				if ((bRet == TRUE) && (sItemSprite != 0)) {
					// 바닥에 아이템이 있다.
					if (cItemColor == 0)
						 m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + sItemSprite]->PutSpriteFast(ix, iy, sItemSpriteFrame, dwTime);
					else {
						// 무기류 아이템은 색상 세트가 다르다는 점에 주의
						switch (sItemSprite) {
						case 1:
						case 2:
						case 3:
						case 15: m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + sItemSprite]->PutSpriteRGB(ix, iy, sItemSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime); break;
						default: m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + sItemSprite]->PutSpriteRGB(ix, iy, sItemSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime); break;
						}
					}
										
					if ((ix - 13 < msX)	&& (ix + 13 > msX) && (iy - 13 < msY) && (iy + 13 > msY)) {
						// 마우스 커서의 줍는 애니메이션을 처리한다.
						if ((dwTime - dwMCAnimTime)	> 200) {
							dwMCAnimTime = dwTime;
							if (sMCAnimFrame == 1) 
								 sMCAnimFrame = 2;
							else sMCAnimFrame = 1;
						}
						m_stMCursor.sCursorFrame  = sMCAnimFrame;
					}
				}
				
				if ((bRet == TRUE) && (_tmp_wObjectID != NULL)) {
					// 죽어있는 캐릭터가 있다. 
					bContact = DrawObject_OnDead(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
				}
						
				// 마우스 커서와의 충돌체크를 한다. 
				if ((bContact == TRUE) && (msY <= 431)) {	// v1.4311
					// 충돌되었다. 좌표저장
					m_sMCX = indexX;
					m_sMCY = indexY;
					sFocusX = ix;
					sFocusY = iy;
					sFocusOwnerType = _tmp_sOwnerType;
					cFocusAction = DEF_OBJECTDEAD;
					wFocusObjectID = _tmp_wObjectID;
					cFocusFrame  = _tmp_cFrame;
					cFocusDir    = _tmp_cDir;
					sFocusAppr1  = _tmp_sAppr1;
					sFocusAppr2  = _tmp_sAppr2;
					sFocusAppr3  = _tmp_sAppr3;
					sFocusAppr4  = _tmp_sAppr4;
					iFocusApprColor = _tmp_iApprColor; // v1.4
					sFocusStatus = _tmp_sStatus;
					ZeroMemory(cFocusName, sizeof(cFocusName));
					strcpy(cFocusName, _tmp_cName);
					ZeroMemory(m_cMCName, sizeof(m_cMCName));
					strcpy(m_cMCName,  _tmp_cName);
				
					sFocus_dX = _tmp_dX; // v2.171
					sFocus_dY = _tmp_dY; // v2.171
					
					bContact = FALSE;
				}
			
				_tmp_wObjectID = _tmp_sOwnerType = _tmp_sAppr1 = _tmp_sAppr2 = _tmp_sAppr3 = _tmp_sAppr4 = _tmp_sStatus = NULL;
				_tmp_cFrame = _tmp_cDir = 0;
				_tmp_iEffectType = _tmp_iEffectFrame = _tmp_iApprColor = _tmp_iChatIndex = 0;
				ZeroMemory(_tmp_cName, sizeof(_tmp_cName));
								
				// +++ 함수 호출의 오버헤드를 막기위해 직접 억세스 한다. 
				if ((indexX < m_pMapData->m_sPivotX) || (indexX > m_pMapData->m_sPivotX + MAPDATASIZEX) || 
					(indexY < m_pMapData->m_sPivotY) || (indexY > m_pMapData->m_sPivotY + MAPDATASIZEY)) {
		
					sItemSprite = NULL;
					bRet = FALSE;
				}
				else {
					_tmp_dX = dX = indexX - m_pMapData->m_sPivotX; // v2.171 2002-6-14
					_tmp_dY = dY = indexY - m_pMapData->m_sPivotY; // v2.171 2002-6-14
					_tmp_wObjectID  = m_pMapData->m_pData[dX][dY].m_wObjectID;
					_tmp_sOwnerType = m_pMapData->m_pData[dX][dY].m_sOwnerType;
					_tmp_cAction    = m_pMapData->m_pData[dX][dY].m_cOwnerAction;
					_tmp_sStatus    = m_pMapData->m_pData[dX][dY].m_sStatus;
					_tmp_cDir       = m_pMapData->m_pData[dX][dY].m_cDir;
					_tmp_sAppr1     = m_pMapData->m_pData[dX][dY].m_sAppr1;
					_tmp_sAppr2     = m_pMapData->m_pData[dX][dY].m_sAppr2;
					_tmp_sAppr3     = m_pMapData->m_pData[dX][dY].m_sAppr3;
					_tmp_sAppr4     = m_pMapData->m_pData[dX][dY].m_sAppr4;
					_tmp_iApprColor = m_pMapData->m_pData[dX][dY].m_iApprColor; // v1.4
					_tmp_cFrame     = m_pMapData->m_pData[dX][dY].m_cOwnerFrame; 
					_tmp_iChatIndex = m_pMapData->m_pData[dX][dY].m_iChatMsg;
					_tmp_iEffectType  = m_pMapData->m_pData[dX][dY].m_iEffectType;
					_tmp_iEffectFrame = m_pMapData->m_pData[dX][dY].m_iEffectFrame;
					 
					strcpy(_tmp_cName, m_pMapData->m_pData[dX][dY].m_cOwnerName);
					bRet = TRUE;

					if (m_iIlusionOwnerH != NULL) {
						// 환상 효과. 모든 캐릭터가 동일하게 보인다.
						if ((strcmp(_tmp_cName, m_cPlayerName) != 0) && (_tmp_sOwnerType < 10)) {
							_tmp_sOwnerType = m_cIlusionOwnerType;
							_tmp_sStatus    = m_sStatus_IE;
							_tmp_sAppr1     = m_sAppr1_IE;
							_tmp_sAppr2     = m_sAppr2_IE;
							_tmp_sAppr3     = m_sAppr3_IE;
							_tmp_sAppr4     = m_sAppr4_IE;
							_tmp_iApprColor = m_iApprColor_IE;
						}
					}
			 	}

				if ((bRet == TRUE) && (strlen(_tmp_cName) > 0)) {
					// 그려야 할 캐릭터가 있다.
					_tmp_dx = 0;
					_tmp_dy = 0;

					switch (_tmp_cAction) {
					case DEF_OBJECTSTOP:
						bContact = DrawObject_OnStop(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTMOVE:
						bContact = DrawObject_OnMove(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTDAMAGEMOVE:
						bContact = DrawObject_OnDamageMove(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;
				
					case DEF_OBJECTRUN:
						bContact = DrawObject_OnRun(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTATTACK:
						bContact = DrawObject_OnAttack(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTATTACKMOVE:
						bContact = DrawObject_OnAttackMove(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTMAGIC:
						bContact = DrawObject_OnMagic(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;
				
					case DEF_OBJECTGETITEM:
						bContact = DrawObject_OnGetItem(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTDAMAGE:
						bContact = DrawObject_OnDamage(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTDYING:
						bContact = DrawObject_OnDying(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;
					}

					// 마우스 커서와의 충돌체크를 한다. 
					if ((bContact == TRUE) && (msY <= 431)) {	// v1.4311
						// 충돌되었다. 좌표저장
						m_sMCX = indexX;
						m_sMCY = indexY;
						sFocusX = ix;
						sFocusY = iy;
						wFocusObjectID = _tmp_wObjectID;
						sFocusOwnerType = _tmp_sOwnerType;
						cFocusAction = _tmp_cAction;
						cFocusFrame  = _tmp_cFrame;
						cFocusDir    = _tmp_cDir;
						sFocusAppr1  = _tmp_sAppr1;
						sFocusAppr2  = _tmp_sAppr2;
						sFocusAppr3  = _tmp_sAppr3;
						sFocusAppr4  = _tmp_sAppr4;
						iFocusApprColor = _tmp_iApprColor; // v1.4
						sFocusStatus = _tmp_sStatus;
						ZeroMemory(cFocusName, sizeof(cFocusName));
						strcpy(cFocusName, _tmp_cName);
						ZeroMemory(m_cMCName, sizeof(m_cMCName));
						strcpy(m_cMCName,  _tmp_cName);
						sFocus_dX = _tmp_dX; // v2.171
						sFocus_dY = _tmp_dY; // v2.171
						bContact = FALSE; 
					}
					  
					if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) {
						if (m_bIsObserverMode == FALSE) {
							// 플레이어 자신의 현재 위치를 뷰포인트가 이동해야 할 목표지점으로 세팅한다.
							m_sViewDstX = (indexX*32) - 288 - 32;
							m_sViewDstY = (indexY*32) - 224;
						}

						// 플레이어의 화면상의 위치를 저장한다.
						SetRect(&m_rcPlayerRect, m_rcBodyRect.left, m_rcBodyRect.top, m_rcBodyRect.right, m_rcBodyRect.bottom);
						
						bIsPlayerDrawed = TRUE;
					}
				}
		   	}
			
			sObjSpr      = m_pMapData->m_tile[indexX][indexY].m_sObjectSprite;
			sObjSprFrame = m_pMapData->m_tile[indexX][indexY].m_sObjectSpriteFrame;
			
			if (sObjSpr != 0) {
				if ((sObjSpr < 100) || (sObjSpr >= 200)) {
					switch (sObjSpr) {
					case 200:
					case 223:
						// 그림자를 그려야 하는 오브젝트: 가로등, 표지판 등등 
						m_pTileSpr[sObjSpr]->PutShadowSprite(ix - 16, iy - 16, sObjSprFrame, dwTime);
						break;

					case 224:
						// 그림자를 그려야 하는 오브젝트: 가로등, 표지판 등등 
						switch (sObjSprFrame) {
						case 24:
						case 34:
						case 35:
						case 36:
						case 37:
						case 38:
							// 그림자를 그리면 안되는 스프라이트: 빨래등등
							break;

						default:
							m_pTileSpr[sObjSpr]->PutShadowSprite(ix - 16, iy - 16, sObjSprFrame, dwTime);
							break;
						}
					}
					if (m_cDetailLevel == 0) {
						// Detail Level이 0이면 특정 이미지는 찍지 않는다.
						if ((sObjSpr != 6) && (sObjSpr != 9))
							m_pTileSpr[sObjSpr]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);	
					}
					else {
						m_pTileSpr[sObjSpr]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
					}
						
					switch (sObjSpr) {
					case 223:
						if (sObjSprFrame == 4) {
							// 가로등 이미지이다. 야간이라면 광원 효과를 그려 넣는다. 
							if (G_cSpriteAlphaDegree == 2) {
								int iDvalue1 = -1*(rand() % 5);
								int iDvalue2 = -1*(rand() % 5);
								int iDvalue3 = -1*(rand() % 5);
								m_pEffectSpr[0]->PutTransSpriteRGB(ix+2 -17,  iy - 147 -15, 1, iDvalue1, iDvalue1, iDvalue1, dwTime);
								m_pEffectSpr[0]->PutTransSpriteRGB(ix+16 -17, iy - 96 -15,  1, iDvalue2, iDvalue2, iDvalue2, dwTime);
								m_pEffectSpr[0]->PutTransSpriteRGB(ix-19 -17, iy - 126 -15, 1, iDvalue3, iDvalue3, iDvalue3, dwTime);
							}
						}
						break;

					case 370:
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 9) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix -16 +30, m_sViewPointY + iy -16 -334, NULL, NULL, NULL, 0);
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 11) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX +ix -16 +17, m_sViewPointY + iy -16 -300, NULL, NULL, NULL, 0);
						break;
					
					case 374:
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 2) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix -7, m_sViewPointY + iy -122, NULL, NULL, NULL, 0);
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 6) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix -14, m_sViewPointY + iy -321, NULL, NULL, NULL, 0);
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 7) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX +ix +7, m_sViewPointY + iy -356, NULL, NULL, NULL, 0);
						break;

					case 376:
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 12) && (G_cSpriteAlphaDegree == 2)) {
							bAddNewEffect(65, m_sViewPointX + ix -16, m_sViewPointY + iy -346, NULL, NULL, NULL, 0);
							bAddNewEffect(65, m_sViewPointX + ix +11, m_sViewPointY + iy -308, NULL, NULL, NULL, 0);
						}
						break;

					case 378:
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 11) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix, m_sViewPointY + iy -91, NULL, NULL, NULL, 0);
						break;

					case 382:
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 9) && (G_cSpriteAlphaDegree == 2)) {
							bAddNewEffect(65, m_sViewPointX + ix +73, m_sViewPointY + iy -264, NULL, NULL, NULL, 0);
							bAddNewEffect(65, m_sViewPointX + ix +23, m_sViewPointY + iy -228, NULL, NULL, NULL, 0);
						}
						break;

					case 429:
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 2)) bAddNewEffect(65, m_sViewPointX + ix -15, m_sViewPointY + iy -224, NULL, NULL, NULL, 0);
						break;
					}
				} 
				else {
					// 나무를 그린다.
					// v1.42 그림자 이미지 //상하야 //testcode v2.16
					m_pTileSpr[sObjSpr]->_GetSpriteRect(ix - 16, iy - 16, sObjSprFrame);
					if (m_cDetailLevel==0)
					{
						if( sObjSpr < 100 + 11 ) m_pTileSpr[100 + 4]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						else if( sObjSpr < 100 + 23 ) m_pTileSpr[100 + 9]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						else if( sObjSpr < 100 + 32 ) m_pTileSpr[100 + 23]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						else m_pTileSpr[100 + 32]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
					}
					else
					{
						if ((bIsPlayerDrawed == TRUE) && (m_pTileSpr[sObjSpr]->m_rcBound.top <= m_rcPlayerRect.top) && (m_pTileSpr[sObjSpr]->m_rcBound.bottom >= m_rcPlayerRect.bottom) &&
							(m_cDetailLevel >= 2) && (m_pTileSpr[sObjSpr]->m_rcBound.left <= m_rcPlayerRect.left) && (m_pTileSpr[sObjSpr]->m_rcBound.right >= m_rcPlayerRect.right))
						{
							// 플레이어가 가렸다. 나무를 투명하게 그린다.
							m_pTileSpr[sObjSpr + 50]->PutFadeSprite(ix , iy , sObjSprFrame, dwTime);
							m_pTileSpr[sObjSpr]->PutTransSprite2(ix - 16, iy - 16, sObjSprFrame, dwTime);
						}
						else 
						{
							m_pTileSpr[sObjSpr + 50]->PutSpriteFast(ix , iy , sObjSprFrame, dwTime);
							m_pTileSpr[sObjSpr]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						}

#ifdef DEF_XMAS	//	X-mas :	나무에 효과?	mando..20021212
						static int ix1[100];
						static int iy2[100];
						static int iXmasTreeBulbDelay = 76;	//	mando 트리전구..딜레이 수..^^; 20021211
						int idelay = 75;

						if (G_cSpriteAlphaDegree == 2)
						{
							if( iXmasTreeBulbDelay < 0 || iXmasTreeBulbDelay > idelay + 1) iXmasTreeBulbDelay = 0;

							if( iXmasTreeBulbDelay > idelay )
							{
								for (int i = 0; i < 100; i++) {
									ix1[i] = 1*(rand() % 400)-200;
									iy2[i] = -1*(rand() % 300);
								}
								iXmasTreeBulbDelay = 0;
							}
							else iXmasTreeBulbDelay++;

							//	오브젝트 스프라이트 값을 안 벗어날경우 출력..
							for (int j = 0; j < 100; j++) {
								if( m_pTileSpr[sObjSpr]->_bCheckCollison(ix-16, iy-16, sObjSprFrame, ix + ix1[j], iy + iy2[j]) )
								{
									m_pEffectSpr[66+(j%6)]->PutTransSprite(ix + ix1[j], iy + iy2[j], (iXmasTreeBulbDelay>>2), dwTime);
								}
							}

						}
#endif
					}
				}
			}

			// Dynamic Object를 그린다.
			if ( (bRet == TRUE) && (sDynamicObject != NULL) ) { 
				switch (sDynamicObject) {
				case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
					if (sDynamicObjectFrame >= 0)
						m_pEffectSpr[23]->PutTransSprite50_NoColorKey(ix+(rand() % 2), iy+(rand() % 2), sDynamicObjectFrame, dwTime);
					break;

				case DEF_DYNAMICOBJECT_PCLOUD_LOOP:
					m_pEffectSpr[23]->PutTransSprite50_NoColorKey(ix+(rand() % 2), iy+(rand() % 2), sDynamicObjectFrame+8, dwTime);
					break;

				case DEF_DYNAMICOBJECT_PCLOUD_END:
					m_pEffectSpr[23]->PutTransSprite50_NoColorKey(ix+(rand() % 2), iy+(rand() % 2), sDynamicObjectFrame+16, dwTime);
					break;
				
				case DEF_DYNAMICOBJECT_ICESTORM:
					iDvalue = (rand() % 5)*(-1);
					m_pEffectSpr[0]->PutTransSpriteRGB(ix, iy, 1, iDvalue, iDvalue, iDvalue, dwTime);
					m_pEffectSpr[13]->PutTransSprite70_NoColorKey(ix, iy, sDynamicObjectFrame, dwTime);
					break;
					
				case DEF_DYNAMICOBJECT_FIRE:
					//iDvalue = (rand() % 5)*(-1);
					//m_pEffectSpr[0]->PutTransSpriteRGB(ix, iy, 1, iDvalue, iDvalue, iDvalue, dwTime);
					switch (rand() % 3) {
					case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(ix, iy, 1, dwTime); break;
					case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(ix, iy, 1, dwTime); break;
					case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(ix, iy, 1, dwTime); break;
					}
					m_pEffectSpr[8 + sDynamicObject]->PutTransSprite70_NoColorKey(ix, iy, sDynamicObjectFrame/3, dwTime);
					break;

				case DEF_DYNAMICOBJECT_FIRE2:
					switch (rand() % 3) {
					case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(ix, iy, 1, dwTime); break;
					case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(ix, iy, 1, dwTime); break;
					case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(ix, iy, 1, dwTime); break;
					}
					break;

				case DEF_DYNAMICOBJECT_FISH:
					{
						char cTmpDOdir, cTmpDOframe;
						cTmpDOdir   = m_Misc.cCalcDirection(cDynamicObjectData1, cDynamicObjectData2, cDynamicObjectData1 + cDynamicObjectData3, cDynamicObjectData2 + cDynamicObjectData4);
						cTmpDOframe = ((cTmpDOdir-1) * 4) + (rand() % 4);
						m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+0]->PutTransSprite2(ix + cDynamicObjectData1, iy + cDynamicObjectData2, cTmpDOframe, dwTime);
					}
					break;

				case DEF_DYNAMICOBJECT_MINERAL1:
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->PutShadowSprite(ix, iy, 0, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->PutSpriteFast(ix, iy, 0, dwTime);
					// 동적 객체와 마우스 커서의 충돌을 계산한다. 
					if ( (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.top != -1) &&
						 (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.top < msY) &&
						 (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.bottom > msY) &&
						 (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.left < msX) &&
						 (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.right > msX) ) {
						// 마우스 커서 충돌 
						m_sMCX = indexX;
						m_sMCY = indexY;
						sFocusStatus = NULL;
						ZeroMemory(cFocusName, sizeof(cFocusName));
						ZeroMemory(m_cMCName, sizeof(m_cMCName));
					}
					break;

				case DEF_DYNAMICOBJECT_MINERAL2:
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->PutShadowSprite(ix, iy, 1, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->PutSpriteFast(ix, iy, 1, dwTime);
						// 동적 객체와 마우스 커서의 충돌을 계산한다. 
					if ( (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.top != -1) &&
						 (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.top < msY) &&
						 (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.bottom > msY) &&
						 (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.left < msX) &&
						 (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.right > msX) ) {
						// 마우스 커서 충돌 
						m_sMCX = indexX;
						m_sMCY = indexY;
						sFocusStatus = NULL;
						ZeroMemory(cFocusName, sizeof(cFocusName));
						ZeroMemory(m_cMCName, sizeof(m_cMCName));
					}
					break;

				case DEF_DYNAMICOBJECT_SPIKE:
					m_pEffectSpr[17]->PutTransSprite70_NoColorKey(ix, iy, sDynamicObjectFrame, dwTime);
					break;
				}
			}						
			indexX++;
		}
		indexY++;
	}

	// 시간 갱신
	if ((dwTime - m_dwEnvEffectTime) > 400) m_dwEnvEffectTime = dwTime;

	if (m_sMCX != NULL) {

		if( _iGetFOE(sFocusStatus) < 0 ) m_stMCursor.sCursorFrame = 3;// 적군의 오브젝트이다.
		else m_stMCursor.sCursorFrame = 6;//중립 또는 아군의 오브젝트이다.
		
		_tmp_wObjectID  = wFocusObjectID;
		_tmp_sOwnerType = sFocusOwnerType;
		_tmp_cAction    = cFocusAction;
		_tmp_cFrame     = cFocusFrame;
		_tmp_cDir       = cFocusDir;
		_tmp_sAppr1     = sFocusAppr1;
		_tmp_sAppr2     = sFocusAppr2;
		_tmp_sAppr3     = sFocusAppr3;
		_tmp_sAppr4     = sFocusAppr4;
		_tmp_iApprColor = iFocusApprColor; // v1.4
		_tmp_sStatus    = sFocusStatus;
		strcpy(_tmp_cName, cFocusName);
		_tmp_dX = sFocus_dX; // v2.171
		_tmp_dY = sFocus_dY; // v2.171
		
		if ( (_tmp_cAction != DEF_OBJECTDEAD) && (_tmp_cFrame < 0) ) return;

		// 오브젝트의 이름을 찍어주는 곳
		switch (_tmp_cAction) {
		case DEF_OBJECTSTOP:
			DrawObject_OnStop(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;
		case DEF_OBJECTMOVE:
			// v1.42 !!!!
			switch (_tmp_sOwnerType) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:

			case 28: // Troll. 원래 8프레임이므로 제외.
			case 29: // Orge.
			case 30: // Liche
			case 31: // Orge
			case 32:
			case 33:
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
			case 58: // 산중거인
			case 59: // 에 틴
			case 60: //식인식물
			case 61: //루돌프
			case 62: //멧돼지
			case 63: //팅커벨
			case 65: //아이스골렘
			case 66: //와이번
				break;

			default:
				_tmp_cFrame = _tmp_cFrame * 2; // 거꾸로 곱해줘야 이름이 제 위치에 찍힌다.
				break;
			}
			
			DrawObject_OnMove(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;
	
		case DEF_OBJECTDAMAGEMOVE:	
			DrawObject_OnDamageMove(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTRUN:
			DrawObject_OnRun(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;
					
		case DEF_OBJECTATTACK:
			DrawObject_OnAttack(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTATTACKMOVE:
			DrawObject_OnAttackMove(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTMAGIC:
			DrawObject_OnMagic(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTDAMAGE:
			DrawObject_OnDamage(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTDYING: 
			DrawObject_OnDying(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTDEAD:
			DrawObject_OnDead(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break; 
		}
	}

	if (m_bIsGetPointingMode == TRUE)
	{		
		if ( (m_iPointCommandType >= 100) && (m_iPointCommandType < 200) )
		{
			// 마법 커서 
			if (m_bCommandAvailable == TRUE)
			{
				if( m_sMCX != NULL )
				{
					if( _iGetFOE(sFocusStatus) < 0 )
						m_stMCursor.sCursorFrame = 5;//적에겐 빨간 화살표
					else m_stMCursor.sCursorFrame = 4;
				}
				else m_stMCursor.sCursorFrame = 4;
			}
			else m_stMCursor.sCursorFrame = 8; // 모래시계
		}
		else if ( (m_iPointCommandType >= 0) && (m_iPointCommandType < 50) )
		{
			// 기술 사용 
			m_stMCursor.sCursorFrame = 10;
		}
	}
}


void CGame::GameRecvMsgHandler(DWORD dwMsgSize, char * pData)
{
 DWORD * dwpMsgID;
	
	dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);

	switch (*dwpMsgID) {
	case MSGID_RESPONSE_CHARGED_TELEPORT:
		ResponseChargedTeleport(pData);
		break;

	case MSGID_RESPONSE_TELEPORT_LIST:
		ResponseTeleportList(pData);
		break;

	case MSGID_RESPONSE_NOTICEMENT:
		NoticementHandler(pData);
		break;
	
	case MSGID_DYNAMICOBJECT:
		DynamicObjectHandler(pData);
		break;

	case MSGID_RESPONSE_INITPLAYER:
		InitPlayerResponseHandler(pData); 
		break;
	
	case MSGID_RESPONSE_INITDATA:
		InitDataResponseHandler(pData);
		break;

	case MSGID_RESPONSE_MOTION:
		MotionResponseHandler(pData);
		break;

	case MSGID_EVENT_COMMON:
		CommonEventHandler(pData);
		break;

	case MSGID_EVENT_MOTION:
		MotionEventHandler(pData);
		break;

	case MSGID_EVENT_LOG:
		LogEventHandler(pData);
		break;

	case MSGID_COMMAND_CHATMSG:
		ChatMsgHandler(pData);
		break;

	case MSGID_PLAYERITEMLISTCONTENTS:
		InitItemList(pData);
		break;

	case MSGID_NOTIFY:
		NotifyMsgHandler(pData);
		break;

	case MSGID_RESPONSE_CREATENEWGUILD:
		// 새 길드 생성요구에 대한 응답.
		CreateNewGuildResponseHandler(pData);
		break;

	case MSGID_RESPONSE_DISBANDGUILD:
		DisbandGuildResponseHandler(pData);
		break;

	case MSGID_PLAYERCHARACTERCONTENTS:
		// 플레이어의 특성치리스트 
		InitPlayerCharacteristics(pData);
		break;
	
	case MSGID_RESPONSE_CIVILRIGHT:
		// 시민권 획득 요청에 대한 응답. 
		CivilRightAdmissionHandler(pData);
		break;

	case MSGID_RESPONSE_RETRIEVEITEM:
		RetrieveItemHandler(pData);
		break;

	case MSGID_RESPONSE_PANNING:
		ResponsePanningHandler(pData);
		break;

// v1.4311-3 변경 메세지 받기 사투장 예약 요청에 대한 응답. 
	case MSGID_RESPONSE_FIGHTZONE_RESERVE:
		ReserveFightzoneResponseHandler(pData);
		break;
	}
}


void CGame::ConnectionEstablishHandler(char cWhere)
{
	if (m_bIsCheckingGateway == FALSE)
		ChangeGameMode(DEF_GAMEMODE_ONWAITINGRESPONSE);
	
	switch (cWhere) {
	case DEF_SERVERTYPE_GAME:
		// 이름과 패스워드를 전송하고 데이터 초기화 시그널을 기다린다.
		bSendCommand(MSGID_REQUEST_INITPLAYER, NULL, NULL, NULL, NULL, NULL, NULL);
		break;

	case DEF_SERVERTYPE_LOG:
		if (m_bIsCheckingGateway == TRUE) {
			// 게이트웨이 커넥션을 체크하는 중이다. MLS에서 Port를 3개 이상 열어놓기 때문에 Gateway Port 주소를 MLS 보다 적은 값으로 설정해야 한다! 주의해야 한다!
			bSendCommand(MSGID_GETMINIMUMLOADGATEWAY, NULL, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			// 
			switch (m_dwConnectMode) {
			case MSGID_REQUEST_LOGIN:
				bSendCommand(MSGID_REQUEST_LOGIN, NULL, NULL, NULL, NULL, NULL, NULL);
				break;

			case MSGID_REQUEST_CREATENEWACCOUNT:
				// 새 계정 생성을 요구하는 메시지를 전송한다. 
				bSendCommand(MSGID_REQUEST_CREATENEWACCOUNT, NULL, NULL, NULL, NULL, NULL, NULL);
				break;

			case MSGID_REQUEST_CREATENEWCHARACTER:
				bSendCommand(MSGID_REQUEST_CREATENEWCHARACTER, NULL, NULL, NULL, NULL, NULL, NULL);
				break;

			case MSGID_REQUEST_ENTERGAME:
				bSendCommand(MSGID_REQUEST_ENTERGAME, NULL, NULL, NULL, NULL, NULL, NULL);
				break;

			case MSGID_REQUEST_DELETECHARACTER:
				bSendCommand(MSGID_REQUEST_DELETECHARACTER, NULL, NULL, NULL, NULL, NULL, NULL);
				break;

			case MSGID_REQUEST_CHANGEPASSWORD:
				bSendCommand(MSGID_REQUEST_CHANGEPASSWORD, NULL, NULL, NULL, NULL, NULL, NULL);
				break;

			case MSGID_REQUEST_INPUTKEYCODE:
				bSendCommand(MSGID_REQUEST_INPUTKEYCODE, NULL, NULL, NULL, NULL, NULL, NULL);
				break;
			}
		}
		break;
	}
}



void CGame::InitPlayerResponseHandler(char * pData)
{
 WORD * wp;
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	switch (*wp) {
	case DEF_MSGTYPE_CONFIRM:
		// 서버의 데이터 초기화 완료. 
		bSendCommand(MSGID_REQUEST_INITDATA, NULL, NULL, NULL, NULL, NULL, NULL);
		ChangeGameMode(DEF_GAMEMODE_ONWAITINGINITDATA);
		break;
		
	case DEF_MSGTYPE_REJECT:
		// v2.15 2002-5-21 월드 서버가 가득 차면 
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		
		// 접속 거부 원인 코드에 맞는 메시지 출력
		ZeroMemory(m_cMsg, sizeof(m_cMsg));

		strcpy(m_cMsg, "3J"); break;

		break;
	}

		
}

#if DEF_LANGUAGE == 2
void CGame::UpdateScreen_OnMainMenu() 
{
 short msX, msY, msZ;
 char cLB, cRB, cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI;
 DWORD dwTime = G_dwGlobalTime;
	
	if (m_cGameModeCount == 0) {

		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket; 
			G_pCalcSocket = NULL;
		}
		
		if ( m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] != NULL ) {
			delete m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING];
			m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = NULL;
		}
		EndInputString();
		
		pMI = new class CMouseInterface; 

		pMI->AddRect(130,160,230,185);
		pMI->AddRect(90,200,265,220);
//		pMI->AddRect(90,240,265,260);
		pMI->AddRect(140,270,230,300);
		m_DInput.m_sX = 400;
		m_DInput.m_sY = 240;

		m_cCurFocus = 1;
		m_cMaxFocus = 3; //4

		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
	}  
	m_cGameModeCount++; 
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;
 
	m_DDraw.ClearBackB4();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, -1, -1, 0, TRUE);


	switch (m_cCurFocus) {

	case 1:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(121 , 161, 1, dwTime);
		break;
	case 2:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(96, 199, 2, dwTime);
		break;
//	case 3:
//		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(121, 234, 3, dwTime);
//		break;
	case 3:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(121, 268, 4, dwTime);
		break;
	}

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
	   	switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// Enter키가 눌렸다. 
		PlaySound('E', 14, 5);
		m_bEnterPressed = FALSE;
		switch (m_cCurFocus) {
		case 1:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			return;
		case 2:
#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONAGREEMENT); 
#else
			GoHomepage();
#endif
			return;
//		case 3:
//			delete pMI;
//			ChangeGameMode(DEF_GAMEMODE_ONINPUTKEYCODE);
//			return;
			
		case 3: //4
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			return;
		}
	}
	
	DrawVersion();

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스 버튼이 클릭되었다.
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		
		case 1:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			delete pMI;
			break;

		case 2:
#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONAGREEMENT); 
#else
			GoHomepage();
#endif
			return;
//		case 3:
//			ChangeGameMode(DEF_GAMEMODE_ONINPUTKEYCODE);
//			delete pMI;
//			break;
		case 3: //4
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			delete pMI;
			break;

		}
	}															   

	if ((msX >= 130) && (msY >= 160) && (msX <= 230) && (msY <= 185)) m_cCurFocus = 1;
	if ((msX >= 90) && (msY >= 200) && (msX <= 265) && (msY <= 220)) m_cCurFocus = 2;
//	if ((msX >= 90) && (msY >= 240) && (msX <= 265) && (msY <= 260)) m_cCurFocus = 3;
	if ((msX >= 140) && (msY >= 270) && (msX <= 230) && (msY <= 300)) m_cCurFocus = 3; //4
	
//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#elif DEF_LANGUAGE == 1

void CGame::UpdateScreen_OnMainMenu() 
{
 short msX, msY, msZ;
 char cLB, cRB, cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI;
 DWORD dwTime = G_dwGlobalTime;
	
	if (m_cGameModeCount == 0) {

		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket; 
			G_pCalcSocket = NULL;
		}
		
		if ( m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] != NULL ) {
			delete m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING];
			m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = NULL;
		}
		EndInputString();
		
		pMI = new class CMouseInterface; 

		pMI->AddRect(120,150,240,191);
		pMI->AddRect(120,192,240,230);

//		pMI->AddRect(120,231,239,262);
		m_DInput.m_sX = 400;
		m_DInput.m_sY = 240;

		m_cCurFocus = 1;
		m_cMaxFocus = 2;

		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
	}  
	m_cGameModeCount++; 
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;
 
	m_DDraw.ClearBackB4();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, -1, -1, 0, TRUE);


	switch (m_cCurFocus) {

	case 1:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(114 , 159, 1, dwTime);
		break;
	case 2:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(82, 197, 2, dwTime);
		break;
	}

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
	   	switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// Enter키가 눌렸다. 
		PlaySound('E', 14, 5);
		m_bEnterPressed = FALSE;
		switch (m_cCurFocus) {
		case 1:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			return;
		case 2:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			return;
		}
	}
	
	DrawVersion();

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스 버튼이 클릭되었다.
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		
		case 1:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			delete pMI;
			break;

		case 2:
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			delete pMI;
			break;

		}
	}															   

	if ((msX >= 120) && (msY >= 150) && (msX <= 240) && (msY <= 191)) m_cCurFocus = 1;
	if ((msX >= 120) && (msY >= 192) && (msX <= 240) && (msY <= 230)) m_cCurFocus = 2;
	
//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#else

void CGame::UpdateScreen_OnMainMenu() 
{
 short msX, msY, msZ;
 char cLB, cRB, cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI;
 DWORD dwTime = G_dwGlobalTime;

 //2002. 10. 29 정진광.. 아이템 버리기용..
 m_iItemDropCnt = 0;
 m_bItemDrop = FALSE;
	
	if (m_cGameModeCount == 0) {

		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket; 
			G_pCalcSocket = NULL;
		}
		
		if ( m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] != NULL ) {
			delete m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING];
			m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = NULL;
		}
		EndInputString();
		
		pMI = new class CMouseInterface; 

		pMI->AddRect(112,150,247,191);
		pMI->AddRect(73,192,281,230);
		pMI->AddRect(120,231,239,262);
		m_DInput.m_sX = 400;
		m_DInput.m_sY = 240;

		m_cCurFocus = 1;
		m_cMaxFocus = 3;

		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
	}  
	m_cGameModeCount++; 
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;
 
	m_DDraw.ClearBackB4();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, -1, -1, 0, TRUE);


	switch (m_cCurFocus) {

	case 1:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(114 , 159, 1, dwTime);
		break;
	case 2:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(82, 197, 2, dwTime);
		break;

	case 3:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(114, 236, 3, dwTime);
		break;
	}

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
	   	switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// Enter키가 눌렸다. 
		PlaySound('E', 14, 5);
		m_bEnterPressed = FALSE;
		switch (m_cCurFocus) {
		case 1:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			return;
		case 2:
#ifndef DEF_FUCK_USA
	#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONAGREEMENT); 
	#else
			GoHomepage();
	#endif
#endif
			return;
		case 3:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			return;
		}
	}
	
	DrawVersion();

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스 버튼이 클릭되었다.
		PlaySound('E', 14, 5);
		m_cCurFocus = iMIbuttonNum;
		switch (iMIbuttonNum)
		{
		case 1:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			delete pMI;
			break;

		case 2:
#ifndef DEF_FUCK_USA
	#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONAGREEMENT); 
	#else
			GoHomepage();
	#endif
#endif
			return;
		case 3:
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			delete pMI;
			break;
		}
	}

//	if ((msX >= 112) && (msY >= 150) && (msX <= 247) && (msY <= 191)) m_cCurFocus = 1;
//	if ((msX >= 73) && (msY >= 192) && (msX <= 281) && (msY <= 230)) m_cCurFocus = 2;
//	if ((msX >= 120) && (msY >= 231) && (msX <= 239) && (msY <= 262)) m_cCurFocus = 3;
	
//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#endif

void CGame::MakeSprite( char* FileName, short sStart, short sCount, bool bAlphaEffect )
{
	int iTotalimage;
	DWORD nCount;
	char PathName[28];
	wsprintf( PathName, "sprites\\%s.pak", FileName );
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( m_hPakFile == INVALID_HANDLE_VALUE ) return;
	SetFilePointer(m_hPakFile, 20, NULL, FILE_BEGIN);
	ReadFile(m_hPakFile, (char *)&iTotalimage, 4, &nCount, NULL);
	for( short i=0 ; i < sCount ; i++ )
	{
		if( i < iTotalimage ) m_pSprite[i+sStart] = new class CSprite(m_hPakFile, &m_DDraw, FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::MakeTileSpr( char* FileName, short sStart, short sCount, bool bAlphaEffect )
{
	int iTotalimage;
	DWORD nCount;
	char PathName[28];
	wsprintf( PathName, "sprites\\%s.pak", FileName );
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( m_hPakFile == INVALID_HANDLE_VALUE ) return;
	SetFilePointer(m_hPakFile, 20, NULL, FILE_BEGIN);
	ReadFile(m_hPakFile, (char *)&iTotalimage, 4, &nCount, NULL);
	for( short i=0 ; i < sCount ; i++ )
	{
		if( i < iTotalimage ) m_pTileSpr[i+sStart] = new class CSprite(m_hPakFile, &m_DDraw, FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::MakeEffectSpr( char* FileName, short sStart, short sCount, bool bAlphaEffect )
{
	int iTotalimage;
	DWORD nCount;
	char PathName[28];
	wsprintf( PathName, "sprites\\%s.pak", FileName );
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( m_hPakFile == INVALID_HANDLE_VALUE ) return;
	SetFilePointer(m_hPakFile, 20, NULL, FILE_BEGIN);
	ReadFile(m_hPakFile, (char *)&iTotalimage, 4, &nCount, NULL);
	for( short i=0 ; i < sCount ; i++ )
	{
		if( i < iTotalimage ) m_pEffectSpr[i+sStart] = new class CSprite(m_hPakFile, &m_DDraw, FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

//정진광 수정, 함수 전체적으로..수정을 많이 했다..
//CSprite class 의 새로 작성한 생성자를 사용하도록 소스를 수정.
//원본은, 이 함수 아래에 주석처리..
void CGame::UpdateScreen_OnLoading(bool bActive)
{ 
	int i;
	if( bActive ) UpdateScreen_OnLoading_Progress();

	switch( m_cLoading )
	{
	case 0:
		{
			m_hPakFile = CreateFile("sprites\\interface.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_MOUSECURSOR] = new class CSprite(m_hPakFile, &m_DDraw, "interface", 0, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS] = new class CSprite(m_hPakFile, &m_DDraw, "interface", 1, FALSE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\interface2.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 1, FALSE); 
				m_pSprite[DEF_SPRID_INTERFACE_F1HELPWINDOWS] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 2, FALSE);
				CloseHandle(m_hPakFile);
			}

			// 폰트 
			m_hPakFile = CreateFile("sprites\\sprfonts.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_FONT1] = new class CSprite(m_hPakFile, &m_DDraw, "sprfonts", 0, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_FONT2] = new class CSprite(m_hPakFile, &m_DDraw, "sprfonts", 1, FALSE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\Newmaps.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 0, FALSE); 
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 1, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 2, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 3, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 4, FALSE); 
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\LoginDialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN] = new class CSprite(m_hPakFile, &m_DDraw, "LoginDialog", 0, FALSE); 
#ifdef DEF_MAKE_ACCOUNT // v2.172
				m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, &m_DDraw, "LoginDialog", 1, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_AGREEMENT] = new class CSprite(m_hPakFile, &m_DDraw, "LoginDialog", 2, FALSE);
#endif
				CloseHandle(m_hPakFile);
			}
			m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 1, FALSE); 
				m_pSprite[DEF_SPRID_INTERFACE_ND_QUIT] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 2, FALSE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\GameDialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_ND_GAME1] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 0, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 1, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_GAME3] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 2, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 3, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE] =    new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 4, FALSE);
				//m_pSprite[DEF_SPRID_INTERFACE_GUIDEMAP] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 5, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 6, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_INVENTORY] =  new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 7, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_SELECTCHAR] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 8, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_NEWCHAR] =    new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 9, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_NEWEXCHANGE] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 10, FALSE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\DialogText.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_ND_TEXT] = new class CSprite(m_hPakFile, &m_DDraw, "DialogText", 0, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON] = new class CSprite(m_hPakFile, &m_DDraw, "DialogText", 1, FALSE);
				CloseHandle(m_hPakFile);
			}

			//2003.06.09 정진광 추가. 중국 진정피드백 카드
			#ifdef DEF_FEEDBACKCARD

			m_hPakFile = CreateFile("sprites\\FeedBack.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_FEEDBACK1] =      new class CSprite(m_hPakFile, &m_DDraw, "FeedBack", 0, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_FEEDBACK2] =      new class CSprite(m_hPakFile, &m_DDraw, "FeedBack", 1, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_FEEDBACK3] =      new class CSprite(m_hPakFile, &m_DDraw, "FeedBack", 2, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_FEEDBACK4] =      new class CSprite(m_hPakFile, &m_DDraw, "FeedBack", 3, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_FEEDBACK5] =		new class CSprite(m_hPakFile, &m_DDraw, "FeedBack", 4, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_FEEDBACK6] =		new class CSprite(m_hPakFile, &m_DDraw, "FeedBack", 5, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_FEEDBACK7] =		new class CSprite(m_hPakFile, &m_DDraw, "FeedBack", 6, FALSE);
				
				CloseHandle(m_hPakFile);
			}

			#endif

			MakeSprite( "Telescope", DEF_SPRID_INTERFACE_GUIDEMAP, 26, FALSE);//v2.181 2002-10-25 안상하추가 주변가이드맵용
			MakeSprite( "monster", DEF_SPRID_INTERFACE_MONSTER, 1, FALSE);//v2.2 2002-12-4 안상하추가 가이드맵 몬스터 이벤트용
			m_cLoading = 4;
		}
		break;
	case 4:
		{
			MakeTileSpr( "maptiles1", 0, 32, TRUE);
			m_hPakFile = CreateFile("sprites\\structures1.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); //안쓰는 타일 로딩 안한다.2002.09.06상하
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pTileSpr[1 + 50] = new class CSprite(m_hPakFile, &m_DDraw, "structures1",  1, TRUE);
				m_pTileSpr[5 + 50] = new class CSprite(m_hPakFile, &m_DDraw, "structures1",  5, TRUE);
				CloseHandle(m_hPakFile);
			}
			MakeTileSpr( "Sinside1", 70, 27, FALSE);// 건물 내부 1 
			MakeTileSpr( "Trees1", 100, 46, TRUE);// 맵 타일 - 나무
			MakeTileSpr( "TreeShadows", 150, 46, TRUE);// 나무 그림자 
			MakeTileSpr( "objects1", 200, 8, TRUE);// 오브젝트
			MakeTileSpr( "objects2", 211, 5, TRUE);// 종유석, 오벨리스크 등등  
			MakeTileSpr( "objects3", 216, 4, TRUE);
			MakeTileSpr( "objects4", 220, 1, TRUE);
			m_cLoading = 8;
		}
		break;
	case 8:
		{
			MakeTileSpr( "Tile223-225", 223, 3, TRUE);
			MakeTileSpr( "Tile226-229", 226, 4, TRUE);
			MakeTileSpr( "maptiles2", 300, 15, TRUE);// 맵 타일 2 - Index 300번 부터 10010번 부터 저장됨 
			MakeTileSpr( "maptiles4", 320, 10, TRUE);// 맵 타일 4 - Index 300번 부터 10010번 부터 저장됨 
			MakeTileSpr( "maptiles5", 330, 19, TRUE);// 맵 타일 5 - Index 300번 부터 10010번 부터 저장됨 
			MakeTileSpr( "maptiles6", 349, 4, TRUE);// 맵 타일 6 - Index 300번 부터 10010번 부터 저장됨 
			MakeTileSpr( "maptiles353-361", 353, 9, TRUE);// 맵 타일 7 - Index 300번 부터 10010번 부터 저장됨 
			MakeTileSpr( "Tile363-366", 363, 4, TRUE);// 맵 타일 8 - Index 300번 부터 10010번 부터 저장됨  
			MakeTileSpr( "Tile370-381", 370, 12, TRUE);// 맵타일 인덱스를 사용하는 오브젝트 로드 Tile370~381
			MakeTileSpr( "Tile382-387", 382, 6, TRUE);
			MakeTileSpr( "Tile388-402", 388, 15, TRUE);
			m_cLoading = 12;
		}
		break;
	case 12:
		{
			MakeTileSpr( "Tile403-405", 403, 3, TRUE);
			MakeTileSpr( "Tile406-421", 406, 16, TRUE);
			MakeTileSpr( "Tile422-429", 422, 8, TRUE);
			MakeTileSpr( "Tile430-443", 430, 14, TRUE);
			MakeTileSpr( "Tile444-444", 444, 1, TRUE);
			MakeTileSpr( "Tile445-461",	445, 17, TRUE);
			// DEF_SPRID_ITEMPACK_PIVOTPOINT+0은 아이템이 없다. 가방에 놓이고 드래깅할때 쓰이는 아이템 
			MakeSprite( "item-pack", DEF_SPRID_ITEMPACK_PIVOTPOINT+1, 17, FALSE);
			m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT+20] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 17, FALSE);// 망토류
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT+21] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 18, FALSE);// 헬름
				CloseHandle(m_hPakFile);
			}

			// DEF_SPRID_ITEMGROUND_PIVOTPOINT+0은 아이템이 없다. 바닥에 놓일때 아이템 
			MakeSprite( "item-ground", DEF_SPRID_ITEMGROUND_PIVOTPOINT+1, 17, FALSE);
			m_hPakFile = CreateFile("sprites\\item-ground.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT+20] = new class CSprite(m_hPakFile, &m_DDraw, "item-ground", 17, FALSE);	// 망토류 
				m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT+21] = new class CSprite(m_hPakFile, &m_DDraw, "item-ground", 18, FALSE);	// 헬름
				CloseHandle(m_hPakFile);
			}
			// 동적 객체 아이템 
			MakeSprite( "item-dynamic", DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT, 2, FALSE);// 0-헤엄치는 물고기, 1- 광물, 2- 깃발
			m_cLoading = 16;
		}
		break;
	case 16:
		{
			// 장착화면용 아이템
			// 남자 
			m_hPakFile = CreateFile("sprites\\item-equipM.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 0, FALSE);	// 몸통 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 1] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 1, FALSE);	// 칼 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 2] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 2, FALSE);	// 활 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 3] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 3, FALSE);	// 방패 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 4] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 4, FALSE);	// 남자 겉옷 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 5] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 5, FALSE);	// 부츠
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 7] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 6, FALSE);	// 남자 속옷 상의 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 8] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 7, FALSE);	// 남자 바지 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 9] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 8, FALSE);	// 남자 갑옷 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 15] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 11, FALSE);  // 도끼
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 17] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 12, FALSE);  // 지팡이
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 9, FALSE);// 남자 머리
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 10, FALSE);// 남자 속옷 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 20] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 13, FALSE);// 남자 망토 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 21] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 14, FALSE);// 헬름
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 16] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 15);// 보석류 ! 가방의 것을 그대로 쓴다 
				CloseHandle(m_hPakFile);
			}

			// 여자 
			m_hPakFile = CreateFile("sprites\\item-equipW.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 0, FALSE); // 몸통 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 41] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 1, FALSE); // 칼 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 42] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 2, FALSE); // 활 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 43] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 3, FALSE); // 방패 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 45] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 4, FALSE); // 부츠
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 50] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 5, FALSE); // 여자 겉옷 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 51] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 6, FALSE); // 여자 속옷 상의  
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 52] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 7, FALSE); // 여자 바지 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 53] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 8, FALSE); // 여자 갑옷 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 55] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 11, FALSE); // 도끼 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 57] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 12, FALSE); // 지팡이 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 58] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 9, FALSE); // 여자 머리
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 59] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 10, FALSE);// 여자 속옷 
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 60] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 13, FALSE);// 여자 망토  
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 61] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 14, FALSE);// 헬름 
				CloseHandle(m_hPakFile);
			}
			
			m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 56] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 15);// 보석류 ! 남,여 구분 없이 가방의 것을 그대로 쓴다 
				CloseHandle(m_hPakFile);
			}
			MakeSprite( "Bm", 500 + 15*8*0, 96, TRUE);// Black Man (Type: 1)
			MakeSprite( "Wm", 500 + 15*8*1, 96, TRUE);// White Man (Type: 2)
			MakeSprite( "Ym", 500 + 15*8*2, 96, TRUE);// Yellow Man (Type: 3)
			m_cLoading = 20;
		}
		break;
	case 20:
		{
			MakeSprite( "Bw", 500 + 15*8*3, 96, TRUE);// Black Woman (Type: 4)
			MakeSprite( "Ww", 500 + 15*8*4, 96, TRUE);// White Woman (Type: 5)
			MakeSprite( "Yw", 500 + 15*8*5, 96, TRUE);// Yellow Woman (Type: 6)
			m_cLoading = 24;
		}
		break;
	case 24:
		{
			MakeSprite( "slm",		1220 + 7*8*0, 40, TRUE);// Slime (Type: 10) 
			MakeSprite( "ske",		1220 + 7*8*1, 40, TRUE);// Skeleton (Type: 11) 
			MakeSprite( "Gol",		1220 + 7*8*2, 40, TRUE);// Stone-Golem (Type: 12) 
			MakeSprite( "Cyc",		1220 + 7*8*3, 40, TRUE);// Cyclops (Type: 13) 
			MakeSprite( "Orc",		1220 + 7*8*4, 40, TRUE);// Orc (Type: 14) 
			MakeSprite( "Shopkpr",	1220 + 7*8*5,  8);// ShopKeeper-Woman (Type: 15) 
			MakeSprite( "Ant",		1220 + 7*8*6, 40, TRUE);//  Giant-Ant (Type: 16) 
			MakeSprite( "Scp",		1220 + 7*8*7, 40, TRUE);//  Scorpion (Type: 17) 
			MakeSprite( "Zom",		1220 + 7*8*8, 40, TRUE);//  Zombie (Type: 18) 
			MakeSprite( "Gandlf",	1220 + 7*8*9,  8, TRUE);// Gandalf 마법사 길드장 (Type: 19)
			MakeSprite( "Howard",	1220 + 7*8*10, 8, TRUE);// Howard 보관소 주인 (Type: 20)
			m_cLoading = 28;
		}
		break;
	case 28:
		{
			MakeSprite( "Guard",	1220 + 7*8*11, 40, TRUE);// Guard (Type: 21) 
			MakeSprite( "Amp",		1220 + 7*8*12, 40, TRUE);// Amphis (Type: 22) 
			MakeSprite( "Cla",		1220 + 7*8*13, 40, TRUE);// Clay-Golem (Type: 23) 
			MakeSprite( "tom",		1220 + 7*8*14,  8, TRUE);// Tom (Type: 24) 
			MakeSprite( "William",	1220 + 7*8*15,  8, TRUE);// William (Type: 25) 
			MakeSprite( "Kennedy",	1220 + 7*8*16,  8, TRUE);// Kennedy (Type: 26) 
			MakeSprite( "Helb",		1220 + 7*8*17, 40, TRUE);// Hellbound (Type: 27) 
			MakeSprite( "Troll",	1220 + 7*8*18, 40, TRUE);// Troll (Type: 28) 
			m_cLoading = 32;
		}
		break;
	case 32:
		{
			MakeSprite( "Orge",		1220 + 7*8*19, 40, TRUE);// Orge (Type: 29) 
			MakeSprite( "Liche",	1220 + 7*8*20, 40, TRUE);// Liche (Type: 30) 
			MakeSprite( "Demon",	1220 + 7*8*21, 40, TRUE);// Demon (Type: 31) 
			MakeSprite( "Unicorn",	1220 + 7*8*22, 40, TRUE);// Unicorn (Type: 32) 
			MakeSprite( "WereWolf",	1220 + 7*8*23, 40, TRUE);// WereWolf (Type: 33) 
			MakeSprite( "Dummy",	1220 + 7*8*24, 40, TRUE);// Dummy (Type: 34) 
			m_hPakFile = CreateFile("sprites\\Effect5.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); // Energy-Ball (Type: 35) 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 40; i++)
					m_pSprite[1220 + i + 7*8*25] = new class CSprite(m_hPakFile, &m_DDraw, "Effect5.pak", 0, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_cLoading = 36;
		}
		break;
	case 36:
		{
			MakeSprite( "GT-Arrow",		1220 + 7*8*26, 40, TRUE);// Arrow-GuardTower (Type: 36) 
			MakeSprite( "GT-Cannon",	1220 + 7*8*27, 40, TRUE);// Cannon-GuardTower (Type: 37) 
			MakeSprite( "ManaCollector",1220 + 7*8*28, 40, TRUE);// Mana Collector (Type: 38)
			MakeSprite( "Detector",		1220 + 7*8*29, 40, TRUE);// Detector (Type: 39) 
			MakeSprite( "ESG",			1220 + 7*8*30, 40, TRUE);// ESG (Type: 40) 
			MakeSprite( "GMG",			1220 + 7*8*31, 40, TRUE);// GMG (Type: 41) 
			MakeSprite( "ManaStone",	1220 + 7*8*32, 40, TRUE);// ManaStone (Type: 42) 
			MakeSprite( "LWB",			1220 + 7*8*33, 40, TRUE);// Light War Beetle (Type: 43) 
			m_cLoading = 40;
		}
		break;
	case 40:
		{
			MakeSprite( "GHK",		1220 + 7*8*34, 40, TRUE);// God's Hand Knight (Type: 44) 
			MakeSprite( "GHKABS",	1220 + 7*8*35, 40, TRUE);// God's Hand Knight with Armored Battle Steed (Type: 45) 
			MakeSprite( "TK",		1220 + 7*8*36, 40, TRUE);// Temple Knight (Type: 46) 
			MakeSprite( "BG",		1220 + 7*8*37, 40, TRUE);// Battle Golem (Type: 47) 
			MakeSprite( "Stalker",	1220 + 7*8*38, 40, TRUE);// Stalker (Type: 48) 
			MakeSprite( "Hellclaw",	1220 + 7*8*39, 40, TRUE);// Hellclaw (Type: 49) 
			MakeSprite( "Tigerworm",1220 + 7*8*40, 40, TRUE);// Tigerworm (Type: 50) 
			m_cLoading = 44;
		}
		break;
	case 44:
		{
			MakeSprite( "Catapult",	1220 + 7*8*41, 40, TRUE);// Catapult (Type: 51) 
			MakeSprite( "Gagoyle",	1220 + 7*8*42, 40, TRUE);// Gargoyle (Type: 52) 
			MakeSprite( "Beholder",	1220 + 7*8*43, 40, TRUE);// Beholder (Type: 53) 
			MakeSprite( "DarkElf",	1220 + 7*8*44, 40, TRUE);// Dark-Elf (Type: 54) 
			MakeSprite( "Bunny",	1220 + 7*8*45, 40, TRUE);// Bunny (Type: 55) 
			m_cLoading = 48;
		}
		break;
	case 48:
		{
			MakeSprite( "Cat",		1220 + 7*8*46, 40, TRUE);// Cat (Type: 56) 
			MakeSprite( "GiantFrog",1220 + 7*8*47, 40, TRUE);// GiantFrog (Type: 57) 
			MakeSprite( "MTGiant",	1220 + 7*8*48, 40, TRUE);// Mountain Giant (Type: 58) 
			MakeSprite( "Ettin",	1220 + 7*8*49, 40, TRUE);// Ettin (Type: 59) 
			MakeSprite( "CanPlant",	1220 + 7*8*50, 40, TRUE);// Cannibal Plant (Type: 60) 
			MakeSprite( "Rudolph",	1220 + 7*8*51, 40, TRUE);// Rudolph (Type: 61) 
			MakeSprite( "DireBoar",	1220 + 7*8*52, 40, TRUE);// 멧돼지 (Type: 62) 
			MakeSprite( "frost",	1220 + 7*8*53, 40, TRUE);// 아이스팅커벨 (Type: 63) 
			MakeSprite( "Crop",		1220 + 7*8*54, 40, TRUE);// 콩나물 오브젝트 (Type: 64)
			MakeSprite( "IceGolem",	1220 + 7*8*55, 40, TRUE);// 아이스골렘 (Type: 65) 
			MakeSprite( "Wyvern",	1220 + 7*8*56, 40, TRUE);// 와이번 (Type: 66) 
			MakeSprite( "McGaffin",	1220 + 7*8*57, 16, TRUE);// 청년 (Type: 67) 
			MakeSprite( "Perry",	1220 + 7*8*58, 16, TRUE);// 처녀 (Type: 68) 
			MakeSprite( "Devlin",	1220 + 7*8*59, 16, TRUE);// 마을마법사 (Type: 69) 
			// 남자 속옷 0~7 
			m_hPakFile = CreateFile("sprites\\Mpt.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 12; i++) m_pSprite[4580 + i + 15*0] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*0, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4580 + i + 15*1] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*1, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4580 + i + 15*2] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*2, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4580 + i + 15*3] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*3, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4580 + i + 15*4] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*4, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4580 + i + 15*5] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*5, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4580 + i + 15*6] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*6, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4580 + i + 15*7] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*7, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_cLoading = 52;
		}
		break;
	case 52:
		{
			// 남자 머리 
			m_hPakFile = CreateFile("sprites\\Mhr.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 12; i++) m_pSprite[4820 + i + 15*0] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*0, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4820 + i + 15*1] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*1, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4820 + i + 15*2] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*2, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4820 + i + 15*3] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*3, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4820 + i + 15*4] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*4, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4820 + i + 15*5] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*5, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4820 + i + 15*6] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*6, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[4820 + i + 15*7] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*7, TRUE);
				CloseHandle(m_hPakFile);
			}
			// 남자 몸통 갑옷 1~15 (0번은 없음)
			MakeSprite( "MLArmor",	5060 + 15*1, 12, TRUE); // 가죽 갑옷 
			MakeSprite( "MCMail",	5060 + 15*2, 12, TRUE); // 체인 메일
			MakeSprite( "MSMail",	5060 + 15*3, 12, TRUE); // 스케일 메일
			MakeSprite( "MPMail",	5060 + 15*4, 12, TRUE); // 플레이트 메일
			MakeSprite( "Mtunic",	5060 + 15*5, 12, TRUE); // 튜닉
			MakeSprite( "MRobe1",	5060 + 15*6, 12, TRUE); // 로브
			MakeSprite( "MSanta",	5060 + 15*7, 12, TRUE); // 산타복
			// 남자 팔 갑옷 1~15 (0번은 없음)
			MakeSprite( "MShirt",	5300 + 15*1, 12, TRUE); // 셔츠
			MakeSprite( "MHauberk",	5300 + 15*2, 12, TRUE); // 호버크
			m_cLoading = 56;
		}
		break;
	case 56:
		{
			// 남자 바지 & 하체 갑옷 1~15 (0번은 없음)
			MakeSprite( "MTrouser",	5540 + 15*1, 12, TRUE); // 롱팬츠
			MakeSprite( "MHTrouser",5540 + 15*2, 12, TRUE); // 반바지
			MakeSprite( "MCHoses",	5540 + 15*3, 12, TRUE); // 체인 호스
			MakeSprite( "MLeggings",5540 + 15*4, 12, TRUE); // 플레이트 레깅스
			// 남자 부츠 1~15 (0번은 없음)
			MakeSprite( "MShoes",	5780 + 15*1, 12, TRUE); // 신발
			MakeSprite( "MLBoots",	5780 + 15*2, 12, TRUE); // 부츠
			// 남자 칼 - 동작용 1~12 (0번은 없음)
			m_hPakFile = CreateFile("sprites\\Msw.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*1] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*0, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*2] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*1, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*3] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*2, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*4] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*3, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*6] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*5, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*7] = new class CSprite(m_hPakFile, &m_DDraw,  "Msw", i + 56*6, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*8] = new class CSprite(m_hPakFile, &m_DDraw,  "Msw", i + 56*7, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*9] = new class CSprite(m_hPakFile, &m_DDraw,  "Msw", i + 56*8, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*10] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*9, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*11] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*10, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*12] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*11, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_cLoading = 60;
		}
		break;
	case 60:
		{
			// v2.13 엑스칼리버 이미지로 대체 
			MakeSprite( "Mswx", 6020 + 64*5, 56, TRUE);
			MakeSprite( "Msw2", 6020 + 64*13, 56, TRUE);
			MakeSprite( "MAxe1", 6020 + 64*20, 56, TRUE);// Axe
			MakeSprite( "MAxe2", 6020 + 64*21, 56, TRUE);
			m_cLoading = 64;
		}
		break;
	case 64:
		{
			MakeSprite( "MAxe3", 6020 + 64*22, 56, TRUE);
			MakeSprite( "MAxe4", 6020 + 64*23, 56, TRUE);
			MakeSprite( "MAxe5", 6020 + 64*24, 56, TRUE);
			MakeSprite( "MPickAxe1", 6020 + 64*25, 56, TRUE);
			MakeSprite( "MAxe6", 6020 + 64*26, 56, TRUE);
			MakeSprite( "Mhoe", 6020 + 64*27, 56, TRUE);
			m_cLoading = 68;
		}
		break;
	case 68:
		{
			MakeSprite( "MHammer", 6020 + 64*30, 56, TRUE);
			MakeSprite( "MBHammer", 6020 + 64*31, 56, TRUE);
			MakeSprite( "Mstaff1", 6020 + 64*35, 56, TRUE);// Staff
			MakeSprite( "Mstaff2", 6020 + 64*36, 56, TRUE);
			m_cLoading = 72;
		}
		break;
	case 72:
		{
			// Bow (ID: 40번부터이므로) 
			MakeSprite( "Mbo", 6020 + 64*40, 56, TRUE);
//			m_hPakFile = CreateFile("sprites\\Mbo.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
//			for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*40] = new class CSprite(m_hPakFile, &m_DDraw, "Mbo", i + 56*0, TRUE);
			m_hPakFile = CreateFile("sprites\\Mbo.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 56; i++) m_pSprite[6020 + i + 64*41] = new class CSprite(m_hPakFile, &m_DDraw, "Mbo", i + 56*1, TRUE);
				CloseHandle(m_hPakFile);
			}
			// 남자 방패 - 동작용 1~9 (0번은 없음)
			m_hPakFile = CreateFile("sprites\\Msh.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 7; i++) m_pSprite[9100 + i + 8*1] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*0, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[9100 + i + 8*2] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*1, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[9100 + i + 8*3] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*2, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[9100 + i + 8*4] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*3, TRUE);
				for (i = 0; i < 7; i++)	m_pSprite[9100 + i + 8*5] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*4, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[9100 + i + 8*6] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*5, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[9100 + i + 8*7] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*6, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[9100 + i + 8*8] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*7, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[9100 + i + 8*9] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*8, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_cLoading = 76;
		}
		break;
	case 76:
		{
			MakeSprite( "Mmantle01", 9230 + 15*1, 12, TRUE);// 남자 망또 
			MakeSprite( "Mmantle02", 9230 + 15*2, 12, TRUE);
			MakeSprite( "Mmantle03", 9230 + 15*3, 12, TRUE);
			MakeSprite( "MHelm1", 9300 + 15*1, 12, TRUE);// 9300번부터 투구 
			MakeSprite( "MHelm2", 9300 + 15*2, 12, TRUE);
			MakeSprite( "MHelm3", 9300 + 15*3, 12, TRUE);
			MakeSprite( "MHelm4", 9300 + 15*4, 12, TRUE);
			MakeSprite( "NMHelm1", 9300 + 15*5, 12, TRUE);
			MakeSprite( "NMHelm2", 9300 + 15*6, 12, TRUE);
			MakeSprite( "NMHelm3", 9300 + 15*7, 12, TRUE);
			MakeSprite( "NMHelm4", 9300 + 15*8, 12, TRUE);
			// 여자 속옷 0~7 
			m_hPakFile = CreateFile("sprites\\Wpt.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 12; i++) m_pSprite[14580 + i + 15*0] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14580 + i + 15*1] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14580 + i + 15*2] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*2, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14580 + i + 15*3] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*3, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14580 + i + 15*4] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*4, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14580 + i + 15*5] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*5, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14580 + i + 15*6] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*6, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14580 + i + 15*7] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*7, TRUE);
				CloseHandle(m_hPakFile);
			}
			
			// 여자 머리 
			m_hPakFile = CreateFile("sprites\\Whr.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 12; i++) m_pSprite[14820 + i + 15*0] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 0, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14820 + i + 15*1] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14820 + i + 15*2] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*2, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14820 + i + 15*3] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*3, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14820 + i + 15*4] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*4, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14820 + i + 15*5] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*5, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14820 + i + 15*6] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*6, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[14820 + i + 15*7] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*7, TRUE);
				CloseHandle(m_hPakFile);
			}

			m_cLoading = 80;
		}
		break;
	case 80:
		{
			MakeSprite( "WBodice1", 15060 + 15*1, 12, TRUE);// 여자 몸통 갑옷 1~15 (0번은 없음)
			MakeSprite( "WBodice2", 15060 + 15*2, 12, TRUE);
			MakeSprite( "WLArmor", 15060 + 15*3, 12, TRUE);
			MakeSprite( "WCMail", 15060 + 15*4, 12, TRUE);
			MakeSprite( "WSMail", 15060 + 15*5, 12, TRUE);
			MakeSprite( "WPMail", 15060 + 15*6, 12, TRUE);
			MakeSprite( "WRobe1", 15060 + 15*7, 12, TRUE);
			MakeSprite( "WSanta", 15060 + 15*8, 12, TRUE);
			MakeSprite( "WChemiss", 15300 + 15*1, 12, TRUE);// 여자 팔 갑옷 1~15 (0번은 없음)
			MakeSprite( "WShirt", 15300 + 15*2, 12, TRUE);
			MakeSprite( "WHauberk", 15300 + 15*3, 12, TRUE);
			MakeSprite( "WSkirt", 15540 + 15*1, 12, TRUE);// 여자 바지 & 하체 갑옷 1~15 (0번은 없음)
			MakeSprite( "WTrouser", 15540 + 15*2, 12, TRUE);
			MakeSprite( "WHTrouser", 15540 + 15*3, 12, TRUE);
			MakeSprite( "WCHoses", 15540 + 15*4, 12, TRUE);
			MakeSprite( "WLeggings", 15540 + 15*5, 12, TRUE);
			MakeSprite( "WShoes", 15780 + 15*1, 12, TRUE);// 여자 부츠 1~15 (0번은 없음)
			MakeSprite( "WLBoots", 15780 + 15*2, 12, TRUE);
			m_cLoading = 84;
		}
		break;
	case 84:
		{
			// 여자 칼 - 동작용 1~12 (0번은 없음)
			m_hPakFile = CreateFile("sprites\\Wsw.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*1] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*0, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*2] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*1, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*3] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*2, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*4] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*3, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*6] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*5, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*7] = new class CSprite(m_hPakFile, &m_DDraw,  "Wsw", i + 56*6, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*8] = new class CSprite(m_hPakFile, &m_DDraw,  "Wsw", i + 56*7, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*9] = new class CSprite(m_hPakFile, &m_DDraw,  "Wsw", i + 56*8, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*10] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*9, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*11] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*10, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*12] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*11, TRUE);
				CloseHandle(m_hPakFile);
			}
			MakeSprite( "Wswx", 16020 + 64*5, 56, TRUE);// v2.13 엑스칼리버 
			MakeSprite( "Wsw2", 16020 + 64*13, 56, TRUE);
			m_cLoading = 88;
		}
		break;
	case 88:
		{
			MakeSprite( "Wmantle01", 19230 + 15*1, 12, TRUE);// 여자 망또 
			MakeSprite( "Wmantle02", 19230 + 15*2, 12, TRUE);
			MakeSprite( "Wmantle03", 19230 + 15*3, 12, TRUE);
			// 19300번부터 투구 
			MakeSprite( "WHelm1", 19300 + 15*1, 12, TRUE);
			MakeSprite( "WHelm4", 19300 + 15*4, 12, TRUE);
			MakeSprite( "NWHelm1", 19300 + 15*5, 12, TRUE);
			MakeSprite( "NWHelm2", 19300 + 15*6, 12, TRUE);
			MakeSprite( "NWHelm3", 19300 + 15*7, 12, TRUE);
			MakeSprite( "NWHelm4", 19300 + 15*8, 12, TRUE);
			MakeSprite( "WAxe1", 16020 + 64*20, 56, TRUE);// Axe
			MakeSprite( "WAxe2", 16020 + 64*21, 56, TRUE);
			MakeSprite( "WAxe3", 16020 + 64*22, 56, TRUE);
			m_cLoading = 92;
		}
		break;
	case 92:
		{
			MakeSprite( "WAxe4", 16020 + 64*23, 56, TRUE);
			MakeSprite( "WAxe5", 16020 + 64*24, 56, TRUE);
			MakeSprite( "WpickAxe1", 16020 + 64*25, 56, TRUE);
			MakeSprite( "WAxe6", 16020 + 64*26, 56, TRUE);
			MakeSprite( "Whoe", 16020 + 64*27, 56, TRUE);
			MakeSprite( "WHammer", 16020 + 64*30, 56, TRUE);
			MakeSprite( "WBHammer", 16020 + 64*31, 56, TRUE);
			m_cLoading = 96;
		}
		break;
	case 96:
		{
			MakeSprite( "Wstaff1", 16020 + 64*35, 56, TRUE);// Staff
			MakeSprite( "Wstaff2", 16020 + 64*36, 56, TRUE);
			MakeSprite( "Wbo", 16020 + 64*40, 56, TRUE);// Bow (ID: 40번부터이므로) 
			m_hPakFile = CreateFile("sprites\\Wbo.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 56; i++) m_pSprite[16020 + i + 64*41] = new class CSprite(m_hPakFile, &m_DDraw, "Wbo", i + 56*1, TRUE);
				CloseHandle(m_hPakFile);
			}
			// 여자 방패 - 동작용 1~9 (0번은 없음)
			m_hPakFile = CreateFile("sprites\\Wsh.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 7; i++) m_pSprite[19100 + i + 8*1] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*0, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[19100 + i + 8*2] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*1, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[19100 + i + 8*3] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*2, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[19100 + i + 8*4] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*3, TRUE);
				for (i = 0; i < 7; i++)	m_pSprite[19100 + i + 8*5] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*4, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[19100 + i + 8*6] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*5, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[19100 + i + 8*7] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*6, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[19100 + i + 8*8] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*7, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[19100 + i + 8*9] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*8, TRUE);
				CloseHandle(m_hPakFile);
			}

			m_cLoading = 100;
		}
		break;
	case 100:
		{
			MakeEffectSpr( "effect", 0, 10, FALSE);
			MakeEffectSpr( "effect2", 10, 3, FALSE);
			MakeEffectSpr( "effect3", 13, 6, FALSE);
			MakeEffectSpr( "effect4", 19, 5, FALSE);
			m_hPakFile = CreateFile("sprites\\effect5.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i <= 6; i++)
					m_pEffectSpr[i+ 24] = new class CSprite(m_hPakFile, &m_DDraw, "effect5", i+1, FALSE);
				CloseHandle(m_hPakFile);
			}
			MakeEffectSpr( "CruEffect1", 31, 9, FALSE);
			MakeEffectSpr( "effect6", 40, 5, FALSE);
			MakeEffectSpr( "effect7", 45, 12, FALSE);
			MakeEffectSpr( "effect8", 57, 9, FALSE);
			MakeEffectSpr( "effect9", 66, 21, FALSE);

			if (m_bSoundFlag) {
				for (i = 1; i <= 24; i++) {
					wsprintf(G_cTxt, "sounds\\C%d.wav", i);
					m_pCSound[i] = new class CSoundBuffer(m_DSound.m_lpDS, m_DSound.m_DSCaps, G_cTxt);
				}
			
				//2002.09 정진광 수정, 새로 추가된 몬스터 사운드 추가. 에틴, 산중거인, 식인식물
				for (i = 1; i <= 98; i++) {
					wsprintf(G_cTxt, "sounds\\M%d.wav", i);
					m_pMSound[i] = new class CSoundBuffer(m_DSound.m_lpDS, m_DSound.m_DSCaps, G_cTxt);
				}
				for (i = 1; i <= 47; i++) {
					wsprintf(G_cTxt, "sounds\\E%d.wav", i);
					m_pESound[i] = new class CSoundBuffer(m_DSound.m_lpDS, m_DSound.m_DSCaps, G_cTxt);
				}
			}
			#ifdef DEF_JAPAN_FOR_TERRA 
			    ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
		}
		break;
	}
}

void CGame::UpdateScreen_OnLoading_Progress()
{
	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOADING, 0,0,0, TRUE);
	DrawVersion();
	//if ((m_cLoading%8) == 0)	
	if( (G_dwGlobalTime%800) < 400 ) m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING]->PutSpriteFast(267,446, 1, G_dwGlobalTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING]->PutSpriteFast(267,446, 2, G_dwGlobalTime);
	m_DDraw.iFlip();
}

void CGame::OnTimer()
{
	if( m_cGameMode < 0 ) return;
	DWORD dwTime = timeGetTime();

	if (m_cGameMode != DEF_GAMEMODE_ONLOADING) {
		if ((dwTime - m_dwCheckSprTime) > 8000) {//3000
			m_dwCheckSprTime = dwTime;
			if( m_bIsProgramActive ) ReleaseUnusedSprites();
			if ((m_pGSock != NULL) && (m_pGSock->m_bIsAvailable == TRUE))
				bSendCommand(MSGID_COMMAND_CHECKCONNECTION, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL);
		}
	}

	if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME) {
		
		if ((dwTime - m_dwCheckConnTime) > 5000) {
			m_dwCheckConnTime = dwTime;
			if ((_iCheckLUS() != 0)) EnableDialogBox(12,NULL, NULL, NULL);
			if ((m_bIsCrusadeMode) && (m_iCrusadeDuty == NULL)) EnableDialogBox(33, 1, NULL, NULL);
		}

		if ((dwTime - m_dwCheckChatTime) > 2000) {
			m_dwCheckChatTime = m_dwTime;
			ReleaseTimeoverChatMsg();
			// 지나친 랙으로 인해 정지한 캐릭터는 접속을 종료한다. (14초간 응답이 없는 상태라면) 
			if (m_cCommandCount >= 6) {
				m_iNetLagCount++;
				if (m_iNetLagCount >= 7) {
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
					delete m_pGSock;
					m_pGSock = NULL;
					return;
				}
			}
			else m_iNetLagCount = NULL;
		}
	
		if ((G_bIsCalcSocketConnected == FALSE) && ((dwTime - G_dwCalcSocketTime) > 5000)) {
			// 게임에 들어갔으나 과금소켓이 5초간 연결되지 않으면 게임 접속 종료 
			delete m_pGSock;
			m_pGSock = NULL;

			// 과금 서비스의 경우 무조건 종료 
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			
			m_bEscPressed = FALSE;
			PlaySound('E', 14, 5);
	
			// 비소리 루핑 스톱 
			if (m_bSoundFlag) m_pESound[38]->bStop();
			// 배경음악 스톱
			if ((m_bSoundFlag) && (m_bMusicStat == TRUE)) {
				if (m_pBGM != NULL) m_pBGM->bStop();
			}
			return;
		}

		if ((G_pCalcSocket != NULL) && (G_bIsCalcSocketConnected == TRUE)) {
			if ((dwTime - G_dwCalcSocketSendTime) > 1000*5) {
				// 종량제 서비스의 경우 5초에 한번씩 과금 소켓으로 메시지를 전송 : 블록 소켓인데 메시지 형식을 Xsocket 형태로 보내야 한다.
				if (memcmp(G_cCmdLineTokenA_Lowercase, "wisetop", 7) == 0) {
					// 로그인 게임인 경우 아무런 메시지도 보내지 않는다.

				}
				else {
					char cPacket[120];
					int  iSended;
					WORD * wp;
					ZeroMemory(cPacket, sizeof(cPacket));

					cPacket[0] = 0;					// Key값은 0
					wp  = (WORD *)(cPacket +1);
					*wp = 5;						// 메시지 사이즈는 5바이트(헤더 포함)

					iSended = G_pCalcSocket->iSendMsgBlockingMode(cPacket, 5);
				}
								
				G_dwCalcSocketSendTime = dwTime;
			}
		}
	}
}


BOOL CGame::_bCheckDlgBoxClick(short msX, short msY)
{
 int i;
 char         cDlgID;
	
	m_DInput.m_sZ = 0;
	for (i = 0; i < 41; i++) 
	if (m_cDialogBoxOrder[40 - i] != NULL) {
		cDlgID = m_cDialogBoxOrder[40 - i];
		if ((m_stDialogBoxInfo[cDlgID].sX < msX)	&& ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) > msX) &&
			(m_stDialogBoxInfo[cDlgID].sY < msY)	&& ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) > msY) ) {
			// 해당 다이얼로그 박스위에서 클릭동작. 선택된 요소를 선택한다.
			switch (cDlgID) {
			case 1:
				DlgBoxClick_Character(msX, msY);
				break;
			case 2:
				DlgBoxClick_Inventory(msX, msY);
				break;
			case 3:
				DlgBoxClick_Magic(msX, msY);
				break;
			case 4:
				DlgBoxClick_ItemDrop(msX, msY);
				break;
			case 5:
				DlgBoxClick_15AgeMsg(msX, msY);
				break;
			case 6:
				DlgBoxClick_WarningMsg(msX, msY);
				break;
			case 7:
				DlgBoxClick_GuildMenu(msX, msY);
				break;
			case 8:
				DlgBoxClick_GuildOp(msX, msY);
				break;
			case 9:
				break;
			case 11:
				DlgBoxClick_Shop(msX, msY);
				break;
			case 12:
				DlgBoxClick_LevelUpSettings(msX, msY);
				break;
			case 13:
				DlgBoxClick_CityhallMenu(msX, msY);
				break;
			case 14:
				DlgBoxClick_Bank(msX, msY);
				break;
			case 15:
				DlgBoxClick_Skill(msX, msY);
				break;
			case 16:
				DlgBoxClick_MagicShop(msX, msY);
				break;
			case 18:
				DlgBoxClick_Text(msX, msY);
				break;
			case 19:
				DlgBoxClick_SysMenu(msX, msY);
				break;
			case 20:
				DlgBoxClick_NpcActionQuery(msX, msY);
				break;
			case 21:
				DlgBoxClick_NpcTalk(msX, msY);
				break;
			case 23:
				DlgBoxClick_ItemSellorRepair(msX, msY);
				break;
			case 24:
				DlgBoxClick_Fish(msX, msY);
				break;
			case 25:
				DlgBoxClick_ShutDownMsg(msX, msY);
				break;
			case 26:
				DlgBoxClick_SkillDlg(msX, msY);
				break;
			case 27:
				DlgBoxClick_Exchange(msX, msY);
				break;
			case 28: 
				DlgBoxClick_Quest(msX, msY);
				break;
			case 30:
				DlgBoxClick_IconPannel(msX, msY);
				break;
			case 31:
				DlgBoxClick_SellList(msX, msY);
				break;
			case 32:
				DlgBoxClick_Party(msX, msY);
				break;
			case 33:
				DlgBoxClick_CrusadeJob(msX, msY);
				break;
			case 34:
				DlgBoxClick_ItemUpgrade(msX, msY);
     			break;
			case 35:
				DlgBoxClick_Help(msX, msY);
				break;

			case 36:
				DlgBoxClick_Commander(msX, msY);
				break;

			case 37:
				DlgBoxClick_Constructor(msX, msY);
				break;

			case 38:
				DlgBoxClick_Soldier(msX, msY);
				break;
			}

			return TRUE;
		}
	}

	return FALSE;
}

BOOL CGame::_bCheckDlgBoxDoubleClick(short msX, short msY)
{
	int i;
	char cDlgID;	
	if (m_iHP <= 0) return FALSE;

	for (i = 0; i < 41; i++) 
	if (m_cDialogBoxOrder[40 - i] != NULL) {
		cDlgID = m_cDialogBoxOrder[40 - i];
		if ((m_stDialogBoxInfo[cDlgID].sX < msX)	&& ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) > msX) &&
			(m_stDialogBoxInfo[cDlgID].sY < msY)	&& ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) > msY) ) {
			// 해당 다이얼로그 박스위에서 클릭동작. 선택된 요소를 선택한다.
			switch (cDlgID) {
			case 1:
				DlbBoxDoubleClick_Character(msX, msY);
				break;
			case 2:
				DlbBoxDoubleClick_Inventory(msX, msY);
				break;
			case 9:
				DlbBoxDoubleClick_GuideMap(msX, msY);
				break;
			}
			return TRUE;
		}
	}
	return FALSE;
}


BOOL CGame::bDlgBoxPress_Inventory(short msX, short msY)
{
 int i;
 char  cItemID;
 short sX, sY, x1, x2, y1, y2;

#ifdef _DEBUG
 AddEventList("Press Inventory", 10);
#endif
	
	if (m_bIsDialogEnabled[2] == FALSE) return FALSE;
	if (m_bIsDialogEnabled[17] == TRUE) return FALSE;
	if (m_bIsDialogEnabled[4] == TRUE) return FALSE;
	
	sX = m_stDialogBoxInfo[2].sX;
	sY = m_stDialogBoxInfo[2].sY;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_cItemOrder[DEF_MAXITEMS - 1 - i] != -1) {
		cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];
		
		if (m_pItemList[cItemID] != NULL) { 
			
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + 32 + m_pItemList[cItemID]->m_sX,
			                                                   sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame);
			// 좌표를 검색하여 선택되었는지를 검사한다. 만약 선택되었다면 Order를 맨 앞(배열상으로는 뒤)으로 옮긴다.
			x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;   
			y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;    
			x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;  
			y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom; 
			
			if ( (m_bIsItemDisabled[cItemID] == FALSE) && (m_bIsItemEquipped[cItemID] == FALSE) && (msX > x1) && (msX < x2) && (msY > y1) && (msY < y2) ) {

				if (m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_bCheckCollison(sX + 32 + m_pItemList[cItemID]->m_sX, sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame, msX, msY) == TRUE) {
					// 선택되었다.
					// Order를 맨 앞으로 (배열상으로는 맨 뒤)
					_SetItemOrder(0, cItemID);
				
					if ( (m_bIsGetPointingMode == TRUE) && (m_iPointCommandType < 100) && (m_iPointCommandType >= 0 ) &&
						 (m_pItemList[m_iPointCommandType] != NULL) &&
						 (m_pItemList[m_iPointCommandType]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) &&
						 (m_iPointCommandType != cItemID) ) {
						
						PointCommandHandler(NULL, NULL, cItemID);
						//m_bCommandAvailable  = FALSE;
						m_bIsGetPointingMode = FALSE;
					}
					else {
						// 선택되었다.
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
						m_stMCursor.sSelectedObjectID   = cItemID;
						m_stMCursor.sDistX = msX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
						m_stMCursor.sDistY = msY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
					}
					return TRUE;
				}
			}
		}
	}

	return FALSE;
}

void CGame::_SetItemOrder(char cWhere, char cItemID)
{
 int i;

	switch (cWhere) {
	case 0:
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_cItemOrder[i] == cItemID) 
			m_cItemOrder[i] = -1;

		for (i = 1; i < DEF_MAXITEMS; i++)
		if ((m_cItemOrder[i-1] == -1) && (m_cItemOrder[i] != -1)) {
			m_cItemOrder[i-1] = m_cItemOrder[i];	
			m_cItemOrder[i]   = -1;
		}

		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_cItemOrder[i] == -1) {
			m_cItemOrder[i] = cItemID;
			return;
		}
		break;
	}
}

BOOL CGame::_bCheckDraggingItemRelease(short msX, short msY)
{
 int i;
 char         cDlgID;
	
	for (i = 0; i < 41; i++) 
	if (m_cDialogBoxOrder[40 - i] != NULL) {
		cDlgID = m_cDialogBoxOrder[40 - i];
		if ((m_stDialogBoxInfo[cDlgID].sX < msX) && ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) > msX) &&
			(m_stDialogBoxInfo[cDlgID].sY < msY) && ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) > msY) ) {
			// 해당 다이얼로그 위에 아이템이 드롭되었다.
			EnableDialogBox(cDlgID, NULL, NULL, NULL);

			switch (cDlgID) {
			case 1:
				bItemDrop_Character();
				break;

			case 2:
				bItemDrop_Inventory(msX, msY);
				break;

			case 14:
				bItemDrop_Bank(msX, msY);
				break;

			case 26:
				bItemDrop_SkillDialog();
				break;

			case 27:
				bItemDrop_ExchangeDialog(msX, msY);
				break;

			case 30:
				bItemDrop_IconPannel(msX, msY);
				break;

			case 31:
				bItemDrop_SellList(msX, msY);
				break;

			case 34:
				bItemDrop_ItemUpgrade();
				break;
			}

			return TRUE;
		}
	}

	// 아이템을 버리거나 다른 캐릭터에게 전달했다.
	bItemDrop_ExternalScreen((char)m_stMCursor.sSelectedObjectID, msX, msY);

	return FALSE;
}



void CGame::bItemDrop_ExternalScreen(char cItemID, short msX, short msY)
{

 char  cName[21];
 short sType, sStatus, tX, tY;

	if (bCheckItemOperationEnabled(cItemID) == FALSE) return;
	
	// 아이템을 버릴 것인지 캐릭터에게 줄 것인지를 판단한다. 
	// 아이템을 주기 위해서는 주고자 하는 캐릭터와 어느정도 인접해 있어야만 한다.
	// v1.4334 아이템 맞기는 거리가 늘어난다. 8 로
	if ((m_sMCX != 0) && (m_sMCY != 0) && (abs(m_sPlayerX - m_sMCX) <= 8) && (abs(m_sPlayerY - m_sMCY) <= 8)) {
	
		ZeroMemory(cName, sizeof(cName));
		m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sType, &sStatus, &m_wCommObjectID); // v1.4
				
		if (memcmp(m_cPlayerName, cName, 10) == 0) {
			// 자기 자신에게 아이템을 줄 수는 없다. 무시한다.

		}
		else {
			if ( ( (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW) ) && 
				 (m_pItemList[cItemID]->m_dwCount > 1)) {
				// 소비하는 아이템을 다른 캐릭터에게 전달한다. 
				m_stDialogBoxInfo[17].sX  = msX - 140;
				m_stDialogBoxInfo[17].sY  = msY - 70;
				if (m_stDialogBoxInfo[17].sY < 0) m_stDialogBoxInfo[17].sY = 0;
			
				m_stDialogBoxInfo[17].sV1 = m_sMCX;
				m_stDialogBoxInfo[17].sV2 = m_sMCY;
				// NPC 종류
				m_stDialogBoxInfo[17].sV3 = sType;
				// v1.4
				m_stDialogBoxInfo[17].sV4 = m_wCommObjectID;
				
				ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
				if (sType < 10)
					memcpy(m_stDialogBoxInfo[17].cStr, cName, 10);
				else {
					// Npc의 이름을 입력한다.
					GetNpcName(sType, m_stDialogBoxInfo[17].cStr);
				}
				EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);
			}
			else {
				// 일반 플레이어에게라면 (그냥준다 / 교환한다) 
				// NPC중 상점 주인이라면 (판다 / 수리한다) 
				switch (sType) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
					EnableDialogBox(20, 1, cItemID, sType);	// 그냥준다 : 교환한다
					m_stDialogBoxInfo[20].sV3 = 1;							// 팔거나 고칠 아이템 갯수 당연이 1개 
					m_stDialogBoxInfo[20].sV4 = m_wCommObjectID;			// v1.4
					m_stDialogBoxInfo[20].sV5 = m_sMCX;
					m_stDialogBoxInfo[20].sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > 639) tX = 639 - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > 479) tY = 479 - 100;
					m_stDialogBoxInfo[20].sX  = tX;
					m_stDialogBoxInfo[20].sY  = tY;

					ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
					strcpy(m_stDialogBoxInfo[20].cStr, cName);
					//캐릭터이다.
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName); //v1.4
					break;

				case 20:
					// 창고 주인. 맡긴다는 메시지 박스를 띄운다.
					EnableDialogBox(20, 3, cItemID, sType);
					// 아이템 갯수 당연이 1개 
					m_stDialogBoxInfo[20].sV3 = 1;
					m_stDialogBoxInfo[20].sV4 = m_wCommObjectID; // v1.4
					m_stDialogBoxInfo[20].sV5 = m_sMCX;
					m_stDialogBoxInfo[20].sV6 = m_sMCY;
					
					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > 639) tX = 639 - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > 479) tY = 479 - 100;
					m_stDialogBoxInfo[20].sX  = tX;
					m_stDialogBoxInfo[20].sY  = tY;

					ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
					GetNpcName(sType, m_stDialogBoxInfo[20].cStr);
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName); 
					break;
				
				case 15:
					// 상점 아줌마 
		  		case 24:
					// 대장간 주인 
					EnableDialogBox(20, 2, cItemID, sType);
					// 팔거나 고칠 아이템 갯수 당연이 1개 
					m_stDialogBoxInfo[20].sV3 = 1;
					m_stDialogBoxInfo[20].sV4 = m_wCommObjectID; // v1.4
					m_stDialogBoxInfo[20].sV5 = m_sMCX;
					m_stDialogBoxInfo[20].sV6 = m_sMCY;
					
					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > 639) tX = 639 - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > 479) tY = 479 - 100;
					m_stDialogBoxInfo[20].sX  = tX;
					m_stDialogBoxInfo[20].sY  = tY;

					ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
					GetNpcName(sType, m_stDialogBoxInfo[20].cStr);
					break;

				default:
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName); 
					break;
				}
				
				// 아이템 관련 응답이 오기 전까지는 이 아이템을 선택할 수 없다. 
				//m_bIsItemDisabled[cItemID] = TRUE;
			}
			m_bIsItemDisabled[cItemID] = TRUE;
		}
	}
	else {
		// 아이템을 버린다는 메시지를 전송한다 
		if ( ( (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW) ) && 
			 (m_pItemList[cItemID]->m_dwCount > 1)) {
			// 소비하는 아이템이므로 얼마나 줄 것인지를 결정한다. 
			m_stDialogBoxInfo[17].sX  = msX - 140;
			m_stDialogBoxInfo[17].sY  = msY - 70;
			if (m_stDialogBoxInfo[17].sY < 0) m_stDialogBoxInfo[17].sY = 0;
						
			m_stDialogBoxInfo[17].sV1 = NULL;
			m_stDialogBoxInfo[17].sV2 = NULL;
			
			m_stDialogBoxInfo[17].sV3 = NULL; // v1.4
			m_stDialogBoxInfo[17].sV4 = NULL; 
			ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
			EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);
		}
	else {
			// 수량 개념이 없는 아이템.
		 if(_ItemDropHistory(m_pItemList[cItemID]->m_cName))
		  {
			m_stDialogBoxInfo[4].sX  = msX - 140;
			m_stDialogBoxInfo[4].sY  = msY - 70;
	
			if (m_stDialogBoxInfo[4].sY < 0) 
				     m_stDialogBoxInfo[4].sY = 0;
    		m_stDialogBoxInfo[4].sV1 = NULL;
			m_stDialogBoxInfo[4].sV2 = NULL;
			
			m_stDialogBoxInfo[4].sV3 = 1; // v1.4
			m_stDialogBoxInfo[4].sV4 = NULL; 
			m_stDialogBoxInfo[4].sV5 = cItemID; 

			ZeroMemory(m_stDialogBoxInfo[4].cStr, sizeof(m_stDialogBoxInfo[4].cStr));
			EnableDialogBox(4, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);
		  }
		 else
		 {
		    bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_ITEMDROP, NULL, cItemID, 1, NULL, m_pItemList[cItemID]->m_cName); 
		 }
	}
		m_bIsItemDisabled[cItemID] = TRUE;
	}
}


void CGame::CommonEventHandler(char * pData)
{
 WORD * wp, wEventType;
 short * sp, sX, sY, sV1, sV2, sV3, sV4;
 char * cp;

	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wEventType = *wp;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	sp  = (short *)cp;
	sX  = *sp;
	cp += 2;

	sp  = (short *)cp;
	sY  = *sp;
	cp += 2;

	sp  = (short *)cp;
	sV1 = *sp;
	cp += 2;

	sp  = (short *)cp;
	sV2 = *sp;
	cp += 2;

	sp  = (short *)cp;
	sV3 = *sp;
	cp += 2;

	sp  = (short *)cp;
	sV4 = *sp;
	cp += 2;

	switch (wEventType) {
	case DEF_COMMONTYPE_ITEMDROP:				// 최초로 떨어지는 아이템 
		if ((sV1 == 6) && (sV2 == 0)) {
			bAddNewEffect(4, sX, sY, NULL, NULL, 0);
		}
		//else
		
		m_pMapData->bSetItem(sX, sY, sV1, sV2, (char)sV3);  //v1.4 color sV3
		break;
	
	case DEF_COMMONTYPE_SETITEM:				// 아이템을 주웠을때 바닥에 숨겨져 있던 아이템 
		m_pMapData->bSetItem(sX, sY, sV1, sV2, (char)sV3, FALSE); // v1.4 color
		break;

	case DEF_COMMONTYPE_MAGIC:
		bAddNewEffect(sV3, sX, sY, sV1, sV2, 0, sV4); // 마법 공격자 타입이 추가되었다.
		break;
	case DEF_COMMONTYPE_CLEARGUILDNAME:
		ClearGuildNameList();
		break;
	}
}

void CGame::ClearGuildNameList()
{
	for (int i = 0; i < DEF_MAXGUILDNAMES; i++) {
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		ZeroMemory(m_stGuildName[i].cCharName, sizeof(m_stGuildName[i].cCharName));
		ZeroMemory(m_stGuildName[i].cGuildName, sizeof(m_stGuildName[i].cGuildName));
	} 
}

void CGame::InitGameSettings()	  
{
 int i;
	
#if DEF_LANGUAGE == 2
	m_bForceAttack = TRUE;	//	중국버젼 적은 자동 강제 공격^^;
#else
	m_bForceAttack = FALSE;
#endif
	m_dwCommandTime = 0;

	// 초기화 해주어야 할 수치를 설정한다.	
	m_bInputStatus = FALSE;
	m_pInputBuffer = NULL;

	m_iPDBGSdivX = 0;
	m_iPDBGSdivY = 0;
	m_bIsRedrawPDBGS = TRUE; 

	m_iCameraShakingDegree = 0;

	m_cCommand = DEF_OBJECTSTOP;
	m_cCommandCount = 0;

	m_bIsGetPointingMode = FALSE;
	m_iPointCommandType  = -1; //v2.15 NULL -> -1

	m_bIsCombatMode = FALSE;
	m_bRunningMode = FALSE;

	m_stMCursor.cPrevStatus       = DEF_CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = NULL;

	m_bSkillUsingStatus = FALSE;
	m_bItemUsingStatus  = FALSE;

	m_bIsWhetherEffect   = FALSE;
	m_cWhetherEffectType = NULL;

	m_iDownSkillIndex = -1;
	m_stDialogBoxInfo[15].bFlag = FALSE;

	m_bIsConfusion = FALSE;

	m_iIlusionOwnerH = NULL;
	m_cIlusionOwnerType = NULL;

	m_iDrawFlag = 0;
	m_bDrawFlagDir = FALSE;

	m_bIsCrusadeMode = FALSE;
	m_iCrusadeDuty = NULL;

	m_iNetLagCount = NULL;

	m_dwEnvEffectTime = timeGetTime();
	
	for (i = 0; i < DEF_MAXGUILDNAMES; i++) {
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		ZeroMemory(m_stGuildName[i].cCharName, sizeof(m_stGuildName[i].cCharName));
		ZeroMemory(m_stGuildName[i].cGuildName, sizeof(m_stGuildName[i].cGuildName));
	} 

	for (i = 0; i < 41; i++)
		m_bIsDialogEnabled[i] = FALSE;

	for (i = 0; i < 38; i++)
		m_cDialogBoxOrder[i] = NULL;

	for (i = 0; i < DEF_MAXEFFECTS; i++) {
		if (m_pEffectList[i] != NULL) delete m_pEffectList[i];
		m_pEffectList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXCHATMSGS; i++) {
		if (m_pChatMsgList[i] != NULL) delete m_pChatMsgList[i];
		m_pChatMsgList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++) {
		if (m_pChatScrollList[i] != NULL) delete m_pChatScrollList[i];
		m_pChatScrollList[i] = NULL;
	}
	
	for (i = 0; i < DEF_MAXWHISPERMSG; i++) {
		if (m_pWhisperMsg[i] != NULL) delete m_pWhisperMsg[i];
		m_pWhisperMsg[i] = NULL;
	}

	ZeroMemory(m_cLocation, sizeof(m_cLocation));

	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	m_iTotalGuildsMan = 0;
	
	for (i = 0; i < 100; i++) {
		m_stGuildOpList[i].cOpMode = NULL;
		ZeroMemory(m_stGuildOpList[i].cName, sizeof(m_stGuildOpList[i].cName));
	} 

	for (i = 0; i < 6; i++) {
		ZeroMemory(m_stEventHistory[i].cTxt, sizeof(m_stEventHistory[i].cTxt));
		m_stEventHistory[i].dwTime = G_dwGlobalTime;

		ZeroMemory(m_stEventHistory2[i].cTxt, sizeof(m_stEventHistory2[i].cTxt));
		m_stEventHistory2[i].dwTime = G_dwGlobalTime;
	}

    for (i = 0; i < DEF_MAXMENUITEMS; i++) {
		if (m_pItemForSaleList[i] != NULL) delete m_pItemForSaleList[i];
		m_pItemForSaleList[i] = NULL;
	}

	for (i = 0; i < 21; i++) {
		m_stDialogBoxInfo[i].bFlag = FALSE;
		m_stDialogBoxInfo[i].sView = 0;
		m_stDialogBoxInfo[i].bIsScrollSelected = FALSE;
	}

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL) {
		delete m_pItemList[i];
		m_pItemList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXSELLLIST; i++) {
		m_stSellItemList[i].iIndex = -1;
		m_stSellItemList[i].iAmount = 0;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pBankList[i] != NULL) {
		delete m_pBankList[i];
		m_pBankList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_cMagicMastery[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_cSkillMastery[i] = NULL;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != NULL) 
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;

		if (m_pMsgTextList2[i] != NULL) 
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = NULL;

		if (m_pAgreeMsgTextList[i] != NULL) 
			delete m_pAgreeMsgTextList[i];
		m_pAgreeMsgTextList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) {
		m_stPartyMember[i].cStatus = 0;
		ZeroMemory(m_stPartyMember[i].cName, sizeof(m_stPartyMember[i].cName));
	}
	
	m_iLU_Point = 3;
	m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
	m_bDialogTrans   = FALSE;
	m_cWhetherStatus = NULL;

	m_cLogOutCount = -1;
	m_dwLogOutCountTime = NULL;
	m_iSuperAttackLeft = 0;
	m_bSuperAttackMode = FALSE;

	// v1.4311-3 추가 변수 초기화 m_iFightzoneNumber
	m_iFightzoneNumber = 0 ;


	ZeroMemory(m_cBGMmapName, sizeof(m_cBGMmapName));
	
	m_dwWOFtime = 0;

	m_stQuest.sWho          = NULL;
	m_stQuest.sQuestType    = NULL;
	m_stQuest.sContribution = NULL;
	m_stQuest.sTargetType   = NULL;
	m_stQuest.sTargetCount  = NULL;
	m_stQuest.sX            = NULL;
	m_stQuest.sY            = NULL;
	m_stQuest.sRange        = NULL;
	m_stQuest.bIsQuestCompleted = FALSE;

	ZeroMemory(m_stQuest.cTargetName, sizeof(m_stQuest.cTargetName));
	
	m_bIsObserverMode = FALSE;
	m_bIsObserverCommanded = FALSE;
//	m_iRating = NULL;

	m_bIsPoisoned = FALSE;
	m_bIsPrevMoveBlocked = FALSE;
	m_iPrevMoveX = m_iPrevMoveY = -1;

	m_sDamageMove = 0;
	m_sDamageMoveAmount = 0;


	m_bForceDisconn = FALSE;

	m_bIsSpecialAbilityEnabled = FALSE;
	m_iSpecialAbilityType = 0;

	m_dwSpecialAbilitySettingTime = NULL;
	m_iSpecialAbilityTimeLeftSec = NULL;

	m_stMCursor.cSelectedObjectType = NULL;

	m_bIsF1HelpWindowEnabled = FALSE;
	m_bIsTeleportRequested = FALSE;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		m_stCrusadeStructureInfo[i].cType = NULL;
		m_stCrusadeStructureInfo[i].cSide = NULL;
		m_stCrusadeStructureInfo[i].sX = NULL;
		m_stCrusadeStructureInfo[i].sY = NULL;
	} 
	ZeroMemory(m_cStatusMapName, sizeof(m_cStatusMapName));

	m_dwCommanderCommandRequestedTime = NULL;
 
	ZeroMemory(m_cTopMsg, sizeof(m_cTopMsg));
	m_iTopMsgLastSec = NULL;
	m_dwTopMsgTime   = NULL;

	m_iConstructionPoint = NULL;
	m_iWarContribution   = NULL;

	ZeroMemory(m_cTeleportMapName, sizeof(m_cTeleportMapName)); 
	m_iTeleportLocX = m_iTeleportLocY = -1;

	ZeroMemory(m_cConstructMapName, sizeof(m_cConstructMapName));
	m_iConstructLocX = m_iConstructLocY = -1;

	m_iTotalPartyMember = 0;
	m_iPartyStatus = 0;
	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));

	m_iGizonItemUpgradeLeft = 0;

	EnableDialogBox(9, 0, 0, 0 );
}

void CGame::_GetHairColorRGB(int iColorType, int * pR, int * pG, int * pB)
{
	switch (iColorType) {
	case 0:
		*pR = 14; *pG = -5; *pB = -5; break;
	case 1:
		*pR = 20; *pG = 0; *pB = 0; break;
	case 2:
		*pR = 22; *pG = 13; *pB = -10; break;
	case 3:
		*pR = 0; *pG = 10; *pB = 0; break;
	case 4:
		*pR = 0; *pG = 0; *pB = 22; break;
	case 5:
		*pR = -5; *pG = -5; *pB = 15; break;
	case 6:
		*pR = 15; *pG = -5; *pB = 16; break;
	case 7:
		*pR = -6; *pG = -6; *pB = -6; break;
	case 8:
		*pR = 10; *pG = 3; *pB = 10; break;
	case 9:
		*pR = 10; *pG = 3; *pB = -10; break;
	case 10:
		*pR = -10; *pG = 3; *pB = 10; break;
	case 11:
		*pR = 10; *pG = 3; *pB = 20; break;
	case 12:
		*pR = 21; *pG = 3; *pB = 3; break;
	case 13:
		*pR = 3; *pG = 3; *pB = 25; break;
	case 14:
		*pR = 3; *pG = 11; *pB = 3; break;
	case 15:
		*pR = 6; *pG = 8; *pB = 0; break;
	}
}

void CGame::DlgBoxClick_GuildMenu(short msX, short msY)
{ 
 short sX, sY;
 char cTemp[21]; 
 int iAdjX , iAdjY ;

	// 길드 메뉴 다이얼로그 박스가 클릭되었다. 버튼이 클릭되었다면 해당 동작 메시지를 서버로 전송하고 응답을 기다려야 한다.
	sX = m_stDialogBoxInfo[7].sX;
	sY = m_stDialogBoxInfo[7].sY ;
	
	iAdjX = -13; 
	iAdjY = 30; 

	switch (m_stDialogBoxInfo[7].cMode) {
	case 0:
		if ((msX > sX + iAdjX + 80) && (msX < sX + iAdjX + 210) && (msY > sY + iAdjY + 63) && (msY < sY + iAdjY + 78)) {
			if (m_iGuildRank != -1) return;
			if (m_iCharisma < 20) return;
			if (m_iLevel < 20) return;
			if (m_bIsCrusadeMode) return;
			// 새로운 길드 생성 메뉴가 클릭되었다. 길드 이름 입력상태로 전환한다.
			EndInputString(); 
			StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
			m_stDialogBoxInfo[7].cMode = 1; 
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + iAdjX + 72) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 82) && (msY < sY + iAdjY + 99)) {
			if (m_iGuildRank != 0) return;
			if (m_bIsCrusadeMode) return;
			// 길드 해산 메뉴가 클릭되었다.	해산 확인 모드로 전환 
			m_stDialogBoxInfo[7].cMode = 5;
			PlaySound('E', 14, 5);
		} 

		if ((msX > sX + iAdjX + 61) && (msX < sX + iAdjX + 226) && (msY > sY + iAdjY + 103) && (msY < sY + iAdjY + 120)) {
			// 길드 가입 신청서 구입메뉴가 클릭되었다.	
			m_stDialogBoxInfo[7].cMode = 9;
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + iAdjX + 60) && (msX < sX + iAdjX + 227) && (msY > sY + iAdjY + 123) && (msY < sY + iAdjY + 139)) {
			// 길드 탈퇴 신청서 구입메뉴가 클릭되었다.	
			m_stDialogBoxInfo[7].cMode = 11;
			PlaySound('E', 14, 5);
		}

		// 사투장 입장권을 다 사용한 경우 ..
		if( m_iFightzoneNumber < 0 ) break ;
		// v1.4311-3 변경 사투장 입장권 구입 메뉴 
		if ((msX > sX + iAdjX + 72) && (msX < sX + iAdjX + 228) && (msY > sY + iAdjY + 143) && (msY < sY + iAdjY + 169)) {
			// 사투장 입장권 구입 메뉴가 클릭 되었다.	
			if (m_iGuildRank != 0) return;
			
			if (m_iFightzoneNumber == 0 )	m_stDialogBoxInfo[7].cMode = 13;  // 사투장 입장권 구입 매뉴 
			else  m_stDialogBoxInfo[7].cMode = 19;							  // 사투장 입장권 받기 매뉴 
				
			PlaySound('E', 14, 5);
		}

		break;
	case 1: 
		// 길드이름 입력상태 
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Submit버튼 Click되었다. 길드이름이 유효하면 서버생성요구 메시지를 전송한다.
			// "NONE"이라는 이름은 사용할 수 없다.
			if (strcmp(m_cGuildName, "NONE") == 0) return;
			if (strlen(m_cGuildName) == 0) return;

			bSendCommand(MSGID_REQUEST_CREATENEWGUILD, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 2;
			EndInputString();
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel버튼 Click되었다
			m_stDialogBoxInfo[7].cMode = 0;
			EndInputString();
			PlaySound('E', 14, 5);
		}
		break;
	
	case 3:
	case 4:
	case 7:
	case 8:
	case 10:
	case 12:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 9:
		// 길드 가입 신청서 구입 확인 화면  
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Purchase버튼 Click되었다. 아이템 구입명령을 전송한다.
			ZeroMemory(cTemp, sizeof(cTemp));
#ifdef DEF_ENGLISHITEM
			strcpy(cTemp,"GuildAdmissionTicket");
#else
			strcpy(cTemp,"길드가입신청서");
#endif
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_PURCHASEITEM, NULL, 1, NULL, NULL, cTemp); 
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel버튼 Click되었다
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;
	
	case 11:
		// 길드 탈퇴 신청서 구입 확인화면 
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Purchase버튼 Click되었다. 아이템 구입명령을 전송한다.
			ZeroMemory(cTemp, sizeof(cTemp));
#ifdef DEF_ENGLISHITEM
			strcpy(cTemp,"GuildSecessionTicket");
#else
			strcpy(cTemp,"길드탈퇴신청서");
#endif
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_PURCHASEITEM, NULL, 1, NULL, NULL, cTemp); 
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel버튼 Click되었다
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;
	
	case 5:
		// 길드 해산 확인메뉴 
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Confirm버튼 Click되었다. 길드 해산 명령을 전송한다.
			bSendCommand(MSGID_REQUEST_DISBANDGUILD, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 6;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel버튼 Click되었다
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;
	// v1.4311-3 추가 인터페이스 사용자가 선택한 사투장을 예약한다.
	// BOOL bSendCommand(DWORD dwMsgID, WORD wCommand, char cDir, int iV1, int iV2, int iV3, char * pString, int iV4 = NULL); // v1.4
		
	case 13:
		// 예약할 사투장 선택 		
		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185)) {
			// 1번 사투장 예약 			
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 1, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 1; 
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185)){ 
			// 2번 사투장 예약 
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 2, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 2; 
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205)) {
			// 3번 사투장 예약 
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 3, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 3; 
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205)) {
			// 4번 사투장 예약 
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 4, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 4; 
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225)) {
			// 5번 사투장 예약 
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 5, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 5; 
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225)) {
			// 6번 사투장 예약 
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 6, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 6; 
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245)) {
			// 7번 사투장 예약 
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 7, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 7; 
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245)){ 
			// 8번 사투장 예약 
			bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 8, NULL, NULL, NULL); 
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 8; 
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel버튼 Click되었다
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break ;

	// v1.4311-3 추가  인터페이스 사투장 관련
	case 14:// 예약 성공시 
	case 15:// 예약 실패시 예약 가능한 시간이 아닌경우 
	case 16:// 예약 실패시 이미 예약된 사투장을 선택한경우
	case 17:// 예약 실패시 예약에 필요한 금액이 모질라는경우 
	case 21:// 예약 실패시 사용이 불가능한 요일인 경우 
	case 22:// 예약 실패시 다른 사투장을 예약을 한 경우 
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// OK 버튼이 Click 되었다.
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break ;
	}
}

void CGame::CreateNewGuildResponseHandler(char * pData)
{
 WORD * wpResult;	
	
 	wpResult = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	// 길드 생성요구에 대한 응답이 왔다.
	switch (*wpResult) {
	case DEF_MSGTYPE_CONFIRM:
		// 성공했다. 
		m_iGuildRank = 0;
		m_stDialogBoxInfo[7].cMode = 3;
		break;

	case DEF_MSGTYPE_REJECT:
		// 실패했다.
		m_iGuildRank = -1;
		m_stDialogBoxInfo[7].cMode = 4;
		break;
	}
}



void CGame::InitPlayerCharacteristics(char * pData)
{
 int  * ip;
 char * cp;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
 
	ip   = (int *)cp;
	m_iHP = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iMP = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iSP = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iAC = *ip;		//상하야 여기 m_iDefenseRatio
	cp += 4;

	ip   = (int *)cp;
	m_iTHAC0 = *ip;    //상하야 여기 m_iHitRatio
	cp += 4;		 

	ip   = (int *)cp;
	m_iLevel = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iStr = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iInt = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iVit = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iDex = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iMag = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iCharisma = *ip;
	cp += 4;

	m_cLU_Str = *cp;
	cp++;
	m_cLU_Vit = *cp;
	cp++;
	m_cLU_Dex = *cp;
	cp++;
	m_cLU_Int = *cp;
	cp++;
	m_cLU_Mag = *cp;
	cp++;
	m_cLU_Char = *cp;
	cp++;

	m_iLU_Point = 3 - (m_cLU_Str + m_cLU_Vit + m_cLU_Dex + m_cLU_Int + m_cLU_Mag + m_cLU_Char);

	ip   = (int *)cp;
	m_iExp = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iEnemyKillCount = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iPKCount = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iRewardGold = *ip;
	cp += 4;

	memcpy(m_cLocation, cp, 10);
	cp += 10;
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{
		m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter = FALSE;
	}
	else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{
		m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter = TRUE;
	}
	else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{
		m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter = FALSE;
	}
	else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{
		m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter = TRUE;
	}
	else
	{
		m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter = TRUE;
	}

	cp = (char *)cp;
	memcpy(m_cGuildName, cp, 20);
	cp += 20;

	if (strcmp(m_cGuildName, "NONE") == 0)
		ZeroMemory(m_cGuildName, sizeof(m_cGuildName));

	m_Misc.ReplaceString(m_cGuildName, '_', ' ');

	ip   = (int *)cp;
	m_iGuildRank = *ip;
	cp += 4;

	//v1.4311
	m_iSuperAttackLeft = (int)*cp;
	cp++;

	// v1.4311-3 변경 사투장 예약에 관한 값인 사투장 번호를 받는다.
	ip   = (int *)cp;
	m_iFightzoneNumber = *ip;
	cp += 4;
}

void CGame::DisbandGuildResponseHandler(char * pData)
{
 WORD * wpResult;	
	
 	wpResult = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	// 길드 해산요구에 대한 응답이 왔다.
	switch (*wpResult) {
	case DEF_MSGTYPE_CONFIRM:
		// 성공했다. 
		ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
		m_iGuildRank = -1;
		m_stDialogBoxInfo[7].cMode = 7;
		break;

	case DEF_MSGTYPE_REJECT:
		// 실패했다.
		m_stDialogBoxInfo[7].cMode = 8;
		break;
	}
}


// v1.4311-3 추가 함수 길드원 강제 추방 되었을때 나오는 메세지및 처리 
void CGame::NotifyMsg_BanGuildMan(char * pData)
{
 char * cp, cName[24], cLocation[12];
 
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cLocation, sizeof(cLocation));
	// 길드 오퍼레이션 다이얼로그박스를 활성화 시킨다.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;

	cp += 2;

	// 플레이어 소속 마을의 이름
	memcpy(cLocation, cp, 10);
	cp += 10;

	// 길드 이름과 랭크를 초기화한다.
	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	m_iGuildRank = -1;

	// 환원된 마을 이름 저장 
	ZeroMemory(m_cLocation, sizeof(m_cLocation));
	memcpy(m_cLocation, cLocation, 10);
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{
		m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter = FALSE;
	}
	else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{
		m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter = TRUE;
	}
	else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{
		m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter = FALSE;
	}
	else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{
		m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter = TRUE;
	}
	else
	{
		m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter = TRUE;
	}

	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 8);
}




void CGame::_PutGuildOperationList(char * pName, char cOpMode)
{
 int i;

	for (i = 0; i < 100; i++) 
	if (m_stGuildOpList[i].cOpMode == NULL) {
		m_stGuildOpList[i].cOpMode = cOpMode;
		ZeroMemory(m_stGuildOpList[i].cName, sizeof(m_stGuildOpList[i].cName));
		memcpy(m_stGuildOpList[i].cName, pName, 20);
		return;
	}
}

void CGame::_ShiftGuildOperationList()
{
 int i;
	
	ZeroMemory(m_stGuildOpList[0].cName ,sizeof(m_stGuildOpList[0].cName));
	m_stGuildOpList[0].cOpMode = NULL;

	for (i = 1; i < 100; i++)
	if ((m_stGuildOpList[i-1].cOpMode == NULL) && (m_stGuildOpList[i].cOpMode != NULL)) {
		m_stGuildOpList[i-1].cOpMode = m_stGuildOpList[i].cOpMode;
		ZeroMemory(m_stGuildOpList[i-1].cName, sizeof(m_stGuildOpList[i-1].cName));
		memcpy(m_stGuildOpList[i-1].cName, m_stGuildOpList[i].cName, 20);

		ZeroMemory(m_stGuildOpList[i].cName ,sizeof(m_stGuildOpList[i].cName));
		m_stGuildOpList[i].cOpMode = NULL;
	}
}



void CGame::DlgBoxClick_GuildOp(short msX, short msY)
{
 short sX, sY;
 char cName[12], cName20[24];

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cName20, sizeof(cName20));
	sX = m_stDialogBoxInfo[8].sX;
	sY = m_stDialogBoxInfo[8].sY;

	switch (m_stGuildOpList[0].cOpMode) {
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			_ShiftGuildOperationList();
			// 처리가 모두 종료되었다면 윈도우를 닫는다.
			if (m_stGuildOpList[0].cOpMode == NULL) DisableDialogBox(8);
		}
		return;
	}
	
	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Approve버튼 Click되었다. 
		PlaySound('E', 14, 5);

		switch (m_stGuildOpList[0].cOpMode) {
		case 1:
			// 가입 신청이 승인되었다.
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL, cName20);
			break;

		case 2: 
			// 탈퇴 신청이 승인되었다.
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL, cName20);
			break;
		}
		
		_ShiftGuildOperationList();
		// 처리가 모두 종료되었다면 윈도우를 닫는다.
		if (m_stGuildOpList[0].cOpMode == NULL) DisableDialogBox(8);
	}

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Reject버튼 Click되었다
		PlaySound('E', 14, 5);

		switch (m_stGuildOpList[0].cOpMode) {
		case 1:
			// 가입 신청이 거부 되었다.
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL, cName20);
			break;

		case 2: 
			// 탈퇴 신청이 거부 되었다.
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL, cName20);
			break;
		}
		
		_ShiftGuildOperationList();
		// 처리가 모두 종료되었다면 윈도우를 닫는다.
		if (m_stGuildOpList[0].cOpMode == NULL) DisableDialogBox(8);
	}	
}

void CGame::SetItemCount(char * pItemName, DWORD dwCount)
{
 int i;
 char cTmpName[21];
	
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		m_pItemList[i]->m_dwCount = dwCount;
		return;
	}
}


void CGame::AddEventList(char * pTxt, char cColor, BOOL bDupAllow)
{
 int i;

	if ((bDupAllow == FALSE) && (strcmp(m_stEventHistory[5].cTxt, pTxt) == 0)) return;
   
	// v2.12
	if (cColor == 10) {
		// 공지 메시지는 이쪽으로.
		for (i = 1; i < 6; i++) {
			strcpy(m_stEventHistory2[i-1].cTxt, m_stEventHistory2[i].cTxt);
			m_stEventHistory2[i-1].cColor = m_stEventHistory2[i].cColor;
			m_stEventHistory2[i-1].dwTime = m_stEventHistory2[i].dwTime;
		} 

		ZeroMemory(m_stEventHistory2[5].cTxt, sizeof(m_stEventHistory2[5].cTxt));
		strcpy(m_stEventHistory2[5].cTxt, pTxt);
		m_stEventHistory2[5].cColor = cColor;
		m_stEventHistory2[5].dwTime = m_dwCurTime;

	}
	else {
		for (i = 1; i < 6; i++) {
			strcpy(m_stEventHistory[i-1].cTxt, m_stEventHistory[i].cTxt);
			m_stEventHistory[i-1].cColor = m_stEventHistory[i].cColor;
			m_stEventHistory[i-1].dwTime = m_stEventHistory[i].dwTime;
		}

		ZeroMemory(m_stEventHistory[5].cTxt, sizeof(m_stEventHistory[5].cTxt));
		strcpy(m_stEventHistory[5].cTxt, pTxt);
		m_stEventHistory[5].cColor = cColor;
		m_stEventHistory[5].dwTime = m_dwCurTime;
	}
}

              
int _iAttackerHeight[] = {0, 35, 35,35,35,35,35, 0,0,0,   
5,  // Slime
35, // Skeleton
40, // Stone-Golem
45, // Cyclops
35,// OrcMage
35,// ShopKeeper
5,// GiantAnt
8,// Scorpion
35,// Zombie
35,// Gandalf
35,// Howard
35,// Guard
10,// Amphis
38,// Clay-Golem
35,// Tom
35,// William
35,// Kennedy
35,// Hellhound
50,// Troll
45,// Orge
55,// Liche
65,// Demon
46,// Unicorn
49,// WereWolf
55,// Dummy
35,// Energysphere
75,// Arrow Guard Tower
75,// Cannon Guard Tower
50,// Mana Collector
50,// Detector
50,// Energy Shield Generator
50,// Grand Magic Generator
50,// ManaStone 42
40,// Light War Beetle
35,// GHK
40,// GHKABS
35,// TK
60,// BG
40,// Stalker
70,// HellClaw
85,// Tigerworm
50,// Catapult
85,// Gargoyle
70,// Beholder
40,// Dark-Elf
20,// Bunny
20,// Cat
40,// Giant-Frog
80,// Mountain-Giant
85,// Ettin
50,// Cannibal-Plant
50 // Rudolph
};

void CGame::bAddNewEffect(short sType, int sX, int sY, int dX, int dY, char cStartFrame, int iV1)
{
 int i;
 short sAbsX, sAbsY, sDist;
 long lPan;
 int  iV2 = 0;

	// v1.41 Detail Level이 Low면 추가하지 않는 Effect들 검사 
	if (m_cDetailLevel == 0) {
		switch (sType) {
		case 8:
		case 9:
		case 11:
		case 12:
		case 14:
		case 15:
			return;
		}
	}

	if( m_bIsProgramActive == FALSE ) return;

  	sAbsX = abs(((m_sViewPointX / 32) + 10) - dX);
	sAbsY = abs(((m_sViewPointY / 32) + 7) - dY);

	if (sAbsX > sAbsY) sDist = sAbsX;
	else sDist = sAbsY;

	for (i = 0; i < DEF_MAXEFFECTS; i++) 
	if (m_pEffectList[i] == NULL) {
		m_pEffectList[i] = new class CEffect;

		m_pEffectList[i]->m_sType  = sType;
		m_pEffectList[i]->m_sX     = sX;
		m_pEffectList[i]->m_sY     = sY;
		m_pEffectList[i]->m_dX     = dX;
		m_pEffectList[i]->m_dY     = dY;
		m_pEffectList[i]->m_iV1    = iV1;

		m_pEffectList[i]->m_cFrame = cStartFrame;
		m_pEffectList[i]->m_dwTime = m_dwCurTime;

		switch (sType) {
		case 1:
			// 검광 
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - _iAttackerHeight[iV1];
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;
		case 2:
			// 일반 화살 
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - _iAttackerHeight[iV1];
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = 0;
			m_pEffectList[i]->m_dwFrameTime = 10;
			
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);

			PlaySound('C', 4, sDist);
			break;

		case 4:
			// Gold 떨어지는 효과. 끝난후에는 아이템으로 바닥에 놓인다는 점에 주의.
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32;
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 100;

			sAbsX = abs(((m_sViewPointX / 32) + 10) - sX);
			sAbsY = abs(((m_sViewPointY / 32) + 7)  - sY);

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 12, sDist, lPan);
			break;

		case 5:
			// FireBall 폭발 효과
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 11;
			m_pEffectList[i]->m_dwFrameTime = 10;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;
	
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist);
			break;

		case 6:	 // Energy Bolt
		case 10: // Lightning Arrow
			
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 10;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;

			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 2, sDist, lPan);
			SetCameraShakingEffect(sDist);
			break;

		case 7:
			// Magic Missile Exp
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 5;
			m_pEffectList[i]->m_dwFrameTime = 50;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;

			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 3, sDist, lPan);
			break;

		case 8:
			// Burst 효과 타입 1
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 4;
			m_pEffectList[i]->m_dwFrameTime = 30;
			break;

		case 9:
			// Burst 효과 타입 2
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_rX     =  6 - (rand() % 12);
			m_pEffectList[i]->m_rY     = -8 - (rand() % 6);
			
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 30;
			break;

		case 11:
         #if DEF_LANGUAGE != 3
			// Burst 효과 3 - 피튀김 
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_rX     =  6 - (rand() % 12);
			
			if (iV2 == 0)
				 m_pEffectList[i]->m_rY     = -2 - (rand() % 4);
			else m_pEffectList[i]->m_rY     = -2 - (rand() % 10);
			
			m_pEffectList[i]->m_cMaxFrame   = 8;
			m_pEffectList[i]->m_dwFrameTime = 30;
          #endif
			break;

		case 12:
			// Burst 효과 4- 불꽃 튀김 
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_rX    =  8 - (rand() % 16);
			m_pEffectList[i]->m_rY    =  4 - (rand() % 12);
			
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 30;
			break;

		case 13: 
			// 수중 공기방울 
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 18;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 14:
			// 먼지 구름 
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 4;
			m_pEffectList[i]->m_dwFrameTime = 100;
			break;

		case 15:
			// 불꽃 남은 잔상 
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 16: // 날아가는 에너지 스트라이크 
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 17:
			m_pEffectList[i]->m_mX     = sX + (rand() % 20) - 40; // 아이스 스톰 알갱이 위치 
			m_pEffectList[i]->m_mY     = sY + (rand() % 20) - 40;
			m_pEffectList[i]->m_rX     =  8 - (rand() % 16);
			m_pEffectList[i]->m_rY     =  4 - (rand() % 12);
			m_pEffectList[i]->m_mX3    = sX; // 아이스 스톰 알갱이 추적 위치 
			m_pEffectList[i]->m_mY3    = sY;
			m_pEffectList[i]->m_iV1    = 0;     // 프레임 계산용 
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 18:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 50;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;
	
			SetCameraShakingEffect(sDist);
			break;

		case 20:
		case 21:
		case 22:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:

			// 필살기 
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = 0;
			m_pEffectList[i]->m_dwFrameTime = 10;
			
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
			break;
		
		case 30:
			// Mass-Fire-Strike 주 폭발 
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 9;
			m_pEffectList[i]->m_dwFrameTime = 40;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;
	
			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist*2);
			break;

		case 31:
			// Mass-Fire-Strike 부 폭발 
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 8;
			m_pEffectList[i]->m_dwFrameTime = 40;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
	
			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist);
			break;

		case 32:
			// 물방울 튀기는 에펙트(비오는 날 뛸때)
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = 4;
			m_pEffectList[i]->m_dwFrameTime = 100;
			break;

		case 33:
			// 번개 땅에 퍼지는 효과 
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 34: // 움직이는 지상 번개 
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;
				
			SetCameraShakingEffect(sDist);
			break;

		case 40:
			// 냉기 효과
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 30;
			
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;

			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 45, sDist, lPan);
			break;

		case 41: // 얼음 송곳 낙하 Large Type 1, 2, 3, 4
		case 42:
		case 43:
		case 44:

		case 45: // 얼음 송곳 낙하 Small Type 1, 2
		case 46: 
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY -220;
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 20;
			m_pEffectList[i]->m_iV1 = 20;
			
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;

			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 46, sDist, lPan);
			break;

		// v2.16 2002-5-23 고광현 수정 
		case 47: // Blizzard용 아이스 조각 (중)
		case 48: // Blizzard용 아이스 조각 (소)
		case 49: // Blizzard용 아이스 조각 (대)
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY -220;
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 20;
			m_pEffectList[i]->m_iV1 = 20;
			
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;

			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 46, sDist, lPan);
			break;

		case 50: // 얼음 송곳 부서짐
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 50;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;

			lPan = ((sX - m_sViewPointX)-320)*30;
			if ((rand()%4) == 1) SetCameraShakingEffect(sDist);
			PlaySound('E', 47, sDist, lPan);
			break;   

		case 51:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 9; //15;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 52: // Protect ring
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 80;
			
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;

			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 53: // Hold twist
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 80;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;

			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 54: // star twingkling
		case 55:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 15;
			break;

		case 56:
			// 새 냉기 효과
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 30;
			
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;

			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 45, sDist, lPan);
			break;

		case 57:
			// 캐스팅 효과
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 60:
			// 메테오 스트라이크 낙하, 명중 효과
			m_pEffectList[i]->m_mX    = sX +300;
			m_pEffectList[i]->m_mY    = sY -460;
			
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 50;
			break;

		case 61:
			// 메테오 폭발 효과 
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 10;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;
	
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist, 2);
			break;

		case 62: // 어두운 연기
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 6;
			m_pEffectList[i]->m_dwFrameTime = 100;
			break;

		case 63: // 
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 64: // 서몬 효과 
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 65: // 날아가는 어두운 연기
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 30;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 66: // 건물 폭발
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 30;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;
	
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist, 2);
			break;

		case 67: // 불 
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 27;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 68: // worm-bite 
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 17;
			m_pEffectList[i]->m_dwFrameTime = 30;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;
	
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 4, sDist, lPan);
			// 거리를 저장해 놓는다.
			m_pEffectList[i]->m_iV1 = sDist;
			//SetCameraShakingEffect(sDist, 2);
			break;

		case 69: // 축하용 불꽃 1
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 11;
			m_pEffectList[i]->m_dwFrameTime = 30;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;

			lPan = -(((m_sViewPointX / 32) + 10) - (sX/32))*1000;
			PlaySound('E', 42, sDist, lPan);
			break;

		case 70: // 축하용 불꽃 2
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			
			m_pEffectList[i]->m_cMaxFrame   = 11;
			m_pEffectList[i]->m_dwFrameTime = 30;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
 
			sDist = sDist / 32;

			lPan = -(((m_sViewPointX / 32) + 10) - (sX/32))*1000;
			PlaySound('E', 42, sDist, lPan);
			break;

		// v2.16 2002-5-23 고광현
		case 71: // 움직이는 지상 아이스  
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;

			sDist = sDist / 32;
				
			SetCameraShakingEffect(sDist);
			break;
		
		case 72: // Blizzard알갱이 깨짐
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 20;

			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));

			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;

			lPan = ((sX - m_sViewPointX)-320)*30;
			if ((rand()%4) == 1) SetCameraShakingEffect(sDist);
			PlaySound('E', 47, sDist, lPan);
			break;

		case 73:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 60;
			break;
		
		case 74:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 19;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 75:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_dX = dX;
			m_pEffectList[i]->m_dY = dY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 76:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_dX = dX;
			m_pEffectList[i]->m_dY = dY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 77:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_dX = dX;
			m_pEffectList[i]->m_dY = dY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 100:
			// 매직 미사일 Flying
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;

			PlaySound('E', 1, sDist, lPan);
			break;
		
		case 124: // Protect form N.M
		case 133: // Protection from Magic
 			bAddNewEffect(52, dX*32, dY*32, NULL, NULL, 0, 0);
			delete m_pEffectList[i];
			m_pEffectList[i] = NULL;
			break;

		case 125: // Hold Person
		case 135: // Paralyze
			bAddNewEffect(53, dX*32, dY*32, NULL, NULL, 0, 0);
			delete m_pEffectList[i];
			m_pEffectList[i] = NULL;
			break;
		case 102: //
		// v2.16 2002-5-24 고광현 
		case 122: // Recall
		case 126:
		case 134:
		case 142:
		case 152:
		case 127: // Poison
		case 153: // Mass-Poison
		case 162: // Confusion
		case 171: // Mass-Confusion
		case 136: // Cure
   			//
			m_pEffectList[i]->m_cMaxFrame   = 13;
			m_pEffectList[i]->m_dwFrameTime = 120;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 150: // Berserk : Cirlcle 6 magic 
		case 180: // Illusion
		case 190: // Mass-Illusion
   			//
			m_pEffectList[i]->m_cMaxFrame   = 11;
			m_pEffectList[i]->m_dwFrameTime = 100;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 113: // Defense-Shield
		case 144: // Great-Defense-Shield
   			//
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 120;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		// v2.16 2002-5-24 고광현 
		case 111: // Staminar-Drain
		case 101: //Heal
		case 121: // Great Heal
		case 123: // Staminar-Recovery
		case 128: // Great-Staminar-Recovery
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 80;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 132: // Invi
		case 112: // Recall
		case 131: // Summon
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 80;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;
		//

		case 110:
			// Energy-Bolt
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

		case 114: // Celebrating Light
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, -12);
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, -9);
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, -6);
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, -3);
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, 0);
			delete m_pEffectList[i];
			m_pEffectList[i] = NULL;
			break;

		case 120:
			// Fire Ball
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			
			//방향을 계산한다. 
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

		case 130: // Fire Strike
		case 137: // Lightning Arrow
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			
			//방향을 계산한다. 
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

		case 138: // Tremor. 화면을 흔든다. 
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist, 2);
						
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);

			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);

			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 164: // worm-bite
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 4, sDist, lPan);
									
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);

			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			
			m_pEffectList[i]->m_cMaxFrame   = 1;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		// v2.16 2002-5-24 고광현
		case 166: // Armor Break
			m_pEffectList[i]->m_cMaxFrame   = 13;
			m_pEffectList[i]->m_dwFrameTime = 80;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 165: // Absolute-Magic-Protection
			m_pEffectList[i]->m_cMaxFrame   = 21;
			m_pEffectList[i]->m_dwFrameTime = 70;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;
		// 여기까지 

		case 143:
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 50;
						
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_rX     = 5 - (rand() % 10);
			m_pEffectList[i]->m_rY	   = 5 - (rand() % 10);
			m_pEffectList[i]->m_cMaxFrame   = 7;
			m_pEffectList[i]->m_dwFrameTime = 10;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 40, sDist, lPan);
			break;

		case 145:
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 147: // v1.4334 Triple-Energy-Bolt 
			m_pEffectList[i]->m_cMaxFrame   = NULL ;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		
		case 151:
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 50;
						
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_rX     = 5 - (rand() % 10);
			m_pEffectList[i]->m_rY	   = 5 - (rand() % 10);
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 10;

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 40, sDist, lPan);
			break;

		case 156: // Mass-Ligtning-Arrow
			m_pEffectList[i]->m_cMaxFrame   = 3;
			m_pEffectList[i]->m_dwFrameTime = 130;
			break;

		case 157: // Ice-Strike
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;
		
		case 160: // Energy-Strike
			m_pEffectList[i]->m_cMaxFrame   = 7;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 161: // Mass-Fire-Strike
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			
			//방향을 계산한다. 
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);

			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

		case 163: // Mass-Chill-Wind
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 170: // Bloody-Shock-Wave
			m_pEffectList[i]->m_cMaxFrame   = 7;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 172: // Mass-Ice-Strike
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 174: // Lightning-Strike
			m_pEffectList[i]->m_cMaxFrame   = 5;
			m_pEffectList[i]->m_dwFrameTime = 120;
			break;

		case 181:
			// 메테오 스트라이크 
			m_pEffectList[i]->m_mX    = dX*32 +300;
			m_pEffectList[i]->m_mY    = dY*32 -460;
			
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 25;
			break;

		// v2.16 2002-5-23 고광현 수정 
		case 191:
			// 블리자드
			m_pEffectList[i]->m_cMaxFrame   = 7;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		default:
			delete m_pEffectList[i];
			m_pEffectList[i] = NULL;
			break;
		}
		
		if (m_pEffectList[i] != NULL) {
			m_pEffectList[i]->m_mX2 = m_pEffectList[i]->m_mX;
			m_pEffectList[i]->m_mY2 = m_pEffectList[i]->m_mY; 
		}

		return;
	}
}



void CGame::DrawEffects()
{
 int i, dX, dY, iDvalue,  tX, tY, rX, rY, rX2, rY2, rX3, rY3, rX4, rY4, rX5, rY5, iErr;
 char  cTempFrame;
 DWORD dwTime = m_dwCurTime;

 	for (i = 0;	i < DEF_MAXEFFECTS; i++)
	if ((m_pEffectList[i] != NULL) && (m_pEffectList[i]->m_cFrame >= 0)) {
		
		switch (m_pEffectList[i]->m_sType) {
		case 1:
			if (m_pEffectList[i]->m_cFrame < 0) break;
			dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			m_pEffectSpr[8]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 2:
			dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*2;
			if (cTempFrame < 0) break;
			m_pEffectSpr[7]->PutSpriteFast(dX, dY, cTempFrame, dwTime);
			break;

		case 20:
		case 21:
		case 22:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:
			dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			m_pEffectSpr[8]->PutTransSprite_NoColorKey(dX, dY, 1, dwTime);
			break;

		case 4:
			/* 1.5
			if (m_pEffectList[i]->m_cFrame < 9) break;
			cTempFrame = m_pEffectList[i]->m_cFrame - 9;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[1]->PutSpriteFast(dX, dY-40, cTempFrame, dwTime);
			*/
			break;

		case 5:
			// Fire Explosion
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 8)*(-5);

			if (cTempFrame < 7)
				 m_pEffectSpr[3]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			else m_pEffectSpr[3]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);
			break;

		case 6:	 // Energy Bolt 
		case 10: // Lightning Arrow
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 7)*(-6);

			if (cTempFrame < 6)
				 m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			else m_pEffectSpr[6]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;
				
		case 7:
			// Magic Missile Explosion
			cTempFrame = m_pEffectList[i]->m_cFrame;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 4)*(-3);

			if (cTempFrame < 4)
				 m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			else m_pEffectSpr[6]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 8:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			cTempFrame = 4 - cTempFrame;
			if (cTempFrame < 0) break;
			
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;

			m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 9:
			cTempFrame = (rand() % 5);
			if (cTempFrame < 0) break;
			
			dX  = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY) - m_sViewPointY;

			m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 11: // 피 튀기는 효과.
        #if DEF_LANGUAGE != 3
			cTempFrame = (rand() % 5) + 5;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY) - m_sViewPointY;

			m_pEffectSpr[11]->PutTransSprite2(dX, dY, cTempFrame, dwTime);
        #endif
			break;

		case 12:
			cTempFrame = (rand() % 6) + 10;
			if (cTempFrame < 0) break;
	
			iDvalue = (m_pEffectList[i]->m_cFrame - 4)*(-3);

			dX  = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY) - m_sViewPointY;

			if (cTempFrame < 4)
				 m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			else m_pEffectSpr[11]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			//m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			break;

		case 13:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY) - m_sViewPointY;
	
			if (cTempFrame < 13) {
				// 물방울 올라옴 
				m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, 25 + (cTempFrame / 5), dwTime);
			}
			else {
				// 물방울 터짐 
				m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, (8 + cTempFrame), dwTime);
			}
			break;

		case 14: // 먼지 
			if (m_pEffectList[i]->m_cFrame < 0) break;
	
			dX  = m_pEffectList[i]->m_mX - m_sViewPointX;
			dY  = m_pEffectList[i]->m_mY - m_sViewPointY;
			
			m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, (28 + m_pEffectList[i]->m_cFrame), dwTime);
			break;

		case 15:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = m_pEffectList[i]->m_mX - m_sViewPointX;
			dY  = m_pEffectList[i]->m_mY - m_sViewPointY;
			
			m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, (33 + cTempFrame), dwTime);
			break;

		case 16: // 날아가는 얼음조각 
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 0, dwTime);
			break;

		case 17:
			//test
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			cTempFrame = 39 + (rand() % 3)*3 + (rand() % 3);
			if (cTempFrame < 0) break;
			
			m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);

			dX  = (m_pEffectList[i]->m_mX2)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY2)  - m_sViewPointY;

			m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 18:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			m_pEffectSpr[18]->PutTransSprite70_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 30:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			m_pEffectSpr[14]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 31:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			m_pEffectSpr[15]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 32:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame + 20;
			if (cTempFrame < 0) break;

			m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 33:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			iDvalue = 0;
			m_pEffectSpr[19]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 40:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			m_pEffectSpr[20]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime); // 20
			break;

		case 41:
		case 42:
		case 43:
		case 44:
		case 45:
		case 46:
			
			// 낙석 그림자 그린다.
			dX  = (m_pEffectList[i]->m_sX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_sY)  - m_sViewPointY;
			m_pEffectSpr[21]->PutFadeSprite(dX, dY, 48, dwTime);
			
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			if ((8*(m_pEffectList[i]->m_sType-41) +cTempFrame) < (8*(m_pEffectList[i]->m_sType-41) +7)) {
				iDvalue = -8*(6 - cTempFrame);
				m_pEffectSpr[21]->PutTransSpriteRGB(dX, dY, 8*(m_pEffectList[i]->m_sType-41) +cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			}
			else {
				if ((cTempFrame - 5) >= 8) cTempFrame = ((cTempFrame - 5) - 8) + 5; 
				m_pEffectSpr[21]->PutSpriteFast(dX, dY, 8*(m_pEffectList[i]->m_sType-41) + (cTempFrame - 5), dwTime);
			}
			break;

		// v2.16 2002-5-23 고광현 수정 
		case 47:
		case 48:
		case 49:
			// Blizzard용 얼음 
			dX  = (m_pEffectList[i]->m_sX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_sY)  - m_sViewPointY;
			m_pEffectSpr[m_pEffectList[i]->m_sType-1]->PutRevTransSprite(dX, dY, 0, dwTime);
			
			cTempFrame = m_pEffectList[i]->m_cFrame;
			
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			//PutString(dX, dY, "*", RGB(255,255,255));
			if (cTempFrame < 7) {
				iDvalue = -8*(6 - cTempFrame);
				m_pEffectSpr[m_pEffectList[i]->m_sType-1]->PutTransSpriteRGB(dX, dY, cTempFrame+1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			else {
				if (cTempFrame >= 8) cTempFrame = cTempFrame % 8;
				m_pEffectSpr[m_pEffectList[i]->m_sType-1]->PutSpriteFast(dX, dY, cTempFrame+1, dwTime);
			}
			break;

		case 50:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
						
			if (cTempFrame <= 6) {
				iDvalue = 0;
				m_pEffectSpr[22]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);	// RGB2			
			}
			else {
				iDvalue = -5*(cTempFrame - 6);
				m_pEffectSpr[22]->PutTransSpriteRGB(dX, dY, 6, iDvalue, iDvalue, iDvalue, dwTime); // RGB2				
			}
			break;
		
		case 51: // 냉기 먼지 
			cTempFrame = m_pEffectList[i]->m_cFrame + 11; //15
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			m_pEffectSpr[28]->PutTransSprite25(dX, dY, cTempFrame, dwTime); //20
			break;

		case 52:
			break;
		/*
		case 52: // Protection Ring
			cTempFrame = m_pEffectList[i]->m_cFrame;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[24]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			break;
		*/

		case 53: // Hold Twist
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			if (cTempFrame < 0) cTempFrame = 0;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[25]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); //25
			break;
 
		case 54: // 별빛 
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) cTempFrame = 0;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[28]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			break;

		case 55: // 별빛 : 좌표의 차이
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) cTempFrame = 0;
			dX  = (m_pEffectList[i]->m_mX);
			dY  = (m_pEffectList[i]->m_mY);
			m_pEffectSpr[28]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break; 

		case 56: // Mass-Chill-Wind용 냉기구름 
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) cTempFrame = 0;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			m_pEffectSpr[29]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime); 
			break;

		case 181:
		case 60: // 메테오 스트라이크 낙하
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			if (cTempFrame > 4) {
				cTempFrame = cTempFrame / 4;
			}
			
			if (cTempFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;

				// 먼저 핵을 그린다.
				m_pEffectSpr[31]->PutSpriteFast(dX, dY, 15 + cTempFrame, dwTime); 
				// 다음 연기구름
				m_pEffectSpr[31]->PutTransSprite(dX, dY, cTempFrame, dwTime); 
			}
			break;

		case 61:
			// 메테오 폭발 효과
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[32]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); 
			break;

		case 62:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			if (cTempFrame > 0) {
				cTempFrame = cTempFrame - 1;
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				// 다음 연기구름
				m_pEffectSpr[31]->PutRevTransSprite(dX, dY, 20 + cTempFrame, dwTime, cTempFrame/3); 
			}
			break;

		case 63:
			// 버섯 구름 
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[33]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); 
			break;

		case 64: // 서몬 효과
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[34]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); 
			break;

		case 65:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			
			cTempFrame = cTempFrame / 6;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				
			m_pEffectSpr[31]->PutRevTransSprite(dX, dY, 20 + cTempFrame, dwTime, cTempFrame >> 2); 
			break;

		case 66:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
						
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				
			m_pEffectSpr[39]->PutRevTransSprite(dX, dY, cTempFrame, dwTime); 
			m_pEffectSpr[39]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); 
			break;

		case 67:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
						
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;

			switch (rand() % 3) {
			case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(dX, dY +20, 1, dwTime); break;
			case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(dX, dY +20, 1, dwTime); break;
			case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(dX, dY +20, 1, dwTime); break;
			}
					
			m_pEffectSpr[35]->PutTransSprite70_NoColorKey(dX, dY, cTempFrame/3, dwTime);
			break;

		case 68:
			cTempFrame = m_pEffectList[i]->m_cFrame; 
			if (cTempFrame < 0) break;
						
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			if (cTempFrame <= 11) {
				m_pEffectSpr[40]->PutSpriteFast(dX, dY, cTempFrame, dwTime); 
				m_pEffectSpr[41]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime); 
				m_pEffectSpr[44]->PutRevTransSprite(dX-2, dY-3, cTempFrame, dwTime); 
				m_pEffectSpr[44]->PutTransSprite_NoColorKey(dX-4, dY-3, cTempFrame, dwTime); 
			}
			else {
				switch (cTempFrame) {
				case 12:
				case 13:
				case 14: m_pEffectSpr[40]->PutSpriteFast(dX, dY, 11, dwTime); break;
				case 15: m_pEffectSpr[40]->PutTransSprite70_NoColorKey(dX, dY, 11, dwTime); break;
				case 16: m_pEffectSpr[40]->PutTransSprite50_NoColorKey(dX, dY, 11, dwTime); break;
				case 17: m_pEffectSpr[40]->PutTransSprite25_NoColorKey(dX, dY, 11, dwTime); break;
				}
			}
			break;

		case 69:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
						
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
						
			m_pEffectSpr[42]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); 
			break;

		case 70:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
						
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
						
			m_pEffectSpr[43]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); 
			break;	
			
		// v2.16 2002-5-23 고광현
		case 72: // Blizzard용 큰 알갱이 깨짐
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
									
			if (cTempFrame <= 8) {
				iDvalue = 0;
				m_pEffectSpr[51]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);	
			}
			else {
				iDvalue = -1*(cTempFrame - 8);
				m_pEffectSpr[51]->PutTransSpriteRGB(dX, dY, 8, iDvalue, iDvalue, iDvalue, dwTime);	// RGB2			
			}
			break;

		case 100: // Magic Missile
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 0, dwTime);
			break;

		case 110: // Energy-Bolt
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 2 + (rand() % 4), dwTime);
			break;

		// v2.16 2002-5-24 고광현
		case 102: // Create Food
		
		case 124: // Protection from N.M
		case 125: // Hold-Person
		case 126: // Possession
		case 127: // Poison
		case 133: // Protect-From-Magic
		case 134: // Detect-Invisibility
		case 135: // Paralyze
		case 136: // Cure
		case 142: // Confuse Language
		case 152:
		case 153: // Mass-Poison
		case 162: // Confusion
		case 171: // Mass-Confusion
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 5)*(-5);

			if (cTempFrame < 5)
				 m_pEffectSpr[4]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[4]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 180: // Illusion
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 5)*(-3);

			if (cTempFrame < 9)	m_pEffectSpr[60]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[60]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 190: // Mass-Illusion
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 5)*(-3);

			if (cTempFrame < 9) m_pEffectSpr[61]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);				 
			else m_pEffectSpr[61]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 113: // Defense Shield
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 5)*(-5);

			if (cTempFrame < 6)
				 m_pEffectSpr[62]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[62]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 144: // Great-Defense-Shield
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 5)*(-5);

			if (cTempFrame < 9)
				 m_pEffectSpr[63]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[63]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		//v2.16 2002-5-24 고광현 Staminar Drain 몸을 감싸면서 아래로 내려오는 이펙트
		case 111: // Staminar Drain 몸을 감싸면서 내려가는 이펙트
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 5)*(-5);
			m_pEffectSpr[49]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 101: // Heal
		case 121: // Great-Heal 몸을 감싸면서 올라가는 이펙트 노랑색
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 5)*(-5);
			m_pEffectSpr[50]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 123: // Staminar-Recovery
		case 128: // Great-Staminar-Recovery 몸을 감싸면서 올라가는 이펙트 녹색
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 5)*(-5);
			m_pEffectSpr[56]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 132: // Invisibility
		case 112: // Recall
		case 131: // Summon-Creature
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			
			iDvalue = (cTempFrame - 5)*(-5);
			m_pEffectSpr[52]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;


		case 165: // Absolute-Magic-Protect
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[53]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;
		// 여기까지

		case 166: // Armor-Break
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;

			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[55]->PutRevTransSprite(dX, dY+35, m_pEffectList[i]->m_cFrame, dwTime);
			m_pEffectSpr[54]->PutTransSprite50(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 120: // Fire Ball
		case 130: // Fire Strike
		case 161: // Mass-Fire-Strike
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[5]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 137: // Lightning Arrow
			
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
							
			tX  = (m_pEffectList[i]->m_mX2)  - m_sViewPointX;
			tY  = (m_pEffectList[i]->m_mY2)  - m_sViewPointY;
			
			iErr = 0;
			m_Misc.GetPoint(dX, dY, tX, tY, &rX, &rY, &iErr, 15);
			m_Misc.GetPoint(dX, dY, tX, tY, &rX2, &rY2, &iErr, 30);
			m_Misc.GetPoint(dX, dY, tX, tY, &rX3, &rY3, &iErr, 45);
			m_Misc.GetPoint(dX, dY, tX, tY, &rX4, &rY4, &iErr, 60);
			m_Misc.GetPoint(dX, dY, tX, tY, &rX5, &rY5, &iErr, 75);

			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite25_NoColorKey(rX5, rY5, cTempFrame, dwTime);
			
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite25_NoColorKey(rX4, rY4, cTempFrame, dwTime);
			
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite50_NoColorKey(rX3, rY3, cTempFrame, dwTime);
			
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite50_NoColorKey(rX2, rY2, cTempFrame, dwTime);
			
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite70_NoColorKey(rX,  rY, cTempFrame, dwTime);
			
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			break;

		case 143: // Lightning
			_DrawThunderEffect(m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY - 800,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY, 
								m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);
			
			_DrawThunderEffect(m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY - 800,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY, 
								m_pEffectList[i]->m_rX+4, m_pEffectList[i]->m_rY+2, 2);

			_DrawThunderEffect(m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY - 800,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY, 
								m_pEffectList[i]->m_rX-2, m_pEffectList[i]->m_rY-2, 2);
			break;

		case 151: // Lightning Bolt
			_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY, 
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY, 
								m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);

			_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY, 
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY, 
								m_pEffectList[i]->m_rX+2, m_pEffectList[i]->m_rY-2, 2);

			_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY, 
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY, 
								m_pEffectList[i]->m_rX-2, m_pEffectList[i]->m_rY-2, 2);
			break;
		}
	}
}

void CGame::bItemDrop_IconPannel(short msX, short msY)
{

 short sX, sY, sItemIndex;

	sX = m_stDialogBoxInfo[30].sX;
	sY = m_stDialogBoxInfo[30].sY;

	sItemIndex = m_stMCursor.sSelectedObjectID;
	if (m_bIsItemDisabled[sItemIndex] == TRUE) return;

	// 명령이 유효하지 않은 상태라면(죽었다거나) 명령을 수행할 수 없다.
	if (m_cCommand < 0) return;

	// 인벤토리에 놓았다면 
	if ((453 < msX) && (486 > msX) && (440 < msY) && (475 > msY)) {
		bItemDrop_Inventory(m_stDialogBoxInfo[2].sX + (rand() % 148), m_stDialogBoxInfo[2].sY + (rand() % 55));
		return;
	}

	if ((425 < msX)	&& (448 > msX) && (440 < msY) && (475 > msY)) {
		bItemDrop_Character();
		return;
	}
}



void CGame::DrawEffectLights()
{
 int i, dX, dY, iDvalue;
 DWORD dwTime = m_dwCurTime;
 char  cTempFrame;

	// Effect의 광원효과를 보조하는 효과이다.
	for (i = 0;	i < DEF_MAXEFFECTS; i++)
	if (m_pEffectList[i] != NULL) {
		switch (m_pEffectList[i]->m_sType) {
		case 1:
			break;

		case 2:
			break;

		case 4:
			break;

		case 5:
			// Fire Explosion
			if (m_pEffectList[i]->m_cFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				
				iDvalue = (m_pEffectList[i]->m_cFrame - 7)*(-1);
			
				if (m_pEffectList[i]->m_cFrame < 6)
					 m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY+30, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY+30, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			break;

		case 7:
			// Magic Missile Explosion
			if (m_pEffectList[i]->m_cFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				
				iDvalue = (m_pEffectList[i]->m_cFrame - 2)*(-1);
			
				if (m_pEffectList[i]->m_cFrame < 2)
					 m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY+30, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY+30, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			break;

		case 69:
		case 70:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[0]->PutTransSprite25(dX, dY+30, 1, dwTime);
			break;

		case 16:
		case 61:
		case 66:
		case 100:
		case 110:
		case 120:
		case 130:
		case 137:
		case 165: // v2.16 2002-5-24 고광현
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			iDvalue = -5;
			m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY+30, 1, iDvalue, iDvalue, iDvalue, dwTime);
			break;

		case 6:	 // Energy Bolt
		case 10: // Lightning Arrow
			if (m_pEffectList[i]->m_cFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				
				iDvalue = (m_pEffectList[i]->m_cFrame - 9)*(-1);
			
				if (m_pEffectList[i]->m_cFrame < 8)
					 m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY+30, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY+30, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			break;

		case 33: // 번개 퍼지는 효과 
			/*
			if (m_pEffectList[i]->m_cFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				
				iDvalue = (m_pEffectList[i]->m_cFrame - 9)*(-1);
			
				if (m_pEffectList[i]->m_cFrame < 8)
					 m_pEffectSpr[0]->PutTransSprite(dX, dY, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			*/
			break;

		case 40: // 냉기
		case 56:
			if (m_pEffectList[i]->m_cFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				
				iDvalue = (m_pEffectList[i]->m_cFrame - 7)*(-1);
			
				if (m_pEffectList[i]->m_cFrame < 6)
					 m_pEffectSpr[0]->PutTransSprite(dX, dY, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			break;

		case 52: // Protection Ring
			if (m_pEffectList[i]->m_cFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				m_pEffectSpr[24]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			}
			break;

		case 57:
			if (m_pEffectList[i]->m_cFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				m_pEffectSpr[30]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			}
			break;

		case 73:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[74]->PutTransSprite(dX, dY-34, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 74:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[75]->PutTransSprite(dX, dY+35, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 75:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[76]->PutTransSprite25(dX+m_pEffectList[i]->m_dX*m_pEffectList[i]->m_cFrame, dY+m_pEffectList[i]->m_dY*m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 76:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[77]->PutTransSprite25(dX+m_pEffectList[i]->m_dX*m_pEffectList[i]->m_cFrame, dY+m_pEffectList[i]->m_dY*m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 77:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[78]->PutTransSprite25(dX+m_pEffectList[i]->m_dX*m_pEffectList[i]->m_cFrame, dY+m_pEffectList[i]->m_dY*m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 150: // Berserk : Cirlcle 6 magic 
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[58]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 180:
		case 190:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[59]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			//if( cTempFrame < 9 ) m_pEffectSpr[59]->PutTransSprite_NoColorKey( dX, dY, cTempFrame, dwTime );
			//else m_pEffectSpr[59]->PutSpriteFast( dX, dY, cTempFrame, dwTime );
			break;
		}
	}
}

void CGame::_LoadShopMenuContents(char cType)
{
 char cFileName[255], cTemp[255];
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;
 char * pBuffer;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));
	wsprintf(cTemp, "contents%d", cType);
	strcat(cFileName, "contents" );
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return;
	else {
		pBuffer = new char[dwFileSize+1];
		ZeroMemory(pBuffer, dwFileSize+1);
		fread(pBuffer, dwFileSize, 1, pFile);

		__bDecodeContentsAndBuildItemForSaleList(pBuffer);
		delete[] pBuffer;
	}
	fclose(pFile);
}

BOOL CGame::__bDecodeContentsAndBuildItemForSaleList(char * pBuffer)
{
 char * pContents, * token;
 char seps[] = "= ,\t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iItemForSaleListIndex = 0;
 class CStrTok * pStrTok;

	pContents = pBuffer;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			//
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 아이템 이름
					ZeroMemory(m_pItemForSaleList[iItemForSaleListIndex]->m_cName, sizeof(m_pItemForSaleList[iItemForSaleListIndex]->m_cName));
					memcpy(m_pItemForSaleList[iItemForSaleListIndex]->m_cName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					// m_cItemType
					m_pItemForSaleList[iItemForSaleListIndex]->m_cItemType = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					// m_cEquipPos
					m_pItemForSaleList[iItemForSaleListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_sItemEffectType
					//m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectType = atoi(token);안씀
					cReadModeB = 5;
					break;
				case 5:
					// m_sItemEffectValue1
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_sItemEffectValue2
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_sItemEffectValue3
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 8;
					break;
				case 8:
					// m_sItemEffectValue4
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 9;
					break;
				case 9:
					// m_sItemEffectValue5
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 10;
					break;
				case 10:
					// m_sItemEffectValue6
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 11;
					break;
				case 11:
					// m_wMaxLifeSpan
					m_pItemForSaleList[iItemForSaleListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 12;
					break;
				case 12:
					// m_sMaxFixCount
					//m_pItemForSaleList[iItemForSaleListIndex]->m_sMaxFixCount = atoi(token);
					cReadModeB = 13;
					break;
				case 13:
					// m_sSprite
					m_pItemForSaleList[iItemForSaleListIndex]->m_sSprite = atoi(token);
					cReadModeB = 14;
					break;
				case 14:
					// m_sSpriteFrame
					m_pItemForSaleList[iItemForSaleListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 15;
					break;
				case 15:
					// m_wPrice
					m_pItemForSaleList[iItemForSaleListIndex]->m_wPrice = atoi(token);
					cReadModeB = 16;
					break;
				case 16:
					// m_wWeight
					m_pItemForSaleList[iItemForSaleListIndex]->m_wWeight = atoi(token);
					cReadModeB = 17;
					break;
				case 17:
					// Appr Value
					//m_pItemForSaleList[iItemForSaleListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 18;
					break;
				case 18:
					// m_cSpeed
					m_pItemForSaleList[iItemForSaleListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// Level Limit
					m_pItemForSaleList[iItemForSaleListIndex]->m_sLevelLimit = atoi(token);
					m_pItemForSaleList[iItemForSaleListIndex]->m_dwCount = 1;
					cReadModeA = 0;
					cReadModeB = 0;
					iItemForSaleListIndex++;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "ItemForSale", 4) == 0) {
				// v2.14 
				if (iItemForSaleListIndex >= DEF_MAXMENUITEMS) {
					delete pStrTok;
					return FALSE;
				}
				cReadModeA = 1;
				cReadModeB = 1;
				m_pItemForSaleList[iItemForSaleListIndex] = new class CItem;
			}
			
		}
		token = pStrTok->pGet();
	}	
	delete pStrTok;

	if ((cReadModeA != 0) || (cReadModeB != 0)) return FALSE;
	return TRUE;
}


static char __cSpace[] = {8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8, 8,6,8,7,8,8,9,10,9,7, 8,8,8,8,8, 8,8, 
                          15,16,12,17,14,15,14,16,10,13, 19,10,17,17,15,14,15,16,13,17, 16,16,20,17,16,14,
	       			      8,8,8,8,8,8,	8,6,7,8,7,7,7,7,4,7,7,  4,11,7,8,8,7,8,6,5,8,9,14,8,9,8, 8,8,8,8, 
				          8,8,8,8,8,8,8};
void CGame::PutString_SprFont(int iX, int iY, char * pStr, short sR, short sG, short sB)
{
 int iXpos;
 DWORD iCnt;
 DWORD dwTime = G_dwGlobalTime;
 char  cTmpStr[100];

	ZeroMemory(cTmpStr, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);
	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
		if ((cTmpStr[iCnt] >= 33) && (cTmpStr[iCnt] <= 122)) {
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteRGB(iXpos+1, iY, cTmpStr[iCnt] - 33, sR+11, sG+7, sB+6, dwTime);	
			if ((sR == 0) && (sG == 0) && (sB == 0)) 
				 m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 33, dwTime);	
			else m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 33, sR, sG, sB, dwTime);	
			 iXpos += __cSpace[cTmpStr[iCnt] - 33];
		}
		else iXpos += 5;
	}
}

void CGame::PutString_SprFont2(int iX, int iY, char * pStr, short sR, short sG, short sB)
{
 int iXpos, iR, iG, iB;
 DWORD iCnt;
 DWORD dwTime = G_dwGlobalTime;
 char  cTmpStr[200];
 
	m_DDraw.ColorTransferRGB(RGB(sR, sG, sB), &iR, &iG, &iB);

	ZeroMemory(cTmpStr, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);

	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
		if ((cTmpStr[iCnt] >= 33) && (cTmpStr[iCnt] <= 122)) {
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos+1, iY, cTmpStr[iCnt] - 33, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos+1, iY+1, cTmpStr[iCnt] - 33, dwTime);
			if ((sR == 0) && (sG == 0) && (sB == 0)) 
				 m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 33, dwTime);	
			else m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 33, iR, iG, iB, dwTime);	
			 iXpos += __cSpace[cTmpStr[iCnt] - 33];
		}
		else iXpos += 5;
	}
}

void CGame::PutString_SprFont3(int iX, int iY, char * pStr, short sR, short sG, short sB, BOOL bTrans, int iType)
{
 int iXpos, iAdd;
 DWORD iCnt;
 DWORD dwTime = G_dwGlobalTime;
 char  cTmpStr[128];

	ZeroMemory(cTmpStr, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);

	if (iType != -1) {
		iAdd = 95*iType;
		iXpos = iX;
		for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
			if ((cTmpStr[iCnt] >= 32) && (cTmpStr[iCnt] <= 126)) {
			
				if (bTrans == FALSE) {
					m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteFast(iXpos, iY+1, cTmpStr[iCnt] - 32 +iAdd, dwTime);	
					m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteFast(iXpos+1, iY+1, cTmpStr[iCnt] - 32 +iAdd, dwTime);	
					if ((sR == 0) && (sG == 0) && (sB == 0)) 
						 m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, dwTime);	
					else m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, sR, sG, sB, dwTime);	
				
				}
				else m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutTransSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, sR, sG, sB, dwTime);	
					
				iXpos += (m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->m_stBrush[cTmpStr[iCnt] - 32 +iAdd].szx);
			}
			else iXpos += 5;
		}
	}
	else {
		iAdd = 0;
		iXpos = iX;
		for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
			if ((cTmpStr[iCnt] >= 32) && (cTmpStr[iCnt] <= 126)) {
			
				if (bTrans == FALSE) {
					m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteFast(iXpos, iY+1, cTmpStr[iCnt] - 32 +iAdd, dwTime);	
					m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteFast(iXpos+1, iY+1, cTmpStr[iCnt] - 32 +iAdd, dwTime);	
					if ((sR == 0) && (sG == 0) && (sB == 0)) 
						 m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, dwTime);	
					else m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, sR, sG, sB, dwTime);	
				
				}
				else m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutTransSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, sR, sG, sB, dwTime);	
					
				iXpos += (m_pSprite[DEF_SPRID_INTERFACE_FONT2]->m_stBrush[cTmpStr[iCnt] - 32 +iAdd].szx);
			}
			else iXpos += 5;
		}
	}
}

static char __cSpace2[] = {6,4,6,6,6,6,6,6,6,6,6}; //{8,6,9,8,8,9,8,8,8,8};
void CGame::PutString_SprNum(int iX, int iY, char * pStr, short sR, short sG, short sB)
{
 int iXpos;
 unsigned char iCnt;
 DWORD dwTime = G_dwGlobalTime;
 char  cTmpStr[200];
 WORD  wR, wG, wB;

	ZeroMemory(cTmpStr, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);

	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(sR, sG, sB), &wR, &wG, &wB);

	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
		if ((cTmpStr[iCnt] >= 0x30) && (cTmpStr[iCnt] <= 0x39)) {
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSprite(iXpos+2, iY, cTmpStr[iCnt] - 0x30 +6, dwTime);	
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSprite(iXpos+1, iY+1, cTmpStr[iCnt] - 0x30 +6, dwTime);	
			if ((sR == 0) && (sG == 0) && (sB == 0)) 
				 m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSprite(iXpos, iY, cTmpStr[iCnt] - 0x30 +6, dwTime);	
			else m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 0x30 +6, wR, wG, wB, dwTime);	
			iXpos += __cSpace2[cTmpStr[iCnt] - 0x30];
		}
	}
}

void CGame::PutString(int iX, int iY, char * pString, COLORREF color, BOOL bHide, char cBGtype, BOOL bIsPreDC)
{
 char * pTmp;
 int i;
	
	if (strlen(pString) == 0) return;

	if (bIsPreDC == FALSE) m_DDraw._GetBackBufferDC();

	if (bHide == FALSE) {
		switch (cBGtype) {
		case 0:
			m_DDraw.TextOut(iX+1, iY, pString, color);
			break;
		case 1:
			m_DDraw.TextOut(iX, iY+1, pString, RGB(5,5,5));
			m_DDraw.TextOut(iX+1, iY+1, pString, RGB(5,5,5));
			m_DDraw.TextOut(iX+1, iY, pString, RGB(5,5,5));
			break;
		}
		m_DDraw.TextOut(iX, iY, pString, color);
	}	
	else { 
		pTmp = new char[strlen(pString)+2];
		ZeroMemory(pTmp, strlen(pString)+2);
		strcpy(pTmp, pString);
		for (i = 0; i < (int)strlen(pString); i++) 
			if (pTmp[i] != NULL) pTmp[i] = '*';
		
		switch (cBGtype) {
		case 0:
			m_DDraw.TextOut(iX+1, iY, pTmp, color);
			break;
		case 1:
			m_DDraw.TextOut(iX, iY+1, pTmp, RGB(5,5,5));
			m_DDraw.TextOut(iX+1, iY+1, pTmp, RGB(5,5,5));
			m_DDraw.TextOut(iX+1, iY, pTmp, RGB(5,5,5));
			break;
		}
		m_DDraw.TextOut(iX, iY, pTmp, color);
		delete[] pTmp;
	}
	if (bIsPreDC == FALSE) m_DDraw._ReleaseBackBufferDC();
}


void CGame::PutString(int iX, int iY, char * pString, COLORREF color)
{
	m_DDraw._GetBackBufferDC();
	m_DDraw.TextOut(iX, iY, pString, color);
	m_DDraw._ReleaseBackBufferDC();
}

void CGame::PutString2(int iX, int iY, char * pString, short sR, short sG, short sB)
{
	m_DDraw._GetBackBufferDC();
	m_DDraw.TextOut(iX+1, iY, pString, RGB(0, 0, 0));
	m_DDraw.TextOut(iX, iY+1, pString, RGB(0, 0, 0));
	m_DDraw.TextOut(iX+1, iY+1, pString, RGB(0, 0, 0));
	m_DDraw.TextOut(iX, iY, pString, RGB(sR, sG, sB));
	m_DDraw._ReleaseBackBufferDC();
}

void CGame::PutAlignedString(int iX1, int iX2, int iY, char * pString, short sR, short sG, short sB)
{
	RECT rt;
	m_DDraw._GetBackBufferDC();
	SetRect(&rt, iX1, iY, iX2, iY+15);
	m_DDraw.DrawText(&rt, pString, RGB(sR, sG, sB));
	m_DDraw._ReleaseBackBufferDC();
}

BOOL CGame::bInitMagicCfgList()
{
 char cFn[255], cTemp[255];
 char * pContents, * token;
 char seps[] = "= ,\t\n"; 
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMagicCfgListIndex = 0;
 class CStrTok * pStrTok;
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFn, sizeof(cFn));

	strcpy(cTemp, "magiccfg.txt");

	strcat(cFn, "contents");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}
	
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 마법 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pMagicCfgList[atoi(token)] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicCfgList[atoi(token)] = new class CMagic;
					iMagicCfgListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 마법 이름 
					ZeroMemory(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, sizeof(m_pMagicCfgList[iMagicCfgListIndex]->m_cName));
					memcpy(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 6;
					break;

				case 6://쓰지 않으므로 뺐음.
					// m_sValue4
					//if (_bGetIsStringIsNumber(token) == FALSE) {
					//	delete[] pContents;
					//	delete pStrTok;
					//	return FALSE;
					//}
					//m_pMagicCfgList[iMagicCfgListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 7;
					break;

				case 7://쓰지 않으므로 뺐음.
					// m_sValue5
					//if (_bGetIsStringIsNumber(token) == FALSE) {
					//	delete[] pContents;
					//	delete pStrTok;
					//	return FALSE;
					//}
					//m_pMagicCfgList[iMagicCfgListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 8;
					break;

				case 8://쓰지 않으므로 뺐음.
					// m_sValue6
					//if (_bGetIsStringIsNumber(token) == FALSE) {
					//	delete[] pContents;
					//	delete pStrTok;
					//	return FALSE;
					//}
					//m_pMagicCfgList[iMagicCfgListIndex]->m_sValue6 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_bIsVisible
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					if( atoi(token) == 0 ) m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = FALSE;
					else m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = TRUE;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		return FALSE;
	}

	return TRUE;
}

BOOL CGame::bCheckImportantFile()
{
	HANDLE hFile;
	hFile = CreateFile("CONTENTS\\badword.txt", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( hFile == INVALID_HANDLE_VALUE ) return FALSE;
	CloseHandle( hFile );
	
//	hFile = CreateFile("SPRITES\\TREES1.PAK", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
//	if( hFile == INVALID_HANDLE_VALUE ) return FALSE;
//
//	//2003.02.18 현재 FileSize : 2945524
//	//미국 서비스용은 현재 FileSize : 1846406..
//	if( GetFileSize( hFile, NULL ) != 2945524 )
//	{
//		CloseHandle( hFile );
//		return FALSE;
//	}
//	CloseHandle( hFile );
	return TRUE;
}

BOOL CGame::bInitSkillCfgList()
{
 char cFn[255], cTemp[255];
 char * pContents, * token;
 char seps[] = "= ,\t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillCfgListIndex = 0;
 class CStrTok * pStrTok;
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFn, sizeof(cFn));

	strcpy(cTemp, "Skillcfg.txt");
	strcat(cFn, "contents");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}
	
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 기술 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pSkillCfgList[atoi(token)] != NULL) {
						// 이미 할당된 기술이 있다. 에러이다.
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillCfgList[atoi(token)] = new class CSkill;
					iSkillCfgListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 기술 이름 
					ZeroMemory(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, sizeof(m_pSkillCfgList[iSkillCfgListIndex]->m_cName));
					memcpy(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// m_bIsUseable
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillCfgList[iSkillCfgListIndex]->m_bIsUseable = (BOOL)atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_cUseMethod
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillCfgList[iSkillCfgListIndex]->m_cUseMethod = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		return FALSE;
	}

	return TRUE;
}


BOOL CGame::_bGetIsStringIsNumber(char * pStr)
{
 int i;
	for (i = 0; i < (int)strlen(pStr); i++)
	if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;
	
	return TRUE;
}


void CGame::RequestFullObjectData(WORD wObjectID)
{
 char    cMsg[256];
 int     iRet;
 DWORD * dwp;
 WORD  * wp;

	ZeroMemory(cMsg, sizeof(cMsg));

	dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
	*dwp = MSGID_REQUEST_FULLOBJECTDATA;
	wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
	*wp = wObjectID;

	iRet = m_pGSock->iSendMsg((char *)cMsg, 6);

	switch (iRet) {
	case DEF_XSOCKEVENT_SOCKETCLOSED:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_QUENEFULL:
		// 소켓에 에러가 발생했으므로 접속을 해제한다.
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		
		delete m_pGSock;
		m_pGSock = NULL;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pGSock;
		m_pGSock = NULL;

		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		break;
	}
}


BOOL   CGame::DrawObject_OnAttack(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iWeapon, iAdd, iShieldIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	// v1.41 특수 크리쳐 처리 
	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern
	// v1.4
	// v1.41 Detail Level이 Low면 컬러정보를 표시하지 않는다.
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 소지하고 있는 무기에 따라서 동작이 바뀐다.
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4); 
			if (iWeapon == 0) iAdd = 6;							// 맨손 
			if ((iWeapon >= 1)  && (iWeapon <= 39)) iAdd = 6;	// 검, 도끼등  
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;	// 활  

			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*4 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 4;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
		}
		else {
			// 비전투모드이다. 공격명령은 곧 인사동작. 
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (5 * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 5;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 5; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 5; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 5; 

			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 5; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 5; 

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 5; 
			
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 5; 
			
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	case 4:
	case 5:
	case 6:
		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 소지하고 있는 무기에 따라서 동작이 바뀐다.
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4); 
			if (iWeapon == 0) iAdd = 6;							// 맨손 
			if ((iWeapon >= 1)  && (iWeapon <= 39)) iAdd = 6;	// 검, 도끼등  
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;	// 활  

			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*4 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 4;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
		}
		else {
			// 비전투모드이다. 공격명령은 곧 인사동작. 
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (5 * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 5;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 5; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 5; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 5; 

			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 5; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 5; 

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 5; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 5; 

			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;


	default:								
		if (_tmp_sAppr2 != 0) {
			 iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			 _tmp_cFrame = _tmp_sAppr2 -1;
		}
		else if (_tmp_sOwnerType == 66) iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1; 
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);

	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == FALSE) {
		
		if (_cDrawingOrder[_tmp_cDir] == 1) {
			// 무기를 먼저 그린다.
			if (iWeaponIndex != -1) {
				if (iWeaponColor == 0) {
					m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
				}
				else {
					m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}

				// 무기 잔상 
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame -1, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
			}
			
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
            case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}

			// 에너지 볼 바닥 조명 
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
			
			if (bInv == TRUE) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				    m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			
			if ((iHairIndex   != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					 m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)	
					 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}
			
			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iShieldIndex != -1) {
				if (iShieldColor == 0)
					 m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
		}
		else {
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}

			// 에너지 볼 바닥 조명 
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
			
			if (bInv == TRUE) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				    m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
				
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			
			if ((iHairIndex   != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					 m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)	
					 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}

			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iShieldIndex != -1) {
				if (iShieldColor == 0)
					 m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iWeaponIndex != -1) {
				if (iWeaponColor == 0)
					 m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}

				// 무기 잔상 
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame -1, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
			}
		}
				
		// Berserk 
		if ((_tmp_sStatus & 0x20) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		// Protection From Magic
		if ((_tmp_sStatus & 0x80) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, -5, 0, 5, dwTime);
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_sStatus);
	}

	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}


BOOL   CGame::DrawObject_OnAttackMove(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iWeapon, iAdd, iShieldIndex, iMantleIndex, dx, dy, dsx, dsy;
 int cFrameMoveDots;
 BOOL bInv = FALSE, bDashDraw = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;
 

	// v1.41 특수 크리쳐 처리 
	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern

	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);

	if ( (_tmp_sStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;
		else if( _iGetFOE(_tmp_sStatus) == 1 ) bInv = TRUE;//우리편은 인비여도 투명하게 보여준다
		else return FALSE;
	}
	
	switch (_tmp_cFrame) {
	case 4:  _tmp_cFrame = 4; break;
	case 5:  _tmp_cFrame = 4; break;
	case 6:  _tmp_cFrame = 4; break;
	case 7:  _tmp_cFrame = 4; break;
	case 8:  _tmp_cFrame = 4; break;
	case 9:  _tmp_cFrame = 4; break;
	case 10: _tmp_cFrame = 5; break;
	case 11: _tmp_cFrame = 6; break;
	case 12: _tmp_cFrame = 7; break;
	}
		
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 소지하고 있는 무기에 따라서 동작이 바뀐다.
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4); 
			if (iWeapon == 0) iAdd = 6;							// 맨손 
			if ((iWeapon >= 1)  && (iWeapon <= 39)) iAdd = 6;	// 검, 도끼등  
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;	// 활  

			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*4 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 4;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
		}
		else {
			// 비전투모드이다. 공격명령은 곧 인사동작. 
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (5 * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 5;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 5; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 5; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 5; 

			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 5; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 5; 

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 5; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 5; 

			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	case 4:
	case 5:
	case 6:
		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 소지하고 있는 무기에 따라서 동작이 바뀐다.
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4); 
			if (iWeapon == 0) iAdd = 6;							// 맨손 
			if ((iWeapon >= 1)  && (iWeapon <= 39)) iAdd = 6;	// 검, 도끼등  
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;	// 활  

			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*4 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 4;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
		}
		else {
			// 비전투모드이다. 공격명령은 곧 인사동작. 
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (5 * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 5;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 5; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 5; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 5; 

			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 5; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 5; 

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 5; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 5; 

			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;


	default:
		iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1; 
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}

	dx = 0;
	dy = 0;
	if ((_tmp_cFrame >= 1) && (_tmp_cFrame <= 3)) {
		
		switch (_tmp_cFrame) {
		case 1: cFrameMoveDots = 26; break;
		case 2: cFrameMoveDots = 16; break;
		case 3: cFrameMoveDots = 0;  break;
		}
		
		switch (_tmp_cDir) {
		case 1 : dy =  cFrameMoveDots; break;
		case 2 : dy =  cFrameMoveDots; dx = -cFrameMoveDots; break;
		case 3 : dx = -cFrameMoveDots; break;
		case 4 : dx = -cFrameMoveDots; dy = -cFrameMoveDots; break;
		case 5 : dy = -cFrameMoveDots; break;
		case 6 : dy = -cFrameMoveDots; dx =  cFrameMoveDots; break;
		case 7 : dx =  cFrameMoveDots; break;
		case 8 : dx =  cFrameMoveDots; dy =  cFrameMoveDots; break;
		}

		switch (_tmp_cFrame) {
		case 1: dy++;    break;
		case 2: dy += 2; break;
		case 3: dy++;    break;
		}

		// 대쉬 효과 잔상용
		switch (_tmp_cFrame) {
		case 2: bDashDraw = TRUE; cFrameMoveDots = 26; break;
		case 3: bDashDraw = TRUE; cFrameMoveDots = 16; break;
		}
		
		dsx = 0; 
		dsy = 0;
		switch (_tmp_cDir) {
		case 1 : dsy =  cFrameMoveDots; break;
		case 2 : dsy =  cFrameMoveDots; dsx = -cFrameMoveDots; break;
		case 3 : dsx = -cFrameMoveDots; break;
		case 4 : dsx = -cFrameMoveDots; dsy = -cFrameMoveDots; break;
		case 5 : dsy = -cFrameMoveDots; break;
		case 6 : dsy = -cFrameMoveDots; dsx =  cFrameMoveDots; break;
		case 7 : dsx =  cFrameMoveDots; break;
		case 8 : dsx =  cFrameMoveDots; dsy =  cFrameMoveDots; break;
		}
	}
	else if (_tmp_cFrame > 3) {
		dx = 0;
		dy = 0;
	}
	else {
		switch (_tmp_cDir) {
		case 1: dy = 32; break;
		case 2: dy = 32; dx = -32; break;
		case 3: dx = -32; break;
		case 4: dx = -32; dy = -32; break;
		case 5: dy = -32; break;
		case 6: dy = -32; dx = 32; break;
		case 7: dx = 32; break;
		case 8: dx = 32; dy = 32; break;
		}
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX+dx, sY+dy, _tmp_cFrame);

	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == FALSE) {
		
		if (_cDrawingOrder[_tmp_cDir] == 1) {
			// 무기를 먼저 그린다.
			if (iWeaponIndex != -1) {
				if (iWeaponColor == 0)
					 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}

				// 무기 잔상 
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame -1, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
			}
			/*			
			if ((_tmp_sOwnerType != 10) && (_tmp_sOwnerType != 35)) {
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
			}
			*/
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
            case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}
			
			if (bInv == TRUE) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				    m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
						
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)	
					 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}
			
			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iShieldIndex != -1) {
				if (iShieldColor == 0)
					 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
		}
		else {
			// 무기와 방패를 마지막에 그린다.
			/*
			if ((_tmp_sOwnerType != 10) && (_tmp_sOwnerType != 35)) {
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
			}
			*/
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}
			
			if (bInv == TRUE) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				    m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)	
					 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}

			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iShieldIndex != -1) {
				if (iShieldColor == 0)
					 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iWeaponIndex != -1) {
				if (iWeaponColor == 0)
					 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}

				// 무기 잔상 
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame -1, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
			}
		}
				
		// Berserk 
		if ((_tmp_sStatus & 0x20) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, 0, -5, -5, dwTime);
		// Protection From Magic
		if ((_tmp_sStatus & 0x80) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, -5, 0, 5, dwTime);

		if (bDashDraw == TRUE) {
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX+dsx, sY+dsy, _tmp_cFrame, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime); 
			if (iWeaponIndex != -1) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dsx, sY+dsy, _tmp_cFrame, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
			if (iShieldIndex != -1) m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dsx, sY+dsy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
		}
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX+dx, sY+dy, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX+dx, sY+dy, _tmp_sOwnerType, _tmp_sStatus);
	}

	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX+dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY+dy;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	_tmp_dx = dx;
	_tmp_dy = dy;

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}


BOOL   CGame::DrawObject_OnMagic(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	// v1.41 특수 크리쳐 처리 
	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern

	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	// Invisibility flag가 설정되어 있으면 그리지 않는다.
	if ( (_tmp_sStatus & 0x10) != 0) {
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) 
			bInv = TRUE;
		else {
			// v1.4 
			if (_tmp_iChatIndex != NULL) { 
				if (m_pChatMsgList[_tmp_iChatIndex] != NULL) {
					// 그려야 할 위치정보를 입력한다.
					m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
					m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
				}
				else {
					// 시간이 초과해 지워진 메시지이므로 
					m_pMapData->ClearChatMsg(indexX, indexY);
				}
			} 
			// v1.4

			return FALSE;
		}
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
  		iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (8 * 8);
		iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 8;
		iHairIndex   = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 8;
	
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 8; 
		}
	
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 8; 

		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 8; 

		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 8; 

		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 8;
		
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 8; 
		break;

	case 4:
	case 5:
	case 6:
  		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		
		iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (8 * 8);
		
		iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 8;
		iHairIndex   = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 8;
	
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 8; 
		}
	
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 8; 

		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 8; 

		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 8; 

		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 8; 

		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 8; 
		break;
	}

	// 프레임 값 보정 
	/*
	switch (_tmp_cFrame) {
	case 15:
		_tmp_cFrame = 14;
		break;
	case 16:
		_tmp_cFrame = 14;
		break;
	case 17:
		_tmp_cFrame = 15;
		break;
	case 18:
		_tmp_cFrame = 15;
		break;
	case 19:
		_tmp_cFrame = 15;
		break;
	case 20:
		_tmp_cFrame = 15;
		break;
	case 21:
		_tmp_cFrame = 15;
		break;
	case 22:
		_tmp_cFrame = 15;
		break;
	case 23:
		_tmp_cFrame = 14;
		break;
	}
	*/

	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);

	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == FALSE) {
		/*
		if (m_cDetailLevel != 0) {
			if (sX < 50) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
		}
		*/
		switch (_tmp_sOwnerType) {
		case 10: // 그림자를 그리면 안되는 것들.
		case 35:
		case 50:
		case 51:
		case 60: // 정진광 수정, 식인식물은 그림자 없음.
		case 65:
		case 66:
			break;

		default:
			if (m_cDetailLevel != 0) {
				if (sX < 50) 
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			break;
		}
			
		if (bInv == TRUE) 
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
		else {
			if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime); 
		}
		// 몸통의 위치 저장한다.
		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
				
		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
		
		if ((iHairIndex != -1) && (iHelmIndex == -1)) {
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, iR, iG, iB, dwTime);
		}
		
		if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}

		if (iPantsIndex != -1) {
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
		}

		if (iArmArmorIndex != -1) {
			if (iArmColor == 0)	
				m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
		}
				
		if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}
		
		if (iBodyArmorIndex != -1) {
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
		}

		if (iHelmIndex != -1) {
			if (iHelmColor == 0)
				 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
		}
				
		if (iMantleIndex != -1) {
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}
				
		// Berserk 
		if ((_tmp_sStatus & 0x20) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		// Protection From Magic
		if ((_tmp_sStatus & 0x80) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, -5, 0, 5, dwTime);
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_sStatus);
	}

	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}


BOOL   CGame::DrawObject_OnGetItem(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	// v1.41 특수 크리쳐 처리 
	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern

	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	if ( (_tmp_sStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;
		else if( _iGetFOE(_tmp_sStatus) == 1 ) bInv = TRUE;//우리편은 인비여도 투명하게 보여준다
		else return FALSE;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (9 * 8);
		iUndiesIndex    = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 9;
		iHairIndex      = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 9;
		
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 9; 
		}
		
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 9; 
		
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 9; 
		
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 9; 

		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 9; 

		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 9; 
		break;

	case 4:
	case 5:
	case 6:
		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (9 * 8);
		
		iUndiesIndex    = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 9;
		iHairIndex      = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 9;
		
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 9; 
		}
		
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 9; 
		
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 9; 
		
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 9; 

		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 9; 

		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 9; 
		break;

	default:
		iUndiesIndex    = -1;			     
		iHairIndex      = -1;
		iArmArmorIndex  = -1;
		iBodyArmorIndex = -1;
		iPantsIndex     = -1;
		iBootsIndex     = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);
		
	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == FALSE) {
		/*
		if (m_cDetailLevel != 0) {
			if (sX < 50) 
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
		}
		*/
		switch (_tmp_sOwnerType) {
		case 10: // 그림자를 그리면 안되는 것들.
		case 35:
		case 50:
		case 51:
		case 60: // 정진광 수정, 식인식물은 그림자 없음.
		case 65:
		case 66:
			break;

		default:
			if (m_cDetailLevel != 0) {
				if (sX < 50) 
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			break;
		}
			
		if (bInv == TRUE) 
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX, sY, _tmp_cFrame, dwTime);
		else {
			if ((_tmp_sStatus & 0x40) != 0)
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime); 
		}
		// 몸통의 위치 저장한다.
		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
				
		if (iUndiesIndex != -1)
		{
			if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
		}
		
		if ((iHairIndex != -1) && (iHelmIndex == -1)) {
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, iR, iG, iB, dwTime);
		}
		
		if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
			if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}
		}

		if (iPantsIndex != -1) {
			if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}
		}

		if (iArmArmorIndex != -1) {
			if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iArmColor == 0)	
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}
		}
				
		if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
			if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}
		}
		
		if (iBodyArmorIndex != -1) {
			if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}
		}

		if (iHelmIndex != -1) {
			if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}
		}
		
		if (iMantleIndex != -1) {
			if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
		}
			
		// Berserk 
		if ((_tmp_sStatus & 0x20) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		// Protection From Magic
		if ((_tmp_sStatus & 0x80) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, -5, 0, 5, dwTime);
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_sStatus);
	}

	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}


BOOL   CGame::DrawObject_OnDamage(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iWeaponIndex, iShieldIndex, iHelmIndex, iR, iG, iB;
 int iAdd, iDrawMode, iMantleIndex;
 char cFrame;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	// v1.41 특수 크리쳐 처리 
	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern

	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);

	if ( (_tmp_sStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;
		else if( _iGetFOE(_tmp_sStatus) == 1 ) bInv = TRUE;//우리편은 인비여도 투명하게 보여준다
		else return FALSE;
	}

	cFrame = _tmp_cFrame;

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if (cFrame < 4) {
			if ((_tmp_sAppr2 & 0xF000) != 0) iAdd = 1;
			else iAdd = 0;

			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + iAdd;

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*iAdd + (_tmp_cDir - 1);
			}
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
			
			iDrawMode = 0;
		}
		else {
			cFrame -= 4;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (10 * 8);
			iUndiesIndex    = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 10;
			iHairIndex      = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 10;
		
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 10; 
			}
		
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 10; 
		
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 10; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 10; 

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 5;

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*5 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 10; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 10; 

			iDrawMode = 1;
		}
		break;

	case 4:
	case 5:
	case 6:
		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		if (cFrame < 4) {
			if ((_tmp_sAppr2 & 0xF000) != 0) iAdd = 1;
			else iAdd = 0;

			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex   = 14820	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + iAdd;

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*iAdd + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
		
			iDrawMode = 0;
		}
		else {
			cFrame -= 4;
			
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (10 * 8);
		
			iUndiesIndex    = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 10;
			iHairIndex      = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 10;
		
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 10; 
			}
		
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 10; 
		
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 10; 
		
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 10; 

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 5;

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*5 + (_tmp_cDir - 1);
			}
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 10; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 10; 

			iDrawMode = 1;
		}
		break;

	default:
		if (cFrame < 4) {
			if (_tmp_sAppr2 != 0) {
				iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
				 cFrame = _tmp_sAppr2 -1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		}
		else {
			cFrame -= 4;
			if (_tmp_sAppr2 != 0) {
				 iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
				cFrame = _tmp_sAppr2 -1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
		}

		iUndiesIndex    = -1;			     
		iHairIndex      = -1;
		iArmArmorIndex  = -1;
		iBodyArmorIndex = -1;
		iPantsIndex     = -1;
		iBootsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;

		iDrawMode = 0;
		break;
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, cFrame);

	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}
	
	if (bTrans == FALSE) {
		if (iDrawMode == 1) {
			
			if (_cDrawingOrder[_tmp_cDir] == 1) {
				// 무기를 먼저 그린다.
				if (iWeaponIndex != -1) {
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY,  cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);

					//V1.432 Weapon Glare
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
				
				/*
				if ((_tmp_sOwnerType != 10) && (_tmp_sOwnerType != 35)) {
					if (m_cDetailLevel != 0) {
						if (sX < 50) 
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
				}
				*/
				switch (_tmp_sOwnerType) {
				case 10: // 그림자를 그리면 안되는 것들.
				case 35:
				case 50:
				case 51:
				case 60: // 정진광 수정, 식인식물은 그림자 없음.
				case 65:
				case 66:
					break;

				default:
					if (m_cDetailLevel != 0) {
						if (sX < 50) 
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
					break;
				}

				// 에너지 볼 바닥 조명 
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
				
				if (bInv == TRUE) 
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else {
					if ((_tmp_sStatus & 0x40) != 0)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime); 
				}
				// 몸통의 위치 저장한다.
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
				//
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
				
				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				
				if ((iHairIndex != -1) && (iHelmIndex == -1)) {
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, iR, iG, iB, dwTime);
				}
				
				if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iPantsIndex != -1) {
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1) {
					if (iArmColor == 0)	
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
								
				if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
				
				if (iBodyArmorIndex != -1) {
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}

				if (iHelmIndex != -1) {
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
				
				//
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
				
				if (iShieldIndex != -1) {
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

					//V1.432 Shield Glare
					switch (iShieldGlare) {
					case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					// v2.16 2002-5-14 고광현수정
					case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
				
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
			else {
				// 무기와 방패를 마지막에 그린다.
				/*
				if ((_tmp_sOwnerType != 10) && (_tmp_sOwnerType != 35)) {
					if (m_cDetailLevel == 0) {
						if (sX < 50) 
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
				}
				*/
				switch (_tmp_sOwnerType) {
				case 10: // 그림자를 그리면 안되는 것들.
				case 35:
				case 50:
				case 51:
				case 60: // 정진광 수정, 식인식물은 그림자 없음.
				case 65:
				case 66:
					break;

				default:
					if (m_cDetailLevel != 0) {
						if (sX < 50) 
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
					break;
				}

				// 에너지 볼 바닥 조명 
				if (_tmp_sOwnerType == 35)
					m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
				
				if (bInv == TRUE) 
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else {
					if ((_tmp_sStatus & 0x40) != 0)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime); 
				}
				// 몸통의 위치 저장한다.
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
				
				//
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				
				if ((iHairIndex != -1) && (iHelmIndex == -1)) {
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, iR, iG, iB, dwTime);
				}
				
				if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iPantsIndex != -1) {
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1) {
					if (iArmColor == 0)	
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
								
				if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
				
				if (iBodyArmorIndex != -1) {
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}

				if (iHelmIndex != -1) {
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
				
				//
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
								
				if (iShieldIndex != -1) {
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

					//V1.432 Shield Glare
					switch (iShieldGlare) {
					case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					// v2.16 2002-5-14 고광현수정
					case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
				
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
				
				if (iWeaponIndex != -1) {
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);

					//V1.432 Weapon Glare
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
			}
						
			// Berserk 
			if ((_tmp_sStatus & 0x20) != 0) 
				m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, cFrame, 0, -5, -5, dwTime);
			// Protection From Magic
			if ((_tmp_sStatus & 0x80) != 0) 
				m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, cFrame, -5, 0, 5, dwTime);
		}
		else {
			
			if (_cDrawingOrder[_tmp_cDir] == 1) {
				// 무기를 먼저 그린다.
				if (iWeaponIndex != -1) {
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY,  cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);

					//V1.432 Weapon Glare
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
				
				/*
				if ((_tmp_sOwnerType != 10) && (_tmp_sOwnerType != 35)) {
					if (m_cDetailLevel != 0) {
						if (sX < 50) 
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
				}
				*/
				switch (_tmp_sOwnerType) {
				case 10: // 그림자를 그리면 안되는 것들.
				case 35:
				case 50:
				case 51:
				case 60: // 정진광 수정, 식인식물은 그림자 없음.
				case 65:
				case 66:
					break;

				default:
					if (m_cDetailLevel != 0) {
						if (sX < 50) 
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
					}
					break;
				}
				
				if (bInv == TRUE) 
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else {
					if ((_tmp_sStatus & 0x40) != 0)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime); 
				}
				// 몸통의 위치 저장한다.
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
				//
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
				
				if ((iHairIndex != -1) && (iHelmIndex == -1)) {
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, iR, iG, iB, dwTime);
				}
				
				if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iPantsIndex != -1) {
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1) {
					if (iArmColor == 0)	
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
								
				if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
				
				if (iBodyArmorIndex != -1) {
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}

				if (iHelmIndex != -1) {
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
				
				//
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
				
				if (iShieldIndex != -1) {
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

					//V1.432 Shield Glare
					switch (iShieldGlare) {
					case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					// v2.16 2002-5-14 고광현수정
					case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
				
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
			else {
				// 무기와 방패를 마지막에 그린다.
				/*
				if ((_tmp_sOwnerType != 10) && (_tmp_sOwnerType != 35)) {
					if (m_cDetailLevel != 0) {
						if (sX < 50) 
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
				}
				*/
				switch (_tmp_sOwnerType) {
				case 10: // 그림자를 그리면 안되는 것들.
				case 35:
				case 50:
				case 51:
				case 60: // 정진광 수정, 식인식물은 그림자 없음.
				case 65:
				case 66:
					break;

				default:
					if (m_cDetailLevel != 0) {
						if (sX < 50) 
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
					break;
				}
				
				if (bInv == TRUE) 
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else {
					if ((_tmp_sStatus & 0x40) != 0)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime); 
				}
				// 몸통의 위치 저장한다.
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
				
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
				
				if ((iHairIndex != -1) && (iHelmIndex == -1)) {
					_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, iR, iG, iB, dwTime);
				}
						
				if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iPantsIndex != -1) {
					if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1) {
					if (iArmColor == 0)	
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
								
				if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
				
				if (iBodyArmorIndex != -1) {
					if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}

				if (iHelmIndex != -1) {
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
				
				//
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
				
				if (iShieldIndex != -1) {
					if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

					//V1.432 Shield Glare
					switch (iShieldGlare) {
					case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					// v2.16 2002-5-14 고광현수정
					case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
				
				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
					if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
				
				if (iWeaponIndex != -1) {
					if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);

					//V1.432 Weapon Glare
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}
			}
			
			// Berserk 
			if ((_tmp_sStatus & 0x20) != 0) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, cFrame, 0, -5, -5, dwTime);
			// Protection From Magic
			if ((_tmp_sStatus & 0x80) != 0) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, cFrame, -5, 0, 5, dwTime);
		}
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_sStatus);
	}

	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}

BOOL CGame::DrawObject_OnDying(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB,  iHelmIndex, iMantleIndex;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;
 char cFrame;

	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	cFrame = _tmp_cFrame;

	// 죽는 동작의 시간적인 간격을 맞추기 위함.
	 switch (_tmp_sOwnerType) {
	 case 1:
	 case 2:
	 case 3:
		if (cFrame < 6) {
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (0 * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15;
			iHairIndex   = 4820	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 0;
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 0;
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 0; 
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 0; 
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 0; 
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 0; 
		}
		else {
			cFrame -= 6;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (11 * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 11;
			iHairIndex   = 4820	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 11;
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				     iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 11;
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 11; 
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 11; 
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 11; 
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 11; 
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 11; 
		}
		break;
	
	 case 4:
	 case 5:
	 case 6:
		 // 스커트 그리는 모드인지 판단.
		 if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		 if (cFrame < 6) {
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (0 * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15;
			iHairIndex   = 14820	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 0;
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 0;
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 0; 
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 0; 
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 0; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 0; 
		}
		else { 
			cFrame -= 6;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (11 * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 11;
			iHairIndex   = 14820	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 11;
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				     iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 11;
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 11; 
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 11; 
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 11; 
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 11; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 11; 
		}
		break;
		
	 default:
		if (cFrame < 4) {
			if (_tmp_sAppr2 != 0) {
				 iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
				 cFrame = _tmp_sAppr2 -1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			iUndiesIndex = -1;
			iHairIndex   = -1;
			iArmArmorIndex = -1;
			iBodyArmorIndex = -1;
			iPantsIndex = -1;
			iBootsIndex = -1;
			iMantleIndex = -1;
			iHelmIndex      = -1;

			switch (_tmp_sOwnerType) {
			case 36: // 애로우 가드 타워
			case 37: // 캐논 가드 타워 
			case 39: // 디텍터
			case 38: // 마나 콜렉터
			case 40:
			case 41:
			case 42:
			
				if (_tmp_sAppr2 == 0) cFrame = 0;
				break;

			case 51: cFrame = 0; break;
			}
		} 
		else {
			switch (_tmp_sOwnerType) {
			case 51: cFrame = 0; break;

			default: cFrame -= 4; break;
			}
			
			if (_tmp_sAppr2 != 0) {
				 iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
				 cFrame = _tmp_sAppr2 -1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			iUndiesIndex = -1;
			iHairIndex   = -1;
			iArmArmorIndex = -1;
			iBodyArmorIndex = -1;
			iPantsIndex = -1;
			iBootsIndex = -1;
			iMantleIndex = -1;
			iHelmIndex   = -1;
		}
		break;
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, cFrame);

	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == FALSE) {
		
		/*
		if (_tmp_sOwnerType != 10) {
			if (m_cDetailLevel != 0) {
				if (sX < 50) 
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
			}
		}
		*/
		switch (_tmp_sOwnerType) {
		case 10: // 그림자를 그리면 안되는 것들.
		case 35:
		case 50:
		case 51:
		case 60: // 정진광 수정, 식인식물은 그림자 없음.
		case 65:
		case 66:
			break;

		default:
			if (m_cDetailLevel != 0) {
				if (sX < 50) 
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
			}
			break;
		}
			
		if( _tmp_sOwnerType == 66 ) m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime); 
		else
		{
			if ((_tmp_sStatus & 0x40) != 0)
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime); 
		}
		// 몸통의 위치 저장한다.
		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
		
		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
		
		if ((iHairIndex != -1) && (iHelmIndex == -1)) {
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, iR, iG, iB, dwTime);
		}
		
		if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}

		if (iPantsIndex != -1) {
			if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
		}

		if (iArmArmorIndex != -1) {
			if (iArmColor == 0)	
				m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
		}
				
		if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
			if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}
		
		if (iBodyArmorIndex != -1) {
			if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
		}

		if (iHelmIndex != -1) {
			if (iHelmColor == 0)
				 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
		}
		
		if (iMantleIndex != -1) {
			if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}
		
		// Berserk 
		if ((_tmp_sStatus & 0x20) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY,  cFrame, 0, -5, -5, dwTime);
		// Protection From Magic
		if ((_tmp_sStatus & 0x80) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY,  cFrame, -5, 0, 5, dwTime);
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_sStatus);
	}

	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}

BOOL   CGame::DrawObject_OnDead(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iFrame, iMantleIndex, iHelmIndex;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if( _tmp_sOwnerType == 66 ) return FALSE;
	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iFrame = 7;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (11 * 8);
		iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 11;
		iHairIndex   = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 11;
		
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 11;
		}
		
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 11; 
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 11; 
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 11; 

		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 11; 

		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 11; 
		break;

	case 4:
	case 5:
	case 6:
		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		iFrame = 7;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (11 * 8);
		iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 11;
		iHairIndex   = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 11;
		
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 11;
		}

		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 11; 
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 11; 
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 11; 
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 11; 

		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 11; 
		break;


	default:
		switch (_tmp_sOwnerType) {
		case 28:
		case 29:
		case 30:
		case 31:
			iFrame = 5;
			iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;

		case 32:
		case 33:
		case 43:
		case 44:
		case 45:
		case 46:
		case 47:
		case 48:
		case 49:
		case 50:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57:		
		case 58: //산중거인
		case 59: //에틴
		case 60: //식인식물
		case 61: //루돌프
		case 62:
		case 64:
		case 65:
			iFrame = 7;
			iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;
			
		case 63:
			iFrame = 5;
			iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;

		case 66:
			iFrame = 15;
			iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			break;

		case 51:
			iFrame = 0;
			iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;

		case 52:
			iFrame = 11;
			iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;

		default:
			iFrame = 3;
			iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;
		}
		
		iUndiesIndex = -1;
		iHairIndex   = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iMantleIndex = -1;
		iHelmIndex      = -1;
		break;
	}

	if (bTrans == FALSE) {
		if (_tmp_cFrame == -1) {
			_tmp_cFrame = 7; // v1.4
			
			if ((_tmp_sStatus & 0x40) != 0)
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, iFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, iFrame, dwTime); 
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)	
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}
						
			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}
			
			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}
			
			if (iMantleIndex != -1) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
		}
		else {
			if ((_tmp_sStatus & 0x20) != 0) 
				 m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, iFrame, -2*_tmp_cFrame +5, -2*_tmp_cFrame -5, -2*_tmp_cFrame -5, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, iFrame, -2*_tmp_cFrame,-2*_tmp_cFrame,-2*_tmp_cFrame, dwTime);
		}
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_sStatus);
	}

	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearDeadChatMsg(indexX, indexY);
		}
	}

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}



BOOL   CGame::DrawObject_OnMove(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int dx, dy;
 int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iShieldIndex, iAdd, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	// v1.41 특수 크리쳐 처리 
	//if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern
	if(_tmp_sOwnerType == 35) bInv = TRUE; //Energy-Ball,Wyvern
	if(_tmp_sOwnerType == 66)
	{
		bInv = TRUE; //Energy-Ball,Wyvern
	}

	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);

	if ( (_tmp_sStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;
		else if( _iGetFOE(_tmp_sStatus) == 1 ) bInv = TRUE;//우리편은 인비여도 투명하게 보여준다
		else return FALSE;
	}
	
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 소지하고 있는 무기에 따라서 동작이 바뀐다.
			iAdd = 3;							
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*3 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 3;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
		}
		else {
			// 비전투모드이다. 그냥 이동한다. 
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (2 * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 2;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 2; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 2; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 2; 

			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 2; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 2; 

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*2 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 2;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 2; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 2; 
		}
		break;

	case 4:
	case 5:
	case 6:
		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 소지하고 있는 무기에 따라서 동작이 바뀐다.
			iAdd = 3;							
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*3 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 3;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
		}
		else {
			// 비전투모드이다. 그냥 이동한다. 
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (2 * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 2;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 2; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 2; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 2; 

			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 2; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 2; 

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*2 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 2;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 2; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 2; 
		}
		break;

	default:
		if (_tmp_sOwnerType == 66) iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (1 * 8);
		else iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (1 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1; 
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
    
	dx = 0; 
	dy = 0;
	
	switch (_tmp_cDir) {
	case 1 : dy = 28 - (_tmp_cFrame<<2); break;
	case 2 : dy = 28 - (_tmp_cFrame<<2); dx = (_tmp_cFrame<<2) - 28; break;
	case 3 : dx = (_tmp_cFrame<<2) - 28; break;
	case 4 : dx = (_tmp_cFrame<<2) - 28; dy = (_tmp_cFrame<<2) - 28; break;
	case 5 : dy = (_tmp_cFrame<<2) - 28; break;
	case 6 : dy = (_tmp_cFrame<<2) - 28; dx = 28 - (_tmp_cFrame<<2); break;
	case 7 : dx = 28 - (_tmp_cFrame<<2); break;
	case 8 : dx = 28 - (_tmp_cFrame<<2); dy = 28 - (_tmp_cFrame<<2); break;
	}

	// 그림은 4프레임, 처리는 8프레임 몬스터들 찍을때 프레임값 보정
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:

	case 28: // Troll. 원래 8프레임이므로 제외.
	case 29: // Orge.
	case 30: // Liche
	case 31: // Orge
	case 32:
	case 33:
	case 43:
	case 44:
	case 45:
	case 46:
	case 47:
	case 48:
	case 49:
	case 50:
	case 52:
	case 53:
	case 54:
	case 55:
	case 56:
	case 57:
	case 58: //산중거인
	case 59: //에틴
	case 60: //식인식물
	case 61: //루돌프
	case 62:
	case 63:
	case 65:
	case 66:
		break;

	default:
		_tmp_cFrame = _tmp_cFrame / 2;
		break;
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX+dx, sY+dy, _tmp_cFrame);

	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if( _tmp_sOwnerType == 65 )
	{
		m_pEffectSpr[77]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime);
		/*
		switch( rand()%3 )
		{
		case 0:
			m_pEffectSpr[76]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			break;
		case 1:
			m_pEffectSpr[77]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			break;
		case 2:
			m_pEffectSpr[78]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			break;
		}
		*/
	}
	
	if (bTrans == FALSE) {
		
		if (_cDrawingOrder[_tmp_cDir] == 1) {
			// 무기를 먼저 그린다.
			if (iWeaponIndex != -1) {
				if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
			
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 53:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;
			
			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}

			// 에너지 볼 바닥 조명 
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX+dx, sY+dy, 1, dwTime);
			
			if (bInv == TRUE) 
				 //m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
			
			if (iUndiesIndex != -1)
			{
				if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1) {
				if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1) {
				if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)	
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}
			
			if (iBodyArmorIndex != -1) {
				if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}
			}
			
			if (iHelmIndex != -1) {
				if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
			}
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
			
			if (iShieldIndex != -1) {
				if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
				}

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
		}
		else {
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 53:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}

			// 에너지 볼 바닥 조명 
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX+dx, sY+dy, 1, dwTime);
			
			if (bInv == TRUE) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1) {
				if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1) {
				if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)	
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}

			if (iBodyArmorIndex != -1) {
				if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1) {
				if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
			}

			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
			
			if (iShieldIndex != -1) {
				if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
				}

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}

			if (iWeaponIndex != -1) {
				if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
		}
		
		// Berserk 
		if ((_tmp_sStatus & 0x20) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, 0, -5, -5, dwTime);
		// Protection From Magic
		if ((_tmp_sStatus & 0x80) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, -5, 0, 5, dwTime);
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX+dx, sY+dy, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX+dx, sY+dy, _tmp_sOwnerType, _tmp_sStatus);
	}
	
	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX+dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY+dy;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	
	_tmp_dx = dx;
	_tmp_dy = dy;

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}


BOOL CGame::DrawObject_OnDamageMove(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int cFrame, cDir;
 int dx, dy;
 int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iShieldIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	// v1.41 특수 크리쳐 처리 
	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern

	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);

	if ( (_tmp_sStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;
		else if( _iGetFOE(_tmp_sStatus) == 1 ) bInv = TRUE;//우리편은 인비여도 투명하게 보여준다
		else return FALSE;
	}

	cDir = _tmp_cDir;
	switch (_tmp_cDir) {
	case 1: _tmp_cDir = 5; break;
	case 2: _tmp_cDir = 6; break;
	case 3: _tmp_cDir = 7; break;
	case 4: _tmp_cDir = 8; break;
	case 5: _tmp_cDir = 1; break;
	case 6: _tmp_cDir = 2; break;
	case 7: _tmp_cDir = 3; break;
	case 8: _tmp_cDir = 4; break;
	}
	
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (10 * 8);
		iUndiesIndex    = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 10;
		iHairIndex      = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 10;
		
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 10; 
		}
		
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 10; 
		
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 10; 
			
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 10; 

		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 5;

		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else {
			iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*5 + (_tmp_cDir - 1);
		}

		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 10; 

		if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 10; 
		break;

	case 4:
	case 5:
	case 6:
		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (10 * 8);
		
		iUndiesIndex    = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 10;
		iHairIndex      = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 10;
		
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 10; 
		}
		
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 10; 
		
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 10; 
		
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 10; 

		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 5;

		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else {
			iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*5 + (_tmp_cDir - 1);
		}
		
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 10; 

		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 10; 
		break;

	default:
		if (_tmp_sOwnerType == 66) iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);

		iUndiesIndex    = -1;			     
		iHairIndex      = -1;
		iArmArmorIndex  = -1;
		iBodyArmorIndex = -1;
		iPantsIndex     = -1;
		iBootsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
    
	dx = 0; 
	dy = 0;
	
	switch (_tmp_cDir) {
	case 1 : dy = 28 - (_tmp_cFrame<<2); break;
	case 2 : dy = 28 - (_tmp_cFrame<<2); dx = (_tmp_cFrame<<2) - 28; break;
	case 3 : dx = (_tmp_cFrame<<2) - 28; break;
	case 4 : dx = (_tmp_cFrame<<2) - 28; dy = (_tmp_cFrame<<2) - 28; break;
	case 5 : dy = (_tmp_cFrame<<2) - 28; break;
	case 6 : dy = (_tmp_cFrame<<2) - 28; dx = 28 - (_tmp_cFrame<<2); break;
	case 7 : dx = 28 - (_tmp_cFrame<<2); break;
	case 8 : dx = 28 - (_tmp_cFrame<<2); dy = 28 - (_tmp_cFrame<<2); break;
	}

	cFrame = _tmp_cFrame;

	if (m_bIsCrusadeMode) DrawObjectFOE(sX+dx, sY+dy, cFrame);

	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX+dy, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}
	
	if (bTrans == FALSE) {
		
		if (_cDrawingOrder[_tmp_cDir] == 1) {
			// 무기를 먼저 그린다.
			if (iWeaponIndex != -1) {
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
			
			/*
			if ((_tmp_sOwnerType != 10) && (_tmp_sOwnerType != 35)) {
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, cFrame, dwTime);
				}
			}
			*/
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, cFrame, dwTime);
				}
				break;
			}

			// 에너지 볼 바닥 조명 
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
			
			if (bInv == TRUE) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iUndiesIndex != -1)
			{
				if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
			}
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}
			
			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}
			
			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)	
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}
			
			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iShieldIndex != -1) {
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
			
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
		}
		else {
			// 무기와 방패를 마지막에 그린다.
			/*
			if ((_tmp_sOwnerType != 10) && (_tmp_sOwnerType != 35)) {
				if (m_cDetailLevel == 0) {
					if (sX < 50) 
						m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, cFrame, dwTime);
				}
			}
			*/
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, cFrame, dwTime);
				}
				break;
			}

			// 에너지 볼 바닥 조명 
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
			
			if (bInv == TRUE) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iUndiesIndex != -1)
			{
				if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
			}
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}
			
			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}
			
			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)	
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}
			
			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iShieldIndex != -1) {
				if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
			
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
			
			if (iWeaponIndex != -1) {
				if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
		}
		
		// Berserk 
		if ((_tmp_sStatus & 0x20) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, cFrame, 0, -5, -5, dwTime);
		// Protection From Magic
		if ((_tmp_sStatus & 0x80) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, cFrame, -5, 0, 5, dwTime);
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX+dx, sY+dy, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX+dx, sY+dy, _tmp_sOwnerType, _tmp_sStatus);
	}
 
	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX+dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY+dy;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	
	_tmp_dx = dx;
	_tmp_dy = dy;

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}

BOOL CGame::DrawObject_OnMove_ForMenu(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 short dx, dy;
 int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iShieldIndex, iAdd, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	// v1.4
	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
	iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
	iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
	iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
	iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
	iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
	iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
	iHelmColor   = (_tmp_iApprColor & 0x0000000F);

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 소지하고 있는 무기에 따라서 동작이 바뀐다.
			iAdd = 3;							
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else {
					iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd; 
					// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
				}
			}
			else {
				// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
				iBodyArmorIndex = -1;
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else {
				iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
				// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
			}
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*3 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 3;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
		}
		else {
			// 비전투모드이다. 그냥 이동한다. 
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (2 * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 2;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 2; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else {
					iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 2; 
					// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
				}
			}
			else {
				iBodyArmorIndex = -1;
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else {
				iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 2; 
				// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
			}

			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else {
				iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 2; 
				// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
			}
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else {
				iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 2; 
				// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
			}

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*2 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 2;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 2; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 2; 
		}
		break;

	case 4:
	case 5:
	case 6:
		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 소지하고 있는 무기에 따라서 동작이 바뀐다.
			iAdd = 3;							
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else {
					iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd; 
					// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
				}
			}
			else {
				iBodyArmorIndex = -1;
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else {
				iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + iAdd; 
				// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
			}
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				 iWeaponIndex = -1;
			else iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*3 + (_tmp_cDir - 1);
			
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 3;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd; 
		}
		else {
			// 비전투모드이다. 그냥 이동한다. 
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (2 * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 2;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 2; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else {
					iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 2; 
					// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
				}
			} 
			else {
				iBodyArmorIndex = -1;
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else {
				iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 2; 
				// v1.4 기존 복장으로 인한 클라이언트 크래쉬를 막기 위함이다.
			}

			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 2; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 2; 

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*2 + (_tmp_cDir - 1);
			
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 2;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 2;
			
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 2; 
		}
		break;

	default:								
		iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (1 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1; 
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
	
	dx = 0; 
	dy = 0;
	
	if (_cDrawingOrder[_tmp_cDir] == 1) {
		// 무기를 먼저 그린다.
		if (iWeaponIndex != -1) {
			if (iWeaponColor == 0)
				 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
		}
		
		switch (_tmp_sOwnerType) {
		case 10: // 그림자를 그리면 안되는 것들.
		case 35:
		case 50:
		case 51:
			break;

		default:
			if (m_cDetailLevel != 0) {
				if (sX < 50) 
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}
			break;
		}
		
		if (bInv == TRUE) 
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime); 
		
		//
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
			if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}

		if (iUndiesIndex != -1)
		{
			if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
		}
		
		if ((iHairIndex != -1) && (iHelmIndex == -1)) {
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
		}
		
		if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
			if (iBootsColor == 0)
				 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}

		if (iPantsIndex != -1) {
			if (iPantsColor == 0)
				 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
		}

		if (iArmArmorIndex != -1) {
			if (iArmColor == 0)	
				 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
		}
		
		if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
			if (iBootsColor == 0)
				 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}
		
		if (iBodyArmorIndex != -1) {
			if (iArmorColor == 0)
				 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
		}
		
		if (iHelmIndex != -1) {
			if (iHelmColor == 0)
				 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
		}
		//
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
			if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}
					
		if (iShieldIndex != -1) {
			if (iShieldColor == 0)
				 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
		}

		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
			if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}
	}
	else {
		switch (_tmp_sOwnerType) {
		case 10: // 그림자를 그리면 안되는 것들.
		case 35:
		case 50:
		case 51:
		case 60: // 정진광 수정, 식인식물은 그림자 없음.
		case 65:
		case 66:
			break;

		default:
			if (m_cDetailLevel != 0) {
				if (sX < 50) 
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}
			break;
		}

		if (bInv == TRUE) 
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime); 
		
		//
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
			if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}

		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
		
		if ((iHairIndex != -1) && (iHelmIndex == -1)) {
			_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
		}
		
		if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
			if (iBootsColor == 0)
				 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}

		if (iPantsIndex != -1) {
			if (iPantsColor == 0)
				 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
		}

		if (iArmArmorIndex != -1) {
			if (iArmColor == 0)	
				 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
			if (iBootsColor == 0)
				 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}

		if (iBodyArmorIndex != -1) {
			if (iArmorColor == 0)
				 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
		}

		if (iHelmIndex != -1) {
			if (iHelmColor == 0)
				 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
		}

		//
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
			if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}
		
		if (iShieldIndex != -1) {
			if (iShieldColor == 0)
				 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
		}

		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
			if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}

		if (iWeaponIndex != -1) {
			if (iWeaponColor == 0)
				 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
		}
	}
	
	if (_tmp_iChatIndex != NULL) {
		if (m_pChatMsgList[_tmp_iChatIndex] != NULL) {
			
			DrawChatMsgBox(sX+dx, sY+dy, _tmp_iChatIndex, FALSE);
			
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	
	_tmp_dx = dx;
	_tmp_dy = dy;

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}


BOOL   CGame::DrawObject_OnStop(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int iBodyIndex, iUndiesIndex, iHairIndex, iBodyArmorIndex, iArmArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iShieldIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	// v1.41 특수 크리쳐 처리 
	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern

	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

#ifdef DEF_COLOR	//	mando 030125	색상 테스트 부분.
	iWeaponColor = G_iColor;
	iShieldColor = G_iColor;
	iArmorColor  = G_iColor;
	iMantleColor = G_iColor;
	iArmColor    = G_iColor;
	iPantsColor  = G_iColor;
	iBootsColor  = G_iColor;
	iHelmColor   = G_iColor;
#endif

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	
	if ( (_tmp_sStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;
		else if( _iGetFOE(_tmp_sStatus) == 1 ) bInv = TRUE;//우리편은 인비여도 투명하게 보여준다
		else return FALSE;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		_tmp_cFrame = _tmp_cFrame / 2;

		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (1 * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 1;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 1; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 1; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 1; 
					
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 1; 

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 1; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*1 + (_tmp_cDir - 1);
			}
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 1;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 1; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 1; 
		}
		else {
			// 비전투모드이다.
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (0 * 8);
			iUndiesIndex = 4580 + (_tmp_sAppr1 & 0x000F)*15;
			iHairIndex	 = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15; 

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*0 + (_tmp_cDir - 1);
			}
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 0;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15; 

			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 0; 
		}
		break;

	case 4:
	case 5:
	case 6:
		_tmp_cFrame = _tmp_cFrame / 2;

		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		if ((_tmp_sAppr2 & 0xF000) != 0) {
			// 전투모드이다. 
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (1 * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 1;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 1; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 1; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 1; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 1; 
		
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 1; 
			
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*1 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 1;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 1;
			
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 1; 
		}
		else {
			// 비전투모드이다.
			iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (0 * 8);
			
			iUndiesIndex = 14580 + (_tmp_sAppr1 & 0x000F)*15;
			iHairIndex	 = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15; 
			
			if ((_tmp_sAppr4 & 0x80) == 0) {
				if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15; 
			}
			
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15; 
			
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15; 
			
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15; 

			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else {
				iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*0 + (_tmp_cDir - 1);
			}

			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 0;

			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15;
			
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 0; 
		}
		break;

	default:	
		if (_tmp_sAppr2 != 0) {
			 iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			 _tmp_cFrame = (_tmp_sAppr2 & 0x00FF ) -1;
		}
		else if (_tmp_sOwnerType == 66) iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else iBodyIndex = 1220 +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1; 
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX, sY, _tmp_cFrame);

	// 중요 NPC의 경우 바닥에 광원을 그린다.
	switch (_tmp_sOwnerType) {
	case 15:
	case 19:
	case 20:
	case 24:
	case 25:
	case 26:
		m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
		break;
	}

#ifdef _DEBUG
	//m_pEffectSpr[74]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime );
	//m_pEffectSpr[79]->PutTransSprite70_NoColorKey(sX, sY+32, _tmp_cFrame, dwTime );
#endif

	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}
		
	if (bTrans == FALSE) {
		
		if (_cDrawingOrder[_tmp_cDir] == 1) {
			// 무기를 먼저 그린다.
			if (iWeaponIndex != -1) {
				if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX, sY, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}
				
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}

			// 에너지 볼 바닥 조명 
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
			
			if (bInv) m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			//
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1) {
				if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1) {
				if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)	
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}
			
			if (iBodyArmorIndex != -1) {
				if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1) {
				if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
			}
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
			
			if (iShieldIndex != -1) {
				if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
				}

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
		}
		else {
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
			case 66:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}

			// 에너지 볼 바닥 조명 
			if (_tmp_sOwnerType == 35)
				m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
			
			if (bInv) m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			//
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1) {
				if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1) {
				if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)	
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}

			if (iBodyArmorIndex != -1) {
				if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1) {
				if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
			}
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}

			if (iShieldIndex != -1) {
				if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
				}

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}

			if (iWeaponIndex != -1) {
				if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX, sY, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}

				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
		}
		
		if (_tmp_sOwnerType == 64)
		{
			switch( _tmp_cFrame )
			{
			case 0:
				m_pEffectSpr[84]->PutTransSprite(sX+52, sY+54, (dwTime%3000)/120, dwTime );
				break;
			case 1:
				m_pEffectSpr[83]->PutTransSprite(sX+53, sY+59, (dwTime%3000)/120, dwTime );
				break;
			case 2:
				m_pEffectSpr[82]->PutTransSprite(sX+53, sY+65, (dwTime%3000)/120, dwTime );
				break;
			}
		}
		// Berserk 
		if ((_tmp_sStatus & 0x20) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		// Protection From Magic
		if ((_tmp_sStatus & 0x80) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, -5, 0, 5, dwTime);
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_sStatus);
	}

	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}
	
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX) ) return TRUE;
	

	return FALSE;
}




void CGame::_ReadMapData(short sPivotX, short sPivotY, char * pData)
{
 int i;
 char  * cp, ucHeader, cDir, cName[12], cItemColor;
 short * sp, sTotal, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sStatus, sItemSpr, sItemSprFrame, sDynamicObjectType;
 int   * ip, iApprColor;
 WORD    wObjectID;
 WORD  * wp, wDynamicObjectID;

	cp = pData;

	// 기준점은 데이터가 유효한 사각형의 기준 위치로 삼는다. 
	m_sVDL_X = sPivotX; // Valid Data Loc-X
	m_sVDL_Y = sPivotY;

	// 총 몇개의 데이터가 있는지 읽는다.
	sp = (short *)cp;
	sTotal = *sp;
	cp += 2;
	
	for (i = 1;	i <= sTotal; i++) {
		// 상대 위치를 읽는다.
		sp = (short *)cp;
		sX = *sp;
		cp += 2;
		sp = (short *)cp;
		sY = *sp;
		cp += 2;
		
		// 헤더를 읽는다.
		ucHeader = *cp;
		cp++;

		if (ucHeader & 0x01) {
			// 케릭터가 있다. 정보를 읽는다.
			// object ID
			wp  = (WORD *)cp;
			wObjectID = *wp;
			cp += 2;
			// object type
			sp  = (short *)cp;
			sType = *sp;
			cp += 2;
			// dir
			cDir = *cp;
			cp++;
			
			if (wObjectID < 10000) {
				// 플레이어의 데이터이다. 
				// Appearance1
				sp  = (short *)cp;
				sAppr1 = *sp;
				cp += 2;
				// Appearance2
				sp  = (short *)cp;
				sAppr2 = *sp;
				cp += 2;
				// Appearance3
				sp  = (short *)cp;
				sAppr3 = *sp;
				cp += 2;
				// Appearance4
				sp  = (short *)cp;
				sAppr4 = *sp;
				cp += 2;
				// v1.4 ApprColor
				ip = (int *)cp;
				iApprColor = *ip;
				cp += 4;
				// Status
				sp  = (short *)cp;
				sStatus = *sp;
				cp += 2;
				// Name
				ZeroMemory(cName, sizeof(cName));
				memcpy(cName, cp, 10);
				cp    += 10;
			}
			else {
				// NPC의 데이터이다. 
				sAppr1 = sAppr3 = sAppr4 = 0;
				// Appearance2
				sp  = (short *)cp;
				sAppr2 = *sp;
				cp += 2;
				// Status
				sp  = (short *)cp;
				sStatus = *sp;
				cp += 2;
				// Name
				ZeroMemory(cName, sizeof(cName));
				memcpy(cName, cp, 5);
				cp    += 5;
			}

			m_pMapData->bSetOwner(wObjectID, sPivotX + sX, sPivotY + sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, sStatus, cName, DEF_OBJECTSTOP, NULL, NULL, NULL);
		}

		if (ucHeader & 0x02) {
			// 죽은 캐릭터가 있다. 정보를 읽는다.
			// object ID
			wp  = (WORD *)cp;
			wObjectID = *wp;
			cp += 2;
			// object type
			sp  = (short *)cp;
			sType = *sp;
			cp += 2;
			// dir
			cDir = *cp;
			cp++;
			if (wObjectID < 10000) {
				// 플레이어이다.
				// Appearance1
				sp  = (short *)cp;
				sAppr1 = *sp;
				cp += 2;
				// Appearance2
				sp  = (short *)cp;
				sAppr2 = *sp;
				cp += 2;
				// Appearance3
				sp  = (short *)cp;
				sAppr3 = *sp;
				cp += 2;
				// Appearance4
				sp  = (short *)cp;
				sAppr4 = *sp;
				cp += 2;
				// v1.4 ApprColor
				ip = (int *)cp;
				iApprColor = *ip;
				cp += 4;
				// Status
				sp  = (short *)cp;
				sStatus = *sp;
				cp += 2;
				// Name
				ZeroMemory(cName, sizeof(cName));
				memcpy(cName, cp, 10);
				cp    += 10;
			}
			else {
				// NPC의 데이터이다. 
				sAppr1 = sAppr3 = sAppr4 = 0;
				// Appearance2
				sp  = (short *)cp;
				sAppr2 = *sp;
				cp += 2;
				// Status
				sp  = (short *)cp;
				sStatus = *sp;
				cp += 2;
				// Name
				ZeroMemory(cName, sizeof(cName));
				memcpy(cName, cp, 5);
				cp    += 5;
			}
			
			m_pMapData->bSetDeadOwner(wObjectID, sPivotX + sX, sPivotY + sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, sStatus, cName);
		}

		if (ucHeader & 0x04) {
			// 아이템 정보가 있다. 
			// 스프라이트 
			sp  = (short *)cp;
			sItemSpr = *sp;
			cp += 2;
			// 스프라이트 프레임 
			sp  = (short *)cp;
			sItemSprFrame = *sp;
			cp += 2;
			cItemColor = *cp;
			cp++;

			m_pMapData->bSetItem(sPivotX + sX, sPivotY + sY, sItemSpr, sItemSprFrame, cItemColor, FALSE);
		}

		if (ucHeader & 0x08) {
			// 동적 객체가 있다. 
			wp = (WORD *)cp;
			wDynamicObjectID = *wp;
			cp += 2;
			
			sp  = (short *)cp;
			sDynamicObjectType = *sp;
			cp += 2;

			m_pMapData->bSetDynamicObject(sPivotX + sX, sPivotY + sY, wDynamicObjectID, sDynamicObjectType, FALSE);
		}
	}
}
		    
void CGame::LogEventHandler(char * pData)
{
 WORD * wp, wEventType, wObjectID;
 short * sp, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sStatus;
 char  * cp, cDir, cName[12];
 int   * ip, iApprColor;

	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wEventType = *wp;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	wp  = (WORD *)cp;
	wObjectID  = *wp;
	cp += 2;

	sp  = (short *)cp;
	sX  = *sp;
	cp += 2;

	sp  = (short *)cp;
	sY  = *sp;
	cp += 2;
	
	sp  = (short *)cp;
	sType = *sp;
	cp += 2;

	cDir = *cp;
	cp++;
	
	ZeroMemory(cName, sizeof(cName));
	if (wObjectID < 10000) {
		// 플레이어의 이벤트이다.
		memcpy(cName, cp, 10);
		cp += 10;

		sp  = (short *)cp;
		sAppr1 = *sp;
		cp += 2;

		sp  = (short *)cp;
		sAppr2 = *sp;
		cp += 2;

		sp  = (short *)cp;
		sAppr3 = *sp;
		cp += 2;

		sp  = (short *)cp;
		sAppr4 = *sp;
		cp += 2;

		ip = (int *)cp;
		iApprColor = *ip;
		cp += 4;

		sp  = (short *)cp;
		sStatus = *sp;
		cp += 2;
	}
	else {
		// NPC의 이벤트이다.
		memcpy(cName, cp, 5);
		cp += 5;

		sAppr1 = sAppr3 = sAppr4 = 0;

		sp  = (short *)cp;
		sAppr2 = *sp;
		cp += 2;

		sp  = (short *)cp;
		sStatus = *sp;
		cp += 2;
	}

	switch (wEventType) { 
	case DEF_MSGTYPE_CONFIRM:
		// 새로운 플레이어의 접속 혹은 NPC의 등장 
		m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, sStatus, cName, DEF_OBJECTSTOP, NULL, NULL, NULL);
		switch (sType) {
		case 43: // 전쟁용 유니트의 등장시에는 서몬 효과 추가.
		case 44:
		case 45:
		case 46:
		case 47:
			bAddNewEffect(64, (sX)*32 ,(sY)*32, NULL, NULL, 0);
			break;
		}
		break;
	
	case DEF_MSGTYPE_REJECT:
		// 플레이어의 접속해제 
		m_pMapData->bSetOwner(wObjectID, -1, -1, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, sStatus, cName, DEF_OBJECTSTOP, NULL, NULL, NULL);
		break;
	}

	//오브젝트 아이디가 같은 모든 채팅 메시지를 삭제한다.
	_RemoveChatMsgListByObjectID(wObjectID);
}

int CGame::_iCheckLUS()
{
	if (m_iLU_Point != 0) return 1;
	if ((m_iStr + m_cLU_Str) > 200) return 2;
	if ((m_iDex + m_cLU_Dex) > 200) return 2;
	if ((m_iInt + m_cLU_Int) > 200) return 2;
	if ((m_iVit + m_cLU_Vit) > 200) return 2;
	if ((m_iMag + m_cLU_Mag) > 200) return 2;
	if ((m_iCharisma + m_cLU_Char) > 200) return 2;

	return 0;

}

void CGame::OnLogSocketEvent(WPARAM wParam, LPARAM lParam)
{
 int iRet;
 char * pData;
 DWORD  dwMsgSize;
	
	if (m_pLSock == NULL) return;

	iRet = m_pLSock->iOnSocketEvent(wParam, lParam);	
	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// *** 소켓이 연결되었다. 해당 커넥션에 따라 처리한다.
		ConnectionEstablishHandler(DEF_SERVERTYPE_LOG);
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		// *** 메시지가 수신되었다.
		pData = m_pLSock->pGetRcvDataPointer(&dwMsgSize);
		LogRecvMsgHandler(pData);
		// 서버로부터의 응답시간 체크를 위해 타임값 기록 
		m_dwTime = G_dwGlobalTime;
		break;
	
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// *** 서버와의 연결이 끊어졌다. 
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		
		delete m_pLSock;
		m_pLSock = NULL;
		break;
	
	case DEF_XSOCKEVENT_SOCKETERROR:
		// *** 서버와의 연결상태에 에러가 발생했다.
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		
		delete m_pLSock;
		m_pLSock = NULL;
		break;
	
	case DEF_XSOCKEVENT_CRITICALERROR:
		// *** 치명적인 에러가 발생했다. 프로그램을 종료해야만 한다.
		delete m_pLSock;
		m_pLSock = NULL;
		break;
	} 
}

void CGame::LogResponseHandler(char * pData)
{
 WORD  * wp, wResponse; 
 WORD wServerUpperVersion, wServerLowerVersion;
 DWORD * dwp;
 char  * cp, cCharName[12]; 
 int   * ip, i; 
	
	dwp = (DWORD *)(pData);
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wResponse = *wp; 
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
  
#ifdef DEF_USING_GATEWAY // 12-16 성후니 수정 
	// v2.05 
	switch (*dwp) {
	case MSGID_GETMINIMUMLOADGATEWAY:
		char cIpAddr[16];
		// 부하가 가장 적은 Gateway의 주소다.		
		cp = (char *)(pData +6);
		ZeroMemory(cIpAddr, sizeof(cIpAddr));
		memcpy(cIpAddr, cp, 15);
		cp += 15; 
		
		ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
		strcpy(m_cLogServerAddr, cIpAddr);
		// proxy 서버 추가를 위해 포트 검색까지 ..
		ip = (int *)cp; 
		m_iLogServerPort =  *ip;
		cp += 4;
		
		// 접속 종료
		delete m_pLSock; 
		m_pLSock = NULL;

		m_bIsCheckingGateway = FALSE;
		break;
	}
#endif

	switch (wResponse) {
	case DEF_LOGRESMSGTYPE_CHARACTERDELETED:
		// 캐릭터가 지워진 후 남은 캐릭터들 정보 
		cp = (pData + DEF_INDEX2_MSGTYPE + 2);
		
		//m_iAccountStatus = (int)*cp; // v1.43 로그인때 받은 정보를 그대로 유지한다.
		cp++;

		m_iTotalChar = (int)*cp;
		cp++;
		
		for (i = 0; i < 4; i++)
		if (m_pCharList[i] != NULL) {
			delete m_pCharList[i];
			m_pCharList[i] = NULL;
		}

		for (i = 0; i < m_iTotalChar; i++) {
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, cp, 10);
			cp += 10;
			if (*cp == 0) {
				// 캐릭터의 데이터화일이 손상되었다.
				m_pCharList[i]->m_sSex = NULL; // Sex가 NULL이면 그리지 않아야 한다.
				cp += 40;
			}
			else {
				cp++;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr1 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr2 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr3 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr4 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sSex = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sSkinCol = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sLevel = *wp;
				cp += 2;

				dwp = (DWORD *)cp;
				m_pCharList[i]->m_iExp = *dwp; 
				cp += 4;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sStr = *wp;
				cp += 2; 

				wp = (WORD *)cp;
				m_pCharList[i]->m_sVit = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sDex = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sInt = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sMag = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sChr = *wp;
				cp += 2;

				ip = (int *)cp; // v1.4
				m_pCharList[i]->m_iApprColor = *ip;
				cp += 4;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iYear = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iMonth = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iDay = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iHour = (int)*wp; 
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iMinute = (int)*wp;
				cp += 2;

				ZeroMemory(m_pCharList[i]->m_cMapName, sizeof(m_pCharList[i]->m_cMapName));
				memcpy(m_pCharList[i]->m_cMapName, cp, 10);
				cp += 10;
			}
		}
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "3A");
		break;
	
	case DEF_LOGRESMSGTYPE_CONFIRM: 

		// 계정의 소유자가 갖고 있는 캐릭터 정보를 읽는다.
		cp = (pData + DEF_INDEX2_MSGTYPE + 2);
		
		//버젼 정보를 얻어온다////// 
		wp = (WORD *)cp;
		wServerUpperVersion = *wp;
		cp += 2;

		wp = (WORD *)cp;
		wServerLowerVersion = *wp;
		cp += 2;
		////////////////////////////

//		m_iAccountStatus = (int)*cp;
		cp++;

		//v1.2 계정의 날짜 정보를 읽는다.
		wp = (WORD *)cp;
		m_iAccntYear = *wp;
		cp += 2;

		wp = (WORD *)cp;
		m_iAccntMonth = *wp;
		cp += 2;

		wp = (WORD *)cp;
		m_iAccntDay = *wp;
		cp += 2;

		wp = (WORD *)cp;
		m_iIpYear = *wp;
		cp += 2;

		wp = (WORD *)cp;
		m_iIpMonth = *wp;
		cp += 2;

		wp = (WORD *)cp;
		m_iIpDay = *wp;
		cp += 2;

		m_iTotalChar = (int)*cp;
		cp++;
			
		for (i = 0; i < 4; i++)
		if (m_pCharList[i] != NULL) {
			delete m_pCharList[i];
			m_pCharList[i] = NULL;
		}

		for (i = 0; i < m_iTotalChar; i++) {
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, cp, 10);
			cp += 10;
			if (*cp == 0) {
				// 캐릭터의 데이터화일이 손상되었다.
				m_pCharList[i]->m_sSex = NULL; // Sex가 NULL이면 그리지 않아야 한다.
				cp += 40;
			}
			else {
				cp++;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr1 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr2 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr3 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr4 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sSex = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sSkinCol = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sLevel = *wp;
				cp += 2;

				dwp = (DWORD *)cp;
				m_pCharList[i]->m_iExp = *dwp;
				cp += 4;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sStr = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sVit = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sDex = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sInt = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sMag = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sChr = *wp;
				cp += 2;

				ip = (int *)cp;
				m_pCharList[i]->m_iApprColor = *ip; // v1.4
				cp += 4;
					  
				wp = (WORD *)cp;
				m_pCharList[i]->m_iYear = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iMonth = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iDay = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iHour = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iMinute = (int)*wp;
				cp += 2;

				ZeroMemory(m_pCharList[i]->m_cMapName, sizeof(m_pCharList[i]->m_cMapName));
				memcpy(m_pCharList[i]->m_cMapName, cp, 10);
				cp += 10;
			}
		}

		// v1.432 IP와 계정의 남은 사용시간을 얻어온다.
		ip = (int *)cp;
		m_iTimeLeftSecAccount = *ip;
		cp += 4;

		ip = (int *)cp;
		m_iTimeLeftSecIP = *ip;
		cp += 4;

		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		ClearContents_OnSelectCharacter();

		// 서버의 버젼을 검사한다. 
#ifndef _DEBUG
		if ( (wServerUpperVersion!=DEF_UPPERVERSION) || (wServerLowerVersion!=DEF_LOWERVERSION) ) ChangeGameMode(DEF_GAMEMODE_ONVERSIONNOTMATCH);
#endif
		break;

	case DEF_LOGRESMSGTYPE_REJECT:
		// 접속이 거부되었다 - 게임서버가 작동중이 아니던지 기타 접속 불가능한 상황  
		cp = (pData + DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		m_iBlockYear = *ip;
		cp += 4;
		
		ip = (int *)cp;
		m_iBlockMonth = *ip;
		cp += 4;

		ip = (int *)cp;
		m_iBlockDay = *ip;
		cp += 4;

		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "7H");
		break;

		// v2.11 성후니 추가 GD2S 용 과금 에라 메세지 
	case DEF_LOGRESMSGTYPE_NOTENOUGHPOINT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "7I");
		break; 

	// 06-19 성후니 추가 GD2S 용 과금 에라 메세지 
	case DEF_LOGRESMSGTYPE_ACCOUNTLOCKED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "7K");
		break; 

	// 06-19 성후니 추가 GD2S 용 과금 에라 메세지 
	case DEF_LOGRESMSGTYPE_SERVICENOTAVAILABLE:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "7L");
		break; 

	case DEF_LOGRESMSGTYPE_PASSWORDCHANGESUCCESS:
		// 패스워드를 성공적으로 바꾸었다.
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "6B");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDCHANGEFAIL:
		// 패스워드 갱신에 실패하였다.
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "6C");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDMISMATCH:
		// 패스워드가 일치하지 않는다. 
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "11");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGACCOUNT:
		// 계정이 존재하지 않는다. 
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "12");
		break;

	case DEF_LOGRESMSGTYPE_NEWACCOUNTCREATED:
		// 새 계정이 만들어 졌다. 
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "54");
		break;

	case DEF_LOGRESMSGTYPE_NEWACCOUNTFAILED:
		// 새 계정 생성에 실패했다.
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "05");
		break;

	case DEF_LOGRESMSGTYPE_ALREADYEXISTINGACCOUNT:
		// 새 계정 생성에 실패했다. - 이미 존재하는 계정이다.
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "06");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGCHARACTER:
		// 캐릭터가 존재하지 않는다. 
		ChangeGameMode(DEF_GAMEMODE_ONMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "Not existing character!");
		break;

	case DEF_LOGRESMSGTYPE_NEWCHARACTERCREATED:
		// 새 캐릭터가 만들어 졌다. 
		// 계정의 소유자가 갖고 있는 캐릭터 정보를 읽는다.
		ZeroMemory(cCharName, sizeof(cCharName));
		memcpy(cCharName, cp, 10);
		cp += 10;
		
		m_iTotalChar = (int)*cp;
		cp++;
		
		for (i = 0; i < 4; i++)
		if (m_pCharList[i] != NULL) delete m_pCharList[i];
		//
		for (i = 0; i < m_iTotalChar; i++) {
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, cp, 10);
			cp += 10;
			if (*cp == 0) {
				// 캐릭터의 데이터화일이 손상되었다.
				m_pCharList[i]->m_sSex = NULL; // Sex가 NULL이면 그리지 않아야 한다.
				cp += 40;
			}
			else {
				cp++;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr1 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr2 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr3 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr4 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sSex = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sSkinCol = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sLevel = *wp;
				cp += 2;

				dwp = (DWORD *)cp;
				m_pCharList[i]->m_iExp = *dwp;
				cp += 4;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sStr = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sVit = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sDex = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sInt = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sMag = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sChr = *wp;
				cp += 2;

				ip = (int *)cp; // v1.4
				m_pCharList[i]->m_iApprColor = *ip;
				cp += 4;
					   
				wp = (WORD *)cp;
				m_pCharList[i]->m_iYear = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iMonth = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iDay = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iHour = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iMinute = (int)*wp;
				cp += 2;

				ZeroMemory(m_pCharList[i]->m_cMapName, sizeof(m_pCharList[i]->m_cMapName));
				memcpy(m_pCharList[i]->m_cMapName, cp, 10);
				cp += 10;
			}
		}
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "47");
		break;

	case DEF_LOGRESMSGTYPE_NEWCHARACTERFAILED:
		// 새 캐릭터 생성에 실패했다.
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "28");
		break;

	case DEF_LOGRESMSGTYPE_ALREADYEXISTINGCHARACTER:
		// 새 캐릭터 생성에 실패했다. - 이미 존재하는 캐릭터이다.
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "29");
		break;

	case DEF_ENTERGAMERESTYPE_PLAYING:
		// 현재 플레이 중이다. 
		ChangeGameMode(DEF_GAMEMODE_ONQUERYFORCELOGIN);
		break;

	case DEF_ENTERGAMERESTYPE_CONFIRM:
		{
			int iGameServerPort;
			char cGameServerAddr[16];
			// 게임서버의 주소를 얻어 접속을 시도한다. 
			ZeroMemory(cGameServerAddr, sizeof(cGameServerAddr));
			cp = (pData + DEF_INDEX2_MSGTYPE + 2);
			memcpy(cGameServerAddr, cp, 16);
			cp += 16;

			wp = (WORD *)cp;
			iGameServerPort = *wp;
			cp += 2; 

			// v2.04 Gateway
			ZeroMemory(m_cGameServerName, sizeof(m_cGameServerName));
			memcpy(m_cGameServerName, cp, 20);
			cp += 20;

			// 게임서버로의 접속을 시도한다. 
			m_pGSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);

#ifdef DEF_USING_GATEWAY
			m_pGSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_GAMESOCKETEVENT);   // v2.04 Gateway 사용시
#else 
			m_pGSock->bConnect(cGameServerAddr, iGameServerPort, WM_USER_GAMESOCKETEVENT); // v2.04 Gateway
#endif
			m_pGSock->bInitBufferSize(30000);
		}
		break;

	case DEF_ENTERGAMERESTYPE_REJECT:
		// 게임서버로 접속이 불가능한 상태다. 
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		
		// 접속 거부 원인 코드에 맞는 메시지 출력
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		switch (*cp) {
		case 1:	strcpy(m_cMsg, "3E"); break;
		case 2:	strcpy(m_cMsg, "3F"); break;
		case 3:	strcpy(m_cMsg, "33"); break;
		case 4: strcpy(m_cMsg, "3D"); break;
		case 5: strcpy(m_cMsg, "3G"); break;
		case 6: strcpy(m_cMsg, "3Z"); break;
 		// v2.15 2002-5-21 월드 인원 제한용 
		case 7: strcpy(m_cMsg, "3J"); break;
		}  
		break;

	case DEF_ENTERGAMERESTYPE_FORCEDISCONN:
		// 접속 종료 요청을 하였다.
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "3X");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGWORLDSERVER:
		// 해당 월드 서버가 동작하고 있지 않다.
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "1Y");
		break;
	//v2.15 상하추가 중국 과금용 응답 메세지
	case DEF_LOGRESMSGTYPE_INPUTKEYCODE:
		// 새 캐릭터 생성에 실패했다.
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		// 접속 거부 원인 코드에 맞는 메시지 출력
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		switch (*cp) {
		case 1:	strcpy(m_cMsg, "8U"); break; //MainMenu, Keycode registration success
		case 2:	strcpy(m_cMsg, "82"); break; //MainMenu, Not existing Account
		case 3:	strcpy(m_cMsg, "81"); break; //MainMenu, Password wrong
		case 4: strcpy(m_cMsg, "8V"); break; //MainMenu, Invalid Keycode
		case 5: strcpy(m_cMsg, "8W"); break; //MainMenu, Already Used Keycode
		}  
		break;

		// 2002-09-16 #1 for Terra
#ifdef DEF_ACCOUNTLONG
	case DEF_LOGRESMSGTYPE_REALACCOUNT:
		// 사용자의 10글자 account를 가져 온다.
		cp = (pData + DEF_INDEX2_MSGTYPE + 2);
		strncpy(m_cAccountName, cp, DEF_ACCOUNTLEN);
		return;
		break;
#endif

	// v2.18 인터네셔널 서버 강제 패스워드 변경 		
	case DEF_LOGRESMSGTYPE_FORCECHANGEPASSWORD:
//		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
//		ZeroMemory(m_cMsg, sizeof(m_cMsg));
//		strcpy(m_cMsg, "2M");

		// 2002-10-17 #1
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "6M");
		break;

	case DEF_LOGRESMSGTYPE_INVALIDKOREANSSN:	// 주민등록번호 에러..
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "1a");
		break;

	case DEF_LOGRESMSGTYPE_LESSTHENFIFTEEN:		//	15세 미만..
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "1b");
		break;

	}
	
	// 로그 서버로의 연결을 종료한다. 
	delete m_pLSock;
	m_pLSock = NULL;
}

void CGame::LogRecvMsgHandler(char * pData)
{
	LogResponseHandler(pData);
}

void CGame::UpdateScreen_OnMsg()
{
 short msX, msY, msZ;
 char cLB, cRB;
 DWORD dwTime = G_dwGlobalTime;

	m_DDraw.ClearBackB4();
	
	PutString(10, 10, m_cMsg, RGB(255,155,155), FALSE, 1);

	DrawVersion(); 

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();

	if ((G_dwGlobalTime - m_dwTime) > 1500) 
	{
		#ifdef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
		#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		#endif
	}
}

void CGame::_InitOnCreateNewCharacter()
{
	m_cGender    = rand() % 2 + 1;
	m_cSkinCol   = rand() % 3 + 1;
	m_cHairStyle = rand() % 8;
	m_cHairCol   = rand() % 16;
	m_cUnderCol  = rand() % 8;
	m_ccStr = 10;
	m_ccVit = 10;
	m_ccDex = 10;
	m_ccInt = 10;
	m_ccMag = 10;
	m_ccChr = 10;
}

void CGame::ClearContents_OnCreateNewAccount()
{
	ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
	ZeroMemory(m_cAccountAge, sizeof(m_cAccountAge));
	ZeroMemory(m_cAccountCountry, sizeof(m_cAccountCountry));
	ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
	ZeroMemory(m_cEmailAddr, sizeof(m_cEmailAddr));
	//v1.4334 
	ZeroMemory(m_cAccountQuiz, sizeof(m_cAccountQuiz));
	ZeroMemory(m_cAccountAnswer, sizeof(m_cAccountAnswer));
}

void CGame::ChangeGameMode(char cMode)
{
	m_cGameMode = cMode;
	m_cGameModeCount = 0;
	m_dwTime = G_dwGlobalTime;
#ifndef DEF_SELECTSERVER
	if( cMode == DEF_GAMEMODE_ONSELECTSERVER )
	{
		ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
		strcpy(m_cWorldServerName, "WS1");
		m_cGameMode = DEF_GAMEMODE_ONLOGIN;
	}
#endif
}

BOOL CGame::bReadLoginConfigFile(char * cFn)
{
#ifdef DEF_TESTSERVER
	ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
	strcpy(m_cLogServerAddr, "203.234.215.200"); // v2.20 내부태섭
	//strcpy(m_cLogServerAddr, "211.239.170.87"); // v2.17 외부 테섭
	m_iLogServerPort = 2848;  //v2.17
	return TRUE;
#endif

#ifdef DEF_JAPAN_FOR_TERRA
	ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
	strcpy(m_cLogServerAddr, "211.43.213.43");
	m_iLogServerPort = 2849;
	return TRUE;
#endif

#if DEF_LANGUAGE > 3
	ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
	#ifdef DEF_FUCK_USA
		strcpy(m_cLogServerAddr, "216.27.13.36");
	#else
//		strcpy(m_cLogServerAddr, "218.145.52.70");
		strcpy(m_cLogServerAddr, "61.100.0.103");	//	20030221	mando..
	#endif
	//	mando 030113..
	m_iLogServerPort = 2848;
	//strcpy(m_cLogServerAddr, "211.239.170.86");
	//m_iLogServerPort = 2849;
//	m_iLogServerPort = 7964;
	return TRUE;
#else
 FILE * pFile; 
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= ,\t\n";

	cReadMode = 0; 

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	cp = new char[dwFileSize+2];
	ZeroMemory(cp, dwFileSize+2);
	fread(cp, dwFileSize, 1, pFile);

	token = strtok( cp, seps );
	while( token != NULL )
	{		
		if (cReadMode != 0)
		{
			switch (cReadMode)
			{
			case 1:
				if (strlen(token) > 15)
				{
					delete[] cp;
					if (pFile != NULL) fclose(pFile);
					return FALSE;
				}
				ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
				strcpy(m_cLogServerAddr, token);
				cReadMode = 0;
				break;
			case 2:
				m_iLogServerPort = atoi(token);
				if (m_iLogServerPort == 0)
				{
					delete[] cp;
					if (pFile != NULL) fclose(pFile);
					return FALSE;
				}
				cReadMode = 0;
				break;
			}
		}	
		else {
			if (memcmp(token, "log-server-address",18) == 0) cReadMode = 1;
			if (memcmp(token, "log-server-port",15) == 0)    cReadMode = 2;
		}
		token = strtok( NULL, seps );
	}
	delete[] cp;
	if (pFile != NULL) fclose(pFile);
	return TRUE;
#endif
}

void CGame::ReleaseUnusedSprites()
{
	int i;

	// 스프라이트 해제
	for (i = 0; i < DEF_MAXSPRITES; i++) 
	if ((m_pSprite[i] != NULL))
	{
		if( (m_pSprite[i]->m_bIsSurfaceEmpty == FALSE) && (m_pSprite[i]->m_bOnCriticalSection == FALSE) )
		{
			if ((G_dwGlobalTime - m_pSprite[i]->m_dwRefTime) > 60000 ) m_pSprite[i]->_iCloseSprite();
		}
	}
	for (i = 0; i < DEF_MAXTILES; i++) 
	if ((m_pTileSpr[i] != NULL))
	{
		if( (m_pTileSpr[i]->m_bIsSurfaceEmpty == FALSE) && (m_pTileSpr[i]->m_bOnCriticalSection == FALSE) )
		{
			if ((G_dwGlobalTime - m_pTileSpr[i]->m_dwRefTime) > 60000 ) m_pTileSpr[i]->_iCloseSprite();
		}
	}
	for (i = 0; i < DEF_MAXEFFECTSPR; i++) 
	if ((m_pEffectSpr[i] != NULL))
	{
		if( (m_pEffectSpr[i]->m_bIsSurfaceEmpty == FALSE) && (m_pEffectSpr[i]->m_bOnCriticalSection == FALSE) )
		{
			if ((G_dwGlobalTime - m_pEffectSpr[i]->m_dwRefTime) > 60000 ) m_pEffectSpr[i]->_iCloseSprite();
		}
	}

	// 사운드 해제 
	for (i = 0; i < DEF_MAXSOUNDEFFECTS; i++) {
		if (m_pCSound[i] != NULL) {
			if (((G_dwGlobalTime - m_pCSound[i]->m_dwTime) > 30000) && (m_pCSound[i]->m_bIsLooping == FALSE)) m_pCSound[i]->_ReleaseSoundBuffer();
		}
		if (m_pMSound[i] != NULL) {
			if (((G_dwGlobalTime - m_pMSound[i]->m_dwTime) > 30000) && (m_pMSound[i]->m_bIsLooping == FALSE)) m_pMSound[i]->_ReleaseSoundBuffer();
		}
		if (m_pESound[i] != NULL) {
			if (((G_dwGlobalTime - m_pESound[i]->m_dwTime) > 30000) && (m_pESound[i]->m_bIsLooping == FALSE)) m_pESound[i]->_ReleaseSoundBuffer();
		}
	}
}

void CGame::PutChatScrollList(char * pMsg, char cType)
{
 int i;
	
	if (m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1] != NULL) {
		delete m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1];
		m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1] = NULL;
	}
	for (i = DEF_MAXCHATSCROLLMSGS - 2; i >= 0; i--) {
		m_pChatScrollList[i+1] = m_pChatScrollList[i];
		m_pChatScrollList[i] = NULL;
	}
	// m_dwTime이 사실 메시지의 종류를 의미한다.
	m_pChatScrollList[0] = new class CMsg(1, pMsg, cType);
}

void CGame::ChatMsgHandler(char * pData)
{
 int i, iObjectID, iLoc;
 short * sp, sX, sY;
 char * cp, cMsgType, cName[21], cTemp[100], cMsg[100], cTxt1[100], cTxt2[100];
 DWORD dwTime;
 WORD * wp;
 BOOL bFlag;

 char cHeadMsg[200];

	dwTime = m_dwCurTime;

	ZeroMemory(cTxt1, sizeof(cTxt1));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	ZeroMemory(cMsg, sizeof(cMsg));

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	iObjectID = (int)*wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, (char *)cp, 10);
	cp += 10;

	cMsgType = *cp;
	cp++;

	// 수신 거부 당한 캐릭터의 대화 내용은 적지 않는다. 
	if (bCheckExID(cName) == TRUE) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	strcpy(cTemp, cp);

#if DEF_LANGUAGE == 4
	if( (cMsgType==0) || (cMsgType==2) || (cMsgType==3) )
	{
		if( m_Misc.bCheckIMEString(cTemp)==FALSE ) return;
	}
#endif
	if( !m_bWhisper )
	{
		if( cMsgType == 20 ) return;
	}
	if( !m_bShout )
	{
		if( cMsgType == 2 || cMsgType == 3 ) return;
	}

	ZeroMemory(cMsg, sizeof(cMsg));
	wsprintf(cMsg, "%s: %s", cName, cTemp);

	// 이제 cMsg의 스트링 길이를 구해서 나누어 저장한다.
	m_DDraw._GetBackBufferDC();

	bFlag = FALSE;
	short sCheckByte = 0;

	while (bFlag == FALSE) {
		iLoc = m_Misc.iGetTextLengthLoc(m_DDraw.m_hDC, cMsg, 305);
		for( int i=0 ; i<iLoc ; i++ ) if( cMsg[i] < 0 ) sCheckByte ++;
		if (iLoc == 0) {
			PutChatScrollList(cMsg, cMsgType);
			bFlag = TRUE;
		}
		else {
			if ((sCheckByte%2)==0) {
				// iLoc-1 까지 짜른다.
				ZeroMemory(cTemp, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc);
				PutChatScrollList(cTemp, cMsgType);
				// 남은 스트링 cMsg로 
				ZeroMemory(cTemp, sizeof(cTemp));
				strcpy(cTemp, cMsg +iLoc );
				ZeroMemory(cMsg, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
			}
			else  {
				// iLoc까지 짜른다.
				ZeroMemory(cTemp, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc+1);
				PutChatScrollList(cTemp, cMsgType);
				// 남은 스트링 cMsg로 
				ZeroMemory(cTemp, sizeof(cTemp));
				strcpy(cTemp, cMsg +iLoc+1);
				ZeroMemory(cMsg, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
			}
		}
	}
	
	m_DDraw._ReleaseBackBufferDC();

	// 먼저 같은 오브젝트 아이디를 가진 채팅 메시지를 삭제한다.
	_RemoveChatMsgListByObjectID(iObjectID);
	
	// 그다음 머리말 리스트에 넣는다.
	for (i = 1; i < DEF_MAXCHATMSGS; i++) 
	if (m_pChatMsgList[i] == NULL) {
		m_pChatMsgList[i] = new class CMsg(1, (char *)(cp), dwTime);
		m_pChatMsgList[i]->m_iObjectID = iObjectID;
		
		if (m_pMapData->bSetChatMsgOwner(iObjectID, sX, sY, i) == FALSE) {
			delete m_pChatMsgList[i];
			m_pChatMsgList[i] = NULL;
		}

		if ( (cMsgType != 0) && (m_bIsDialogEnabled[10] != TRUE) ) {
			ZeroMemory(cHeadMsg, sizeof(cHeadMsg));
			wsprintf(cHeadMsg, "%s:%s", cName, cp);
			AddEventList(cHeadMsg, cMsgType);
		}
		return;
	}
}

void CGame::ReleaseTimeoverChatMsg()
{
 int i;
 DWORD dwTime;

	dwTime = G_dwGlobalTime;

	for ( i = 1; i < DEF_MAXCHATMSGS; i++) 
	if (m_pChatMsgList[i] != NULL) {
		
		if ((m_pChatMsgList[i]->m_cType >= 1) && (m_pChatMsgList[i]->m_cType <= 20)) {
			if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_A) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
		}
		else
		if ((m_pChatMsgList[i]->m_cType >= 21) && (m_pChatMsgList[i]->m_cType <= 40)) {
			if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_B) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
		}
		else 
		if ((m_pChatMsgList[i]->m_cType >= 41) && (m_pChatMsgList[i]->m_cType <= 60)) {
			if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_C) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
		}
		else if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_A) {
			delete m_pChatMsgList[i];
			m_pChatMsgList[i] = NULL;
		}
	}
}

void CGame::DrawBackground(short sDivX, short sModX, short sDivY, short sModY)
{
 int indexX, indexY, ix, iy;
 short sSpr, sSprFrame;
	// v2.14 텔레포트시 물건 집으면 클라이언트 죽는 에러 처리 
 	if (sDivX < 0 || sDivY < 0) return ;
	if ((m_bIsRedrawPDBGS == TRUE) || (m_iPDBGSdivX != sDivX) || (m_iPDBGSdivY != sDivY)) {
		// Pre-Draw Background Surface 다시 그려야 한다. 
		m_bIsRedrawPDBGS = FALSE;
		m_iPDBGSdivX = sDivX;
		m_iPDBGSdivY = sDivY;
		SetRect(&m_DDraw.m_rcClipArea, 0,0, 640+32, 480+32);
		indexY = sDivY+m_pMapData->m_sPivotY;
		for (iy = -sModY; iy < 427+48 ; iy += 32)
		{
			indexX = sDivX+m_pMapData->m_sPivotX;
			for (ix = -sModX; ix < 640+48 ; ix += 32)
			{
				sSpr      = m_pMapData->m_tile[indexX][indexY].m_sTileSprite;
				sSprFrame = m_pMapData->m_tile[indexX][indexY].m_sTileSpriteFrame;
				m_pTileSpr[sSpr]->PutSpriteFastNoColorKeyDst(m_DDraw.m_lpPDBGS, ix - 16 +sModX, iy - 16 +sModY, sSprFrame, m_dwCurTime);
				// 그림자 이미지를 그린다.
				indexX++;
			}
			indexY++;
		}
		SetRect(&m_DDraw.m_rcClipArea, 0,0, 640, 480);
	}
	RECT rcRect;
	SetRect(&rcRect, sModX, sModY, 640+sModX, 480+sModY); // our fictitious sprite bitmap is 
	m_DDraw.m_lpBackB4->BltFast( 0, 0, m_DDraw.m_lpPDBGS, &rcRect, DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);
	// 건설위치, 텔레포트 위치 출력 
	if( m_bIsCrusadeMode )
	{
		if(m_iConstructLocX != -1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, m_iConstructLocX*32 - m_sViewPointX, m_iConstructLocY*32 - m_sViewPointY, 41);
		if( m_iTeleportLocX != -1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, m_iTeleportLocX*32 - m_sViewPointX, m_iTeleportLocY*32 - m_sViewPointY, 42);
	}
}


BOOL CGame::bEffectFrameCounter()
{
 int i, x;
 DWORD dwTime;
 BOOL bRet = FALSE;
 short sAbsX, sAbsY, sDist;
 char  cDir;
 long lPan;

	dwTime = m_dwCurTime;
	dwTime += m_pMapData->m_dwFrameAdjustTime;
	
	for (i = 0; i < DEF_MAXEFFECTS; i++)
	if (m_pEffectList[i] != NULL) {
		if ((dwTime - m_pEffectList[i]->m_dwTime) > m_pEffectList[i]->m_dwFrameTime) {
			// 프레임 갱신시간이 되었다.
			m_pEffectList[i]->m_dwTime = dwTime;
			m_pEffectList[i]->m_cFrame++;
			bRet = TRUE;

			m_pEffectList[i]->m_mX2 = m_pEffectList[i]->m_mX;
			m_pEffectList[i]->m_mY2 = m_pEffectList[i]->m_mY; 

			switch (m_pEffectList[i]->m_sType) {
			case 1:
#if DEF_LANGUAGE != 3
    			// 검광 효과. 프레임 카운트에 의해 계산된다.
				if (m_pEffectList[i]->m_cFrame == 1) {                
					// 피 튀기는 효과 추가.
					for (int j = 1; j <= m_pEffectList[i]->m_iV1; j++) bAddNewEffect(11, m_pEffectList[i]->m_mX + 15 - (rand() % 30), m_pEffectList[i]->m_mY + 15 - (rand() % 30), NULL, NULL, -1*(rand() % 2));                
				}
#endif
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}			
				break;

			case 2:
				// 일반 화살 날라가는 효과 m_mX, m_mY를 계산한다. 
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32 - 40, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 70);
				
				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY*32 - 40)) <= 2) ) {
					
					// 명중시 먼지구름
					bAddNewEffect(14, m_pEffectList[i]->m_mX +(rand() % 5) - 2, m_pEffectList[i]->m_mY +(rand() % 5) - 2, NULL, NULL, 0, 0);

					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 20:
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27:
				// 검기 날아가는 효과 
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32 - 40, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 50);
				
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));

				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY*32 - 40)) <= 2) ) {
					
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 4:
				// Gold Drop 
				
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. Gold Item을 바닥에 놓는다. 
					//m_pMapData->bSetItem(m_pEffectList[i]->m_mX/32, m_pEffectList[i]->m_mY/32, 6, 0, 0); //v1.41
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				
				break;

			case 5:
			case 30:
			case 31:
				// Fire Explosion
				
				if (m_pEffectList[i]->m_cFrame == 1) {
					// 불꽃 뛰기는 효과 추가.
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
				}

				if (m_pEffectList[i]->m_cFrame == 7) {
					// 불꽃 잔상 효과 추가 	
					bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, NULL, NULL);
					bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, NULL, NULL);
					bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, NULL, NULL);
				}
				
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;
			
			case 6:
				// Lightning Bolt Burst
#if DEF_LANGUAGE != 3
				if (m_pEffectList[i]->m_cFrame == 1) {
					// 피 튀기는 효과 추가.
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
				}
#endif

				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}

				break;

			case 7:
#if DEF_LANGUAGE != 3
				// Magic Missile Burst
				if (m_pEffectList[i]->m_cFrame == 1) {
					// 피 튀기는 효과 추가.
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
				}
#endif

				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}

				break;

			case 9:
				// Burst Type 2
				m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
				m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;

				m_pEffectList[i]->m_rY++;

				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 10:
				// Lightning Arrow Burst
				if (m_pEffectList[i]->m_cFrame == 1) {
					// 에너지 파편 튀기는 효과 추가.
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
				}
							
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 11:
             #if DEF_LANGUAGE != 3
				// Burst Type 3 피튀김 
				m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
				m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;

				m_pEffectList[i]->m_rY++;

				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
              #endif				
				break;

			case 12:
				// Burst Type 4 불꽃 튀김 
				m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
				m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
								
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 13:
				// 물방울 
				if (m_pEffectList[i]->m_cFrame < 15) {
					if ((rand() % 2) == 0)
						 m_pEffectList[i]->m_mX++;
					else m_pEffectList[i]->m_mX--;
					m_pEffectList[i]->m_mY--;
				}
				
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 16:
				// 날아가는 에너지 스트라이크 
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 40);

				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				
				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2) ) {
									
					bAddNewEffect(18, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, NULL, NULL, 0); // testcode 0111 18
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 34:
				// 날아가는 지상 번개 
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 50);

				bAddNewEffect(33, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, NULL, NULL, -1*(rand() % 4));
				
				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2) ) {
									
					bAddNewEffect(33, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, NULL, NULL, 0); //7
					
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 17:
				// Ice-Storm 알갱이 궤적 처리 
				cDir = m_Misc.cGetNextMoveDir(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, m_pEffectList[i]->m_mX3, m_pEffectList[i]->m_mY3);
				
				switch (cDir) {
				case 1:
					m_pEffectList[i]->m_rY -= 2;
					break;
				case 2:
					m_pEffectList[i]->m_rY -= 2;
					m_pEffectList[i]->m_rX += 2;
					break;
				case 3:
					m_pEffectList[i]->m_rX += 2;
					break;
				case 4:
					m_pEffectList[i]->m_rX += 2;
					m_pEffectList[i]->m_rY += 2;
					break;
				case 5:
					m_pEffectList[i]->m_rY += 2;
					break;
				case 6:
					m_pEffectList[i]->m_rX -= 2;
					m_pEffectList[i]->m_rY += 2;
					break;
				case 7:
					m_pEffectList[i]->m_rX -= 2;
					break;
				case 8:
					m_pEffectList[i]->m_rX -= 2;
					m_pEffectList[i]->m_rY -= 2;
					break;
				}
				
				if (m_pEffectList[i]->m_rX < -10) m_pEffectList[i]->m_rX = -10;
				if (m_pEffectList[i]->m_rX >  10) m_pEffectList[i]->m_rX =  10;
				if (m_pEffectList[i]->m_rY < -10) m_pEffectList[i]->m_rY = -10;
				if (m_pEffectList[i]->m_rY >  10) m_pEffectList[i]->m_rY =  10;

				m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
				m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;

				m_pEffectList[i]->m_mY3--;
				
				if (m_pEffectList[i]->m_cFrame > 10) {
					m_pEffectList[i]->m_cFrame = 0;
					if (abs(m_pEffectList[i]->m_sY - m_pEffectList[i]->m_mY3) > 100) {
						delete m_pEffectList[i];
						m_pEffectList[i] = NULL;
					}
				}
				break;

			case 40:
			case 56:
				if (m_pEffectList[i]->m_cFrame == 9) {
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
				}

				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 41: // 얼음 송곳 Large Type 1, 2, 3, 4
			case 42:
			case 43:
			case 44: 
			
			case 45: // 얼음 송곳 Small Type 1, 2
			case 46:
							
				if (m_pEffectList[i]->m_cFrame >= 7) {
					m_pEffectList[i]->m_mX--;
					m_pEffectList[i]->m_mY += m_pEffectList[i]->m_iV1;
					m_pEffectList[i]->m_iV1++;
				}
				
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 작은 알갱이가 아니면 깨지는 처리
					if ((m_pEffectList[i]->m_sType != 45) && (m_pEffectList[i]->m_sType != 46)) {
						bAddNewEffect(50, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0);
						// 먼지 연기
						bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
						bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
						bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);

						bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
						bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					}
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				} 
				break;  

			// v2.16 2002-5-23 고광현 수정 
			case 47: // Blizzard용 얼음 조각
			case 48:
			case 49:
							
				if (m_pEffectList[i]->m_cFrame >= 7) {
					m_pEffectList[i]->m_mX--;
					m_pEffectList[i]->m_mY += m_pEffectList[i]->m_iV1;
					m_pEffectList[i]->m_iV1 += 4;
				}
				
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 작은 알갱이가 아니면 깨지는 처리
					if (m_pEffectList[i]->m_sType == 49)
						 bAddNewEffect(72, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0);
					else bAddNewEffect(50, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0);
					// 먼지 연기
					bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);

					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				} 
				break;  

			case 181:
			case 60: // 메테오 스트라이크 낙하, 명중
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					
					bAddNewEffect(61, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
					bAddNewEffect(63, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);

					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));

					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				else if (m_pEffectList[i]->m_cFrame >= 0) {
					m_pEffectList[i]->m_mX -= 30;
					m_pEffectList[i]->m_mY += 46;
					
					// 연기 구름 생성 
					bAddNewEffect(62, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
				}
				break;

			case 62:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				} 
				else if (m_pEffectList[i]->m_cFrame >= 0) {
					m_pEffectList[i]->m_mX += (rand() % 3) -1;
					m_pEffectList[i]->m_mY += (rand() % 3) -1;
				}
				break;

			case 65:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				else if (m_pEffectList[i]->m_cFrame >= 0) {
					m_pEffectList[i]->m_mX += (rand() % 3) -1;
					m_pEffectList[i]->m_mY -= 4 +(rand() % 2);
				}
				break;

			case 66:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 68:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				else if (m_pEffectList[i]->m_cFrame == 11) {
					SetCameraShakingEffect(m_pEffectList[i]->m_iV1, 2);
				}
				break;
			case 69:
			case 70:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;
				   
			// v2.16 2002-5-23 고광현수정 
			case 71:
				// 날아가는 지상 번개 
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 50);

				
				bAddNewEffect(48, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, NULL, NULL, 0); 
				bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
								
				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2) ) {

					bAddNewEffect(49, m_pEffectList[i]->m_mX/* + (rand() % 30) - 15*/, m_pEffectList[i]->m_mY/* + (rand() % 30) - 15*/, NULL, NULL, 0);
														
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;
				   
			case 100:
				// 매직 미사일
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 50);
				
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));

				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY*32/* - 40*/)) <= 2) ) {
					
					bAddNewEffect(7, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;
			
			case 110:
				// Enegy-Bolt
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 50);
				
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				
				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) ) {
					
					bAddNewEffect(6, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0); // 6 testcode 0111
					
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 120:
				// Fire Ball
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 50);
				
				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) ) {
					
					bAddNewEffect(5, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 130:
				// Fire Strike
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 50);
				
				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) ) {
					
					bAddNewEffect(5, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					bAddNewEffect(5, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -7);
					bAddNewEffect(5, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -5);
					bAddNewEffect(5, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;
			
			case 137:
				// Lightning Arrow
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 50);
								
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				
				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) ) {
					
					bAddNewEffect(10, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
				
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 145:
				// Chill-Wind 얼리는 에펙트 생성후 삭제
				bAddNewEffect(40, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
				bAddNewEffect(40, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -10);
				bAddNewEffect(40, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -6);
				bAddNewEffect(40, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;

			case 147:  // v1.4334 Triple-Energy-Bolt 
				bAddNewEffect(110, m_pEffectList[i]->m_sX , m_pEffectList[i]->m_sY , 
						               m_pEffectList[i]->m_dX -1, m_pEffectList[i]->m_dY-1, 0);

				bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY, 
						               m_pEffectList[i]->m_dX +1, m_pEffectList[i]->m_dY -1, 0);				

				bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY, 
						               m_pEffectList[i]->m_dX +1, m_pEffectList[i]->m_dY +1, 0);
				
								
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));

								
				lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX)*1000;
				PlaySound('E', 1, sDist, lPan);

				bAddNewEffect(7, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);

		
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;

			break ;


			case 143: // Lightning
			case 151: // Lightning-Bolt
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					bAddNewEffect(10, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0); 
					
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				else {
					m_pEffectList[i]->m_rX = 5 - (rand() % 10);
					m_pEffectList[i]->m_rY = 5 - (rand() % 10);
				}
				break;

			case 156: // Mass-Lightnig-Arrow
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				else {
					// 매 프레임마다 목표지점으로 날아가는 에너지 스트라이크를 생성한다.
					bAddNewEffect(137, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY, 
						               m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 0);
					
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);

					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;

					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX)*1000;
					PlaySound('E', 1, sDist, lPan);
				}
				break;

			case 157:
				// Ice-Strike 얼음송곳 하강 그림 
				bAddNewEffect(41, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
				for (x = 0; x < 14; x++) {
					bAddNewEffect(41 + (rand() % 3), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1);
				}
				
				for (x = 0; x < 6; x++) {
					bAddNewEffect(45 + (rand() % 2), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1 -10);
				}
				
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;

			case 160: // Energy-Strike
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				else {
					// 매 프레임마다 목표지점으로 날아가는 에너지 스트라이크를 생성한다.
					bAddNewEffect(16, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY, 
						          m_pEffectList[i]->m_dX*32 + 50 - (rand() % 100), m_pEffectList[i]->m_dY*32 + 50 - (rand() % 100), 0);

					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);

					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;

			case 161:
				// Mass-Fire-Strike
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY, 
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/, 
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, 
								&m_pEffectList[i]->m_iErr, 50);
				
				// m_mX, m_mY가 목표점에 도달했으면 제거되어야만 한다.
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) ) {
					
					bAddNewEffect(30, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -7);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -5);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 163: // Mass-Chill-Wind
				// Chill-Wind 얼리는 에펙트 생성후 삭제
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -10);
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -6);
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);
				
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +(rand()%100)-50, m_pEffectList[i]->m_dY*32 +(rand()%70)-35, NULL, NULL, -1*(rand()%10));
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +(rand()%100)-50, m_pEffectList[i]->m_dY*32 +(rand()%70)-35, NULL, NULL, -1*(rand()%10));
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +(rand()%100)-50, m_pEffectList[i]->m_dY*32 +(rand()%70)-35, NULL, NULL, -1*(rand()%10));
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +(rand()%100)-50, m_pEffectList[i]->m_dY*32 +(rand()%70)-35, NULL, NULL, -1*(rand()%10));
				
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;

			case 164: // worm-bite
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					// 입 에펙트 추가 
					bAddNewEffect(68, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0); // testcode 0111 18
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 170:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				else if ((m_pEffectList[i]->m_cFrame % 2) == 0) {
					
					bAddNewEffect(34, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY, 
						          m_pEffectList[i]->m_dX*32 + 30 - (rand() % 60), m_pEffectList[i]->m_dY*32 + 30 - (rand() % 60), 0);
					
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);

					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;

			case 172:
				// Mass-Ice-Strike 얼음송곳 하강 그림 
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
				
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
				
				for (x = 0; x < 16; x++) {
					bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*x-1);
				}
				
				for (x = 0; x < 8; x++) {
					bAddNewEffect(45 + (rand() % 2), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1 -10);
				}
				
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;


			case 174: // Lightning-Strike
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				else {
					bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY, 
						          m_pEffectList[i]->m_dX +(rand()%3) -1, m_pEffectList[i]->m_dY +(rand()%3) -1, 0);
					
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);

					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;

			// v2.16 2002-5-23 고광현 수정 
			case 191:
				// 블리자드
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
										
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				else /*if (m_pEffectList[i]->m_cFrame == 1)*/ {
					
					bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY, 
						          m_pEffectList[i]->m_dX*32 +(rand()%120)-60, m_pEffectList[i]->m_dY*32 +(rand()%120)-60, 0);
					
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);

					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;

			case 33:
				// 땅에 번개 퍼지는 효과 
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 8:
			case 14:
			case 15:
			case 18:
			case 32:
			case 50: // 얼음 송곳 깨짐
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 57:
			case 61:
			case 63:
			case 64:
			case 67:
			case 72: // v2.16 2002-5-23 고광현
			case 73:
			case 74:
			case 75:
			case 76:
			case 77:
				
			case 101:
			case 102:
			case 111:
			case 112:
			case 113:
			case 121:
			case 122:
			case 123:
			case 124:
			case 125:
			case 126:
			case 127:
			case 128:
			case 131:
			case 132:
			case 133:
			case 134:
			case 135:
			case 136:
			case 142:
			case 144:
			case 150: // Berserk : Cirlcle 6 magic 
			case 152:
			case 153:
			case 162:
			case 165: // v2.16 2002-5-24 고광현 
			case 166: // v2.16 2002-5-24 고광현 
			case 171:
			case 180:
			case 190:
				// 한계 프레임이 지나면 사라져야 할 에펙트 
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame) {
					// 제거되야만 한다. 
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;
			}
		}
	}
	
	return bRet;
}


BOOL   CGame::DrawObject_OnRun(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int dx, dy;
 int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iWeaponIndex, iShieldIndex, iHelmIndex, iR, iG, iB, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	// v1.41 특수 크리쳐 처리 
	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern

	// v1.4
	if (m_cDetailLevel == 0) {
		iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}
	else {
		iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);

	if ( (_tmp_sStatus & 0x10) != 0)
	{
		if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;
		else if( _iGetFOE(_tmp_sStatus) == 1 ) bInv = TRUE;//우리편은 인비여도 투명하게 보여준다
		else return FALSE;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex  = 500  + (_tmp_sOwnerType - 1 )*8*15 + (4 * 8);
		iUndiesIndex    = 4580 + (_tmp_sAppr1 & 0x000F)*15 + 4;
		iHairIndex	    = 4820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 4;
		
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 5060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 4; 
		}
		
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 5300 + (_tmp_sAppr3 & 0x000F)*15 + 4; 

		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 5540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 4; 
		
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 5780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 4; 

		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else {
			iWeaponIndex = 6020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*6 + (_tmp_cDir - 1);
		}
		
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = 9100 + (_tmp_sAppr2 & 0x000F)*8 + 6;

		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 9230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 4; 

		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = 9300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 4; 
		break;

	case 4:
	case 5:
	case 6:
		// 스커트 그리는 모드인지 판단.
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		iBodyIndex  = 500  + (_tmp_sOwnerType - 1 )*8*15 + (4 * 8);
		
		iUndiesIndex    = 14580 + (_tmp_sAppr1 & 0x000F)*15 + 4;
		iHairIndex	    = 14820 + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 4;
		
		if ((_tmp_sAppr4 & 0x80) == 0) {
			if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = 15060 + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 4; 
		}
		
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = 15300 + (_tmp_sAppr3 & 0x000F)*15 + 4; 

		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = 15540 + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 4; 
		
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = 15780 + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 4; 
	
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else {
			iWeaponIndex = 16020 + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*6 + (_tmp_cDir - 1);
		}
		
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = 19100 + (_tmp_sAppr2 & 0x000F)*8 + 6;
		
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = 19230 + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 4; 

		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = 19300 + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 4; 
		break;

	default:
		iUndiesIndex    = -1;
		iHairIndex   	= -1;
		iArmArmorIndex  = -1;
		iBodyArmorIndex = -1;
		iPantsIndex     = -1;
		iBootsIndex     = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}

	dx = 0; 
	dy = 0;
	
	switch (_tmp_cDir) {
	case 1 : dy = 28 - (_tmp_cFrame<<2); break;
	case 2 : dy = 28 - (_tmp_cFrame<<2); dx = (_tmp_cFrame<<2) - 28; break;
	case 3 : dx = (_tmp_cFrame<<2) - 28; break;
	case 4 : dx = (_tmp_cFrame<<2) - 28; dy = (_tmp_cFrame<<2) - 28; break;
	case 5 : dy = (_tmp_cFrame<<2) - 28; break;
	case 6 : dy = (_tmp_cFrame<<2) - 28; dx = 28 - (_tmp_cFrame<<2); break;
	case 7 : dx = 28 - (_tmp_cFrame<<2); break;
	case 8 : dx = 28 - (_tmp_cFrame<<2); dy = 28 - (_tmp_cFrame<<2); break;
	}

	if (m_bIsCrusadeMode) DrawObjectFOE(sX+dx, sY+dy, _tmp_cFrame);

	// v1.432 Effect 그린다. 
	if (_tmp_iEffectType != 0) {
		// 활성화된 Effect가 있다.
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == FALSE) {
		if (_cDrawingOrder[_tmp_cDir] == 1) {
			// 무기를 먼저 그린다.
			if (iWeaponIndex != -1) {
				if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else
				{					
					if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
				
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}
			
			if (bInv == TRUE) 
				//m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 0)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
						
			if (iUndiesIndex != -1)
			{
				if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1) {
				if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1) {
				if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)	
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}
			
			if (iBodyArmorIndex != -1) {
				if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1) {
				if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
			}
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 2)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
			
			if (iShieldIndex != -1) {
				if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
				}

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 1)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}
		}
		else {
			switch (_tmp_sOwnerType) {
			case 10: // 그림자를 그리면 안되는 것들.
			case 35:
			case 50:
			case 51:
			case 60: // 정진광 수정, 식인식물은 그림자 없음.
			case 65:
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50) 
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}
			
			if (bInv == TRUE) 
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_sStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime); 
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime); 
			}
			// 몸통의 위치 저장한다.
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			
			//
			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 0)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}

			if (iUndiesIndex != -1)
			{
				if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}
			
			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}
			
			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}

			if (iPantsIndex != -1) {
				if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}
			}

			if (iArmArmorIndex != -1) {
				if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmColor == 0)	
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}
			}

			if (iBodyArmorIndex != -1) {
				if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}
			}

			if (iHelmIndex != -1) {
				if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}
			}

			//	
			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 2)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}

			if (iShieldIndex != -1) {
				if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
				}

				//V1.432 Shield Glare
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				// v2.16 2002-5-14 고광현수정
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 1)) {
				if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{
					if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}

			if (iWeaponIndex != -1) {
				if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else
				{
					if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}

				//V1.432 Weapon Glare
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}
		}
		
		// Berserk 
		if ((_tmp_sStatus & 0x20) != 0) 
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, 0, -5, -5, dwTime);
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX+dx, sY+dy, _tmp_cName, _tmp_sStatus);
		else DrawNpcName(sX+dx, sY+dy, _tmp_sOwnerType, _tmp_sStatus);
	}

	if (_tmp_iChatIndex != NULL) {
		if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			// 그려야 할 위치정보를 입력한다.
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX+dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY+dy;
		}
		else {
			// 시간이 초과해 지워진 메시지이므로 
			m_pMapData->ClearChatMsg(indexX, indexY);
		}
	}

	_tmp_dx = dx;
	_tmp_dy = dy;

	// 마우스 커서와의 충돌을 체크한다.
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE; 
}

void CGame::GetPlayerTurn()
{
 char cDir;
 short sX, sY, sCnt1, sCnt2;
 int   iError;

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt1 = 0;
	m_cPlayerTurn = 0;
	iError = 0;
	while (1) {
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir) {
		case 1: sY--;       break;
		case 2: sX++; sY--; break;
		case 3: sX++;       break;
		case 4: sX++; sY++; break;
		case 5: sY++;       break;
		case 6: sX--; sY++; break;
		case 7: sX--;       break;
		case 8: sX--; sY--; break;
		}
		sCnt1++;
		if (sCnt1 > 30) break;
	}

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt2 = 0;
	m_cPlayerTurn = 1;
	iError = 0;
	while (1) {
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir) {
		case 1: sY--;       break;
		case 2: sX++; sY--; break;
		case 3: sX++;       break;
		case 4: sX++; sY++; break;
		case 5: sY++;       break;
		case 6: sX--; sY++; break;
		case 7: sX--;       break;
		case 8: sX--; sY--; break;
		}
		sCnt2++;
		if (sCnt2 > 30) break;
	}

	if (sCnt1 > sCnt2) 
		 m_cPlayerTurn = 0;
	else m_cPlayerTurn = 1;
}


int CGame::_iCheckDlgBoxFocus(short msX, short msY, char cButtonSide)
{
 int i;
 char         cDlgID;
 short        sX, sY;
 DWORD		  dwTime = m_dwCurTime;

	if (cButtonSide == 1) {
		// 왼쪽버튼이 눌린 경우 
		for (i = 0; i < 41; i++) 
		if (m_cDialogBoxOrder[40 - i] != NULL) {
			cDlgID = m_cDialogBoxOrder[40 - i];
			if ((m_stDialogBoxInfo[cDlgID].sX <= msX)	&& ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) >= msX) &&
				(m_stDialogBoxInfo[cDlgID].sY <= msY)	&& ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) >= msY) ) {
				// 해당 다이얼로그 박스가 눌렸다. 선택된 요소를 선택한다.
				EnableDialogBox(cDlgID, NULL, NULL, NULL);
			
				m_stMCursor.sPrevX = msX;
				m_stMCursor.sPrevY = msY;
				m_stMCursor.sDistX = msX - m_stDialogBoxInfo[cDlgID].sX;
				m_stMCursor.sDistY = msY - m_stDialogBoxInfo[cDlgID].sY;

				// 다이얼로그 박스의 눌린 부분을 검색하여 만약 드래깅 할 경우 선택되는 오브젝트를 결정한다.
				switch (cDlgID) {
				case 1:
					// 다이얼로그 박스 23번(Sell Item)이 활성화 되어 있는 경우 아이템과 관련된 연산을 해서는 안된다!!! 
					// 캐릭터 장착화면. 장착중인 아이템을 선택했는지를 검사한다.
					if (bDlgBoxPress_Character(msX, msY) == FALSE) {
						// 아이템이 선택되지 않았다.
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					break;
								
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
								
				case 12:
				case 13:
				case 16:
				case 17:
				case 20:
				case 22:
				case 23:
				case 24:
				case 25:
				case 28:		
				case 29:
				case 30:
				case 31:
				case 32:
				case 33:
				case 34:
				case 35:
				case 36:
				case 37:
				case 38:
				// 마을 NPC에게  대화가능..^^; 20021221
				case 67:
				case 68:
				case 69:
					m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID   = cDlgID;
					break;
				
				case 2:
					// 다이얼로그 박스 23번(Sell Item)이 활성화 되어 있는 경우 아이템과 관련된 연산을 해서는 안된다!!! 
					// 아이템 순서가 뒤집혀 오류가 발생할 수 있다. 
					
					// 인벤토리의 경우 아이템이 선택되었는지를 먼저 검색해 봐야 한다.
					if (bDlgBoxPress_Inventory(msX, msY) == FALSE) {
						// 아이템이 선택되지 않았다.
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					break;
				
				case 10:
					sX = m_stDialogBoxInfo[10].sX;
					sY = m_stDialogBoxInfo[10].sY;	
					// 마우스 커서가 드래깅 포지션에 있으므로 다이얼로그 박스 드래깅에 해당되지 않는다.
					if ((msX >= sX + 340) && (msX <= sX + 360) && (msY >= sY + 22) && (msY <= sY + 138)) {
						m_stDialogBoxInfo[10].bIsScrollSelected = TRUE;
						return -1;
					}
					
					if (m_stDialogBoxInfo[10].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;	
					}
					else return -1;
					break;
				
				case 11:   
					sX = m_stDialogBoxInfo[11].sX;
					sY = m_stDialogBoxInfo[11].sY;	
					// 마우스 커서가 드래깅 포지션에 있으므로 다이얼로그 박스 드래깅에 해당되지 않는다.
					if ((m_stDialogBoxInfo[11].cMode == 0) && (msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 20) && (msY <= sY + 330)) {
						m_stDialogBoxInfo[11].bIsScrollSelected = TRUE;
						return -1;
					}
					 
					if ((m_stDialogBoxInfo[11].bIsScrollSelected == FALSE)) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;	
					} 
					else return -1;
					break;

				case 14:
					sX = m_stDialogBoxInfo[14].sX;
					sY = m_stDialogBoxInfo[14].sY;	
					// 마우스 커서가 드래깅 포지션에 있으므로 다이얼로그 박스 드래깅에 해당되지 않는다.
					if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
						m_stDialogBoxInfo[14].bIsScrollSelected = TRUE;
						return -1;
					}
					 
					if (m_stDialogBoxInfo[14].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;	
					} 
					else return -1;
					break;

				case 15:
					sX = m_stDialogBoxInfo[15].sX;
					sY = m_stDialogBoxInfo[15].sY;	
					// 마우스 커서가 드래깅 포지션에 있으므로 다이얼로그 박스 드래깅에 해당되지 않는다.
					if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
						m_stDialogBoxInfo[15].bIsScrollSelected = TRUE;
						return -1;
					}
					 
					if (m_stDialogBoxInfo[15].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;	
					} 
					else return -1;
					break;

				case 18:
					sX = m_stDialogBoxInfo[18].sX;
					sY = m_stDialogBoxInfo[18].sY;	
					// 마우스 커서가 드래깅 포지션에 있으므로 다이얼로그 박스 드래깅에 해당되지 않는다.
					if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
						m_stDialogBoxInfo[18].bIsScrollSelected = TRUE;
						return -1;
					}
					
					if (m_stDialogBoxInfo[18].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;	
					} 
					else return -1;
					break;

				case 19: 
					sX = m_stDialogBoxInfo[19].sX;
					sY = m_stDialogBoxInfo[19].sY;	
					// 마우스 커서가 드래깅 포지션에 있으므로 다이얼로그 박스 드래깅에 해당되지 않는다.
					if ((msX >= sX + 126) && (msX <= sX + 238) && (msY >= sY +122) && (msY <= sY +138)) {
						m_stDialogBoxInfo[19].bIsScrollSelected = TRUE;
						return -1;
					}
					if ((msX >= sX + 126) && (msX <= sX + 238) && (msY >= sY +139) && (msY <= sY +155)) {
						m_stDialogBoxInfo[19].bIsScrollSelected = TRUE;
						return -1;		
					}
					
					if (m_stDialogBoxInfo[19].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;	
					}
					else return -1;
					break;

				case 21:
					sX = m_stDialogBoxInfo[21].sX;
					sY = m_stDialogBoxInfo[21].sY;	
					// 마우스 커서가 드래깅 포지션에 있으므로 다이얼로그 박스 드래깅에 해당되지 않는다.
					if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
						m_stDialogBoxInfo[21].bIsScrollSelected = TRUE;
						return -1;
					}
					
					if (m_stDialogBoxInfo[21].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;	
					} 
					else return -1;
					break;
				
				case 26:
					// 스킬 다이얼로그박스의 경우 아이템이 선택되었는지를 먼저 검색해 봐야 한다.
					if (bDlgBoxPress_SkillDlg(msX, msY) == FALSE) {
						// 아이템이 선택되지 않았다.
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					break;

				case 27:
					m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID   = cDlgID;
					break;
				}

				return 1;
			}
		}

		return 0;  
	}
	else 
	if (cButtonSide == 2)
	{
		if ((dwTime - m_dwDialogCloseTime) < 300) return 0;
		// 오른쪽 버튼이 눌렸다. 다이얼로그의 경우 닫는다. 
		for (i = 0; i < 41; i++) 
		if (m_cDialogBoxOrder[40 - i] != NULL) {
			cDlgID = m_cDialogBoxOrder[40 - i];
			if ((m_stDialogBoxInfo[cDlgID].sX < msX) && ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) > msX) &&
				(m_stDialogBoxInfo[cDlgID].sY < msY) && ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) > msY) ) {
				// 해당 다이얼로그 박스가 눌렸다. 다이얼로그박스를 닫는다.
				if ((cDlgID != 5) && (cDlgID != 6) && (cDlgID != 8) && (cDlgID != 12) && ((cDlgID != 23) || (m_stDialogBoxInfo[23].cMode < 3)) && (cDlgID != 24) && (cDlgID != 27) && (cDlgID != 34) && 
					(cDlgID != 33) && !((cDlgID == 32) && ((m_stDialogBoxInfo[cDlgID].cMode == 1) || (m_stDialogBoxInfo[cDlgID].cMode == 3)))) // 8번 다이얼로그: 길드 가입/탈퇴 확인다이얼로그는 절차가 끝날때까지 없앨수 없다. 12번: Level-Up Setting    23번: Sell Item    27번: 교환창   33: 임무 선택창  32: 파티창
					DisableDialogBox(cDlgID);
				
				m_dwDialogCloseTime = dwTime;
				return 1;
			}
		}
	}
	return 0;
}


void CGame::InitItemList(char * pData)
{
 char    cTotalItems;
 int     i;
 short * sp;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;

	// 아이템 순서 배열을 초기화한다.
	for (i = 0; i < DEF_MAXITEMS; i++) 
		m_cItemOrder[i] = -1;

	// 아이템 장착상태 배열 초기화 
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
		m_sItemEquipmentStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
		m_bIsItemDisabled[i] = FALSE;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cTotalItems = *cp;
	cp++;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL) {
		delete m_pItemList[i];
		m_pItemList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pBankList[i] != NULL) {
		delete m_pBankList[i];
		m_pBankList[i] = NULL;
	}
	
	for (i = 0; i < cTotalItems; i++) {
		m_pItemList[i] = new class CItem;
		memcpy(m_pItemList[i]->m_cName, cp, 20);
		cp += 20;

		dwp = (DWORD *)cp;
		m_pItemList[i]->m_dwCount = *dwp;
		m_pItemList[i]->m_sX      =	40;
		m_pItemList[i]->m_sY      =	30;
		cp += 4;

		m_pItemList[i]->m_cItemType = *cp;
		cp++;

		m_pItemList[i]->m_cEquipPos = *cp;
		cp++;

		if( *cp == 0 ) m_bIsItemEquipped[i] = FALSE;
		else m_bIsItemEquipped[i] = TRUE;
		cp++;

		if (m_bIsItemEquipped[i] == TRUE) {
			// 만약 아이템이 장착된 상태라면 
			m_sItemEquipmentStatus[m_pItemList[i]->m_cEquipPos] = i;
		}
		sp = (short *)cp;
		m_pItemList[i]->m_sLevelLimit = *sp;
		cp += 2;

		m_pItemList[i]->m_cGenderLimit = *cp;
		cp++;
		
		wp =(WORD *)cp;
		m_pItemList[i]->m_wCurLifeSpan = *wp;
		cp += 2;

		wp =(WORD *)cp;
		m_pItemList[i]->m_wWeight = *wp;
		cp += 2;

		sp = (short *)cp;
		m_pItemList[i]->m_sSprite = *sp;
		cp += 2;

		sp = (short *)cp;
		m_pItemList[i]->m_sSpriteFrame = *sp;
		cp += 2;

		m_pItemList[i]->m_cItemColor = *cp;
		cp++;

		m_pItemList[i]->m_sItemSpecEffectValue2 = (short)*cp; // v1.41
		cp++;

		dwp = (DWORD *)cp;
		m_pItemList[i]->m_dwAttribute = *dwp;
		cp += 4;
		/*
		m_pItemList[i]->m_bIsCustomMade = (BOOL)*cp;
		cp++;
		*/
		// 아이템의 장착상태와 우선순위 정보를 설정한다.
		m_cItemOrder[i] = i;
	}

	cTotalItems = *cp;
	cp++;

	// 할당하기 전에 클리어 한다. 
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pBankList[i] != NULL) {
		delete m_pBankList[i];
		m_pBankList[i] = NULL;
	}

	for (i = 0; i < cTotalItems; i++) {
		m_pBankList[i] = new class CItem;
		memcpy(m_pBankList[i]->m_cName, cp, 20);
		cp += 20;
		
		dwp = (DWORD *)cp;
		m_pBankList[i]->m_dwCount = *dwp;
		cp += 4;

		m_pBankList[i]->m_sX = 40;
		m_pBankList[i]->m_sY = 30;

		m_pBankList[i]->m_cItemType = *cp;
		cp++;

		m_pBankList[i]->m_cEquipPos = *cp;
		cp++;

		sp = (short *)cp;
		m_pBankList[i]->m_sLevelLimit = *sp;
		cp += 2;

		m_pBankList[i]->m_cGenderLimit = *cp;
		cp++;
		
		wp =(WORD *)cp;
		m_pBankList[i]->m_wCurLifeSpan = *wp;
		cp += 2;

		wp =(WORD *)cp;
		m_pBankList[i]->m_wWeight = *wp;
		cp += 2;

		sp = (short *)cp;
		m_pBankList[i]->m_sSprite = *sp;
		cp += 2;

		sp = (short *)cp;
		m_pBankList[i]->m_sSpriteFrame = *sp;
		cp += 2;

		m_pBankList[i]->m_cItemColor = *cp;
		cp++;

		m_pBankList[i]->m_sItemSpecEffectValue2 = (short)*cp; // v1.41
		cp++;
		
		dwp = (DWORD *)cp;
		m_pBankList[i]->m_dwAttribute = *dwp;
		cp += 4;
		/*
		m_pBankList[i]->m_bIsCustomMade = (BOOL)*cp;
		cp++;
		*/
	}

	// Magic, Skill Mastery테이블을 로드한다.
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		m_cMagicMastery[i] = *cp;
		cp++;
	}

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_cSkillMastery[i] = (unsigned char)*cp;
		if (m_pSkillCfgList[i] != NULL) 
			m_pSkillCfgList[i]->m_iLevel = (int)*cp;
		cp++;
	}
}

void CGame::DrawDialogBox_GuideMap(short msX, short msY, char cLB)
{
	if( m_cMapIndex < 0 ) return;
	short sX, sY, shX, shY, szX, szY;
	sX = m_stDialogBoxInfo[9].sX;
	sY = m_stDialogBoxInfo[9].sY;
	szX = m_stDialogBoxInfo[9].sSizeX;
	szY = m_stDialogBoxInfo[9].sSizeY;
	if( sX < 20 ) sX = 0;
	if( sY < 20 ) sY = 0;
	if( sX > 640-128-20 ) sX = 640-128;
	if( sY > 427-128-20 ) sY = 427-128;
	for( shX=-2 ; shX<130 ; shX++ )
	{
		m_DDraw.PutPixel( sX+shX, sY-2  , 50,50,50);
		m_DDraw.PutPixel( sX+shX, sY-1  , 50,50,50);
		m_DDraw.PutPixel( sX+shX, sY+128, 50,50,50);
		m_DDraw.PutPixel( sX+shX, sY+129, 50,50,50);
	}
	for( shY=-2 ; shY<130 ; shY++ )
	{
		m_DDraw.PutPixel( sX-2  , sY+shY, 50,50,50);
		m_DDraw.PutPixel( sX-1  , sY+shY, 50,50,50);
		m_DDraw.PutPixel( sX+128, sY+shY, 50,50,50);
		m_DDraw.PutPixel( sX+129, sY+shY, 50,50,50);
	}
	if( m_bZoomMap )
	{
		shX = m_sPlayerX-64;
		shY = m_sPlayerY-64;
		if( shX < 0 ) shX = 0;
		if( shY < 0 ) shY = 0;
		if( shX > m_pMapData->m_sMapSizeX-128 ) shX = m_pMapData->m_sMapSizeX-128;
		if( shY > m_pMapData->m_sMapSizeY-128 ) shY = m_pMapData->m_sMapSizeY-128;
		if (m_bDialogTrans) m_pSprite[DEF_SPRID_INTERFACE_GUIDEMAP+m_cMapIndex+1]->PutShiftTransSprite2(sX, sY, shX, shY, 0, m_dwCurTime );
		else m_pSprite[DEF_SPRID_INTERFACE_GUIDEMAP+m_cMapIndex+1]->PutShiftSpriteFast(sX, sY, shX, shY, 0, m_dwCurTime );
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX - shX + m_sPlayerX, sY - shY + m_sPlayerY, 37, m_dwCurTime); //위치 보여주는 파란점..
		//v2.2 안상하 추가 몬스터 이벤트 보여주기용.
		if( (m_dwCurTime - m_dwMonsterEventTime) < 30000 )
		{
			if( (m_dwCurTime%500)< 370 )
			{
				if( m_sEventX >= shX && m_sEventX <= shX+128 && m_sEventY >= shY && m_sEventY <= shY+128 )
					m_pSprite[DEF_SPRID_INTERFACE_MONSTER]->PutSpriteFast(sX + m_sEventX - shX, sY + m_sEventY -shY, m_sMonsterID, m_dwCurTime);
			}
		}
		else
		{
			m_dwMonsterEventTime = 0;
			m_sMonsterID = 0;
		}
	}
	else
	{
		if (m_bDialogTrans) m_pSprite[DEF_SPRID_INTERFACE_GUIDEMAP]->PutTransSprite2(sX, sY, m_cMapIndex, m_dwCurTime);
		else m_pSprite[DEF_SPRID_INTERFACE_GUIDEMAP]->PutSpriteFastNoColorKey(sX, sY, m_cMapIndex, m_dwCurTime);
		shX = (m_sPlayerX*128)/(m_pMapData->m_sMapSizeX);
		shY = (m_sPlayerY*128)/(m_pMapData->m_sMapSizeX);
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + shX, sY + shY, 37, m_dwCurTime); //위치 보여주는 파란점..

		if( (G_dwGlobalTime - m_dwMonsterEventTime) < 30000 )
		{
			if( (m_dwCurTime%500)< 370 )
			{
				shX = (m_sEventX*128)/(m_pMapData->m_sMapSizeX);
				shY = (m_sEventY*128)/(m_pMapData->m_sMapSizeX);
				m_pSprite[DEF_SPRID_INTERFACE_MONSTER]->PutSpriteFast(sX + shX, sY + shY, m_sMonsterID, m_dwCurTime);
			}
		}
		else
		{
			m_dwMonsterEventTime = 0;
			m_sMonsterID = 0;
		}
	}

	if( cLB != 0 ) return;
	if( msX >= sX && msX < sX+szY && msY >= sY && msY < sY+szY )
	{
		if( sY > 213 ) shY = sY - 17;
		else shY = sY + szY + 4;
		if( m_bZoomMap ) PutString( sX, shY, DEF_MSG_GUIDEMAP_MIN, RGB(200, 200, 120) );//"(-) : 전체맵 축소모드"
		else PutString( sX, shY, DEF_MSG_GUIDEMAP_MAX, RGB(200, 200, 120) );//"(+) : 주변맵 확대모드"

		if( m_bZoomMap )
		{
			shX = m_sPlayerX-64;
			shY = m_sPlayerY-64;
			if( shX < 0 ) shX = 0;
			if( shY < 0 ) shY = 0;
			if( shX > m_pMapData->m_sMapSizeX-128 ) shX = m_pMapData->m_sMapSizeX-128;
			if( shY > m_pMapData->m_sMapSizeY-128 ) shY = m_pMapData->m_sMapSizeY-128;
			shX += msX - sX;
			shY += msY - sY;
		}
		else
		{
			shX = (msX-sX)*m_pMapData->m_sMapSizeX/128;
			shY = (msY-sY)*m_pMapData->m_sMapSizeX/128;
		}
		wsprintf( G_cTxt, "%d, %d", shX, shY );
		if( m_cMapIndex == 11 ) // 아레스덴
		{
			if( shX > 165 && shX < 225 && shY > 136 && shY < 175 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_CITYHALL );//"시청"
			else if( shX >  47 && shX <  76 && shY > 134 && shY < 165 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_MAGICTOWER );
			else if( shX >  99 && shX < 124 && shY > 204 && shY < 227 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_DUNGEON );
			else if( shX > 125 && shX < 157 && shY > 185 && shY < 218 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 147 && shX < 184 && shY >  65 && shY <  97 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BARRACK );
			else if( shX > 155 && shX < 185 && shY > 110 && shY < 136 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_GUILDHALL );
			else if( shX > 166 && shX < 193 && shY > 185 && shY < 211 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_SHOP );
			else if( shX > 175 && shX < 202 && shY >  97 && shY < 120 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_DUNGEON );
			else if( shX > 201 && shX < 229 && shY > 220 && shY < 245 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BLACKSMITH );
			else if( shX > 205 && shX < 249 && shY >  98 && shY < 140 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_CATH );
			else if( shX > 262 && shX < 290 && shY > 148 && shY < 178 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
		}
		else if( m_cMapIndex == 3 ) //엘바인
		{
			if( shX >  77 && shX < 114 && shY >  81 && shY < 114 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_MAGICTOWER );
			else if( shX >  88 && shX < 120 && shY > 151 && shY < 183 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_GUILDHALL );
			else if( shX > 126 && shX < 171 && shY >  97 && shY < 141 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_CATH );
			else if( shX > 157 && shX < 194 && shY > 150 && shY < 190 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_CITYHALL );
			else if( shX > 171 && shX < 207 && shY >  76 && shY < 107 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BARRACK );
			else if( shX > 207 && shX < 231 && shY >  99 && shY < 124 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_DUNGEON );
			else if( shX > 247 && shX < 277 && shY > 139 && shY < 170 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 237 && shX < 270 && shY > 225 && shY < 258 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 258 && shX < 287 && shY > 109 && shY < 137 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_SHOP );
			else if( shX > 302 && shX < 333 && shY > 147 && shY < 175 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BLACKSMITH );
			else if( shX > 301 && shX < 330 && shY > 239 && shY < 265 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_DUNGEON );
		}
		else if( m_cMapIndex == 5 ) //엘바인 농경지
		{
			if( shX >  62 && shX < 78 && shY >  178 && shY < 192 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 82 && shX < 95 && shY > 163 && shY < 174 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_SHOP );
			else if( shX > 107 && shX < 122 && shY > 177 && shY < 189 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BLACKSMITH );
		}
		else if( m_cMapIndex == 6 ) // 아레스덴 농경지
		{
			if( shX >  35 && shX < 48 && shY >  70 && shY < 85 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 55 && shX < 73 && shY > 77 && shY < 90 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BLACKSMITH );
			else if( shX > 53 && shX < 66 && shY > 53 && shY < 65 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_SHOP );
		}
		PutString( msX-10, msY-13, G_cTxt, RGB(200, 200, 120) );
	}
}

void CGame::DrawDialogBoxs(short msX, short msY, short msZ, char cLB)
{
 int i;

	// v1.41 관람 모드에서는 다이얼로그 박스를 그리지 않는다. 
	if (m_bIsObserverMode == TRUE) return;
	m_DInput.m_sZ = 0;

	for (i = 0; i < 41; i++) 
	if (m_cDialogBoxOrder[i] != NULL) {
		// 뒤에있는 순서대로 다이얼로그 박스를 그린다.
		switch (m_cDialogBoxOrder[i]) {
		case 1:
			DrawDialogBox_Character(msX, msY); //@@@
			break;
		case 2:
			DrawDialogBox_Inventory(msX, msY); //@@@
			break; 
		case 3:
			DrawDialogBox_Magic(msX, msY, msZ); //@@@
			break;
		case 4:
			DrawDialogBox_ItemDrop(msX, msY); //@@@
			break;
		case 5:
			DrawDialogBox_15AgeMsg(msX, msY); //@@@
			break;
		case 6:
			DrawDialogBox_WarningMsg(msX, msY); //@@@
			break;
		case 7:
			DrawDialogBox_GuildMenu(msX, msY); 
			break;
		case 8:
			DrawDialogBox_GuildOperation(msX, msY);
			break;
		case 9:
			DrawDialogBox_GuideMap(msX, msY, cLB); 
			break;
		case 10:
			DrawDialogBox_Chat(msX, msY, msZ, cLB); //@@@
			break;
		case 11:
			DrawDialogBox_Shop(msX, msY, msZ, cLB); //@@@
			break;
		case 12:
			DrawDialogBox_LevelUpSetting(msX, msY); //@@@
			break;
		case 13:
			DrawDialogBox_CityHallMenu(msX, msY);
			break;
		case 14:
			DrawDialogBox_Bank(msX, msY, msZ, cLB); //@@@
			break;
		case 15:
			DrawDialogBox_Skill(msX, msY, msZ, cLB); //@@@
			break;
		case 16:
			DrawDialogBox_MagicShop(msX, msY, msZ); //@@@
			break;
		case 17:
			DrawDialogBox_QueryDropItemAmount();
			break;
		case 18:
			DrawDialogBox_Text(msX, msY, msZ, cLB); //@@@
			break;
		case 19:
			DrawDialogBox_SysMenu(msX, msY, cLB); //@@@
			break;
		case 20:
			DrawDialogBox_NpcActionQuery(msX, msY); //@@@
			break;
		case 21:
			DrawDialogBox_NpcTalk(msX, msY, cLB); //@@@
			break;
		case 22:
			DrawDialogBox_Map();
			break;
		case 23:
			DrawDialogBox_SellorRepairItem(msX, msY); //@@@
			break;
		case 24:
			DrawDialogBox_Fishing(msX, msY); 
			break;
		case 25:
			DrawDialogBox_ShutDownMsg(msX, msY); //@@@
			break; 
		case 26:
			DrawDialogBox_SkillDlg(msX, msY, msZ, cLB); 
			break; 
		case 27: 
			DrawDialogBox_Exchange(msX, msY); //@@@
			break;
		case 28:
			DrawDialogBox_Quest(msX, msY); //@@@
			break;
		case 29:
			DrawDialogBox_GaugePannel(); //@@@
			break; 
		case 30:
			DrawDialogBox_IconPannel(msX, msY); //@@@
			break;
		case 31:
			DrawDialogBox_SellList(msX, msY); //@@@
			break;
		case 32: 
			DrawDialogBox_Party(msX, msY); //@@@
			break;
		case 33:
			DrawDialogBox_CrusadeJob(msX, msY); //@@@
			break;
		case 34:
			DrawDialogBox_ItemUpgrade(msX, msY);
			break;
		case 35:
			DrawDialogBox_Help(msX, msY); //@@@
			break;
		case 36:
			DrawDialogBox_Commander(msX, msY); //@@@
			break;
		case 37:
			DrawDialogBox_Constructor(msX, msY); //@@@
			break;
		case 38:
			DrawDialogBox_Soldier(msX, msY); //@@@
			break;
		}
	}
	
	if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) { 
		// 필살기 아이콘 
		if (m_iSuperAttackLeft > 0) {
			if (GetAsyncKeyState(VK_MENU)>>15)
				m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutTransSprite(368, 439, 3, m_dwCurTime);
		
			wsprintf(G_cTxt, "%d", m_iSuperAttackLeft);
			PutString_SprFont2(380, 454, G_cTxt, 220, 200, 200);
		}
	}
	else {
		if (m_iSuperAttackLeft > 0) {
			wsprintf(G_cTxt, "%d", m_iSuperAttackLeft);
			PutString_SprFont2(380, 454, G_cTxt, 10, 10, 10);
		}
	}
}

void CGame::_Draw_CharacterBody(short sX, short sY, short sType)
{
 DWORD dwTime = m_dwCurTime;
 int  iR, iG, iB;
	
	if (sType <= 3)	{
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0]->PutSpriteFast(sX, sY,  sType-1, dwTime);
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18]->PutSpriteRGB(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, iR, iG, iB, dwTime);

		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19]->PutSpriteFast(sX, sY, (_tmp_sAppr1 & 0x000F), dwTime);
	}
	else {
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40]->PutSpriteFast(sX, sY, sType-4, dwTime);
		
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18 +40]->PutSpriteRGB(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, iR, iG, iB, dwTime);

		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19 +40]->PutSpriteFast(sX, sY, (_tmp_sAppr1 & 0x000F), dwTime);
	}
}


void CGame::EnableDialogBox(int iBoxID, int cType, int sV1, int sV2, char * pString)
{
 int i;
 short sX, sY;

	switch (iBoxID) {
	case 11:
		if (m_bIsDialogEnabled[11] == FALSE) {
			// 내용을 로딩한다.
			switch (cType) {
			case NULL:
				break;
			default:
				// 해당 메뉴 번호의 내용을 로드한다. 
				_LoadShopMenuContents(cType);
				m_stDialogBoxInfo[11].sV1 = cType;
				m_stDialogBoxInfo[11].cMode	= 0;
				m_stDialogBoxInfo[11].sView = 0;
				m_stDialogBoxInfo[11].bFlag = TRUE;
				m_stDialogBoxInfo[11].sV3   = 1; // 구매하는 수량 
				break;
			}
		}
		break;

	case 12:
		if (m_bIsDialogEnabled[12] == FALSE) {
			m_stDialogBoxInfo[12].sX = m_stDialogBoxInfo[1].sX + 20;
			m_stDialogBoxInfo[12].sY = m_stDialogBoxInfo[1].sY + 20;
		}
		break;

	case 3:
		// Magic Dialog의 경우 변경시키지 않는다.
		break;
  
	case 4:
		if (m_bIsDialogEnabled[4] == FALSE) {
			m_stDialogBoxInfo[4].sView = cType;
		}
		break;

	case 5:
		if (m_bIsDialogEnabled[5] == FALSE) {
			m_stDialogBoxInfo[5].sView = cType;
		}
		break;

	case 6:
		if (m_bIsDialogEnabled[6] == FALSE) {
			m_stDialogBoxInfo[6].sView = cType;
		}
		break;

	case 7:
		if (m_stDialogBoxInfo[7].cMode == 1) {
			sX = m_stDialogBoxInfo[7].sX;
			sY = m_stDialogBoxInfo[7].sY;
			EndInputString();
			StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
		}
		break;

	case 17:
		// 수량을 묻는 다이얼로그 박스 
		if (m_bIsDialogEnabled[17] == FALSE) {
			m_stDialogBoxInfo[iBoxID].cMode = 1;
			m_stDialogBoxInfo[17].sView	= cType; // 수량을 Query중인 아이템 인덱스 번호 	
			EndInputString();
			ZeroMemory(m_cAmountString, sizeof(m_cAmountString));
			wsprintf( m_cAmountString, "%d", sV1 );
			
			sX = m_stDialogBoxInfo[17].sX;
			sY = m_stDialogBoxInfo[17].sY;
			StartInputString(sX + 40, sY + 57, 11, m_cAmountString, FALSE);
		}
		else {
			// 이미 활성화 되어 있었고 
			if (m_stDialogBoxInfo[17].cMode == 1) {
				// 입력 중이었다면 입력 포커스를 다시 활성화한다.
				sX = m_stDialogBoxInfo[17].sX;
				sY = m_stDialogBoxInfo[17].sY;
				EndInputString();
				StartInputString(sX + 40, sY + 57, 11, m_cAmountString, FALSE);
			}
		}
		break;

	case 18:
		if (m_bIsDialogEnabled[18] == FALSE) {
			// 처음 활성화 되는 것이라면 텍스트 내용을 로드한다.	
			switch (cType) { 
			case NULL:
				m_stDialogBoxInfo[18].cMode	= 0;
				m_stDialogBoxInfo[18].sView = 0;
				break;
			default:
				// 해당 메뉴 번호의 내용을 로드한다. 
				_LoadTextDlgContents(cType);
				m_stDialogBoxInfo[18].cMode	= 0;
				m_stDialogBoxInfo[18].sView = 0;
				break;
			}
		} 
		break;   

	case 19:
		break;

	case 20:
		// v1.41
		m_bIsItemDisabled[m_stDialogBoxInfo[20].sV1] = FALSE;

		if (m_bIsDialogEnabled[20] == FALSE) {
			m_stDialogBoxInfo[11].sV1 = m_stDialogBoxInfo[11].sV2 = m_stDialogBoxInfo[11].sV3 = 
				m_stDialogBoxInfo[11].sV4 = m_stDialogBoxInfo[11].sV5 = m_stDialogBoxInfo[11].sV6 = NULL;

			m_stDialogBoxInfo[20].cMode	= cType;
			m_stDialogBoxInfo[20].sView = 0;
			m_stDialogBoxInfo[20].sV1 = sV1;
			m_stDialogBoxInfo[20].sV2 = sV2;
		}
		break;

	case 21:
		if (m_bIsDialogEnabled[21] == FALSE) {
			m_stDialogBoxInfo[21].cMode	= cType;
			m_stDialogBoxInfo[21].sView = 0;
			
			// 해당 메뉴 번호의 내용을 로드한다. 로드한 후 인덱스를 저장. 
			m_stDialogBoxInfo[21].sV1 = _iLoadTextDlgContents2(sV1+20);
			m_stDialogBoxInfo[21].sV2 = sV1+20;
		}
		break;

	case 22:
		if (m_bIsDialogEnabled[22] == FALSE) {
			m_stDialogBoxInfo[22].sV1 = sV1;
			m_stDialogBoxInfo[22].sV2 = sV2;

			m_stDialogBoxInfo[22].sSizeX = 290;
			m_stDialogBoxInfo[22].sSizeY = 290;
		}
		break;

	case 23:
		if (m_bIsDialogEnabled[23] == FALSE) {
			m_stDialogBoxInfo[23].cMode	= cType;
			m_stDialogBoxInfo[23].sV1   = sV1;		// ItemID
			m_stDialogBoxInfo[23].sV2   = sV2;
			if( cType == 2 )
			{
				m_stDialogBoxInfo[23].sX = m_stDialogBoxInfo[11].sX;
				m_stDialogBoxInfo[23].sY = m_stDialogBoxInfo[11].sY;
			}
		}
		break;

	case 15:
		break;

	case 24:
		if (m_bIsDialogEnabled[24] == FALSE) {
			m_stDialogBoxInfo[24].cMode	= cType;
			m_stDialogBoxInfo[24].sV1   = sV1;		
			m_stDialogBoxInfo[24].sV2   = sV2;
			// 낚시창이 떠있다는 것 자체가 스킬을 사용하고 있다는 의미이므로 
			m_bSkillUsingStatus = TRUE;
		}
		break;

	case 25:
		if (m_bIsDialogEnabled[25] == FALSE) {
			m_stDialogBoxInfo[25].cMode	= cType;
			m_stDialogBoxInfo[25].sV1   = sV1;		
			m_stDialogBoxInfo[25].sV2   = sV2;
		}
		break;

	case 26:
		switch (cType) {
		case 1:
		case 2:
			// 연금술 창 
			if (m_bIsDialogEnabled[26] == FALSE) {
				m_stDialogBoxInfo[26].cMode	= cType;
				m_stDialogBoxInfo[26].sV1   = -1;		
				m_stDialogBoxInfo[26].sV2   = -1;
				m_stDialogBoxInfo[26].sV3   = -1;
				m_stDialogBoxInfo[26].sV4   = -1;
				m_stDialogBoxInfo[26].sV5   = -1;
				m_stDialogBoxInfo[26].sV6   = -1;
				m_stDialogBoxInfo[26].cStr[0] = 0;
				// 연금술 창이 떠있다는 것 자체가 스킬을 사용하고 있다는 의미이므로 
				m_bSkillUsingStatus = TRUE;

				// 연금창의 사이즈를 설정 
				m_stDialogBoxInfo[26].sSizeX = 195;
				m_stDialogBoxInfo[26].sSizeY = 215;

				// 이 창이 열리면 닫혀야 하는 다이얼로그 
				DisableDialogBox(17);
				DisableDialogBox(20);
				DisableDialogBox(23);
			}
			break;

		case 3:
			// 무기제작 창 
			if (m_bIsDialogEnabled[26] == FALSE) {
				m_stDialogBoxInfo[26].sView = 0;
				m_stDialogBoxInfo[26].cMode	= cType;
				m_stDialogBoxInfo[26].sV1   = -1;		
				m_stDialogBoxInfo[26].sV2   = -1;
				m_stDialogBoxInfo[26].sV3   = -1;
				m_stDialogBoxInfo[26].sV4   = -1;
				m_stDialogBoxInfo[26].sV5   = -1;
				m_stDialogBoxInfo[26].sV6   = -1;
				m_stDialogBoxInfo[26].cStr[0] = 0;
				m_stDialogBoxInfo[26].cStr[1] = 0;
				m_stDialogBoxInfo[26].cStr[4] = 0;
				
				// 무기 제작 창이 떠있다는 것 자체가 스킬을 사용하고 있다는 의미이므로 
				m_bSkillUsingStatus = TRUE;
				_bCheckBuildItemStatus();

				// 무기 제작 창의 위치와 사이즈를 설정 
				//m_stDialogBoxInfo[26].sX = 0;
				//m_stDialogBoxInfo[26].sY = 0;
				
				m_stDialogBoxInfo[26].sSizeX = 270;
				m_stDialogBoxInfo[26].sSizeY = 381;

				DisableDialogBox(17);
				DisableDialogBox(20);
				DisableDialogBox(23);
			}
			break;

		case 6:
			if (m_bIsDialogEnabled[26] == FALSE) {
				// 무기 제작 결과 
				m_stDialogBoxInfo[26].cMode	= cType;

				m_stDialogBoxInfo[26].cStr[2] = sV1;
				m_stDialogBoxInfo[26].cStr[3] = sV2;

				m_stDialogBoxInfo[26].sSizeX = 270;
				m_stDialogBoxInfo[26].sSizeY = 381;

				m_bSkillUsingStatus = TRUE;
				_bCheckBuildItemStatus();

				DisableDialogBox(17);
				DisableDialogBox(20);
				DisableDialogBox(23);
			}
			break;
		}
		break;

	case 27:
		if (m_bIsDialogEnabled[27] == FALSE) {
			m_stDialogBoxInfo[27].cMode = cType;
			ZeroMemory(m_stDialogBoxInfo[27].cStr, sizeof(m_stDialogBoxInfo[27].cStr));
			ZeroMemory(m_stDialogBoxInfo[27].cStr2, sizeof(m_stDialogBoxInfo[27].cStr2));
			ZeroMemory(m_stDialogBoxInfo[27].cStr3, sizeof(m_stDialogBoxInfo[27].cStr3));
			ZeroMemory(m_stDialogBoxInfo[27].cStr4, sizeof(m_stDialogBoxInfo[27].cStr4));
			m_stDialogBoxInfo[27].sV1   = -1;		
			m_stDialogBoxInfo[27].sV2   = -1;
			m_stDialogBoxInfo[27].sV3   = -1;
			m_stDialogBoxInfo[27].sV4   = -1;
			m_stDialogBoxInfo[27].sV5   = -1;
			m_stDialogBoxInfo[27].sV6   = -1;
			m_stDialogBoxInfo[27].sV7   = -1;
			m_stDialogBoxInfo[27].sV8   = -1;
			m_stDialogBoxInfo[27].sV9   = -1;
			m_stDialogBoxInfo[27].sV10   = -1;
			m_stDialogBoxInfo[27].sV11   = -1;
			m_stDialogBoxInfo[27].sV12   = -1;
			m_stDialogBoxInfo[27].sV13   = -1;
			m_stDialogBoxInfo[27].sV14   = -1;
			m_stDialogBoxInfo[27].dwV1   = 0;
			m_stDialogBoxInfo[27].dwV2   = 0;

			// 닫혀야 할 다이얼로그 
			DisableDialogBox(17);
			DisableDialogBox(20);
			DisableDialogBox(23);
			DisableDialogBox(26);
		} 
		break;

	case 28:   
		if (m_bIsDialogEnabled[28] == FALSE) {
			m_stDialogBoxInfo[28].cMode = cType;
			m_stDialogBoxInfo[28].sX = m_stDialogBoxInfo[1].sX + 20;
			m_stDialogBoxInfo[28].sY = m_stDialogBoxInfo[1].sY + 20;
		}
		break;

	case 32:
		if (m_bIsDialogEnabled[32] == FALSE) {
			m_stDialogBoxInfo[32].cMode = cType;
			m_stDialogBoxInfo[32].sX = m_stDialogBoxInfo[1].sX + 20;
			m_stDialogBoxInfo[32].sY = m_stDialogBoxInfo[1].sY + 20;
		}
		break;

	case 33: 
		// 크루세이드 역할 : 중립이거나 죽어있는 상태라면 안띄움.
		 if ((m_iHP <= 0) || (m_bCitizen==FALSE)) return;

		if (m_bIsDialogEnabled[33] == FALSE) {
			m_stDialogBoxInfo[33].cMode = cType;
			m_stDialogBoxInfo[33].sX  = 360;
			m_stDialogBoxInfo[33].sY  = 65;
			m_stDialogBoxInfo[33].sV1 = sV1;
		}
		break;

	case 34:
#ifdef DEF_GIZON
		if (m_bIsDialogEnabled[34] == FALSE) {
			m_stDialogBoxInfo[34].cMode = cType;
			m_stDialogBoxInfo[34].sV1  = -1;
			m_stDialogBoxInfo[34].dwV1 = NULL;
		}
#else
		if (m_bIsDialogEnabled[34] == FALSE) {
			int iSoX, iSoM;	
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pItemList[i] != NULL) {
				if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 128)) iSoX++;
				if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 129)) iSoM++;
			}
						
			if ((iSoX > 0) || (iSoM > 0)) {
				// 조건 만족
				m_stDialogBoxInfo[34].cMode = 6;
				m_stDialogBoxInfo[34].sV2 = iSoX;
				m_stDialogBoxInfo[34].sV3 = iSoM;
				m_stDialogBoxInfo[34].sV1  = -1;
				m_stDialogBoxInfo[34].dwV1 = NULL;
			}
			else {
				AddEventList(DRAW_DIALOGBOX_ITEMUPGRADE30, 10);
				return;
			}
		}
#endif
		break;

	case 16:
		// 마법 타워
		if (m_bIsDialogEnabled[iBoxID]  == FALSE) {
			if (m_cSkillMastery[4] == 0) {
				// 마법 능력이 0인경우는 대화창을 연다. 그 대화창이 닫힐때 마법 능력을 20%로 올려달라는 요구를 할 것임.
				 DisableDialogBox(16);
				 EnableDialogBox(21, 0, 480, 0); 
				 return;
			}
			else {
				m_stDialogBoxInfo[iBoxID].cMode = 0;
				m_stDialogBoxInfo[iBoxID].sView = 0;
			}
		}
		break;

	case 14:
		EndInputString();
		if (m_bIsDialogEnabled[iBoxID]  == FALSE) {
			m_stDialogBoxInfo[iBoxID].cMode	= 0;
			m_stDialogBoxInfo[iBoxID].sView = 0;
			EnableDialogBox(2, NULL, NULL, NULL);
		}
		break;

	default:
		EndInputString();
		if (m_bIsDialogEnabled[iBoxID]  == FALSE) {
			m_stDialogBoxInfo[iBoxID].cMode	= 0;
			m_stDialogBoxInfo[iBoxID].sView = 0;
		}
		break;
	}

	if( iBoxID != 30 ) {
		if (m_bIsDialogEnabled[iBoxID]  == FALSE) {
			if( m_stDialogBoxInfo[iBoxID].sY > 400 ) m_stDialogBoxInfo[iBoxID].sY = 410;
			if( m_stDialogBoxInfo[iBoxID].sX > 620 ) m_stDialogBoxInfo[iBoxID].sX = 620;
			if( (m_stDialogBoxInfo[iBoxID].sX+m_stDialogBoxInfo[iBoxID].sSizeX) < 10 ) m_stDialogBoxInfo[iBoxID].sX += 20;
			if( (m_stDialogBoxInfo[iBoxID].sY+m_stDialogBoxInfo[iBoxID].sSizeY) < 10 ) m_stDialogBoxInfo[iBoxID].sY += 20;
		}
	}
	m_bIsDialogEnabled[iBoxID] = TRUE;
	if (pString != NULL) strcpy(m_stDialogBoxInfo[iBoxID].cStr, pString);
	for (i = 0; i < 39; i++)
	if (m_cDialogBoxOrder[i] == iBoxID) m_cDialogBoxOrder[i] = NULL;

	for (i = 1; i < 39; i++)
	if ((m_cDialogBoxOrder[i-1] == NULL) && (m_cDialogBoxOrder[i] != NULL)) {
		m_cDialogBoxOrder[i-1] = m_cDialogBoxOrder[i];	
		m_cDialogBoxOrder[i] = NULL;
	}

	for (i = 0; i < 39; i++)
	if (m_cDialogBoxOrder[i] == NULL) {
		m_cDialogBoxOrder[i] = iBoxID;
		return;
	}
}

void CGame::DisableDialogBox(int iBoxID)
{
 int i;
	
	switch (iBoxID) {
	case 4:
		m_bIsItemDisabled[m_stDialogBoxInfo[4].sView] = FALSE;
		break;
	
	case 5:
		m_bIsItemDisabled[m_stDialogBoxInfo[5].sView] = FALSE;
		break;

	case 6:
		m_bIsItemDisabled[m_stDialogBoxInfo[6].sView] = FALSE;
		break;

	case 7:
		if (m_stDialogBoxInfo[7].cMode == 1)
			EndInputString();
		m_stDialogBoxInfo[7].cMode = 0;
		break;
	
	case 11:
		for (i = 0; i < DEF_MAXMENUITEMS; i++) 
		if (m_pItemForSaleList[i] != NULL) {
			delete m_pItemForSaleList[i];
			m_pItemForSaleList[i] = NULL;
		}
		m_stDialogBoxInfo[39].sV3 = 0;
		m_stDialogBoxInfo[39].sV4 = 0; // v1.4
		m_stDialogBoxInfo[39].sV5 = 0;
		m_stDialogBoxInfo[39].sV6 = 0;
		break;

	case 14:
		// 아이템 반환중이라면 다이얼로그 박스를 닫을 수 없다. 
		if (m_stDialogBoxInfo[14].cMode < 0) return;
		break;

	case 17:
		if (m_stDialogBoxInfo[17].cMode == 1) {
			EndInputString();
			m_bIsItemDisabled[m_stDialogBoxInfo[17].sView] = FALSE;
		}
		break;

	case 20: // v1.4
		m_bIsItemDisabled[m_stDialogBoxInfo[20].sV1] = FALSE;
		break;

	case 21:
		if (m_stDialogBoxInfo[21].sV2 == 500) {
			// 마법을 배우는 창이다.
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GETMAGICABILITY, NULL, NULL, NULL, NULL, NULL); 
		}
		break;

	case 24:
		// 낚시창이 닫힘과 동시에 기술 사용이 끝난것으로 간주 
		m_bSkillUsingStatus = FALSE;
		break;

	case 26:
		// 아이템 제작이나 포션제작용 다이얼로그. 
		if (m_stDialogBoxInfo[26].sV1 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV1] = FALSE;
		if (m_stDialogBoxInfo[26].sV2 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV2] = FALSE;
		if (m_stDialogBoxInfo[26].sV3 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV3] = FALSE;
		if (m_stDialogBoxInfo[26].sV4 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV4] = FALSE;
		if (m_stDialogBoxInfo[26].sV5 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV5] = FALSE;
		if (m_stDialogBoxInfo[26].sV6 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV6] = FALSE;
		
		// 연금술 창이 닫힘과 동시에 기술 사용이 끝난것으로 간주 
		m_bSkillUsingStatus = FALSE;
		break;

	case 27:
		ZeroMemory(m_stDialogBoxInfo[27].cStr, sizeof(m_stDialogBoxInfo[27].cStr));
		ZeroMemory(m_stDialogBoxInfo[27].cStr2, sizeof(m_stDialogBoxInfo[27].cStr2));
		ZeroMemory(m_stDialogBoxInfo[27].cStr3, sizeof(m_stDialogBoxInfo[27].cStr3));
		ZeroMemory(m_stDialogBoxInfo[27].cStr4, sizeof(m_stDialogBoxInfo[27].cStr4));
		m_stDialogBoxInfo[27].sV1   = -1;		
		m_stDialogBoxInfo[27].sV2   = -1;
		m_stDialogBoxInfo[27].sV3   = -1;
		m_stDialogBoxInfo[27].sV4   = -1;
		m_stDialogBoxInfo[27].sV5   = -1;
		m_stDialogBoxInfo[27].sV6   = -1;
		m_stDialogBoxInfo[27].sV9   = -1;
		m_stDialogBoxInfo[27].sV10   = -1;
		m_stDialogBoxInfo[27].sV11   = -1;
		m_stDialogBoxInfo[27].sV12   = -1;
		m_stDialogBoxInfo[27].sV13   = -1;
		m_stDialogBoxInfo[27].sV14   = -1;
		m_stDialogBoxInfo[27].dwV1   = 0;
		m_stDialogBoxInfo[27].dwV2   = 0;

		m_bIsItemDisabled[m_stDialogBoxInfo[27].sView] = FALSE;
		break;

	case 31:
		// 비활성화 되었던 아이템 활성화
		for (i = 0; i < DEF_MAXSELLLIST; i++)
		{
			if (m_stSellItemList[i].iIndex != -1) m_bIsItemDisabled[m_stSellItemList[i].iIndex] = FALSE;
			m_stSellItemList[i].iIndex = -1;
			m_stSellItemList[i].iAmount = 0;
		}
		break;

	case 34:
		if(m_stDialogBoxInfo[34].sV1 != -1)
		m_bIsItemDisabled[m_stDialogBoxInfo[34].sV1] = FALSE;		
		break;

 	}

	m_bIsDialogEnabled[iBoxID] = FALSE;	

	for (i = 0; i < 39; i++)	
	if (m_cDialogBoxOrder[i] == iBoxID)
		m_cDialogBoxOrder[i] = NULL;

	for (i = 1; i < 39; i++)
	if ((m_cDialogBoxOrder[i-1] == NULL) && (m_cDialogBoxOrder[i] != NULL)) {
		m_cDialogBoxOrder[i-1] = m_cDialogBoxOrder[i];	
		m_cDialogBoxOrder[i] = NULL;
	}
}


int CGame::iGetTopDialogBoxIndex()
{
 int i;				   

	for (i = 38; i >= 0; i--)	
	if (m_cDialogBoxOrder[i] != NULL)
		return m_cDialogBoxOrder[i];

	return NULL;
}

void CGame::DlgBoxClick_IconPannel(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[30].sX;
	sY = m_stDialogBoxInfo[30].sY;

	if ((msX > 322)	&& (msX < 355) && (434 < msY) && (475 > msY)) {
		// Crusade 기능 토글
		if (m_bIsCrusadeMode == FALSE) return;
		switch (m_iCrusadeDuty) {
		case 1: // Fighter
			EnableDialogBox(38, NULL, NULL, NULL);
			break;

		case 2: // Constructor
			EnableDialogBox(37, NULL, NULL, NULL);
			break;

		case 3: // Commander
			EnableDialogBox(36, NULL, NULL, NULL);
			break;

		default: break;
		}
		PlaySound('E', 14, 5);
	}

	if ((362 < msX)	&& (404 > msX) && (434 < msY) && (475 > msY)) {
		// Combat Mode Toggle
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, NULL, NULL, NULL, NULL, NULL); 
		PlaySound('E', 14, 5);
	}

	// Character
	if ((413 <= msX) && (446 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[1] == TRUE)
			 DisableDialogBox(1);	
		else EnableDialogBox(1, NULL, NULL, NULL);	
		PlaySound('E', 14, 5);
	}

	// Inventory
	if ((453 <= msX) && (486 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[2] == TRUE)
			 DisableDialogBox(2);	
		else EnableDialogBox(2, NULL, NULL, NULL);	
		PlaySound('E', 14, 5);
	}

	// Magic
	if ((490 <= msX) && (522 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[3] == TRUE)
			 DisableDialogBox(3);	
		else EnableDialogBox(3, NULL, NULL, NULL);	
		PlaySound('E', 14, 5);
	}

	// Skill
	if ((526 <= msX) && (552 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[15] == TRUE)
			 DisableDialogBox(15);	
		else EnableDialogBox(15, NULL, NULL, NULL);	
		PlaySound('E', 14, 5);
	}
	
	// Chat
	if ((556 <= msX) && (587 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[10] == TRUE)
			 DisableDialogBox(10);	
		else EnableDialogBox(10, NULL, NULL, NULL);	
		PlaySound('E', 14, 5);
	}

	// System Menu
	if ((589 <= msX) && (621 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[19] == TRUE)
			 DisableDialogBox(19);	
		else EnableDialogBox(19, NULL, NULL, NULL);	
		PlaySound('E', 14, 5);
	}
}



void CGame::DrawChatMsgs(short sX, short sY, short dX, short dY)
{
 int i;

	for (i = 0; i < DEF_MAXCHATMSGS; i++)
	if (m_pChatMsgList[i] != NULL)
	if ( (m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
	     (m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY) ) {
			
		switch (m_pChatMsgList[i]->m_cType) {
		case 41:
		case 42:
		case 21:
		case 22:
		case 23:
			DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, FALSE);
			break;
		}
	}

	m_DDraw._GetBackBufferDC();
	for (i = 0; i < DEF_MAXCHATMSGS; i++)
	if (m_pChatMsgList[i] != NULL)
	if ( (m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
	     (m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY) ) {
			
		switch (m_pChatMsgList[i]->m_cType) {
		case 41:
		case 42:
		case 21:
		case 22:
		case 23:
			break;
		
		case 20:
		default:
			DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, TRUE);
			break;
		}
	}
	m_DDraw._ReleaseBackBufferDC();
}



void CGame::_LoadTextDlgContents(int cType)
{
 char * pContents, * token, cTemp[120], cFileName[120];
 char   seps[] = "\n";
 int    iIndex = 0, i;
 class  CStrTok * pStrTok;
 DWORD  dwFileSize;
 HANDLE hFile;
 FILE * pFile;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != NULL) 
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;
	}

	//// cType에 따라 맞는 내용을 로드한다. 
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", cType);

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return;
	else { 
		pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
	}

	fclose(pFile);
	////

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
 
	while( token != NULL ) {
		m_pMsgTextList[iIndex] = new class CMsg(NULL, token, NULL);
		token = pStrTok->pGet();
		iIndex++;
	}	

	delete pStrTok;
	delete[] pContents;
}



int CGame::_iLoadTextDlgContents2(int iType)
{
 char * pContents, * token, cTemp[120], cFileName[120];
 char   seps[] = "\n";
 int    iIndex = 0, i;
 class  CStrTok * pStrTok;
 DWORD  dwFileSize;
 HANDLE hFile;
 FILE * pFile;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList2[i] != NULL) 
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = NULL;
	}

	//// cType에 따라 맞는 내용을 로드한다. 
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", iType);

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return -1;
	else {
		pContents = new char[dwFileSize+1];
		if (pContents == NULL) return -1;
		
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
	}
	fclose(pFile);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		m_pMsgTextList2[iIndex] = new class CMsg(NULL, token, NULL);
		token = pStrTok->pGet();
		iIndex++;
	}	

	delete pStrTok;
	delete[] pContents;

	return iIndex;
}




void CGame::_LoadGameMsgTextContents()
{
 char * pContents, * token, cTemp[120], cFileName[120];
 char   seps[] = ";\n";
 int    iIndex = 0, i;
 class  CStrTok * pStrTok;
 DWORD  dwFileSize;
 HANDLE hFile;
 FILE * pFile;

	for (i = 0; i < DEF_MAXGAMEMSGS; i++) {
		if (m_pGameMsgList[i] != NULL) 
			delete m_pGameMsgList[i];
		m_pGameMsgList[i] = NULL;
	}

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	strcpy(cTemp, "GameMsgList");

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt"); 

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return;
	else {
		pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
	} 

	fclose(pFile);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		m_pGameMsgList[iIndex] = new class CMsg(NULL, token, NULL);
		token = pStrTok->pGet();
		iIndex++;
	}	

	delete pStrTok;
	delete[] pContents;
}

void CGame::DlgBoxClick_Party(short msX, short msY)
{
 short sX, sY; 

	sX = m_stDialogBoxInfo[32].sX; 
	sY = m_stDialogBoxInfo[32].sY;

	switch (m_stDialogBoxInfo[32].cMode) {
	case 0:
		if (m_iPartyStatus == 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 80) && (msY < sY + 100)) {
				m_stDialogBoxInfo[32].cMode = 2;
				m_bIsGetPointingMode = TRUE;
				m_iPointCommandType  = 200;
				PlaySound('E', 14, 5);
			} 
		}    
				
		if (m_iPartyStatus != 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 100) && (msY < sY + 120)) { 
				m_stDialogBoxInfo[32].cMode = 11;
				PlaySound('E', 14, 5);
			} 
		}    
		
		if (m_iPartyStatus != 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 120) && (msY < sY + 140)) {
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, NULL, 2, NULL, NULL, m_cMCName);
				m_stDialogBoxInfo[32].cMode = 4;
				PlaySound('E', 14, 5);
			} 
		}  

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) DisableDialogBox(32);
		break;

	case 1:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// 파티 가입 승인
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY, NULL, 1, NULL, NULL, m_stDialogBoxInfo[32].cStr);
			DisableDialogBox(32);
			PlaySound('E', 14, 5); 
		}  

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// 파티 가입 거부 
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY, NULL, 0, NULL, NULL, m_stDialogBoxInfo[32].cStr);
			DisableDialogBox(32);
			PlaySound('E', 14, 5);
		}  
		break;   

	case 2:  
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// 파티 가입 취소 
			m_stDialogBoxInfo[32].cMode = 0;
			PlaySound('E', 14, 5);
		} 
		break;

	case 3:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// 파티 가입 신청 취소 
			m_stDialogBoxInfo[32].cMode = 0;
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY, NULL, 2, NULL, NULL, m_stDialogBoxInfo[32].cStr);
			DisableDialogBox(32);
			PlaySound('E', 14, 5);
		}
		break;

	case 4:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_stDialogBoxInfo[32].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 11:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, NULL, NULL, NULL, NULL, m_cMCName);
			m_stDialogBoxInfo[32].cMode = 5;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_stDialogBoxInfo[32].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;
	}
}


void CGame::DlgBoxClick_CrusadeJob(short msX, short msY)
{
 short sX, sY;
 	
	sX = m_stDialogBoxInfo[33].sX;
	sY = m_stDialogBoxInfo[33].sY;

	switch (m_stDialogBoxInfo[33].cMode) {
	case 1:
		if( m_bCitizen == FALSE )
		{
			// 중립이다.
			DisableDialogBox(33);
			PlaySound('E', 14, 5);
		}
		else if (m_bAresden == TRUE) {
			// 아레스덴 소속 
			if (m_iGuildRank == 0) {
				if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165)) {
					// 무조건 지휘관
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 3, NULL, NULL, NULL);	
					DisableDialogBox(33);
					PlaySound('E', 14, 5);
				}
 			}
			else {
				if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165)) {
					// 파이터 
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 1, NULL, NULL, NULL);	
					DisableDialogBox(33);
				}
 			
				// 길드 소속이면 건축가 가능 
				if (m_iGuildRank != -1) {
					if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 175) && (msY < sY + 190)) {
						// 건축가
						bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 2, NULL, NULL, NULL);	
						DisableDialogBox(33);
						PlaySound('E', 14, 5);
					}
				}
			}
		}
		else if (m_bAresden == FALSE) {
			// 엘바인 소속 
			if (m_iGuildRank == 0) {
				// 무조건 지휘관
				if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165)) {
					// 무조건 지휘관
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 3, NULL, NULL, NULL);	
					DisableDialogBox(33);
					PlaySound('E', 14, 5);
				}
			} 
			else {
				if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165)) {
					// 파이터 
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 1, NULL, NULL, NULL);	
					DisableDialogBox(33);
					PlaySound('E', 14, 5);
				}
 			
				// 길드 소속이면 건축가 가능 
				if (m_iGuildRank != -1) {
					if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 175) && (msY < sY + 190)) {
						// 건축가 
						bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 2, NULL, NULL, NULL);	
						DisableDialogBox(33);
						PlaySound('E', 14, 5);
					}
				}
			} 
		}  

		if ((msX > sX + 210) && (msX < sX + 260) && (msY >= sY + 296) && (msY <= sY + 316)) {
			// Help 창을 뜨운다.
			DisableDialogBox(18);
			EnableDialogBox(18, 813, NULL, NULL); 
			PlaySound('E', 14, 5);
		} 
		break;

	case 2:
		if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 160) && (msY < sY + 175))  {
			switch (m_iCrusadeDuty) {
			case 1: EnableDialogBox(18, 803, NULL, NULL); break;
			case 2: EnableDialogBox(18, 805, NULL, NULL); break;
			case 3: EnableDialogBox(18, 808, NULL, NULL); break;
			}
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			DisableDialogBox(33);
			PlaySound('E', 14, 5);
		}
		break;
	}
} 

void CGame::_RequestMapStatus(char * pMapName, int iMode)
{
	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_MAPSTATUS, NULL, iMode, NULL, NULL, pMapName);
}

void CGame::AddMapStatusInfo(char * pData, BOOL bIsLastData)
{
 char * cp, cTotal;
 short * sp, sIndex;
 int i;

	ZeroMemory(m_cStatusMapName, sizeof(m_cStatusMapName));
	
	cp = (char *)(pData + 6);
	memcpy(m_cStatusMapName, cp, 10);
	cp += 10;

	sp = (short *)cp;
	sIndex = *sp;
	cp += 2;

	cTotal = *cp;
	cp++;

	for (i = 1; i <= cTotal; i++) {
		m_stCrusadeStructureInfo[sIndex].cType = *cp;
		cp++;
		sp = (short *)cp;
		m_stCrusadeStructureInfo[sIndex].sX = *sp;
		cp += 2;
		sp = (short *)cp;
		m_stCrusadeStructureInfo[sIndex].sY = *sp;
		cp += 2;
		m_stCrusadeStructureInfo[sIndex].cSide = *cp;
		cp++;

		sIndex++;
	}

	if (bIsLastData == TRUE) {
		// 이후 리스트의 내용을 모두 클라어한다.
		while (sIndex < DEF_MAXCRUSADESTRUCTURES) {
			m_stCrusadeStructureInfo[sIndex].cType = NULL;
			m_stCrusadeStructureInfo[sIndex].sX = NULL;
			m_stCrusadeStructureInfo[sIndex].sY = NULL;
			m_stCrusadeStructureInfo[sIndex].cSide = NULL;
			sIndex++;
		}
	}
}

#ifdef DEF_USING_WIN_IME
bool CGame::GetText(HWND hWnd,UINT msg,WPARAM wparam, LPARAM lparam)
{ 
	if( m_pInputBuffer == NULL) return FALSE;
	if( G_hEditWnd == NULL ) return FALSE;

	switch( msg )
	{
	case WM_CHAR:
		{
			if( (wparam == 22) || (wparam == 3) || (wparam == 9) || (wparam == 13) ) return TRUE;
			if( strlen(m_pInputBuffer) < m_cInputMaxLen-1 ) SendMessage( G_hEditWnd, msg, wparam, lparam );
		}
		return TRUE;
	case WM_IME_COMPOSITION:
		{
			if( strlen(m_pInputBuffer) < (m_cInputMaxLen -2) ) SendMessage( G_hEditWnd, msg, wparam, lparam );
		}
		return TRUE;
	case WM_IME_CHAR:
	case WM_IME_COMPOSITIONFULL:
	case WM_IME_CONTROL:
	case WM_IME_ENDCOMPOSITION:
	case WM_IME_NOTIFY:
	case WM_IME_STARTCOMPOSITION:
	case WM_IME_SETCONTEXT:
	case WM_IME_KEYDOWN:
	case WM_IME_KEYUP:
	case WM_IME_SELECT:
		SendMessage( G_hEditWnd, msg, wparam, lparam );
		return TRUE;
	case WM_KEYUP:
		SendMessage( G_hEditWnd, msg, wparam, lparam );
		return FALSE;
	case WM_KEYDOWN:
		if( wparam == 8 ) SendMessage( G_hEditWnd, msg, wparam, lparam );
		return FALSE;
	}
	return FALSE;
}

#else

bool CGame::GetText(HWND hWnd,UINT msg,WPARAM wparam, LPARAM lparam)
{ 
	int len;//그냥 여기저기서 써먹을 변수!
	HIMC hIMC=NULL;//IME핸들

	if (m_pInputBuffer == NULL) return FALSE;
	switch (msg)
	{
		case WM_IME_COMPOSITION://글씨조합중
			ZeroMemory(m_cEdit, sizeof(m_cEdit));
			if (lparam & GCS_RESULTSTR)//글자의 조합이 완성되면.
			{
				hIMC = ImmGetContext(hWnd);
				len = ImmGetCompositionString(hIMC, GCS_RESULTSTR, NULL, 0);
				if( len > 4 ) len = 4;
				ImmGetCompositionString(hIMC, GCS_RESULTSTR, m_cEdit, len);
				ImmReleaseContext(hWnd, hIMC);
				len = strlen(m_pInputBuffer) + strlen(m_cEdit);
				if (len < m_cInputMaxLen) strcpy(m_pInputBuffer+strlen(m_pInputBuffer),m_cEdit);	
				ZeroMemory(m_cEdit, sizeof(m_cEdit));
			}
			else if (lparam & GCS_COMPSTR)//조합중이면;.
			{
				hIMC = ImmGetContext(hWnd);
				len = ImmGetCompositionString(hIMC, GCS_COMPSTR, NULL, 0);// 조합중인 길이를 얻는다.
				if( len > 4 ) len = 4;
				ImmGetCompositionString(hIMC, GCS_COMPSTR, m_cEdit, len);
				ImmReleaseContext(hWnd, hIMC);
				len = strlen(m_pInputBuffer) + strlen(m_cEdit);
				if (len >= m_cInputMaxLen) ZeroMemory(m_cEdit, sizeof(m_cEdit));
			}
			return TRUE;

		case WM_CHAR://일반문자 넘어오기
			if(wparam == 8)//만약 8번(빽스페이스)라면..
			{
				if(strlen(m_pInputBuffer) > 0)//길이가 0보다 길면
				{
					len = strlen(m_pInputBuffer);
					// 일반 버퍼의 내용을 지운다. IME조합문자면 한번에 지운다.
										
					switch (GetCharKind(m_pInputBuffer, len-1))
					{
					case 1: 
						m_pInputBuffer[len-1] = NULL;
						break;
					case 2:
					case 3:
						m_pInputBuffer[len-2]  = NULL;
						m_pInputBuffer[len-1]  = NULL;
						break;
					}
					ZeroMemory(m_cEdit, sizeof(m_cEdit));
				}
			}
			else if ((wparam != 9) && (wparam != 13) && (wparam != 27)) {  // 빽스페이스가 아니고 탭키도 아니고 엔터키도 아니구 Escape도 아니라면 ..
				len = strlen(m_pInputBuffer);
				if (len >= m_cInputMaxLen-1) return FALSE;
				m_pInputBuffer[len] = wparam & 0xff;   //  넘어온 문자를 문자열에 넣기..
				m_pInputBuffer[len+1] = 0;               //  뒤에 0붙이깃!!
			}

			return TRUE;
	}
	return FALSE;
}

#endif

//문자열 중여서 지정한 위치가 영문인지 한글의 첫번째바이트인지 두번째 바이트
//인지 검사한다.
//입력 str 문자열
//     index 검사할 위치
// 출력 1 영문위치
//      2 한글 위치 1
//      3 한글 위치 2
int CGame::GetCharKind(char *str, int index)
{
	int kind=1;

    do
	{
		if(kind==2) kind=3;
		else
		{
	    	if((unsigned char) *str < 128) kind=1;
	    	else kind=2;
		}
		str++;
		index--;
    }
	while(index>=0);
    return kind;
}

void CGame::ShowReceivedString(BOOL bIsHide)
{
	ZeroMemory(G_cTxt, sizeof(G_cTxt));

#ifdef DEF_USING_WIN_IME
	if( G_hEditWnd != NULL ) GetWindowText(G_hEditWnd, m_pInputBuffer, (int)m_cInputMaxLen);
	strcpy(G_cTxt, m_pInputBuffer);
#else
	strcpy(G_cTxt, m_pInputBuffer);
	if( (m_cEdit[0] != 0) && ( strlen(m_pInputBuffer)+strlen(m_cEdit)+1 <= m_cInputMaxLen ) )
	{
		strcpy(G_cTxt + strlen(m_pInputBuffer), m_cEdit);
	}
#endif	
	if (bIsHide == TRUE) {
		for (unsigned char i = 0; i < strlen(G_cTxt); i++)
		if (G_cTxt[i] != NULL) G_cTxt[i] = '*';
	}
	
	if( (G_dwGlobalTime%400) < 210 ) G_cTxt[strlen(G_cTxt)] = '_';
	
	PutString(m_iInputX+1, m_iInputY+1, G_cTxt, RGB(0,0,0));
	PutString(m_iInputX, m_iInputY+1, G_cTxt, RGB(0,0,0));
	PutString(m_iInputX+1, m_iInputY, G_cTxt, RGB(0,0,0));
	PutString(m_iInputX, m_iInputY, G_cTxt, RGB(255,255,255));
}

void CGame::ClearInputString()
{
	if (m_pInputBuffer != NULL)	ZeroMemory(m_pInputBuffer, sizeof(m_pInputBuffer));
	ZeroMemory(m_cEdit, sizeof(m_cEdit));
#ifdef DEF_USING_WIN_IME
	if (G_hEditWnd != NULL)	SetWindowText(G_hEditWnd, "");
#endif
}  

void CGame::StartInputString(int sX, int sY, unsigned char iLen, char * pBuffer, BOOL bIsHide)
{
	m_bInputStatus = TRUE;
	m_iInputX = sX;
	m_iInputY = sY;  
	m_pInputBuffer = pBuffer;
	ZeroMemory(m_cEdit, sizeof(m_cEdit));
	m_cInputMaxLen = iLen;
#ifdef DEF_USING_WIN_IME 
	if (bIsHide == FALSE) G_hEditWnd = CreateWindow( RICHEDIT_CLASS, NULL, WS_POPUP | ES_SELFIME, sX-5 , sY -1, iLen*12, 16, G_hWnd, (HMENU)0, G_hInstance, NULL);
	else G_hEditWnd = CreateWindow( RICHEDIT_CLASS, NULL, WS_POPUP | ES_PASSWORD | ES_SELFIME, sX-5 , sY -1, iLen*12, 16, G_hWnd, (HMENU)0, G_hInstance, NULL);
	SetWindowText(G_hEditWnd, m_pInputBuffer);
	SendMessage(G_hEditWnd, EM_EXLIMITTEXT, 0, iLen-1 );
	SendMessage(G_hEditWnd, EM_SETLANGOPTIONS, 0, ~IMF_AUTOFONT);
	COMPOSITIONFORM composform;
	composform.dwStyle = CFS_POINT;
	composform.ptCurrentPos.x = sX;
	composform.ptCurrentPos.y = sY;
	HIMC hImc = ImmGetContext(G_hWnd);
	ImmSetCompositionWindow( hImc, &composform );
	int StrLen = strlen( m_pInputBuffer );
	SendMessage(G_hEditWnd, EM_SETSEL, StrLen, StrLen);
#endif
}

void CGame::EndInputString()
{
	m_bInputStatus = FALSE;
#ifdef DEF_USING_WIN_IME
	if (G_hEditWnd != NULL) {
		// 입력 에디트 컨트롤이 포커스를 잃었다.
		GetWindowText(G_hEditWnd, m_pInputBuffer, (int)m_cInputMaxLen);
		CANDIDATEFORM candiform;
		SendMessage(G_hEditWnd, WM_IME_CONTROL, IMC_GETCANDIDATEPOS, (LPARAM)&candiform);
		DestroyWindow(G_hEditWnd);
		G_hEditWnd = NULL;
	}
#else
	// 조합중인 문자가 있음 넣는다.
	int len = strlen(m_cEdit);

	if (len > 0) {
		m_cEdit[len] = 0;
		strcpy(m_pInputBuffer+strlen(m_pInputBuffer),m_cEdit);	
		ZeroMemory( m_cEdit, sizeof(m_cEdit) );
	}
#endif
}

void CGame::ReceiveString(char *pString)
{
	strcpy(pString, m_pInputBuffer);

#ifdef DEF_USING_WIN_IME
	if (G_hEditWnd != NULL) GetWindowText(G_hEditWnd, pString, (int)m_cInputMaxLen);
#endif
}

void CGame::DrawNewDialogBox(char cType, int sX, int sY, int iFrame, BOOL bIsNoColorKey, BOOL bIsTrans)
{
 DWORD dwTime = G_dwGlobalTime;

	if (m_pSprite[cType] == NULL) return;
	if (bIsNoColorKey == FALSE) {
		if (bIsTrans == TRUE)  
			 m_pSprite[cType]->PutTransSprite2(sX, sY, iFrame, dwTime);
		else m_pSprite[cType]->PutSpriteFast(sX, sY, iFrame, dwTime);
	}
	else m_pSprite[cType]->PutSpriteFastNoColorKey(sX, sY, iFrame, dwTime);
}

void CGame::DlgBoxClick_Commander(int msX, int msY)
{
 short sX, sY, tX, tY;	  
 double d1, d2, d3;
  
	if (m_bIsCrusadeMode == FALSE) return;

	sX = m_stDialogBoxInfo[36].sX;
	sY = m_stDialogBoxInfo[36].sY;
		
	switch (m_stDialogBoxInfo[36].cMode) {
	case 0:
		// 일반 아이콘 선택 모드 
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 텔레포트 위치 지정 
			m_stDialogBoxInfo[36].cMode = 1;
			PlaySound('E', 14, 5); 
		}
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 텔레포트 확인 화면으로 
			if (m_iTeleportLocX == -1) {
				// 텔레포트 위치가 지정되지 않았음 
				SetTopMsg(m_pGameMsgList[15]->m_pMsg, 5);
			}
			else if (strcmp(m_cMapName, m_cTeleportMapName) == 0) {
				// 같은 맵에서는 텔레포트 불가능
				SetTopMsg(m_pGameMsgList[16]->m_pMsg, 5);
			}
			else {
				m_stDialogBoxInfo[36].cMode = 2;
				PlaySound('E', 14, 5);
			}
		}
		if ((msX >= sX +20 +100) && (msX <= sX +20 +46 +100) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 소환 
			m_stDialogBoxInfo[36].cMode = 3;
			m_stDialogBoxInfo[36].sV1   = 0; // 소환모드 
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150) && (msX <= sX +20 +46 +150) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 건설 위치 지정
			m_stDialogBoxInfo[36].cMode = 4;
			PlaySound('E', 14, 5);
		}
		
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 808, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break; 

	case 1:
		// 텔레포트 좌표 구하는 모드.
		if ((msX >= sX + 15) && (msX <= sX + 15 + 280) && (msY >= sY + 60) && (msY <= sY + 60 + 253)) {
			d1 = (double)(msX - (sX + 15));
			d2 = (double)(752.0f); // 미들랜드 맵 사이즈
			d3 = (d2*d1)/280.0f;
			tX = (int)d3;

			d1 = (double)(msY - (sY + 60));
			d2 = (double)(680.0f); // 미들랜드 맵 사이즈
			d3 = (d2*d1)/253.0f;
			tY = (int)d3;

			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > 722) tX = 722;
			if (tY > 650) tY = 650;
		
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETGUILDTELEPORTLOC, NULL, tX, tY, NULL, "middleland");
			m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);

			_RequestMapStatus("middleland", 1);
		}

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 뒤로가기
			m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 809, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 2:
		// 텔레포트 확인 모드 
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GUILDTELEPORT, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(36);
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 뒤로가기
			m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 810, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;  

	case 3:
		if( m_bAresden == TRUE ) {
			// 아레스덴 유니트
			if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 배틀골렘 클릭 
				if (m_iConstructionPoint >= 3000) {
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 47, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
				}
			}
			if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 템플나이트 클릭
				if (m_iConstructionPoint >= 2000) {
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 46, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
				}
			}
			if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 라이트 워 비틀 클릭 
				if (m_iConstructionPoint >= 1000) {
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 43, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
				}
			}
			if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 캐터팔트 클릭
				if (m_iConstructionPoint >= 1500) {
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 51, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
				} 
			}
		}   
		else if (m_bAresden == FALSE) {
			// 엘바인 유니트
			if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 고즈 핸드 & 배틀 스티드 클릭 
				if (m_iConstructionPoint >= 3000) {
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 45, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36); 
				}
			} 
			if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 고즈 핸드 클릭
				if (m_iConstructionPoint >= 2000) {
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 44, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
				}  
			}    
			if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 라이트 워 비틀 클릭 
				if (m_iConstructionPoint >= 1000) {
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 43, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
				}
			}
			if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 캐터팔트 클릭
				if (m_iConstructionPoint >= 1500) {
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 51, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
				}
			}
		}

		if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +140) && (msY < sY +160)) {
			m_stDialogBoxInfo[36].sV1   = 0; // 호위 모드 
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +160) && (msY < sY +175)) {
			m_stDialogBoxInfo[36].sV1   = 1; // 지역 방어 모드
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 뒤로가기
			m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 811, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 4:
		// 건설 위치 설정 클릭 
		if ((msX >= sX + 15) && (msX <= sX + 15 + 280) && (msY >= sY + 60) && (msY <= sY + 60 + 253)) {
			d1 = (double)(msX - (sX + 15));
			d2 = (double)(752.0f); // 미들랜드 맵 사이즈
			d3 = (d2*d1)/280.0f;
			tX = (int)d3;

			d1 = (double)(msY - (sY + 60));
			d2 = (double)(680.0f); // 미들랜드 맵 사이즈
			d3 = (d2*d1)/253.0f;
			tY = (int)d3;

			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > 722) tX = 722;
			if (tY > 650) tY = 650;
			
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC, NULL, tX, tY, NULL, "middleland");
			m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);

			_RequestMapStatus("middleland", 1);
		}

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 뒤로가기
			m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 812, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;
	}     
}


void CGame::DlgBoxClick_Constructor(int msX, int msY)
{ 
 short sX, sY;	  
  
	if (m_bIsCrusadeMode == FALSE) return;

	sX = m_stDialogBoxInfo[37].sX;
	sY = m_stDialogBoxInfo[37].sY;
		
	switch (m_stDialogBoxInfo[37].cMode) {
	case 0:
		// 일반 아이콘 선택 모드 
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 건설
			if (m_iConstructLocX == -1) {
				// 건설위치가 지정되지 않았음 
				SetTopMsg(m_pGameMsgList[14]->m_pMsg, 5);
			} 
			else {
				m_stDialogBoxInfo[37].cMode = 1;
				PlaySound('E', 14, 5);
			} 
		}
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 텔레포트 확인 화면으로 
			if (m_iTeleportLocX == -1) {
				// 텔레포트 위치가 지정되지 않았음 
				SetTopMsg(m_pGameMsgList[15]->m_pMsg, 5);
			}
			else if (strcmp(m_cMapName, m_cTeleportMapName) == 0) {
				// 같은 맵에서는 텔레포트 불가능
				SetTopMsg(m_pGameMsgList[16]->m_pMsg, 5);
			}
			else {
				m_stDialogBoxInfo[37].cMode = 2;
				PlaySound('E', 14, 5);
			}
		}
		
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 805, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 1:
		// 건설
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			// 마나 콜렉터 
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 38, 1, m_stDialogBoxInfo[36].sV1, NULL);
			PlaySound('E', 14, 5);
			DisableDialogBox(37);
		}
		if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			// 디텍터 
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 39, 1, m_stDialogBoxInfo[36].sV1, NULL);
			PlaySound('E', 14, 5);
			DisableDialogBox(37);
		}
		if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			// 애로우 가드 타워
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 36, 1, m_stDialogBoxInfo[36].sV1, NULL);
			PlaySound('E', 14, 5);
			DisableDialogBox(37);
		}
		if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			// 캐논 가드 타워
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 37, 1, m_stDialogBoxInfo[36].sV1, NULL);
			PlaySound('E', 14, 5);
			DisableDialogBox(37);
		}
				
		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// Back
			m_stDialogBoxInfo[37].cMode = 0;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 806, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 2:
		// 텔레포트 확인 모드 
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// Teleport Confirm
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GUILDTELEPORT, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(37);
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// Back
			m_stDialogBoxInfo[37].cMode = 0;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 807, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;
	}     
}


void CGame::DlgBoxClick_Soldier(int msX, int msY)
{ 
 short sX, sY;	  
  
	if (m_bIsCrusadeMode == FALSE) return;

	sX = m_stDialogBoxInfo[38].sX;
	sY = m_stDialogBoxInfo[38].sY;
		
	switch (m_stDialogBoxInfo[38].cMode) {
	case 0:
		// 일반 아이콘 선택 모드 
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 텔레포트 확인 화면으로 
			if (m_iTeleportLocX == -1) {
				// 텔레포트 위치가 지정되지 않았음 
				SetTopMsg(m_pGameMsgList[15]->m_pMsg, 5);
			}
			else if (strcmp(m_cMapName, m_cTeleportMapName) == 0) {
				// 같은 맵에서는 텔레포트 불가능
				SetTopMsg(m_pGameMsgList[16]->m_pMsg, 5);
			}
			else {
				m_stDialogBoxInfo[38].cMode = 1;
				PlaySound('E', 14, 5);
			}
		}
				
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 803, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 1:
		// 텔레포트 확인 모드 
		if ((msX >= sX +20) && (msX <= sX +20 +46+50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// Teleport Confirm
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GUILDTELEPORT, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(38);
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// Back
			m_stDialogBoxInfo[38].cMode = 0;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			DisableDialogBox(18);
			EnableDialogBox(18, 804, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;
	}     
}

void CGame::SetCameraShakingEffect(short sDist, int iMul)
{
 int iDegree;

	iDegree = 5 - sDist;
	if (iDegree <= 0) iDegree = 0;
	iDegree *= 2;
	
	if (iMul != 0) iDegree *= iMul;

	if (iDegree <= 2) return;

	m_iCameraShakingDegree = iDegree;
}

void CGame::MeteorStrikeComing(int iCode)
{
	switch (iCode) {
	case 1: // 엘바인 내의 캐릭터들에게 아레스덴 폭격 임박 통보 
		SetTopMsg(m_pGameMsgList[0]->m_pMsg, 5);
		break;
	case 2: // 엘바인 이외지역의 캐릭터들에게 아레스덴의 폭격 임박 통보
		SetTopMsg(m_pGameMsgList[10]->m_pMsg, 10);
		break;
	case 3: // 아레스덴 내의 캐릭터들에게 엘바인 폭격 임박 통보 
		SetTopMsg(m_pGameMsgList[91]->m_pMsg, 5);
		break;
	case 4: // 아레스덴 이외지역의 캐릭터들에게 엘바인의 폭격 임박 통보
		SetTopMsg(m_pGameMsgList[11]->m_pMsg, 10);
		break;
	}
}

void CGame::DrawObjectFOE(int ix, int iy, int iFrame)
{
	if( _iGetFOE(_tmp_sStatus) < 0 )
	{
		if (iFrame <= 4 ) m_pEffectSpr[38]->PutTransSprite(ix, iy, iFrame, G_dwGlobalTime); 
	}
}

void CGame::SetTopMsg(char *pString, unsigned char iLastSec)
{
	ZeroMemory(m_cTopMsg, sizeof(m_cTopMsg));
	strcpy(m_cTopMsg, pString);

	m_iTopMsgLastSec = iLastSec;
	m_dwTopMsgTime   = G_dwGlobalTime;
}

void CGame::DrawTopMsg()
{
	if (strlen(m_cTopMsg) == 0) return;
	m_DDraw.DrawShadowBox(0, 0, 639, 30);
	
	if ((((G_dwGlobalTime - m_dwTopMsgTime)/250) % 2) == 0)
		PutAlignedString(0, 639, 10, m_cTopMsg, 255,255,255); 

	if ( G_dwGlobalTime > (m_iTopMsgLastSec*1000+m_dwTopMsgTime) ) {
		ZeroMemory(m_cTopMsg, sizeof(m_cTopMsg));
	}
}


void CGame::DrawDialogBox_IconPannel(short msX, short msY)
{
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
	
	sX = m_stDialogBoxInfo[30].sX;
	sY = m_stDialogBoxInfo[30].sY;

	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(sX, sY, 14, dwTime);

	if ((362 < msX)	&& (404 > msX) && (434 < msY) && (475 > msY)) { 
		m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(362, 434, 16, dwTime);
	}

	if (m_bIsCombatMode) {
		if (m_bIsSafeAttackMode) 
			 m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(368, 440, 4, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(368, 440, 5, dwTime);
	}

	if ((m_bIsCrusadeMode) && (m_iCrusadeDuty != 0)) {
		if (m_bAresden == TRUE) {
			if ((322 <= msX) && (355 >= msX) && (434 < msY) && (475 > msY)) 
				 m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 2, dwTime);
		}
		else if (m_bAresden == FALSE) {
			if ((322 <= msX) && (355 >= msX) && (434 < msY) && (475 > msY)) 
				 m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 15, dwTime);
		}
	}

	if ((msY > 436) && (msY < 478))
	{		
		if ((msX > 410) && (msX < 447))
		{
#if DEF_LANGUAGE == 3		// Korea 2.19
			if( m_iLevel < 80 ) PutAlignedString(360, 497, 410, "캐릭터 인포(F5)", 200,200,120);
#endif
			m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(412, 434, 6, dwTime);// Character
		}
		if ((msX > 447) && (msX < 484))
		{
#if DEF_LANGUAGE == 3		// Korea 2.19
			if( m_iLevel < 80 ) PutAlignedString(397, 534, 410, "인벤토리(F6)", 200,200,120);
#endif
			m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(449, 434, 7, dwTime);// Inventory
		}
		if ((msX > 484) && (msX < 521))
		{
#if DEF_LANGUAGE == 3		// Korea 2.19
			if( m_iLevel < 80 ) PutAlignedString(434, 571, 410, "마법리스트(F7)", 200,200,120);
#endif
			m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(486, 434, 8, dwTime);// Magic
		}
		if ((msX > 521) && (msX < 558))
		{
#if DEF_LANGUAGE == 3		// Korea 2.19
			if( m_iLevel < 80 ) PutAlignedString(471, 608, 410, "스킬정보(F8)", 200,200,120);
#endif
			m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(523, 434, 9, dwTime);// Skill
		}
		if ((msX > 558) && (msX < 595))
		{
#if DEF_LANGUAGE == 3		// Korea 2.19
			if( m_iLevel < 80 ) PutAlignedString(508, 645, 410, "채팅히스토리(F9)", 200,200,120);
#endif
			m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(560, 434, 10, dwTime);// History
		}
		if ((msX > 595) && (msX < 631))
		{
#if DEF_LANGUAGE == 3		// Korea 2.19
			if( m_iLevel < 80 ) PutAlignedString(530, 640, 410, "시스템 메뉴(F12)", 200,200,120);
#endif
			m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(597, 434, 11, dwTime);// System Menu
		}
	}

	if ( ((msX > 144) && (msX < 317) && (msY > 434) && (msY < 477)) || (m_bCtrlPressed) ) {
		// v2.17 안상하추가 렙업하기 위한 경험치과정 출력

		//2003. 02.07 정진광 수정 인터네셔널 유저들은 국내와 경험치가 다르다.
		int iLev = 0;
		int iCurExp = iGetLevelExp(m_iLevel);
		int iNextExp;

		#if DEF_LANGUAGE > 3
				#if !defined(DEF_JAPAN_FOR_TERRA) || !defined(DEF_FUCK_USA)
					if (m_iLevel > 139)
					{
						iLev = (m_iLevel-139)*3;
						iNextExp = iGetLevelExp(m_iLevel+iLev);
					}
					else
						iNextExp = iGetLevelExp(m_iLevel+1);
				#else
					iNextExp = iGetLevelExp(m_iLevel+1);
				#endif
		#else
	
			iNextExp = iGetLevelExp(m_iLevel+1);

		#endif

		if(m_iExp < iNextExp)
		{
			iNextExp = iNextExp - iCurExp;
			if( m_iExp > iCurExp ) iCurExp = m_iExp - iCurExp;
			else iCurExp = 0;
			short sPerc = 0;
			if( iCurExp > 200000 ) sPerc = short( ((iCurExp>>4)*10000)/(iNextExp>>4) );
			else sPerc = (short)( (iCurExp*10000)/iNextExp );
			wsprintf(G_cTxt, DEF_MSG_EXP"%d/%d(%d.%02d%%)", iNextExp-iCurExp, iNextExp, sPerc/100, sPerc%100);
		}
		else
		{
			wsprintf(G_cTxt, DEF_MSG_EXP"%d / %d", m_iExp, iNextExp);
		}
	}
	else wsprintf(G_cTxt, "%s(%d,%d)", m_cMapMessage, m_sPlayerX, m_sPlayerY);//맵의 이름과 좌표출력
	PutAlignedString(140, 323, 456, G_cTxt, 200,200,120);
}

void CGame::DrawDialogBox_GaugePannel()
{
	int iMaxPoint, iBarWidth, iTemp;

	iMaxPoint = m_iVit*3 + m_iLevel*2 + m_iStr/2;
	iBarWidth = 101 - (m_iHP*101)/iMaxPoint;
	if( iBarWidth < 0 ) iBarWidth = 0;
	if( iBarWidth > 101 ) iBarWidth = 101;
	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFastWidth(23, 437,  12, iBarWidth, m_dwCurTime);
	iTemp = m_iHP;
	wsprintf(G_cTxt, "%d", iTemp);
	if (m_bIsPoisoned) {
		PutString_SprNum(85, 441, G_cTxt, m_wR[5]*11, m_wG[5]*11, m_wB[5]*11);
		PutString_SprFont3(35, 440, "Poisoned", m_wR[5]*8, m_wG[5]*8, m_wB[5]*8, TRUE, 2); 
	}
	else PutString_SprNum(85, 441, G_cTxt, 200, 100, 100);


	iMaxPoint = m_iMag*2 + m_iLevel*2 + m_iInt/2;
	iBarWidth = 101 - (m_iMP*101)/iMaxPoint;
	if( iBarWidth < 0 ) iBarWidth = 0;
	if( iBarWidth > 101 ) iBarWidth = 101;
	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFastWidth(23, 459,  12, iBarWidth, m_dwCurTime);
	iTemp = m_iMP;
	wsprintf(G_cTxt, "%d", iTemp);
	PutString_SprNum(85, 463, G_cTxt, 100, 100, 200);


	iMaxPoint = m_iStr*2 + m_iLevel*2;
	iBarWidth = 167 - (m_iSP*167)/iMaxPoint;
	if( iBarWidth < 0 ) iBarWidth = 0;
	if( iBarWidth > 167 ) iBarWidth = 167;
	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFastWidth(147, 435, 13, iBarWidth, m_dwCurTime);
}
 
void CGame::DrawDialogBox_Text(short msX, short msY, short msZ, char cLB)
{
 short sX, sY;
 int i, iTotalLines, iPointerLoc;
 double d1,d2,d3;
 	
	sX = m_stDialogBoxInfo[18].sX;
	sY = m_stDialogBoxInfo[18].sY;
		
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
 
	iTotalLines = 0;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) 
	if (m_pMsgTextList[i] != NULL) iTotalLines++;

	if( iTotalLines > 17 ) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
	if( iGetTopDialogBoxIndex() == 18 && msZ != 0 )
	{
		m_stDialogBoxInfo[18].sView = m_stDialogBoxInfo[18].sView - msZ/60;
		m_DInput.m_sZ = 0;
	}
	if( m_stDialogBoxInfo[18].sView < 0 ) m_stDialogBoxInfo[18].sView = 0;
	if( iTotalLines>17 && m_stDialogBoxInfo[18].sView > iTotalLines-17 ) m_stDialogBoxInfo[18].sView = iTotalLines-17;

	// 스크롤 바 포인터 그린다.
	if (iTotalLines > 17) {
		d1 = (double)m_stDialogBoxInfo[18].sView;
		d2 = (double)(iTotalLines-17);
		d3 = (274.0f * d1)/d2;
		iPointerLoc = (int)(d3+0.5);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX+242, sY+35+iPointerLoc, 7);
	}
	else iPointerLoc = 0;

	for (i = 0; i < 17; i++)
	if (m_pMsgTextList[i + m_stDialogBoxInfo[18].sView] != NULL) {
		if (m_bDialogTrans == FALSE) { // v2.173 
			switch (m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg[0]) {
			case '_': PutAlignedString(sX +24, sX +236, sY + 50 +i*13, (m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg+1), 255,255,255); break;
			case ';': PutAlignedString(sX +24, sX +236, sY + 50 +i*13, (m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg+1), 4, 0, 50); break;
			default: PutAlignedString(sX +24, sX +236, sY + 50 +i*13, m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg, 45,25,25); break;
			}
		}
		else PutAlignedString(sX +24, sX +236, sY + 50 +i*13, m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg, 0,0,0);
	}

	// 스크롤바 찍기 처리  
	if (cLB != 0 && iTotalLines > 17) {
		if ((iGetTopDialogBoxIndex() == 18)) {
			if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
				d1 = (double)(msY -(sY+35));
				d2 = (double)(iTotalLines-17);
				d3 = (d1 * d2)/274.0f;
				iPointerLoc = (int)d3;
				if (iPointerLoc > iTotalLines-17) iPointerLoc = iTotalLines-17;
				m_stDialogBoxInfo[18].sView = iPointerLoc;
			}
		}
	}
	else m_stDialogBoxInfo[18].bIsScrollSelected = FALSE;

	if ((msX > sX + DEF_RBTNPOSX) && (msX < sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
}

void CGame::DrawDialogBox_15AgeMsg(short msX, short msY)	
{
    short sX, sY;

	if (m_iFeedBackCardIndex == -1) return;
    
	sX = m_stDialogBoxInfo[5].sX;
	sY = m_stDialogBoxInfo[5].sY;
	
	//2003.06.09 정진광. 진정피드백...을 함께 사용한다.
	#ifdef DEF_FEEDBACKCARD
		switch(m_iFeedBackCardIndex)
		{
		case 1:
			DrawNewDialogBox(DEF_SPRID_INTERFACE_FEEDBACK1, sX, sY, 0);
			break;
		case 2:
			DrawNewDialogBox(DEF_SPRID_INTERFACE_FEEDBACK2, sX, sY, 0);
			break;
		case 3:
			DrawNewDialogBox(DEF_SPRID_INTERFACE_FEEDBACK3, sX, sY, 0);
			break;
		case 4:
			DrawNewDialogBox(DEF_SPRID_INTERFACE_FEEDBACK4, sX, sY, 0);
			break;
		case 5:
			DrawNewDialogBox(DEF_SPRID_INTERFACE_FEEDBACK5, sX, sY, 0);
			break;
		case 6:
			DrawNewDialogBox(DEF_SPRID_INTERFACE_FEEDBACK6, sX, sY, 0);
			break;
		case 7:
			DrawNewDialogBox(DEF_SPRID_INTERFACE_FEEDBACK7, sX, sY, 0);
			break;
		
		}
	
	#else
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX, sY, 2);

		PutString(sX + 30, sY + 26, "2003년 1월 16일 이후부터는 '영상물 심의 등급", RGB(200,200,45));
		PutString(sX + 30, sY + 43, "위원회'의 심의 판정에 따라 만 15세 미만의", RGB(200,200,45) );
		PutString(sX + 30, sY + 60, "플레이어는 게임에 접속할 수 없습니다. 문의사항", RGB(200,200,45) );
		PutString(sX + 30, sY + 78, "은 헬브레스 홈페이지(http://www.helbreath", RGB(200,200,45) );
		PutString(sX + 30, sY + 96, ".com) 접속하시거나 헬브레스 고객지원팀으로", RGB(200,200,45) );
		PutString(sX + 30, sY +114, "연락해 주시기 바랍니다.", RGB(200,200,45) );
	
		if ((msX >= sX + 122 ) && (msX <= sX + 125 + DEF_BTNSZX ) && (msY >= sY + 127 ) && (msY <= sY + 127 + DEF_BTNSZY)) 
				 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 122 , sY + 127 , 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 122, sY + 127 , 0);
	#endif
}


void CGame::DrawDialogBox_WarningMsg(short msX, short msY)//6 정진광.
{
    short sX, sY;
    
	sX = m_stDialogBoxInfo[6].sX;
	sY = m_stDialogBoxInfo[6].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX, sY, 2);

    PutString2(sX + 63, sY + 35, DEF_MSG_WARNING1, 200,200,25);//" ** 이 지역은 전쟁지역 입니다. **"

#if DEF_LANGUAGE == 5	
	PutString(sX + 59, sY + 57, DEF_MSG_WARNING2, RGB(220,130,45) );//"이 지역은 본인의지와 관계없이 모든 병사의 공"
	PutString(sX + 59, sY + 74, DEF_MSG_WARNING3, RGB(220,130,45) );//"격으로부터 보호받을 수 없는 위험한 지역입니다."
	PutString(sX + 59, sY + 92, DEF_MSG_WARNING4, RGB(220,130,45) );//"안전한 게임플레이를 위해선 마을에 있는 시청행"
	PutString(sX + 59, sY +110, DEF_MSG_WARNING5, RGB(220,130,45) );//"정관을 찾아 민간인 모드로 변경하시기 바랍니다."

#else
	PutString(sX + 30, sY + 57, DEF_MSG_WARNING2, RGB(220,130,45) );//"이 지역은 본인의지와 관계없이 모든 병사의 공"
	PutString(sX + 30, sY + 74, DEF_MSG_WARNING3, RGB(220,130,45) );//"격으로부터 보호받을 수 없는 위험한 지역입니다."
	PutString(sX + 30, sY + 92, DEF_MSG_WARNING4, RGB(220,130,45) );//"안전한 게임플레이를 위해선 마을에 있는 시청행"
	PutString(sX + 30, sY +110, DEF_MSG_WARNING5, RGB(220,130,45) );//"정관을 찾아 민간인 모드로 변경하시기 바랍니다."
#endif

	if ((msX >= sX + 122 ) && (msX <= sX + 125 + DEF_BTNSZX ) && (msY >= sY + 127 ) && (msY <= sY + 127 + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 122 , sY + 127 , 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 122, sY + 127 , 0);

}

void CGame::DrawDialogBox_ItemDrop(short msX, short msY)
{
    short sX, sY;
    char cTxt[120], cStr1[64], cStr2[64], cStr3[64];

	sX = m_stDialogBoxInfo[4].sX;
	sY = m_stDialogBoxInfo[4].sY;

    //DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 2);

	GetItemName(m_pItemList[m_stDialogBoxInfo[4].sView]->m_cName, m_pItemList[m_stDialogBoxInfo[4].sView]->m_dwAttribute, cStr1, cStr2, cStr3 );
	
	if (strlen(m_stDialogBoxInfo[4].cStr) == 0) // v1.4
			 wsprintf(cTxt, "%s", cStr1);

	// 2003.02.03 정진광 수정.
	if(m_bIsSpecial) // 특성치 아이템은 연두색 이름
	{
		PutString(sX + 35, sY + 20, cTxt, RGB(0,255,50));
		PutString(sX + 36, sY + 20, cTxt, RGB(0,255,50));
	}

	else //보통 아이템은 남색 이름
	{
		PutString(sX + 35, sY + 20, cTxt, RGB(4,0,50));
		PutString(sX + 36, sY + 20, cTxt, RGB(4,0,50));
	}
		
	PutString(sX + 35, sY + 36, DRAW_DIALOGBOX_ITEM_DROP1 , RGB(4,0,50));
	PutString(sX + 36, sY + 36, DRAW_DIALOGBOX_ITEM_DROP1, RGB(4,0,50));
	                            //"이 아이템을 버리시겠습니까?"

	if(m_bItemDrop)
	{
      if ((msX >= sX + 35) && (msX <= sX + 240 ) && (msY >= sY + 80) && (msY <= sY + 90)) 
	  {
	     PutString(sX + 35, sY + 80, DRAW_DIALOGBOX_ITEM_DROP2, RGB(255,255,255));
	     PutString(sX + 36, sY + 80, DRAW_DIALOGBOX_ITEM_DROP2, RGB(255,255,255));
		                             //"같은 아이템은 더이상 묻지 않음 ON"
	  }
	  else
	  {
	     PutString(sX + 35, sY + 80, DRAW_DIALOGBOX_ITEM_DROP2, RGB(4,0,50));
	     PutString(sX + 36, sY + 80, DRAW_DIALOGBOX_ITEM_DROP2, RGB(4,0,50));
		                             //"같은 아이템은 더이상 묻지 않음 ON"
	  }
	}
	else
	{
	  if ((msX >= sX + 35) && (msX <= sX + 240 ) && (msY >= sY + 80) && (msY <= sY + 90)) 
	  {
	     PutString(sX + 35, sY + 80, DRAW_DIALOGBOX_ITEM_DROP3, RGB(255,255,255));
	     PutString(sX + 36, sY + 80, DRAW_DIALOGBOX_ITEM_DROP3, RGB(255,255,255));
		                             //"같은 아이템은 더이상 묻지 않음 OFF" 
	  }
	  else
	  {
         PutString(sX + 35, sY + 80, DRAW_DIALOGBOX_ITEM_DROP3, RGB(4,0,50));
	     PutString(sX + 36, sY + 80, DRAW_DIALOGBOX_ITEM_DROP3, RGB(4,0,50));
		                             //"같은 아이템은 더이상 묻지 않음 OFF"
	  }
	}
		 
	if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + 55) && (msY <= sY + 55 + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55 ,19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55 , 18);

	if ((msX >= sX + 170 ) && (msX <= sX + 170 + DEF_BTNSZX ) && (msY >= sY + 55 ) && (msY <= sY + 55 + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 170 , sY + 55 , 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 55 , 2);
}

void CGame::DrawDialogBox_NpcTalk(short msX, short msY, char cLB)
{
 short sX, sY;
 int i, iTotalLines, iPointerLoc;
 double d1, d2, d3;

 	
	sX = m_stDialogBoxInfo[21].sX;
	sY = m_stDialogBoxInfo[21].sY;
		
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);

	switch (m_stDialogBoxInfo[21].cMode) {
	case 0: // 일반적인 OK 
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 1: // Accept / Decline
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 33);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 32);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 41);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 40);
		break; 

	case 2: // Next
		if ((msX >= sX + 190) && (msX <= sX + 278) && (msY >= sY + 296) && (msY <= sY + 316)) 
			 PutString_SprFont(sX + 190, sY + 270, "Next", 6,6,20);
		else PutString_SprFont(sX + 190, sY + 270, "Next", 0,0,7);	
		break;
	} 

	for (i = 0; i < 17; i++)
	if ((i < DEF_TEXTDLGMAXLINES) && (m_pMsgTextList2[i + m_stDialogBoxInfo[21].sView] != NULL)) {
		PutAlignedString(sX, sX+m_stDialogBoxInfo[21].sSizeX, sY + 57 +i*15, m_pMsgTextList2[i + m_stDialogBoxInfo[21].sView]->m_pMsg, 45,25,25);
	}

	iTotalLines = 0;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) 
	if (m_pMsgTextList2[i] != NULL) iTotalLines++; 

	// 스크롤 바 포인터 그린다.
	if (iTotalLines > 17) {
		d1 = (double)m_stDialogBoxInfo[21].sView;
		d2 = (double)(iTotalLines-17);
		d3 = (274.0f * d1)/d2;
		iPointerLoc = (int)d3;
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
	}
	else iPointerLoc = 0;

	// 스크롤바 찍기 처리 
	if (cLB != 0 && iTotalLines > 17) {
		if ((iGetTopDialogBoxIndex() == 21)) {
			if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
				d1 = (double)(msY -(sY+40));
				d2 = (double)(iTotalLines-17);
				d3 = (d1 * d2)/274.0f;
				iPointerLoc = (int)d3;

				if (iPointerLoc > iTotalLines) iPointerLoc = iTotalLines;
				m_stDialogBoxInfo[21].sView = iPointerLoc;
			}
		}
	}
	else m_stDialogBoxInfo[21].bIsScrollSelected = FALSE;
}


void CGame::DlgBoxClick_NpcTalk(int msX, int msY)
{
 short sX, sY;
  	
	sX = m_stDialogBoxInfo[21].sX;
	sY = m_stDialogBoxInfo[21].sY;

	switch (m_stDialogBoxInfo[21].cMode) {
	case 0: // 일반적인 OK 
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			DisableDialogBox(21);
			PlaySound('E', 14, 5);
		}
		break;

	case 1: // Accept / Decline
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Accept
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_QUESTACCEPTED, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(21);
			PlaySound('E', 14, 5);
		}
			
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel
			DisableDialogBox(21);
			PlaySound('E', 14, 5);
		}
		break; 

	case 2:
		// Next
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			DisableDialogBox(21);
			PlaySound('E', 14, 5);
		}
		break;
	}	
}


void CGame::DrawDialogBox_Chat(short msX, short msY, short msZ, char cLB)
{
 short sX, sY;
 int i, iPointerLoc;
 double d1, d2, d3;

	sX = m_stDialogBoxInfo[10].sX;
	sY = m_stDialogBoxInfo[10].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 4, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 22, FALSE, m_bDialogTrans);

	if ( msZ != 0 && (iGetTopDialogBoxIndex() == 10)) { 
		m_stDialogBoxInfo[10].sView = m_stDialogBoxInfo[10].sView + msZ/30;
		m_DInput.m_sZ = 0;
	}
	if( m_stDialogBoxInfo[10].sView < 0 ) m_stDialogBoxInfo[10].sView = 0;
	if( m_stDialogBoxInfo[10].sView > DEF_MAXCHATSCROLLMSGS-8 ) m_stDialogBoxInfo[10].sView = DEF_MAXCHATSCROLLMSGS-8;

	d1 = (double)m_stDialogBoxInfo[10].sView;
	d2 = (double)(105);
	d3 = (d1*d2)/(DEF_MAXCHATSCROLLMSGS-8);
	iPointerLoc = (int)d3;
	iPointerLoc = 105 - iPointerLoc;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX +346, sY + 33 + iPointerLoc, 7);

	for (i = 0; i < 8; i++)
	if (m_pChatScrollList[i + m_stDialogBoxInfo[10].sView] != NULL) {
		switch ( m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_dwTime ) {
		case 0:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 230, 230, 230); break;
		case 1:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 130, 200, 130); break;
		case 2:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 255, 130, 130); break;
		case 3:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 130, 130, 255); break;
		case 4:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 230, 230, 130); break;
		case 10: PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 180, 255, 180); break;
		case 20: PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 150, 150, 170); break;
		}
	}
	
	if ( (cLB != 0) && (iGetTopDialogBoxIndex()==10) )
	{ 
		// 스크롤 슬라이드 
		if ((msX >= sX + 336) && (msX <= sX + 361) && (msY >= sY + 28) && (msY <= sY + 140)) { 
			d1 = (double)(msY - (sY + 28));
			d2 = ((DEF_MAXCHATSCROLLMSGS-8)*d1)/105.0f;
			m_stDialogBoxInfo[10].sView = DEF_MAXCHATSCROLLMSGS - 8 - (int)d2;
		}

		if ((msX >= sX + 336) && (msX <= sX + 361) && (msY > sY + 18) && (msY < sY + 28)) 
			m_stDialogBoxInfo[10].sView = DEF_MAXCHATSCROLLMSGS - 8;

		if ((msX >= sX + 336) && (msX <= sX + 361) && (msY > sY + 140) && (msY < sY + 163)) 
			m_stDialogBoxInfo[10].sView = 0;
	}
	else m_stDialogBoxInfo[10].bIsScrollSelected = FALSE;
}


void CGame::DlgBoxClick_ItemUpgrade(int msX, int msY)
{
 short sX, sY;
 int i, iSoX, iSoM;

	sX = m_stDialogBoxInfo[34].sX;
	sY = m_stDialogBoxInfo[34].sY;

	switch (m_stDialogBoxInfo[34].cMode) {
	case 1:
		if ((m_stDialogBoxInfo[34].sV1 != -1) && (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Upgrade
			int iValue = (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_dwAttribute & 0xF0000000) >> 28;
			iValue = iValue*(iValue+6)/8 + 2;
			if( m_iGizonItemUpgradeLeft < iValue ) break;
			PlaySound('E', 14, 5); // v2.16 2002-5-21 고광현 수정 
			PlaySound('E', 44, 0);
			m_stDialogBoxInfo[34].cMode = 2;
			m_stDialogBoxInfo[34].dwV1 = timeGetTime();
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel 
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;

	case 3:
	case 4:
	case 7:
	case 8:
	case 9:
	case 10:

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// OK
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;

	// v2.16 2002-5-20 고광현수정 
	case 5: // 일반 아이템 업그레이드 / 지존 아이템 업그레이드 구분 창 
		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +100) && (msY < sY +115)) {
			PlaySound('E', 14, 5);
			// 일반 아이템을 업그레이드 할 수 있는 조건에 맞는지 검사한다.
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pItemList[i] != NULL) {
				if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 128)) iSoX++;
				if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 129)) iSoM++;
			}
						
			if ((iSoX > 0) || (iSoM > 0)) {
				// 조건 만족
				m_stDialogBoxInfo[34].cMode = 6;
				m_stDialogBoxInfo[34].sV2 = iSoX;
				m_stDialogBoxInfo[34].sV3 = iSoM;
			}
			else AddEventList(DRAW_DIALOGBOX_ITEMUPGRADE30, 10);
		}
		
		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +120) && (msY < sY +135)) {
			m_stDialogBoxInfo[34].cMode = 1;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel 
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;

	case 6:
		if ((m_stDialogBoxInfo[34].sV1 != -1) && (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Upgrade
			PlaySound('E', 14, 5);  
			PlaySound('E', 44, 0);
			m_stDialogBoxInfo[34].cMode = 2;
			m_stDialogBoxInfo[34].dwV1 = timeGetTime();
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel 
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;
	}
}


void CGame::DlgBoxClick_SellList(short msX, short msY)
{
 int i, x; 
 short sX, sY;

 	sX = m_stDialogBoxInfo[31].sX;
	sY = m_stDialogBoxInfo[31].sY;
	
	for (i = 0; i < DEF_MAXSELLLIST; i++) 
	if ((msX > sX + 25) && (msX < sX + 250) && (msY >= sY + 55 + i*15) && (msY <= sY + 55 + 14 + i*15)) {	
		if (m_pItemList[m_stSellItemList[i].iIndex] != NULL) {
			// 클릭되는 순간 아이템 선택 해제
			m_bIsItemDisabled[m_stSellItemList[i].iIndex] = FALSE;
			m_stSellItemList[i].iIndex = -1;
			
			PlaySound('E', 14, 5); 
			
			// 재정렬
			for (x = 0; x < DEF_MAXSELLLIST-1; x++)
			if (m_stSellItemList[x].iIndex == -1) {
				m_stSellItemList[x].iIndex  = m_stSellItemList[x+1].iIndex;
				m_stSellItemList[x].iAmount = m_stSellItemList[x+1].iAmount;

				m_stSellItemList[x+1].iIndex  = -1;
				m_stSellItemList[x+1].iAmount = 0;
			}
		} 
		return;
	} 

	if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Sell
		bSendCommand(MSGID_REQUEST_SELLITEMLIST, NULL, NULL, NULL, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
		DisableDialogBox(31);
	}

	if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Cancel 
		PlaySound('E', 14, 5);
		DisableDialogBox(31);
	}
}

#ifdef _DEBUG
void CGame::DlgBoxClick_LevelUpSettings(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[12].sX;
	sY = m_stDialogBoxInfo[12].sY;
	
	//-50 씩 한 이유는..흐음...

	if ((msX > sX + 228 - 50) && (msX < sX + 237 - 50) && (msY > sY + 177 - 50) && (msY < sY + 187 - 50)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Str++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 228 - 50) && (msX < sX + 237 - 50) && (msY > sY + 197 - 50) && (msY < sY + 206 - 50)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Vit++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 228 - 50) && (msX < sX + 237 - 50) && (msY > sY + 216 - 50) && (msY < sY + 224 - 50)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Dex++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 228 - 50) && (msX < sX + 237 - 50) && (msY > sY + 235 - 50) && (msY < sY + 242 - 50)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Int++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 228 - 50) && (msX < sX + 237 - 50) && (msY > sY + 255 - 50) && (msY < sY + 262 - 50)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Mag++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 228 - 50) && (msX < sX + 237 - 50) && (msY > sY + 274 - 50) && (msY < sY + 280 - 50)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Char++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 245 - 50) && (msX < sX + 253 - 50) && (msY > sY + 177 - 50) && (msY < sY + 187 - 50)) {
		if (m_cLU_Str > 0) {
			m_cLU_Str--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 245 - 50) && (msX < sX + 253 - 50) && (msY > sY + 197 - 50) && (msY < sY + 206 - 50)) {
		if (m_cLU_Vit > 0) {
			m_cLU_Vit--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 245 - 50) && (msX < sX + 253 - 50) && (msY > sY + 216 - 50) && (msY < sY + 224 - 50)) {
		if (m_cLU_Dex > 0) {
			m_cLU_Dex--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 245 - 50) && (msX < sX + 253 - 50) && (msY > sY + 235 - 50) && (msY < sY + 242 - 50)) {
		if (m_cLU_Int > 0) {
			m_cLU_Int--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 245 - 50) && (msX < sX + 253 - 50) && (msY > sY + 255 - 50) && (msY < sY + 262 - 50)) {
		if (m_cLU_Mag > 0) {
			m_cLU_Mag--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 245 - 50) && (msX < sX + 253 - 50) && (msY > sY + 274 - 50) && (msY < sY + 280 - 50)) {
		if (m_cLU_Char > 0) {
			m_cLU_Char--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		if (m_iLU_Point == 0) {
			bSendCommand(MSGID_LEVELUPSETTINGS, NULL, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(12);
		}
		PlaySound('E', 14, 5);
	}
}

#else

void CGame::DlgBoxClick_LevelUpSettings(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[12].sX;
	sY = m_stDialogBoxInfo[12].sY;

	if ((msX > sX + 184) && (msX < sX + 197) && (msY > sY + 110) && (msY < sY + 122)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Str++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 184) && (msX < sX + 197) && (msY > sY + 125) && (msY < sY + 137)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Vit++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 184) && (msX < sX + 197) && (msY > sY + 140) && (msY < sY + 152)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Dex++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 184) && (msX < sX + 197) && (msY > sY + 155) && (msY < sY + 168)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Int++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 184) && (msX < sX + 197) && (msY > sY + 170) && (msY < sY + 183)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Mag++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 184) && (msX < sX + 197) && (msY > sY + 185) && (msY < sY + 198)) {
		if (m_iLU_Point > 0) {
			m_iLU_Point--;
			m_cLU_Char++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 199) && (msX < sX + 212) && (msY > sY + 110) && (msY < sY + 122)) {
		if (m_cLU_Str > 0) {
			m_cLU_Str--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 199) && (msX < sX + 212) && (msY > sY + 125) && (msY < sY + 138)) {
		if (m_cLU_Vit > 0) {
			m_cLU_Vit--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 199) && (msX < sX + 212) && (msY > sY + 140) && (msY < sY + 152)) {
		if (m_cLU_Dex > 0) {
			m_cLU_Dex--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 199) && (msX < sX + 212) && (msY > sY + 155) && (msY < sY + 168)) {
		if (m_cLU_Int > 0) {
			m_cLU_Int--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 199) && (msX < sX + 212) && (msY > sY + 170) && (msY < sY + 183)) {
		if (m_cLU_Mag > 0) {
			m_cLU_Mag--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX > sX + 199) && (msX < sX + 212) && (msY > sY + 185) && (msY < sY + 198)) {
		if (m_cLU_Char > 0) {
			m_cLU_Char--;
			m_iLU_Point++;
		}
		PlaySound('E', 14, 5);
	}

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		if (m_iLU_Point == 0) {
			bSendCommand(MSGID_LEVELUPSETTINGS, NULL, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(12);
		}
		PlaySound('E', 14, 5);
	}
}
#endif

void CGame::CannotConstruct(int iCode)
{
	switch (iCode) {
	case 1: // 너무 인접해서 지을 수 없다.
		SetTopMsg(m_pGameMsgList[18]->m_pMsg, 5);
		break;

	case 2: // 건설 위치와 너무 떨어졌다.
		wsprintf(G_cTxt, "%s XY(%d, %d)", m_pGameMsgList[19]->m_pMsg, m_iConstructLocX, m_iConstructLocY);
		SetTopMsg(G_cTxt, 5);
		break;

	case 3: // 건설 개수 제한에 걸렸다.
		SetTopMsg(m_pGameMsgList[20]->m_pMsg, 5);
		break;
	case 4: // 전쟁유닛 소환 개수가 초과됨
		SetTopMsg(m_pGameMsgList[20]->m_pMsg, 5);
		break;

	}
}

void CGame::DisplayGold(int iGold)
{
	char cGold[20];
	int iStrLen;

	ZeroMemory(cGold, sizeof(cGold));
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	
	itoa(iGold, cGold, 10);

	iStrLen = strlen(cGold);
	iStrLen--;

	int cnt = 0;

	for (int i = 0 ; i < iStrLen+1 ; i++)
	{
	 
		if( (cnt != 0) && ((cnt+1)%4 == 0) )
		{
			G_cTxt[cnt] = ',';
			i--;
		}
		else
			G_cTxt[cnt] = cGold[iStrLen-i];
		cnt++;
	}
	
	iStrLen = strlen(G_cTxt);
	G_cTxt[iStrLen] = '\0';
	strrev(G_cTxt);

//	strcpy(G_cTxt, cGold);
}

void CGame::DrawDialogBox_Inventory(int msX, int msY)
{
 int i;
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 char cItemColor;
	
	sX = m_stDialogBoxInfo[2].sX;
	sY = m_stDialogBoxInfo[2].sY;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX, sY, 0);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_cItemOrder[i] != -1) && (m_pItemList[m_cItemOrder[i]] != NULL)) {
		
		if (((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM) &&
			(m_stMCursor.sSelectedObjectID   ==	m_cItemOrder[i])) || 
			(m_bIsItemEquipped[m_cItemOrder[i]] == TRUE) ) {
		}
		else {
			cItemColor = m_pItemList[m_cItemOrder[i]]->m_cItemColor; // v1.4
			if (m_bIsItemDisabled[ m_cItemOrder[i] ] == TRUE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutTransSprite2(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
					 	                                                sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, dwTime);
				else {
					
					if ((m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_LHAND) ||
						(m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_RHAND) ||
						(m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
						// 무기, 방패등은 컬러 세트가 다르다. 갑옷은 이 색상 세트를 써서는 안된다.
						m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutTransSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																			sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, 
																			m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0],
																			dwTime);
					}
					else {
						m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutTransSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																			sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, 
																			m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0],
																			dwTime);
					}
				}
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutSpriteFast(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																		sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, dwTime);
				else {
					if ((m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_LHAND) ||
						(m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_RHAND) ||
						(m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
						// 무기, 방패등은 컬러 세트가 다르다. 갑옷은 이 색상 세트를 써서는 안된다.
						m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																			sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, 
																			m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0],
																			dwTime);
					}
					else {
						m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																			sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, 
																			m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0],
																			dwTime);
					}
				}
			}

			//수량개념이 있는 아이템...
			if ( (m_pItemList[m_cItemOrder[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
				 (m_pItemList[m_cItemOrder[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {

		#ifdef _DEBUG
				DisplayGold((int)m_pItemList[m_cItemOrder[i]]->m_dwCount);
		#else
				wsprintf(G_cTxt,"%d", (int)m_pItemList[m_cItemOrder[i]]->m_dwCount);
		#endif

				PutString_SprNum(sX + 29 + m_pItemList[m_cItemOrder[i]]->m_sX +10, sY + 41 + m_pItemList[m_cItemOrder[i]]->m_sY +10, G_cTxt, 200, 200, 200);
			}
		}
	}

	if ((msX >= sX +23) && (msX <= sX +76) && (msY >= sY +172) && (msY <= sY +184)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX+23, sY+172, 1);
	}

	if ((msX >= sX +140) && (msX <= sX +212) && (msY >= sY +172) && (msY <= sY +184)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX+140, sY+172, 2);
	}
}


void CGame::CrusadeContributionResult(int iWarContribution)
{
 int i; 
 char cTemp[120];

	DisableDialogBox(18);

	// 텍스트 내용을 작성한다.
	// 내용 클리어.
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != NULL) 
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;
	}  
 
	if (iWarContribution > 0) {

		PlaySound('E', 23, 0, 0);
		PlaySound('C', 21, 0, 0);
		PlaySound('C', 22, 0, 0);

		m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[22]->m_pMsg, NULL); // 축하합니다! 당신의 국가가 
		m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[23]->m_pMsg, NULL); // 전면전에서 승리하였습니다!
		m_pMsgTextList[2] = new class CMsg(NULL, " ", NULL); 
		m_pMsgTextList[3] = new class CMsg(NULL, m_pGameMsgList[24]->m_pMsg, NULL); // 전승국가의 시민으로서
		m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[25]->m_pMsg, NULL); // 당신은 다음과 같은 보상을
		m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[26]->m_pMsg, NULL); // 받게 됩니다.
		m_pMsgTextList[6] = new class CMsg(NULL, " ", NULL); 
		
		m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[27]->m_pMsg, NULL); // 전쟁 공헌도에 따른 경험치:

		ZeroMemory(cTemp, sizeof(cTemp));											// 경험치 량
		wsprintf(cTemp, "+%dExp Points!", iWarContribution); 
		m_pMsgTextList[8] = new class CMsg(NULL, cTemp, NULL); 

		for (i = 9; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 

	}
	else if (iWarContribution < 0) {
		
		PlaySound('E', 24, 0, 0);
		PlaySound('C', 12, 0, 0);
		PlaySound('C', 13, 0, 0);
		
		m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[28]->m_pMsg, NULL); // 아쉽군요! 당신의 국가가 
		m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[29]->m_pMsg, NULL); // 전면전에서 졌습니다.
		m_pMsgTextList[2] = new class CMsg(NULL, " ", NULL); 
		m_pMsgTextList[3] = new class CMsg(NULL, m_pGameMsgList[30]->m_pMsg, NULL); // 패전국가의 시민으로서
		m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[31]->m_pMsg, NULL); // 당신은 전쟁활동에 따른 
		m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[32]->m_pMsg, NULL); // 보상을 받지 못합니다.
		m_pMsgTextList[6] = new class CMsg(NULL, " ", NULL); 
		m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[33]->m_pMsg, NULL); // 다음 전면전에서는 반드시
		m_pMsgTextList[8] = new class CMsg(NULL, m_pGameMsgList[34]->m_pMsg, NULL); // 승리하길 바랍니다.
		
		for (i = 9; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
	} 
	else if (iWarContribution == 0) {
		// 크루세이드 포상 기간 만료로 보상받지 못한다.
		PlaySound('E', 25, 0, 0);

		m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[50]->m_pMsg, NULL); // 당신이 참가했던 전면전은 이미
		m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[51]->m_pMsg, NULL); // 종료되었고 다른 전면전이 진행
		m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[52]->m_pMsg, NULL); // 되었습니다. 
		m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL); 
		m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[53]->m_pMsg, NULL); // 전면전이 끝나고 다음 전면전이
		m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[54]->m_pMsg, NULL); // 시작되기 전에 접속을 해야 
		m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[55]->m_pMsg, NULL); // 전쟁결과에 따른 보상을 받을 수 
		m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[56]->m_pMsg, NULL); // 있습니다.

		for (i = 8; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
	}
	
	// 다이얼로그 박스를 오픈한다.
	EnableDialogBox(18, NULL, NULL, NULL);
}
 

void CGame::CrusadeWarResult(int iWinnerSide)
{
 int i, iPlayerSide; 

	DisableDialogBox(18);

	// 텍스트 내용을 작성한다.
	// 내용 클리어.
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != NULL) 
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;
	} 

	if( m_bCitizen == FALSE ) iPlayerSide = 0;
	else if (m_bAresden == TRUE) iPlayerSide = 1;
	else if (m_bAresden == FALSE) iPlayerSide = 2;

	if (iPlayerSide == 0) {
		// 중립의 입장에서
		switch (iWinnerSide) {
		case 0:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // 전면전이 종료되었습니다.
			m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[36]->m_pMsg, NULL); // 전쟁은 무승부로 막을 내렸
			m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[37]->m_pMsg, NULL); // 습니다.
			m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL); 
			break;
		case 1:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // 전면전이 종료되었습니다.
			m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[38]->m_pMsg, NULL); // 전쟁은 아레스덴의 승리로
			m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[39]->m_pMsg, NULL); // 막을 내렸습니다.
			m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL); 
			break;
		case 2:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // 전면전이 종료되었습니다.
			m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[40]->m_pMsg, NULL); // 전쟁은 엘바인의 승리로
			m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[41]->m_pMsg, NULL); // 막을 내렸습니다.
			m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL); 
			break;
		}

		for (i = 4; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
	}
	else {
		if (iWinnerSide == 0) {
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // 전면전이 종료되었습니다.
			m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[36]->m_pMsg, NULL); // 전쟁은 무승부로 막을 내렸
			m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[37]->m_pMsg, NULL); // 습니다.
			m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL); 

			for (i = 4; i < 18; i++)
				m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
		} 
		else { 
			if (iWinnerSide == iPlayerSide) {
				// 전쟁에서 이겼다.
				PlaySound('E', 23, 0, 0);
				PlaySound('C', 21, 0, 0);
				PlaySound('C', 22, 0, 0);

				switch (iWinnerSide) {
				case 1:
					m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // 전면전이 종료되었습니다!
					m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[38]->m_pMsg, NULL); // 전쟁은 아레스덴의 승리로
					m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[39]->m_pMsg, NULL); // 막을 내렸습니다.
					m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL); 
					m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[42]->m_pMsg, NULL); // 축하합니다!
					m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[43]->m_pMsg, NULL); // 당신은 전승국가의 시민으로서
					m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[44]->m_pMsg, NULL); // 전쟁 중 활동에 따른 포상을
					m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[45]->m_pMsg, NULL); // 받게 됩니다!
					break;
				case 2:
					m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // 전면전이 종료되었습니다!
					m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[40]->m_pMsg, NULL); // 전쟁은 엘바인의 승리로
					m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[41]->m_pMsg, NULL); // 막을 내렸습니다.
					m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL); 
					m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[42]->m_pMsg, NULL); // 축하합니다!
					m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[43]->m_pMsg, NULL); // 당신은 전승국가의 시민으로서
					m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[44]->m_pMsg, NULL); // 전쟁 중 활동에 따른 포상을
					m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[45]->m_pMsg, NULL); // 받게 됩니다!
					break;
				}

				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
			}
			else if (iWinnerSide != iPlayerSide) {
				// 전쟁에서 졌다.
				PlaySound('E', 24, 0, 0);
				PlaySound('C', 12, 0, 0);
				PlaySound('C', 13, 0, 0);
 
				switch (iWinnerSide) {
				case 1:
					m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // 전면전이 종료되었습니다!
					m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[38]->m_pMsg, NULL); // 전쟁은 아레스덴의 승리로
					m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[39]->m_pMsg, NULL); // 막을 내렸습니다.
					m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL); 
					m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[46]->m_pMsg, NULL); // 유감스럽게도, 
					m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[47]->m_pMsg, NULL); // 당신은 패전국가의 시민으로서
					m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[48]->m_pMsg, NULL); // 전쟁 중 활동에 따른 포상을
					m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[49]->m_pMsg, NULL); // 전혀 받을 수 없습니다.
					break;
				case 2:
					m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // 전면전이 종료되었습니다!
					m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[40]->m_pMsg, NULL); // 전쟁은 엘바인의 승리로
					m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[41]->m_pMsg, NULL); // 막을 내렸습니다.
					m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL); 
					m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[46]->m_pMsg, NULL); // 유감스럽게도, 
					m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[47]->m_pMsg, NULL); // 당신은 패전국가의 시민으로서
					m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[48]->m_pMsg, NULL); // 전쟁 중 활동에 따른 포상을
					m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[49]->m_pMsg, NULL); // 전혀 받을 수 없습니다.
					break;
				}

				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
			}
		}
	}
	
	// 다이얼로그 박스를 오픈한다.
	EnableDialogBox(18, NULL, NULL, NULL);

	// 크루세이드 창을 닫는다.
	DisableDialogBox(36); 
	DisableDialogBox(37);
	DisableDialogBox(38);   
}

void CGame::_Draw_UpdateScreen_OnCreateNewAccount()
{
	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWACCOUNT, 0,0,0, TRUE);
	PutString2(329, 110, m_cAccountName, 200,200,200);
	PutString( 329, 125, m_cAccountPassword, RGB(200,200,200), TRUE, 1);
	PutString( 329, 140, m_cAccountPassword, RGB(200,200,200), TRUE, 1);
	PutString2(300, 202, m_cAccountCountry, 200,200,200);
	PutString2(300, 218, m_cAccountSSN, 200,200,200);
	PutString2(194, 257, m_cEmailAddr, 200,200,200);
}

void CGame::DrawChatMsgBox(short sX, short sY, int iChatIndex, BOOL bIsPreDC)
{
 char cMsg[100], cMsgA[22], cMsgB[22], cMsgC[22], * cp;
 int  iRet, iLines, i, iSize, iSize2, iLoc, iFontSize;
 DWORD dwTime;
 COLORREF rgb;
 BOOL bIsTrans;
 RECT rcRect;
 SIZE Size;
	
	ZeroMemory(cMsg, sizeof(cMsg));
	ZeroMemory(cMsgA, sizeof(cMsgA));
	ZeroMemory(cMsgB, sizeof(cMsgB));
	ZeroMemory(cMsgC, sizeof(cMsgC));

	dwTime = m_pChatMsgList[iChatIndex]->m_dwTime;
	strcpy(cMsg, m_pChatMsgList[iChatIndex]->m_pMsg);
	cp = (char *)cMsg;
	iLines = 0;

	rgb = RGB(255,255,255); 
	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 1:	 
		rgb = RGB(255,255,255); 
		break;
	case 20: 
		rgb = RGB(255,255,20);  
		// 메시지 표시에 딜레이가 걸린다.
		if ((m_dwCurTime - dwTime) < 650) return; 
		else dwTime += 650;
		break;
	case 41:
		rgb = RGB(255,80,80);  
		break;
	
	case 42:
		rgb = RGB(255,80,80);  
		if ((m_dwCurTime - dwTime) < 650) return; 
		else dwTime += 650;
		break;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgA, cp, 20);
		
		iRet = GetCharKind(cMsgA, 19);
		if (iRet == CODE_HAN1) {
			cMsgA[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 1;
	}
	
	if (strlen(cp) != 0) {
		memcpy(cMsgB, cp, 20);
		
		iRet = GetCharKind(cMsgB, 19);
		if (iRet == CODE_HAN1) {
			cMsgB[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 2;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgC, cp, 20);
		
		iRet = GetCharKind(cMsgC, 19);
		if (iRet == CODE_HAN1) {
			cMsgC[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 3;
	}

	iSize = 0;
	for (i = 0; i < 20; i++) 
	if (cMsgA[i] != 0)

	if ((unsigned char)cMsgA[i] >= 128) {
		iSize += 5;	//6
		i++;
	}
	else iSize += 4;
	
	iLoc = m_dwCurTime - dwTime;
	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 21:
	case 22:
	case 23://데미지는 빨리 뜨고...
		if( iLoc > 80 ) iLoc = 10;
		else iLoc = iLoc>>3;
		break;
	default://나머지는 이쁘게 뜬다...
		if( iLoc > 352 ) iLoc = 9;
		else if( iLoc > 320 ) iLoc = 10;
		else iLoc = iLoc>>5;
		break;
	}

	// v1.42
	if (m_cDetailLevel == 0) 
		 bIsTrans = FALSE;
	else bIsTrans = TRUE;
	
	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 41:
	case 42:
		// 마법 캐스팅 
		iSize2 = 0;
		for (i = 0; i < 100; i++) 
		if (cMsg[i] != 0)
		if ((unsigned char)cMsg[i] >= 128) {
			iSize2 += 5;	//6
			i++;
		}
		else iSize2 += 4;
		if( m_Misc.bCheckIMEString(cMsg) == FALSE )
		{
			PutString(sX - iSize2, sY - 65 - iLoc, cMsg, RGB(180, 30, 30));
			PutString(sX - iSize2+1, sY - 65 - iLoc, cMsg, RGB(180, 30, 30));
		}
		else PutString_SprFont3(sX - iSize2, sY - 65 - iLoc, cMsg, m_wR[14]*4, m_wG[14]*4, m_wB[14]*4, FALSE, 0);
		break;
	
	case 21:
	case 22:
	case 23:
		// 대미지
		iFontSize = 23 - (int)m_pChatMsgList[iChatIndex]->m_cType;
		switch (iLines) {
		case 1:
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgA, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			break;
		case 2:
			PutString_SprFont3(sX - iSize, sY - 81 - iLoc,  cMsgA, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc,  cMsgB, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			break;
		case 3:
			PutString_SprFont3(sX - iSize, sY - 97 - iLoc, cMsgA, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 81 - iLoc, cMsgB, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgC, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			break;
		}
		break;

	case 20:
	default:
		// 일반 채팅 
		if (bIsPreDC == FALSE)
			m_DDraw._GetBackBufferDC();
		
		GetTextExtentPoint32(m_DDraw.m_hDC, cMsg, strlen(cMsg), &Size);
		
		switch (Size.cx / 160) {
		case 0:
			SetRect(&rcRect, sX-80 +1, sY-65 -iLoc, sX+80 +1, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));
			
			SetRect(&rcRect, sX-80, sY-65 -iLoc +1, sX+80, sY -iLoc +1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));

			SetRect(&rcRect, sX-80, sY-65 -iLoc, sX+80, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;
		
		case 1:
			SetRect(&rcRect, sX-80 +1, sY-83 -iLoc, sX+80 +1, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));
			
			SetRect(&rcRect, sX-80, sY-83 -iLoc +1, sX+80, sY -iLoc +1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));
						
			SetRect(&rcRect, sX-80, sY-83 -iLoc, sX+80, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;
		
		case 2:
			SetRect(&rcRect, sX-80 +1, sY-101 -iLoc, sX+80 +1, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));
			
			SetRect(&rcRect, sX-80, sY-101 -iLoc +1, sX+80, sY -iLoc +1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));
			
			SetRect(&rcRect, sX-80, sY-101 -iLoc, sX+80, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;
		
		case 3:
			SetRect(&rcRect, sX-80 +1, sY-119 -iLoc, sX+80 +1, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));
			
			SetRect(&rcRect, sX-80, sY-119 -iLoc +1, sX+80, sY -iLoc +1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));
			
			SetRect(&rcRect, sX-80, sY-119 -iLoc, sX+80, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;
		}
		
		if (bIsPreDC == FALSE)
			m_DDraw._ReleaseBackBufferDC();
		break;
	} 
} 

void CGame::ClearContents_OnSelectCharacter()
{
	m_cCurFocus = 1;
}

#if DEF_LANGUAGE == 1
void CGame::UpdateScreen_OnSelectCharacter() 
{
 short sX, sY, msX, msY, msZ;
 char  cLB, cRB, cTotalChar;
 char  cMIresult;
 static class CMouseInterface * pMI; 
 DWORD dwTime;
 static DWORD dwCTime;
 
 int iMIbuttonNum;

	dwTime = timeGetTime(); 
	sX = 0; 
	sY = 0; 
	cTotalChar = 0;

	if (m_cGameModeCount == 0) {
		
		// 초기 데이터로 게임을 초기화 한후 스프라이트를 로딩, 게임 접근 준비를 한다.
		G_cSpriteAlphaDegree = 1;
		
		InitGameSettings();

		pMI = new class CMouseInterface;
		pMI->AddRect(100, 50, 210, 250);
		pMI->AddRect(211, 50, 321, 250);
		pMI->AddRect(322, 50, 431, 250);
		pMI->AddRect(432, 50, 542, 250);

		pMI->AddRect(360,283,545,315);
		pMI->AddRect(360,316,545,345);
		pMI->AddRect(360,346,545,375);
		pMI->AddRect(360,376,545,405);
//		pMI->AddRect(360,406,545,435);
		
		m_cMaxFocus = 4;
		if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		if (m_cCurFocus < 1)		   m_cCurFocus = 1;

		m_cArrowPressed = 0;
		m_bEnterPressed = FALSE;
		
		dwCTime = timeGetTime();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 2:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다. 
		m_bEnterPressed = FALSE;
		PlaySound('E', 14, 5);

		if (m_pCharList[m_cCurFocus-1] != NULL) {
			if (m_pCharList[m_cCurFocus-1]->m_sSex != NULL) {
				// 접속 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
				ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
				strcpy(m_cPlayerName, m_pCharList[m_cCurFocus-1]->m_cName);
				
				m_iLevel = (int)m_pCharList[m_cCurFocus-1]->m_sLevel;
			
				if (m_Misc.bCheckValidString(m_cPlayerName) == TRUE) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
					m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
					m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
					m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
					m_pLSock->bInitBufferSize(30000);
					// 게임모드 변환 
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
					m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
					m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
					ZeroMemory(m_cMsg, sizeof(m_cMsg));
					strcpy(m_cMsg,"33");
					
					// v1.43
					ZeroMemory(m_cMapName, sizeof(m_cMapName));
					int iTemp = strlen( m_pCharList[m_cCurFocus-1]->m_cMapName );
					if( iTemp > 10 ) iTemp = 10;
					memcpy(m_cMapName, m_pCharList[m_cCurFocus-1]->m_cMapName, iTemp);
					
					delete pMI;
					return;
				} 
			}
			else {
				// 손상된 캐릭터 데이터로 접속할 수는 없다.
			}
		}
		else {
	  		// 새 캐릭터를 만든다.
			_InitOnCreateNewCharacter();
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			delete pMI;
			return;
		}
	} 

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	UpdateScreen_OnSelectCharacter(sX, sY, msX, msY);

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	DrawVersion();
	// 마우스 커서 그린다.
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			if (m_cCurFocus != iMIbuttonNum)
				m_cCurFocus = iMIbuttonNum;
			else {
				if (m_pCharList[m_cCurFocus-1] != NULL) {
					if (m_pCharList[m_cCurFocus-1]->m_sSex != NULL) {
						// 선택된 캐릭으로 접속시도를 한다. 
						// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
						ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
						strcpy(m_cPlayerName, m_pCharList[m_cCurFocus-1]->m_cName);
						m_iLevel = (int)m_pCharList[m_cCurFocus-1]->m_sLevel;

						if (m_Misc.bCheckValidString(m_cPlayerName) == TRUE) {
							m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
							m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
							m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
							m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
							m_pLSock->bInitBufferSize(30000);
							// 게임모드 변환 
							ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
							m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
							m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
							ZeroMemory(m_cMsg, sizeof(m_cMsg));
							strcpy(m_cMsg,"33");

							// v1.43
							ZeroMemory(m_cMapName, sizeof(m_cMapName));
							memcpy(m_cMapName, m_pCharList[m_cCurFocus-1]->m_cMapName, 10);
					
							delete pMI;
							return;
						}
					}
					else {
						// 손상된 캐릭터로는 접속이 불가능하다. 
					}
				}
				else {
					// 새 캐릭터를 만든다.
					_InitOnCreateNewCharacter();
					ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
					delete pMI;
					return;
				}
			}
			break;

		case 5:
			if (m_pCharList[m_cCurFocus - 1] != NULL) {
				if (m_pCharList[m_cCurFocus-1]->m_sSex != NULL) {
					// 선택되어 있는 캐릭터로 접속을 시도한다.
					// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
					ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
					strcpy(m_cPlayerName, m_pCharList[m_cCurFocus-1]->m_cName);
					m_iLevel = (int)m_pCharList[m_cCurFocus-1]->m_sLevel;

					if (m_Misc.bCheckValidString(m_cPlayerName) == TRUE) {
						m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
						m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
						m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
						m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
						m_pLSock->bInitBufferSize(30000);
						// 게임모드 변환 
						ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
						m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
						m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
						ZeroMemory(m_cMsg, sizeof(m_cMsg));
						strcpy(m_cMsg,"33");

						// v1.43
						ZeroMemory(m_cMapName, sizeof(m_cMapName));
						memcpy(m_cMapName, m_pCharList[m_cCurFocus-1]->m_cMapName, 10);
					
						delete pMI;
						return;
					}
				}
				else {
					// 손상된 캐릭터로는 접속이 불가능하다. 
				}
			}
			break;

		case 6:
			if (m_iTotalChar < 4) {
				//
				_InitOnCreateNewCharacter();
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				delete pMI;
				return;
			}
			break;
		
		case 7:
			// 캐릭터를 지운다.	확인 화면으로 전환.
			if ((m_pCharList[m_cCurFocus - 1] != NULL) && (m_pCharList[m_cCurFocus - 1]->m_sLevel < 50)) {
				//
				ChangeGameMode(DEF_GAMEMODE_ONQUERYDELETECHARACTER);
				m_wEnterGameType = m_cCurFocus; // 지울 캐릭터의 인덱스값 !!!@@@@@@@@
				delete pMI;
				return;
			}
			break;
		
		case 8:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#else

void CGame::UpdateScreen_OnSelectCharacter() 
{
 short sX, sY, msX, msY, msZ;
 char  cLB, cRB, cTotalChar;
 char  cMIresult;
 static class CMouseInterface * pMI; 
 DWORD dwTime;
 static DWORD dwCTime;
 
 int iMIbuttonNum;

	dwTime = timeGetTime(); 
	sX = 0; 
	sY = 0; 
	cTotalChar = 0;

	if (m_cGameModeCount == 0) {
		
		// 초기 데이터로 게임을 초기화 한후 스프라이트를 로딩, 게임 접근 준비를 한다.
		G_cSpriteAlphaDegree = 1;
		
		InitGameSettings();

		pMI = new class CMouseInterface;
		pMI->AddRect(100, 50, 210, 250);
		pMI->AddRect(211, 50, 321, 250);
		pMI->AddRect(322, 50, 431, 250);
		pMI->AddRect(432, 50, 542, 250);

		pMI->AddRect(360,283,545,315);
		pMI->AddRect(360,316,545,345);
		pMI->AddRect(360,346,545,375);
		pMI->AddRect(360,376,545,405);
		pMI->AddRect(360,406,545,435);
		
		m_cMaxFocus = 4;
		if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		if (m_cCurFocus < 1)		   m_cCurFocus = 1;

		m_cArrowPressed = 0;
		m_bEnterPressed = FALSE;
		
		dwCTime = timeGetTime();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 2:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEscPressed == TRUE) {
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다. 
		m_bEnterPressed = FALSE;
		PlaySound('E', 14, 5);

		if (m_pCharList[m_cCurFocus-1] != NULL) {
			if (m_pCharList[m_cCurFocus-1]->m_sSex != NULL) {
				// 접속 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
				ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
				strcpy(m_cPlayerName, m_pCharList[m_cCurFocus-1]->m_cName);
				
				m_iLevel = (int)m_pCharList[m_cCurFocus-1]->m_sLevel;
			
				if (m_Misc.bCheckValidString(m_cPlayerName) == TRUE) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
					m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
					m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
					m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
					m_pLSock->bInitBufferSize(30000);
					// 게임모드 변환 
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
					m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
					m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
					ZeroMemory(m_cMsg, sizeof(m_cMsg));
					strcpy(m_cMsg,"33");
					
					// v1.43
					ZeroMemory(m_cMapName, sizeof(m_cMapName));
					memcpy(m_cMapName, m_pCharList[m_cCurFocus-1]->m_cMapName, 10);
					
					delete pMI;
					return;
				} 
			}
			else {
				// 손상된 캐릭터 데이터로 접속할 수는 없다.
			}
		}
		else {
	  		// 새 캐릭터를 만든다.
			_InitOnCreateNewCharacter();
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			delete pMI;
			return;
		}
	} 

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	UpdateScreen_OnSelectCharacter(sX, sY, msX, msY);

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	DrawVersion();
	// 마우스 커서 그린다.
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			if (m_cCurFocus != iMIbuttonNum)
				m_cCurFocus = iMIbuttonNum;
			else {
				if (m_pCharList[m_cCurFocus-1] != NULL) {
					if (m_pCharList[m_cCurFocus-1]->m_sSex != NULL) {
						// 선택된 캐릭으로 접속시도를 한다. 
						// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
						ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
						strcpy(m_cPlayerName, m_pCharList[m_cCurFocus-1]->m_cName);
						m_iLevel = (int)m_pCharList[m_cCurFocus-1]->m_sLevel;

						if (m_Misc.bCheckValidString(m_cPlayerName) == TRUE) {
							m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
							m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
							m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
							m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
							m_pLSock->bInitBufferSize(30000);
							// 게임모드 변환 
							ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
							m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
							m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
							ZeroMemory(m_cMsg, sizeof(m_cMsg));
							strcpy(m_cMsg,"33");

							// v1.43
							ZeroMemory(m_cMapName, sizeof(m_cMapName));
							memcpy(m_cMapName, m_pCharList[m_cCurFocus-1]->m_cMapName, 10);
					
							delete pMI;
							return;
						}
					}
					else {
						// 손상된 캐릭터로는 접속이 불가능하다. 
					}
				}
				else {
					// 새 캐릭터를 만든다.
					_InitOnCreateNewCharacter();
					ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
					delete pMI;
					return;
				}
			}
			break;

		case 5:
			if (m_pCharList[m_cCurFocus - 1] != NULL) {
				if (m_pCharList[m_cCurFocus-1]->m_sSex != NULL) {
					// 선택되어 있는 캐릭터로 접속을 시도한다.
					// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
					ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
					strcpy(m_cPlayerName, m_pCharList[m_cCurFocus-1]->m_cName);
					m_iLevel = (int)m_pCharList[m_cCurFocus-1]->m_sLevel;

					if (m_Misc.bCheckValidString(m_cPlayerName) == TRUE) {
						m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
						m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
						m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
						m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
						m_pLSock->bInitBufferSize(30000);
						// 게임모드 변환 
						ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
						m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
						m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
						ZeroMemory(m_cMsg, sizeof(m_cMsg));
						strcpy(m_cMsg,"33");

						// v1.43
						ZeroMemory(m_cMapName, sizeof(m_cMapName));
						memcpy(m_cMapName, m_pCharList[m_cCurFocus-1]->m_cMapName, 10);
					
						delete pMI;
						return;
					}
				}
				else {
					// 손상된 캐릭터로는 접속이 불가능하다. 
				}
			}
			break;

		case 6:
			if (m_iTotalChar < 4) {
				//
				_InitOnCreateNewCharacter();
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				delete pMI;
				return;
			}
			break;
		
		case 7:
			// 캐릭터를 지운다.	확인 화면으로 전환.
			if ((m_pCharList[m_cCurFocus - 1] != NULL) && (m_pCharList[m_cCurFocus - 1]->m_sLevel < 50)) {
				//
				ChangeGameMode(DEF_GAMEMODE_ONQUERYDELETECHARACTER);
				m_wEnterGameType = m_cCurFocus; // 지울 캐릭터의 인덱스값 !!!@@@@@@@@
				delete pMI;
				return;
			}
			break;
		
		case 8:
//2002.0926 정진광, 테라 버전은 비번 변경이 안된다.
#ifndef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD);
			delete pMI;
#endif
			return;

		case 9:
	
		#ifdef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
		#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		#endif
			delete pMI;
			return;
		}
	}

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}
#endif

BOOL CGame::bDlgBoxPress_Character(short msX, short msY)
{
	int i;
	short sX, sY, sSprH, sFrame;
	char cEquipPosStatus[DEF_MAXITEMEQUIPPOS];

	if (m_bIsDialogEnabled[17] == TRUE) return FALSE;
 
	sX = m_stDialogBoxInfo[1].sX;
	sY = m_stDialogBoxInfo[1].sY;
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) cEquipPosStatus[i] = -1;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if ((m_pItemList[i] != NULL) && (m_bIsItemEquipped[i] == TRUE))	cEquipPosStatus[ m_pItemList[i]->m_cEquipPos ] = i;
	}

	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		if (cEquipPosStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison( sX + 41, sY + 137, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6))
	{
		if (cEquipPosStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if ((cEquipPosStatus[DEF_EQUIPPOS_BOOTS] != -1)) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
	}
	return FALSE;
}

void CGame::DlgBoxClick_CityhallMenu(short msX, short msY)
{
 short sX, sY;

	// 시티홀 메누가 선택되었다. 서버로 전송하고 응답을 기다려야 한다.
	sX = m_stDialogBoxInfo[13].sX;
	sY = m_stDialogBoxInfo[13].sY;

	switch (m_stDialogBoxInfo[13].cMode) {
	case 0:
		// 시청 디폴트 메뉴
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95)) {
			if (m_bCitizen == TRUE) return;
			// 시민권 신청 확인상태로 전환한다.
			m_stDialogBoxInfo[13].cMode = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120)) {
			if (m_iRewardGold <= 0) return;
			// 포상금 습득 확인 화면으로 전환한다.
			m_stDialogBoxInfo[13].cMode = 5;
			PlaySound('E', 14, 5);
		} 
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145)) {
			if (m_iEnemyKillCount < 300) return;
			// 영웅의 망토 확인 화면으로 전환한다.
			m_stDialogBoxInfo[13].cMode = 7;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 170)) {
			if (m_stQuest.sQuestType == NULL) return;
			// 퀘스트 취소 화면으로 전환한다.
			m_stDialogBoxInfo[13].cMode = 8;
			PlaySound('E', 14, 5);
		}

//#if DEF_LANGUAGE > 2		// Korea 2.19
	#ifndef DEF_JAPAN_FOR_TERRA
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 170) && (msY < sY + 195)) {
			if (m_bIsCrusadeMode) return;
			if (m_iPKCount != 0) return;
			if (m_bCitizen == FALSE) return;
			if ((m_iLevel > 100) && (m_bHunter==FALSE)) return;
			
			// 민간인, 병사...모드 전화화면으로 전환한다.
			m_stDialogBoxInfo[13].cMode = 9;
			PlaySound('E', 14, 5);
		}

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 195) && (msY < sY + 220)) {
			// 던전2층으로 텔레포트한다.
			m_stDialogBoxInfo[13].cMode = 10;
			m_iTeleportMapCount = -1;
			bSendCommand(MSGID_REQUEST_TELEPORT_LIST, NULL, NULL, NULL, NULL, NULL, NULL);
			PlaySound('E', 14, 5);
		}
	#endif
//#endif

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 195) && (msY < sY + 220)) {
			if (m_bIsCrusadeMode == FALSE) return;
			// 크루세이드 직업 변경 화면으로 전환한다.
			EnableDialogBox(33, 1, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;
	
	case 1:
		// 시민권 신청 화면
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Yes버튼 Click되었다. 시민권 신청 메시지 전송.
			bSendCommand(MSGID_REQUEST_CIVILRIGHT, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL); 
			m_stDialogBoxInfo[13].cMode = 2;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No버튼 Click되었다
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 3:
		// 시민권 신청 실패 확인화면
	case 4:
		// 시민권 신청 성공 화면
		// OK버튼 
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No버튼 Click되었다
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 5:
		// 포상금 습득 확인 화면
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Yes버튼 Click되었다. 포상금을 받는다는 메지지 전송.
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETREWARDMONEY, NULL, NULL, NULL, NULL, NULL); 
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);

		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No버튼 Click되었다
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 7:
		// 영웅의 망토 습득 확인화면
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Yes버튼 Click되었다. 
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETHEROMANTLE, NULL, NULL, NULL, NULL, NULL); 
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);

		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No버튼 Click되었다
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 8:
		// 퀘스트 취소 확인화면
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Yes버튼 Click되었다.
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_CANCELQUEST, NULL, NULL, NULL, NULL, NULL); 
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No버튼 Click되었다.
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 9:
		// 게임모드
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Yes버튼 Click되었다.
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_HUNTMODE, NULL, NULL, NULL, NULL, NULL); 
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No버튼 Click되었다.
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 10:
		if( m_iTeleportMapCount > 0 )
		{
			for( int i=0 ; i<m_iTeleportMapCount ; i++ )
			{
				if( (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 130 + i*15) && (msY <= sY + 144 + i*15) )
				{
					//TEST CODE
					//wsprintf( G_cTxt, "i : %d, Index : %d, MapName : %s", i, m_stTeleportList[i].iIndex, m_stTeleportList[i].mapname );
					//AddEventList( G_cTxt, 10 );
					bSendCommand(MSGID_REQUEST_CHARGED_TELEPORT, NULL, NULL, m_stTeleportList[i].iIndex, NULL, NULL, NULL); 
					DisableDialogBox(13);
					return;
				}
			}
		}
		break;
	}
}

void CGame::CivilRightAdmissionHandler(char *pData)
{
 WORD * wp, wResult;
 char * cp;
	
	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wResult = *wp;

	switch (wResult) {
	case 0:
		// 시민권 획득에 실패하였다.
		m_stDialogBoxInfo[13].cMode = 4;
		break;

	case 1:
		// 시민권 획득에 성공하였다.
		m_stDialogBoxInfo[13].cMode = 3;
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(m_cLocation, sizeof(m_cLocation));
		memcpy(m_cLocation, cp, 10);
		if (memcmp(m_cLocation, "aresden", 7) == 0)
		{
			m_bAresden = TRUE;
			m_bCitizen = TRUE;
			m_bHunter = FALSE;
		}
		else if (memcmp(m_cLocation, "arehunter", 9) == 0)
		{
			m_bAresden = TRUE;
			m_bCitizen = TRUE;
			m_bHunter = TRUE;
		}
		else if (memcmp(m_cLocation, "elvine", 6) == 0)
		{
			m_bAresden = FALSE;
			m_bCitizen = TRUE;
			m_bHunter = FALSE;
		}
		else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
		{
			m_bAresden = FALSE;
			m_bCitizen = TRUE;
			m_bHunter = TRUE;
		}
		else
		{
			m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter = TRUE;
		}
		break;
	}
}


void CGame::DlgBoxClick_Text(short msX, short msY)
{ 
 short sX, sY;

	sX = m_stDialogBoxInfo[18].sX;
	sY = m_stDialogBoxInfo[18].sY;

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		DisableDialogBox(18);
		PlaySound('E', 14, 5);
	}
}

void CGame::DlgBoxClick_Inventory(short msX, short msY)
{ 
 int i, sX, sY;

	sX = m_stDialogBoxInfo[2].sX;
	sY = m_stDialogBoxInfo[2].sY;

	if ((msX >= sX +23) && (msX <= sX +76) && (msY >= sY +172) && (msY <= sY +184)) {
		if( m_iGizonItemUpgradeLeft == NULL ) m_iGizonItemUpgradeLeft = 0;
		// v2.16 2002-5-20 고광현수정 
		EnableDialogBox(34, 5, NULL, NULL);
		PlaySound('E', 14, 5);
	}

	if ((msX >= sX +140) && (msX <= sX +212) && (msY >= sY +172) && (msY <= sY +184)) {
		// 무기 제작 스킬 
		if (m_cSkillMastery[13] == 0) {
			AddEventList(DLGBOXCLICK_INVENTORY1, 10);
			AddEventList(DLGBOXCLICK_INVENTORY2, 10);
		}
		else if (m_bSkillUsingStatus == TRUE) {
			AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//"이미 다른 기술을 쓰고 있습니다."
			return;
		}
		else if (_bIsItemOnHand() == TRUE) {
			AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"이 아이템을 사용하기 위해서는 두손이 자유로와야 합니다."
			return;
		}
		else {
			// 강철 모루대를 갖고 있는지 검색, 있으면 인터페이스 연다. 
			//
			for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pItemList[i] != NULL) && (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) && 
				(m_pItemList[i]->m_sSpriteFrame == 113) && (m_pItemList[i]->m_wCurLifeSpan > 0)) {
				// 강철 모루대 아이템 발견 
				EnableDialogBox(26, 3, NULL, NULL, NULL);
				AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY12, 10);
				PlaySound('E', 14, 5);
				return;
			}
			AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY14, 10);
			//
		}
		PlaySound('E', 14, 5);
	}
}

void CGame::DlgBoxClick_Character(short msX, short msY)
{
 short sX, sY;  

	sX = m_stDialogBoxInfo[1].sX; 
	sY = m_stDialogBoxInfo[1].sY;
 
	if ((msX >= sX + 15) && (msX <= sX + 15 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY)) {
		EnableDialogBox(28, 1, NULL, NULL);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}
	else if ((msX >= sX + 98) && (msX <= sX + 98 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY)) {
		EnableDialogBox(32, NULL, NULL, NULL);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}
	else if ((msX >= sX + 180) && (msX <= sX + 180 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY)) {
		EnableDialogBox(12, NULL, NULL, NULL);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}
}

void CGame::DlgBoxClick_FeedBackCard(short msX, short msY)
{

}

void CGame::DlgBoxClick_MagicShop(short msX, short msY)
{
 int i, iCPivot, iYloc, iAdjX, iAdjY ;
 short sX, sY;

	sX = m_stDialogBoxInfo[16].sX;   
	sY = m_stDialogBoxInfo[16].sY; 

	iAdjX = -20 ; 
	iAdjY = -35 ;
	
	// 보고있는 마법의 Circle기준점 
	iCPivot = m_stDialogBoxInfo[16].sView*10;   

	iYloc = 0;
	for (i = 0; i < 9; i++) {
		if ((m_pMagicCfgList[iCPivot + i] != NULL) && (m_pMagicCfgList[iCPivot + i]->m_bIsVisible)) {
			if ((msX >= sX + iAdjX + 44) && (msX <= sX + iAdjX + 135 + 44) && (msY >= sY + iAdjY + 70 + iYloc +35) && (msY <= sY + iAdjY + 70 + 14 + iYloc +35)) {
				if (m_cMagicMastery[iCPivot + i] == 0) {
					// 마법이 선택되었다. 배우지 않은 마법이므로 요청 메시지를 보낸다. 
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_STUDYMAGIC, NULL, NULL, NULL, NULL, m_pMagicCfgList[iCPivot + i]->m_cName);
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_STUDYMAGIC, NULL, iCPivot + i, NULL, NULL, NULL); //2002.02.07 상하 변경 배우고싶은 매직네임에서 마법번호로 변경..
					PlaySound('E', 14, 5);
				}
				return;
			}
			iYloc += 18;
		}
	}

	if ((msX >= sX + iAdjX + 42 +31) && (msX <= sX + iAdjX + 50 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 0;
	if ((msX >= sX + iAdjX + 55 +31) && (msX <= sX + iAdjX + 68 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 1;
	if ((msX >= sX + iAdjX + 73 +31) && (msX <= sX + iAdjX + 93 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 2;
	if ((msX >= sX + iAdjX + 98 +31) && (msX <= sX + iAdjX + 113 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 3;
	if ((msX >= sX + iAdjX + 118 +31) && (msX <= sX + iAdjX + 129 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 4;
	if ((msX >= sX + iAdjX + 133 +31) && (msX <= sX + iAdjX + 150 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 5;
	if ((msX >= sX + iAdjX + 154 +31) && (msX <= sX + iAdjX + 177 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 6;
	if ((msX >= sX + iAdjX + 181 +31) && (msX <= sX + iAdjX + 210 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 7;
	if ((msX >= sX + iAdjX + 214 +31) && (msX <= sX + iAdjX + 230 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 8;
	if ((msX >= sX + iAdjX + 234 +31) && (msX <= sX + iAdjX + 245 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35)) 
		m_stDialogBoxInfo[16].sView = 9;
}

void CGame::_RemoveChatMsgListByObjectID(int iObjectID)
{
 int i;

	for (i = 1; i < DEF_MAXCHATMSGS; i++) 
	if ((m_pChatMsgList[i] != NULL) && (m_pChatMsgList[i]->m_iObjectID == iObjectID)) {
		delete m_pChatMsgList[i];
		m_pChatMsgList[i] = NULL;
	}
}

void CGame::PlaySound(char cType, int iNum, int iDist, long lPan)
{
 int iVol;

	if (m_bSoundFlag == FALSE) return;
	if (m_bSoundStat == FALSE) return;

	if (iDist > 10) iDist = 10;

	iVol = (m_cSoundVolume - 100)*20;   
	iVol += -200 * iDist; 

	if (iVol > 0) iVol = 0;
	if (iVol < -10000) iVol = -10000;

	if (iVol > -2000) {
	
		switch (cType) {
		case 'C':
			if (m_pCSound[iNum] == NULL) return;
			m_pCSound[iNum]->Play(FALSE, lPan, iVol); 
			break;

		case 'M':
			if (m_pMSound[iNum] == NULL) return;
			m_pMSound[iNum]->Play(FALSE, lPan, iVol); 
			break;

		case 'E':
			if (m_pESound[iNum] == NULL) return;
			m_pESound[iNum]->Play(FALSE, lPan, iVol); 
			break;
		}
	}
} 

void CGame::_DrawBlackRect(int iSize)
{
 int ix, iy, sx, sy, dcx, dcy;
 DWORD dwTime;

	dwTime = timeGetTime();

	dcx = 40 - iSize*2;
	dcy = 30 - iSize*2;

	sx = iSize*16;
	sy = iSize*16;

	for (ix = 0; ix < dcx; ix++) {
		m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(ix*16 + sx, iSize*16,       12, dwTime);
		m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(ix*16 + sx, 464 - iSize*16, 12, dwTime);
	}

	for (iy = 0; iy < dcy; iy++) {
		m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(iSize*16,       iy*16 + sy, 12, dwTime);
		m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(624 - iSize*16, iy*16 + sy, 12, dwTime);
	}
}

BOOL CGame::_bCheckItemByType(char cType)
{
 int i;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ( (m_pItemList[i] != NULL) && (m_pItemList[i]->m_cItemType == cType) ) return TRUE;

	return FALSE;
}


void CGame::DynamicObjectHandler(char * pData)
{
 WORD * wp;
 char * cp;
 short * sp, sX, sY, sV1, sV2, sV3;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE);
	wp = (WORD *)cp;
	cp += 2;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	sp = (short *)cp;
	sV1 = *sp;
	cp += 2;

	sp = (short *)cp;
	sV2 = *sp;		   // Dyamic Object Index
	cp += 2;

	sp = (short *)cp;
	sV3 = *sp;
	cp += 2;

	switch (*wp) {
	case DEF_MSGTYPE_CONFIRM:
		// Dynamic Object가 발생했다. 
		m_pMapData->bSetDynamicObject(sX, sY, sV2, sV1, TRUE);
		break;

	case DEF_MSGTYPE_REJECT:
		// Dynamic object가 사라졌다.
		m_pMapData->bSetDynamicObject(sX, sY, sV2, NULL, TRUE);
		break;
	}
}


BOOL CGame::_bIsItemOnHand()
{
 int i;
 WORD wWeaponType;

	for (i = 0; i < DEF_MAXITEMS; i++) 
	if ((m_pItemList[i] != NULL) && (m_bIsItemEquipped[i] == TRUE)) {
		if (m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_RHAND) {
			wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);		
			if ((wWeaponType >= 35) && (wWeaponType < 40)) 
				 return FALSE; // 지팡류는 들고 있어도 마법을 사용할 수 있다.
			else if( wWeaponType == 27 ) return FALSE;
			else return TRUE;
		}
		
		if ((m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_LHAND)	||
			(m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) 
			return TRUE;
	}

	return FALSE;
}

int CGame::_iCalcTotalWeight()
{
 int i, iWeight, iCnt, iTemp;
	
	iCnt = 0;
	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL) {
		
		if ( (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			 (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			// v1.432 Gold인 경우 무게는 20분의 1
			iTemp = m_pItemList[i]->m_wWeight * m_pItemList[i]->m_dwCount;
			if (strcmp(m_pItemList[i]->m_cName, "Gold") == 0) iTemp = iTemp / 20;
			
			iWeight += iTemp;
		}
		else iWeight += m_pItemList[i]->m_wWeight;

		iCnt++;
	}

	return iWeight;	
}

void CGame::DlgBoxClick_15AgeMsg(short msX, short msY)// 정진광.
{
	short sX, sY;
	sX = m_stDialogBoxInfo[5].sX;
	sY = m_stDialogBoxInfo[5].sY;

	//2003.06.09 정진광. 진정피드백과 함께 쓰인다...
#ifdef DEF_FEEDBACKCARD
	m_iFeedBackCardIndex = -1;
	DisableDialogBox(5);
#else

    if ((msX >= sX + 120 ) && (msX <= sX + 120 + DEF_BTNSZX ) && (msY >= sY + 127 ) && (msY <= sY + 127 + DEF_BTNSZY)) 
	   DisableDialogBox(5);
#endif
}


void CGame::DlgBoxClick_WarningMsg(short msX, short msY)// 정진광.
{
	short sX, sY;
	sX = m_stDialogBoxInfo[6].sX;
	sY = m_stDialogBoxInfo[6].sY;

    if ((msX >= sX + 120 ) && (msX <= sX + 120 + DEF_BTNSZX ) && (msY >= sY + 127 ) && (msY <= sY + 127 + DEF_BTNSZY)) 
	   DisableDialogBox(6);
}

void CGame::DlgBoxClick_ItemDrop(short msX, short msY)
{
  	short sX, sY;

	// 명령이 유효하지 않은 상태라면(죽었다거나) 명령을 수행할 수 없다.
	if (m_cCommand < 0) return;
	
	sX = m_stDialogBoxInfo[4].sX;
	sY = m_stDialogBoxInfo[4].sY;
	
	if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + 55) && (msY <= sY + 55 + DEF_BTNSZY)) 
	{
	    m_stDialogBoxInfo[4].cMode = 3;
        bSendCommand(MSGID_COMMAND_COMMON, 
                     DEF_COMMONTYPE_ITEMDROP, 
                     NULL, 
                     m_stDialogBoxInfo[4].sView, 
                     1, 
                     NULL, 
                     m_pItemList[m_stDialogBoxInfo[4].sView]->m_cName);
		//m_stDialogBoxInfo[40].sView ;
		DisableDialogBox(4);
	}
	
	else if ((msX >= sX + 170 ) && (msX <= sX + 170 + DEF_BTNSZX ) && (msY >= sY + 55 ) && (msY <= sY + 55 + DEF_BTNSZY))
	{
	
		for (int i = 0; i < DEF_MAXSELLLIST; i++) 
	         m_bIsItemDisabled[i] = FALSE;
	
		DisableDialogBox(4);
	}
    else if ((msX >= sX + 35) && (msX <= sX + 240 ) && (msY >= sY + 80) && (msY <= sY + 90)) 
	{
	   m_bItemDrop = !m_bItemDrop;
	}
}

void CGame::DlgBoxClick_ItemSellorRepair(short msX, short msY)
{
 short sX, sY;
	
	sX = m_stDialogBoxInfo[23].sX;
	sY = m_stDialogBoxInfo[23].sY;

	switch (m_stDialogBoxInfo[23].cMode) {
	case 1:
		// 판다 
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Sell버튼 클릭되었다. 아이템 판매 요청을 한다. 응답을 올때까지 Lock은 풀리지 않는다. 
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_SELLITEMCONFIRM, NULL, m_stDialogBoxInfo[23].sV1, m_stDialogBoxInfo[23].sV4, m_stDialogBoxInfo[23].sV3, m_pItemList[m_stDialogBoxInfo[23].sV1]->m_cName); //v1.2
			m_stDialogBoxInfo[23].cMode = 3;
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel 버튼 클릭되었다. Lock되었던 아이템을 해제하고 다이얼로그 박스를 닫는다. 
			m_bIsItemDisabled[ m_stDialogBoxInfo[23].sV1 ] = FALSE;
			DisableDialogBox(23);
		}
		break;

	case 2:
		// 고친다.
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Repair버튼 클릭되었다. 아이템 수리 요청을 한다. 응답을 올때까지 Lock은 풀리지 않는다. 
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM, NULL, m_stDialogBoxInfo[23].sV1, NULL, NULL, m_pItemList[m_stDialogBoxInfo[23].sV1]->m_cName);
			m_stDialogBoxInfo[23].cMode = 4;
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel 버튼 클릭되었다. Lock되었던 아이템을 해제하고 다이얼로그 박스를 닫는다. 
			m_bIsItemDisabled[ m_stDialogBoxInfo[23].sV1 ] = FALSE;
			DisableDialogBox(23);
		}
		break;
	}
}


int CGame::iGetLevelExp(int iLevel)
{
 int iRet;

		
	if (iLevel == 0) return 0;

	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );

	return iRet;
}

int CGame::_iGetTotalItemNum()
{
 int i, iCnt;

	iCnt = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL) iCnt++;

	return iCnt;
}

BOOL CGame::bCheckExID(char * pName)
{
	if (m_pExID == NULL) return FALSE;
	if (memcmp(m_cPlayerName, pName, 10) == 0) return FALSE;
	char cTxt[12];
	ZeroMemory(cTxt, sizeof(cTxt));
	memcpy(cTxt, m_pExID->m_pMsg, strlen(m_pExID->m_pMsg));
	if (memcmp(cTxt, pName, 10) == 0) return TRUE;
	else return FALSE;
}

void CGame::DrawWhetherEffects()
{
 int i;
 short dX, dY, sCnt;
 char cTempFrame;
 DWORD dwTime = m_dwCurTime;

	switch (m_cWhetherEffectType) {
	case 1:
	case 2:
	case 3:
		// 비내리는 효과 
		switch (m_cWhetherEffectType) {
		case 1: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 2:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 3:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}

		for (i = 0; i < sCnt; i++) {
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 20) && (m_stWhetherObject[i].sX != 0)) {
				dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;
				cTempFrame = 16 + (m_stWhetherObject[i].cStep / 6);

				m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);
 			}
			else if ((m_stWhetherObject[i].cStep >= 20) && (m_stWhetherObject[i].cStep < 25) && (m_stWhetherObject[i].sX != 0)) {
				// 빗방울 땅에서 퍼지는 효과
				dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;
				m_pEffectSpr[11]->PutTransSprite(dX, dY, m_stWhetherObject[i].cStep, dwTime);
			}
		}
		break;

	case 4:
	case 5:
	case 6:
		// 눈내리는 효과 
		switch (m_cWhetherEffectType) {
		case 4: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 5:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 6:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}

#ifdef DEF_XMAS	//	X-mas :	눈 쌓이는 효과	mando..20021212
	#define MAXNUM 1000
		static int ix1[MAXNUM];
		static int iy2[MAXNUM];
		static int iFrame[MAXNUM];
		static int iNum = 0;
#endif

		for (i = 0; i < sCnt; i++) {
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 80)) {
				dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;
				cTempFrame = 39 + (m_stWhetherObject[i].cStep / 20)*3 + (rand() % 3);
			
				m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);

#ifdef DEF_XMAS	//	X-mas : 눈 쌓이는 효과	mando..
				if( dY == 478 - 53 )
				{
					ix1[iNum] = dX;
					iy2[iNum] = dY + (rand()%5);
					iFrame[iNum] = cTempFrame;
					iNum++;
				}
				if( iNum >= MAXNUM )					iNum = 0;
#endif
 			}
			else  {
				
			}
		}

#ifdef DEF_XMAS		//	X-mas : 쌓인눈 찍어주기..	mando..20021212		
		for (i = 0; i <= MAXNUM; i++)
		{
			if( iy2[i] > 10 )	//	초기화값이 아닐때..
				m_pEffectSpr[11]->PutTransSprite(ix1[i], iy2[i], iFrame[i], dwTime);
		}
#endif

		break;
	}
}

void CGame::WhetherObjectFrameCounter()
{
 int i;
 short sCnt;
 char  cAdd;
 DWORD dwTime = m_dwCurTime;

	// 날씨 효과의 속도 오락가락함을 막기 위함.
	if ((dwTime - m_dwWOFtime) < 30) return;
	m_dwWOFtime = dwTime;

	switch (m_cWhetherEffectType) {
	case 1:
	case 2:
	case 3:
		// 비내리는 효과 
		switch (m_cWhetherEffectType) {
		case 1: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 2:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 3:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		
		for (i = 0; i < sCnt; i++) {
			m_stWhetherObject[i].cStep++;
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 20)) {
				// 빗방울의 움직이는 궤적을 계산한다. 
				cAdd = (40 - m_stWhetherObject[i].cStep); 
				if (cAdd < 0) cAdd = 0;
				m_stWhetherObject[i].sY = m_stWhetherObject[i].sY + cAdd;
				if (cAdd != 0) 
					m_stWhetherObject[i].sX = m_stWhetherObject[i].sX - 1;
			}
			else if (m_stWhetherObject[i].cStep >= 25) {
				if (m_bIsWhetherEffect == FALSE) {
					m_stWhetherObject[i].sX    = 0;
					m_stWhetherObject[i].sY    = 0;
					m_stWhetherObject[i].cStep = 30; // 계속 30으로 고정시켜 놓는다.
				}
				else {
					m_stWhetherObject[i].sX    = (m_pMapData->m_sPivotX*32) + ((rand() % 940) - 200) + 300;
					m_stWhetherObject[i].sY    = (m_pMapData->m_sPivotY*32) + ((rand() % 800) - 600) + 240;
					m_stWhetherObject[i].cStep = -1*(rand() % 10);
				}
			}
		}
		break;

	case 4:
	case 5:
	case 6:
		// 눈내리는 효과
		switch (m_cWhetherEffectType) {
		case 4: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 5:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 6:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		
		for (i = 0; i < sCnt; i++) {
			m_stWhetherObject[i].cStep++;
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 80)) {
				// 눈송이의 움직이는 궤적을 계산한다. 
				cAdd = (80 - m_stWhetherObject[i].cStep)/10; 
				if (cAdd < 0) cAdd = 0;
				m_stWhetherObject[i].sY = m_stWhetherObject[i].sY + cAdd;
				//if ((rand() % 3) == 1) 
				m_stWhetherObject[i].sX += 1 - (rand() % 3);
			}
			else if (m_stWhetherObject[i].cStep >= 80) {
				if (m_bIsWhetherEffect == FALSE) {
					m_stWhetherObject[i].sX    = 0;
					m_stWhetherObject[i].sY    = 0;
					m_stWhetherObject[i].cStep = 80; // 계속 40으로 고정시켜 놓는다.
				}
				else {
					m_stWhetherObject[i].sX    = (m_pMapData->m_sPivotX*32) + ((rand() % 940) - 200) + 300;
					m_stWhetherObject[i].sY    = (m_pMapData->m_sPivotY*32) + ((rand() % 800) - 600) + 600;
					m_stWhetherObject[i].cStep = -1*(rand() % 10);
				}
			}
		}
		break;
	}
}

void CGame::SetWhetherStatus(BOOL bStart, char cType)
{
	if (bStart == TRUE)
	{
		m_bIsWhetherEffect   = TRUE;
		m_cWhetherEffectType = cType;		
		// 비오는 소리 루프
		if ((m_bSoundStat == TRUE) && (m_bSoundFlag) && (cType >= 1) && (cType <= 3)) m_pESound[38]->Play(TRUE);

		for (int i = 0; i < DEF_MAXWHETHEROBJECTS; i++)
		{
			m_stWhetherObject[i].sX    = 1;
			m_stWhetherObject[i].sY    = 1;
			m_stWhetherObject[i].cStep = -1*(rand() % 40);
		}
		if( cType >= 4 && cType <= 6 )
		{
			if( m_bMusicStat ) StartBGM();
		}
	}
	else
	{
		m_bIsWhetherEffect = FALSE;
		m_cWhetherEffectType = NULL;
		// 비오는 소리 멈춤
		if ((m_bSoundStat == TRUE) && (m_bSoundFlag)) m_pESound[38]->bStop();
	}
}

void CGame::DlgBoxClick_ShutDownMsg(short msX, short msY)
{
 short sX, sY;
 	
	sX = m_stDialogBoxInfo[25].sX;
	sY = m_stDialogBoxInfo[25].sY;
	if ((msX >= sX + 210) && (msX <= sX + 210 + DEF_BTNSZX) && (msY > sY + 127) && (msY < sY + 127 + DEF_BTNSZY)) {
		DisableDialogBox(25);
		PlaySound('E', 14, 5);
	}
}

void CGame::DrawLine(int x0, int y0, int x1, int y1, int iR, int iG, int iB)
{
 int dx, dy, x_inc, y_inc, error, index, dstR, dstG, dstB;
 int iResultX, iResultY;
 WORD * pDst;

	if ((x0 == x1) && (y0 == y1)) 
		return;

	error = 0;

	iResultX = x0;
	iResultY = y0;

	dx = x1-x0;
	dy = y1-y0;

	if(dx>=0)
	{
		x_inc = 1;
	}
	else
	{
		x_inc = -1;
		dx = -dx;
	}

	if(dy>=0)
	{
		y_inc = 1;
	}
	else
	{
		y_inc = -1;
		dy = -dy;
	}

	if(dx>dy)
	{
		for(index = 0; index <= dx; index++)
		{
			error += dy;
			if(error > dx)
			{
				error -= dx;
				iResultY += y_inc;
			}
			iResultX += x_inc;
			if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
				pDst = (WORD *)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0]&0xF800)>>11][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0]&0x7E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x1F)][iB];
					
					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
					break;
				
				case 2:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x7C00)>>10][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0]&0x3E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x1F)][iB];

					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
					break;
				}
			}
			//
		}
	}
	else
	{
		for(index = 0; index <= dy; index++)
		{
			error += dx;
			if(error > dy)
			{
				error -= dy;
				iResultX += x_inc;
			}
			iResultY += y_inc;
			if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
				pDst = (WORD *)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0]&0xF800)>>11][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0]&0x7E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x1F)][iB];
									
					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
					break;
				
				case 2:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x7C00)>>10][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0]&0x3E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x1F)][iB];

					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
					break;
				}
			}
			//
		}
	}
}


void CGame::DrawLine2(int x0, int y0, int x1, int y1, int iR, int iG, int iB)
{
 int dx, dy, x_inc, y_inc, error, index, dstR, dstG, dstB;
 int iResultX, iResultY;
 WORD * pDst;

	if ((x0 == x1) && (y0 == y1)) 
		return;

	error = 0;

	iResultX = x0;
	iResultY = y0;

	dx = x1-x0;
	dy = y1-y0;

	if(dx>=0)
	{
		x_inc = 1;
	}
	else
	{
		x_inc = -1;
		dx = -dx;
	}

	if(dy>=0)
	{
		y_inc = 1;
	}
	else
	{
		y_inc = -1;
		dy = -dy;
	}

	if(dx>dy)
	{
		for(index = 0; index <= dx; index++)
		{
			error += dy;
			if(error > dx)
			{
				error -= dx;
				iResultY += y_inc;
			}
			iResultX += x_inc;
			if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
				pDst = (WORD *)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0]&0xF800)>>11][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0]&0x7E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
									
					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
					break;
				
				case 2:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x7C00)>>10][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0]&0x3E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];

					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
					break;
				}
			}
			//
		}
	}
	else
	{
		for(index = 0; index <= dy; index++)
		{
			error += dx;
			if(error > dy)
			{
				error -= dy;
				iResultX += x_inc;
			}
			iResultY += y_inc;
			if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
				pDst = (WORD *)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0]&0xF800)>>11][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0]&0x7E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
									
					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
					break;
				
				case 2:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x7C00)>>10][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0]&0x3E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];

					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
					break;
				}
			}
			//
		}
	}
}

void CGame::_DrawThunderEffect(int sX, int sY, int dX, int dY, int rX, int rY, char cType) 
{
 int j, iErr, pX1, pY1, iX1, iY1, tX, tY;
 char cDir;
 DWORD dwTime;
 WORD  wR1, wG1, wB1, wR2, wG2, wB2, wR3, wG3, wB3, wR4, wG4, wB4;

	dwTime = m_dwCurTime;
	sX = pX1 = iX1 = tX = sX;
	sY = pY1 = iY1 = tY = sY;
				
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(50, 50, 100), &wR1, &wG1, &wB1);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(30, 30, 100), &wR2, &wG2, &wB2);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0, 0, 30), &wR3, &wG3, &wB3);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(50, 50, 200), &wR4, &wG4, &wB4);

	for (j = 0; j < 100; j++) {
		
		switch (cType) {
		case 1:
			DrawLine(pX1, pY1, iX1, iY1, 15, 15, 20);
			DrawLine(pX1-1, pY1, iX1-1, iY1, wR1, wG1, wB1);
			DrawLine(pX1+1, pY1, iX1+1, iY1, wR1, wG1, wB1);
			DrawLine(pX1, pY1-1, iX1, iY1-1, wR1, wG1, wB1);
			DrawLine(pX1, pY1+1, iX1, iY1+1, wR1, wG1, wB1);

			DrawLine(pX1-2, pY1, iX1-2, iY1, wR2, wG2, wB2);
			DrawLine(pX1+2, pY1, iX1+2, iY1, wR2, wG2, wB2);
			DrawLine(pX1, pY1-2, iX1, iY1-2, wR2, wG2, wB2);
			DrawLine(pX1, pY1+2, iX1, iY1+2, wR2, wG2, wB2);

			DrawLine(pX1-1, pY1-1, iX1-1, iY1-1, wR3, wG3, wB3);
			DrawLine(pX1+1, pY1-1, iX1+1, iY1-1, wR3, wG3, wB3);
			DrawLine(pX1+1, pY1-1, iX1+1, iY1-1, wR3, wG3, wB3);
			DrawLine(pX1-1, pY1+1, iX1-1, iY1+1, wR3, wG3, wB3);
			break;
		
		case 2:
			DrawLine2(pX1, pY1, iX1, iY1, wR4, wG4, wB4);
			break;
		}

		iErr = 0;
		m_Misc.GetPoint(sX, sY, dX, dY, &tX, &tY, &iErr, j*10);
		
		pX1 = iX1;
		pY1 = iY1;
		
		cDir = m_Misc.cGetNextMoveDir(iX1, iY1, tX, tY);
		switch (cDir) {
		case 1:	rY -= 5; break;
		case 2: rY -= 5; rX += 5; break;
		case 3:	rX += 5; break;
		case 4: rX += 5; rY += 5; break;
		case 5: rY += 5; break;
		case 6: rX -= 5; rY += 5; break;
		case 7: rX -= 5; break;
		case 8: rX -= 5; rY -= 5; break;
		}
		
		if (rX < -20) rX = -20;
		if (rX >  20) rX =  20;
		if (rY < -20) rY = -20;
		if (rY >  20) rY =  20;
		
		iX1 = iX1 + rX;
		iY1 = iY1 + rY;
		
		if ((abs(tX - dX) < 5) && (abs(tY - dY) < 5)) break;
	}

	switch (cType) {
	case 1:
		m_pEffectSpr[6]->PutTransSprite(iX1, iY1, (rand() % 2), dwTime);
		break;
	}
}

BOOL CGame::bDlgBoxPress_SkillDlg(short msX, short msY)
{
 int i , iAdjX, iAdjY ;
 char  cItemID;
 short sX, sY, x1, y1, x2, y2, sArray[10];
	
	sX = m_stDialogBoxInfo[26].sX;
	sY = m_stDialogBoxInfo[26].sY;

	iAdjX = 5 ;
	iAdjY = 10 ;

	switch (m_stDialogBoxInfo[26].cMode) {
	case 1:
		ZeroMemory(sArray, sizeof(sArray));
		sArray[1] = m_stDialogBoxInfo[26].sV1;
		sArray[2] = m_stDialogBoxInfo[26].sV2;
		sArray[3] = m_stDialogBoxInfo[26].sV3;
		sArray[4] = m_stDialogBoxInfo[26].sV4;
		sArray[5] = m_stDialogBoxInfo[26].sV5;
		sArray[6] = m_stDialogBoxInfo[26].sV6;

		for (i = 1; i <= 6; i++)
		if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != NULL)) {
			cItemID = (char)sArray[i];
			
			switch (i) {
			case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 55,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*1, sY + iAdjY + 55,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*2, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 100,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*1, sY + iAdjY + 100,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*2, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
			}
			
			// 좌표를 검색하여 선택되었는지를 검사한다. 만약 선택되었다면 Order를 맨 앞(배열상으로는 뒤)으로 옮긴다.
			x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;   
			y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;    
			x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;  
			y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom; 
			
			if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2)) {
				// 선택되었다.
				switch (i) {
				case 1: m_stDialogBoxInfo[26].sV1 = -1; break;
				case 2: m_stDialogBoxInfo[26].sV2 = -1; break;
				case 3: m_stDialogBoxInfo[26].sV3 = -1; break;
				case 4: m_stDialogBoxInfo[26].sV4 = -1; break;
				case 5: m_stDialogBoxInfo[26].sV5 = -1; break;
				case 6: m_stDialogBoxInfo[26].sV6 = -1; break;
				}
				
				// 아이템을 활성화시킨다. 
				m_bIsItemDisabled[cItemID] = FALSE;

				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = cItemID;
				m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
				m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
				return TRUE;
			}
		}
		break;

	case 4:
		ZeroMemory(sArray, sizeof(sArray));
		sArray[1] = m_stDialogBoxInfo[26].sV1;
		sArray[2] = m_stDialogBoxInfo[26].sV2;
		sArray[3] = m_stDialogBoxInfo[26].sV3;
		sArray[4] = m_stDialogBoxInfo[26].sV4;
		sArray[5] = m_stDialogBoxInfo[26].sV5;
		sArray[6] = m_stDialogBoxInfo[26].sV6;

		for (i = 1; i <= 6; i++)
		if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != NULL)) {
			cItemID = (char)sArray[i];
			
			switch (i) {
			case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 +30 +13, sY + iAdjY + 55 +180,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*1 +30 +13, sY + iAdjY + 55 +180,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*2 +30 +13, sY + iAdjY + 55 +180, m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 +30 +13, sY + iAdjY + 100 +180,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*1 +30 +13, sY + iAdjY + 100 +180,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*2 +30 +13, sY + iAdjY + 100 +180, m_pItemList[cItemID]->m_sSpriteFrame); break;
			}
			
			// 좌표를 검색하여 선택되었는지를 검사한다. 만약 선택되었다면 Order를 맨 앞(배열상으로는 뒤)으로 옮긴다.
			x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;   
			y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;    
			x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;  
			y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom; 
			
			if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2)) {
				// 선택되었다.
				switch (i) {
				case 1: m_stDialogBoxInfo[26].sV1 = -1; break;
				case 2: m_stDialogBoxInfo[26].sV2 = -1; break;
				case 3: m_stDialogBoxInfo[26].sV3 = -1; break;
				case 4: m_stDialogBoxInfo[26].sV4 = -1; break;
				case 5: m_stDialogBoxInfo[26].sV5 = -1; break;
				case 6: m_stDialogBoxInfo[26].sV6 = -1; break;
				}
				
				// 아이템을 활성화시킨다. 
				m_bIsItemDisabled[cItemID] = FALSE;

				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = cItemID;
				m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
				m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;

				m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				return TRUE;
			}
		}
		break;
	}

	return FALSE;	
}

int CGame::_iGetAttackType()
{
 WORD wWeaponType;
	// 현재 무장한 무기의 스킬이 100이면 필살기 코드를 반환한다. 그렇지 않으면 일반 공격 코드를 반환.
	// 20보다 크면 필살기이므로 카운트를 다운시킨다. 

	// 아직 구현이 되어있지 않다. 
	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		// 맨손공격 
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[5] >= 100)) return 20;
		else return 1;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		// 단검류
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[7] >= 100)) return 21;
		else return 1;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) {
			// 펜싱검 
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[9] >= 100)) return 22;
			else return 1;
		}
		else {
			// 장검류	
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[8] >= 100)) return 23;
			else return 1;
		}
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		// 도끼류 
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[10] >= 100)) return 24;
		else return 1;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		// 해머
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[14] >= 100)) return 26;
		else return 1;
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		// 지팡이
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[21] >= 100)) return 27;
		else return 1;
	}
	else if (wWeaponType >= 40) {
		// 활류  
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[6] >= 100)) return 25;
		else return 2;
	}
	
	return 0;
}


int CGame::_iGetWeaponSkillType()
{
 WORD wWeaponType;
	
	// 현재 무장한 무기의 스킬 번호를 반환 
	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		// 맨손공격 
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		// 단검류
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			 return 9; // 펜싱검
		else return 8; // 장검 
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		// 도끼류 
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		// 해머 
		return 14;
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		// 지팡이 
		return 21;
	}
	else if (wWeaponType >= 40) {
		// 활류  
		return 6;
	}
	
	return 1;
}

void CGame::NotifyMsg_AdminInfo(char *pData)
{
 char * cp, cStr[256];
 int  * ip, iV1, iV2, iV3, iV4, iV5;

	cp = (char *)(pData + 6);

	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV5 = *ip;
	cp += 4;

	ZeroMemory(cStr, sizeof(cStr));
	wsprintf(cStr, "%d %d %d %d %d", iV1, iV2, iV3, iV4, iV5);
	AddEventList(cStr);
}

BOOL CGame::_bCheckBadWords(char *pMsg)
{
 char cStr[500]; 
 int i, iLen;

	ZeroMemory(cStr, sizeof(cStr));
	strcpy(cStr, pMsg);
	iLen = strlen(cStr);

	for (i = 0; i < iLen; i++) {
		if (m_pCGameMonitor->bCheckBadWord((char *)(cStr + i)) == TRUE) return TRUE;
		if ((unsigned char)cStr[i] >= 128) i++; 	
	}

	return FALSE;
}

void CGame::bItemDrop_ExchangeDialog(short msX, short msY)
{
 char cItemID;

	// 명령이 유효하지 않은 상태라면(죽었다거나) 명령을 수행할 수 없다.
	if (m_cCommand < 0) return;
	
	// 이미 아이템이 설정되어 있어도 바꿀 수 없다. 안전 관계상 교환창을 다시 띄워야 한다.
	if (m_stDialogBoxInfo[27].sV1 != -1) return;

	cItemID = (char)m_stMCursor.sSelectedObjectID;

	// 만약 소비성 아이템이라면 수량을 묻는다.
	if ( ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) && 
		 (m_pItemList[cItemID]->m_dwCount > 1) ) {
		// 소비하는 아이템을 다른 캐릭터에게 전달한다. 
		m_stDialogBoxInfo[17].sX  = msX - 140;
		m_stDialogBoxInfo[17].sY  = msY - 70;
		if (m_stDialogBoxInfo[17].sY < 0) m_stDialogBoxInfo[17].sY = 0;
					
		m_stDialogBoxInfo[17].sV1 = m_sPlayerX+1; // !!! 거리가 멀다는 메시지를 뜨지 않게 하기 위함이다.
		m_stDialogBoxInfo[17].sV2 = m_sPlayerY+1;
		// NPC 종류: 1000이면 교환창 아이템 드롭이다.
		m_stDialogBoxInfo[17].sV3 = 1000;
		m_stDialogBoxInfo[17].sV4 = cItemID;
		
		m_stDialogBoxInfo[27].sView = cItemID;

		ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
		EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);

		return;
	}
	else {
		// 교환할 아이템을 드래그 해서 놓았다. 비활성화 시키고 서버로 메시지 전송 
		m_stDialogBoxInfo[27].sV1 = m_pItemList[cItemID]->m_sSprite;
		m_stDialogBoxInfo[27].sV2 = m_pItemList[cItemID]->m_sSpriteFrame;
		m_stDialogBoxInfo[27].sV3 = 1;
		m_stDialogBoxInfo[27].sV4 = m_pItemList[cItemID]->m_cItemColor;
		m_stDialogBoxInfo[27].sView = cItemID;
			
		m_bIsItemDisabled[cItemID] = TRUE;
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETEXCHANGEITEM, NULL, cItemID, 1, NULL, NULL);	
		return;
	}
}

void CGame::DlgBoxClick_Exchange(short msX, short msY)
{
 short sX, sY;	

	sX = m_stDialogBoxInfo[27].sX ;
	sY = m_stDialogBoxInfo[27].sY ;


	switch (m_stDialogBoxInfo[27].cMode) {
	case 1:
		if ((msX >= sX + 220) && (msX <= sX + 220 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY)) {
			// Exchange
			if ( (m_stDialogBoxInfo[27].sV1 != -1) && (m_stDialogBoxInfo[27].sV5 != -1) ) {
					
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CONFIRMEXCHANGEITEM, NULL, m_stDialogBoxInfo[27].sView, // ItemID
					m_stDialogBoxInfo[27].sV3, // Amount
					NULL, NULL);
				
				PlaySound('E', 14, 5);
				m_stDialogBoxInfo[27].cMode = 2;
			}
			return;
		}
		
		if ((msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY)) {
			// Cancel: 취소시에 교환을 취소한다는 메시지를 보낸다.
			DisableDialogBox(27);
			DisableDialogBox(22);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL);
			
			PlaySound('E', 14, 5);
			return;
		}
		break;

	case 2:
		if ((msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY)) {
			// Cancel: 취소시에 교환을 취소한다는 메시지를 보낸다.
			DisableDialogBox(27);
				DisableDialogBox(22);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL);
			
			PlaySound('E', 14, 5);
			return;
		}
		break;
	}
}

void CGame::DlgBoxClick_Quest(int msX, int msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[28].sX;
	sY = m_stDialogBoxInfo[28].sY;

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		DisableDialogBox(28);
		PlaySound('E', 14, 5);
	}
}

int CGame::_iGetBankItemCount()
{
 int i, iCnt;

	iCnt = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != NULL) iCnt++;

	return iCnt;
}

BOOL CGame::_bDecodeBuildItemContents()
{
 char cFileName[255], cTemp[255];
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;
 char * pBuffer;
 BOOL   bRet;
 int    i;
 
	// v1.41
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) {
		delete m_pBuildItemList[i];
		m_pBuildItemList[i] = NULL;
	}

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	strcpy(cTemp, "BItemcfg");
	
	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return FALSE;
	else {
		pBuffer = new char[dwFileSize+1];
		ZeroMemory(pBuffer, dwFileSize+1);
		fread(pBuffer, dwFileSize, 1, pFile);

		bRet = __bDecodeBuildItemContents(pBuffer);
		delete[] pBuffer;
	}

	fclose(pFile);

	return bRet;
}

BOOL CGame::_bCheckBuildItemStatus()
{
 int iIndex, i, j, iMatch, iCount;
 char cTempName[21];
 int  iItemCount[DEF_MAXITEMS];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pDispBuildItemList[i] != NULL) {
		delete m_pDispBuildItemList[i];
		m_pDispBuildItemList[i] = NULL;
	}
	
	iIndex = 0;
	// 현재 소지하고 있는 아이템으로 만들수 있는 BuildItem을 체크하여 DispBuildItemList를 작성한다.
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) {
		// Skill-Limit 검사 
		if (m_cSkillMastery[13] >= m_pBuildItemList[i]->m_iSkillLimit) {
	
			iMatch = 0;
			// Skill 수준은 맞으므로 메뉴에 보인다. 
			// 생성하고 내용을 복사한다.
			m_pDispBuildItemList[iIndex] = new class CBuildItem;
			memcpy(m_pDispBuildItemList[iIndex]->m_cName, m_pBuildItemList[i]->m_cName, 20);
					
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName1, m_pBuildItemList[i]->m_cElementName1, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName2, m_pBuildItemList[i]->m_cElementName2, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName3, m_pBuildItemList[i]->m_cElementName3, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName4, m_pBuildItemList[i]->m_cElementName4, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName5, m_pBuildItemList[i]->m_cElementName5, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName6, m_pBuildItemList[i]->m_cElementName6, 20);

			m_pDispBuildItemList[iIndex]->m_iElementCount[1] = m_pBuildItemList[i]->m_iElementCount[1];
			m_pDispBuildItemList[iIndex]->m_iElementCount[2] = m_pBuildItemList[i]->m_iElementCount[2];
			m_pDispBuildItemList[iIndex]->m_iElementCount[3] = m_pBuildItemList[i]->m_iElementCount[3];
			m_pDispBuildItemList[iIndex]->m_iElementCount[4] = m_pBuildItemList[i]->m_iElementCount[4];
			m_pDispBuildItemList[iIndex]->m_iElementCount[5] = m_pBuildItemList[i]->m_iElementCount[5];
			m_pDispBuildItemList[iIndex]->m_iElementCount[6] = m_pBuildItemList[i]->m_iElementCount[6];

			m_pDispBuildItemList[iIndex]->m_iSprH       = m_pBuildItemList[i]->m_iSprH;
			m_pDispBuildItemList[iIndex]->m_iSprFrame   = m_pBuildItemList[i]->m_iSprFrame;
			m_pDispBuildItemList[iIndex]->m_iMaxSkill   = m_pBuildItemList[i]->m_iMaxSkill;
			m_pDispBuildItemList[iIndex]->m_iSkillLimit = m_pBuildItemList[i]->m_iSkillLimit;
							
			// ItemCount 초기화 클리어 
			for (j = 0; j < DEF_MAXITEMS; j++) 
			if (m_pItemList[j] != NULL) 
				 iItemCount[j] = m_pItemList[j]->m_dwCount;
			else iItemCount[j] = 0;

			// Element1 검사 
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName1, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[1];
			
			if (iCount == 0) iMatch++; // 아이템 수량이 0이면 매치 카운트 무조건 증가 
			else {
				// 해당 아이템을 가지고 있는지 검색 
				for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL) {
					if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0)) {
						// 갖고 있다. 카운트 증가.
						iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[1] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP2;
					}
				}
			}

CBIS_STEP2:;
			
			// Element2 검사 
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName2, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[2];
			
			if (iCount == 0) iMatch++; // 아이템 수량이 0이면 매치 카운트 무조건 증가 
			else {
				// 해당 아이템을 가지고 있는지 검색 
				for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL) {
					if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0)) {
						// 갖고 있다. 카운트 증가.
						iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[2] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP3;
					}
				}
			}

CBIS_STEP3:;			

			// Element3 검사 
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName3, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[3];
			
			if (iCount == 0) iMatch++; // 아이템 수량이 0이면 매치 카운트 무조건 증가 
			else {
				// 해당 아이템을 가지고 있는지 검색 
				for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL) {
					if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0)) {
						// 갖고 있다. 카운트 증가.
						iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[3] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP4;
					}
				}
			}

CBIS_STEP4:;	

			// Element4 검사 
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName4, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[4];
			
			if (iCount == 0) iMatch++; // 아이템 수량이 0이면 매치 카운트 무조건 증가 
			else {
				// 해당 아이템을 가지고 있는지 검색 
				for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL) {
					if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0)) {
						// 갖고 있다. 카운트 증가.
						iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[4] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP5;
					}
				}
			}

CBIS_STEP5:;

			// Element5 검사 
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName5, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[5];
			
			if (iCount == 0) iMatch++; // 아이템 수량이 0이면 매치 카운트 무조건 증가 
			else {
				// 해당 아이템을 가지고 있는지 검색 
				for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL) {
					if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0)) {
						// 갖고 있다. 카운트 증가.
						iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[5] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP6;
					}
				}
			}
		
CBIS_STEP6:;

			// Element6 검사 
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName6, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[6];
			
			if (iCount == 0) iMatch++; // 아이템 수량이 0이면 매치 카운트 무조건 증가 
			else {
				// 해당 아이템을 가지고 있는지 검색 
				for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL) {
					if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0)) {
						// 갖고 있다. 카운트 증가.
						iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[6] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP7;
					}
				}
			}

CBIS_STEP7:;
							
			// 현재 만들 수 있는 아이템인지 판정 
			if (iMatch == 6) m_pDispBuildItemList[iIndex]->m_bBuildEnabled = TRUE;
			iIndex++;
		}
	}

	return TRUE;
}

BOOL CGame::_ItemDropHistory(char * ItemName)
{
 // 히스토리에 해당 아이템이 있는지 검색.
  BOOL bFlag = FALSE;
 
   if (m_iItemDropCnt == 0 )
   {
	 strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
	 m_iItemDropCnt++;
     return TRUE; // 버린 적 없는 아이템.
   }
 
   if ( (1 <= m_iItemDropCnt) && (20 >= m_iItemDropCnt) )
   {
	   for (int i = 0; i < m_iItemDropCnt; i++)
	   {
          if (strcmp(m_cItemDrop[i], ItemName) == 0)
		  {
                 bFlag = TRUE; // 버린 적 있는 아이템.
	             break;
		  }
	   }
	   
	   if (bFlag)
	   {
		   if (m_bItemDrop)
			   return FALSE; // 버린 적 있는 아이템은 다이이얼록 안보여줄 때, 
		   else
               return TRUE; // 버린 적 있는 아이템인데 다이얼록 보여줄 때.
	   }
	   
	   if( 20 < m_iItemDropCnt )
	   {
	      for (int i = 0; i < m_iItemDropCnt ; i++)
             strcpy(m_cItemDrop[i-1], ItemName);
	      strcpy(m_cItemDrop[20], ItemName);
	      m_iItemDropCnt = 21;
	   }
	   else
	   {
	     strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
         m_iItemDropCnt++;
	   }
   }
       return TRUE; //버린 적 없는 아이템.
}


BOOL CGame::__bDecodeBuildItemContents(char *pBuffer)
{
 char * pContents, * token;
 char seps[] = "= ,\t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iIndex = 0;
 class CStrTok * pStrTok;

	pContents = pBuffer;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			//
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 아이템 이름
					ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					// 아이템 제작 스킬 리미트 
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					// m_cElementName1
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName1, sizeof(m_pBuildItemList[iIndex]->m_cElementName1));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName1, token, strlen(token));
					cReadModeB = 4;
					break;
				case 4:
					// m_iElementCount1
					m_pBuildItemList[iIndex]->m_iElementCount[1] = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_cElementName2
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName2, sizeof(m_pBuildItemList[iIndex]->m_cElementName2));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName2, token, strlen(token));
					cReadModeB = 6;
					break;
				case 6:
					// m_iElementCount2
					m_pBuildItemList[iIndex]->m_iElementCount[2] = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_cElementName3
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName3, sizeof(m_pBuildItemList[iIndex]->m_cElementName3));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName3, token, strlen(token));
					cReadModeB = 8;
					break;
				case 8:
					// m_iElementCount3
					m_pBuildItemList[iIndex]->m_iElementCount[3] = atoi(token);
					cReadModeB = 9;
					break;
				case 9:
					// m_cElementName4
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName4, sizeof(m_pBuildItemList[iIndex]->m_cElementName4));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName4, token, strlen(token));
					cReadModeB = 10;
					break;
				case 10:
					// m_iElementCount4
					m_pBuildItemList[iIndex]->m_iElementCount[4] = atoi(token);
					cReadModeB = 11;
					break;
				case 11:
					// m_cElementName5
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName5, sizeof(m_pBuildItemList[iIndex]->m_cElementName5));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName5, token, strlen(token));
					cReadModeB = 12;
					break;
				case 12:
					// m_iElementCount5
					m_pBuildItemList[iIndex]->m_iElementCount[5] = atoi(token);
					cReadModeB = 13;
					break;
				case 13:
					// m_cElementName6
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName6, sizeof(m_pBuildItemList[iIndex]->m_cElementName6));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName6, token, strlen(token));
					cReadModeB = 14;
					break;
				case 14:
					// m_iElementCount6
					m_pBuildItemList[iIndex]->m_iElementCount[6] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					m_pBuildItemList[iIndex]->m_iSprH = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					m_pBuildItemList[iIndex]->m_iSprFrame = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					iIndex++;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "BuildItem", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;

	if ((cReadModeA != 0) || (cReadModeB != 0)) return FALSE;
	return TRUE;
}


BOOL CGame::_bCheckCurrentBuildItemStatus()
{
 int i, iCount2, iMatch, iIndex, iItemIndex[7];
 int iCount;
 int iItemCount[7];
 char cTempName[21];
 BOOL bItemFlag[7];

	iIndex = m_stDialogBoxInfo[26].cStr[0];
	
	if (m_pBuildItemList[iIndex] == NULL) return FALSE;
	
	iItemIndex[1] = m_stDialogBoxInfo[26].sV1;
	iItemIndex[2] = m_stDialogBoxInfo[26].sV2;
	iItemIndex[3] = m_stDialogBoxInfo[26].sV3;
	iItemIndex[4] = m_stDialogBoxInfo[26].sV4;
	iItemIndex[5] = m_stDialogBoxInfo[26].sV5;
	iItemIndex[6] = m_stDialogBoxInfo[26].sV6;

	for (i = 1; i <= 6; i++) 
	if (iItemIndex[i] != -1) 
		 iItemCount[i] = m_pItemList[iItemIndex[i]]->m_dwCount;
	else iItemCount[i] = 0;

	iMatch = 0;

	for (i = 1; i <= 6; i++) bItemFlag[i] = FALSE;

	// Element1 검사 
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName1, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[1];
			
	if (iCount == 0) iMatch++; // 아이템 이름이 할당 안되었으므로 매치 카운트 무조건 증가 
	else {
		// 해당 아이템을 가지고 있는지 검색 
		for (i = 1; i <= 6; i++) {
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE)) {
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP2;
			}
		}
	}

CCBIS_STEP2:;

	// Element2 검사 
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName2, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[2];
			
	if (iCount == 0) iMatch++; // 아이템 이름이 할당 안되었으므로 매치 카운트 무조건 증가 
	else {
		// 해당 아이템을 가지고 있는지 검색 
		for (i = 1; i <= 6; i++) {
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE)) {
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP3;
			}
		}
	}

CCBIS_STEP3:;


	// Element3 검사 
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName3, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[3];
			
	if (iCount == 0) iMatch++; // 아이템 이름이 할당 안되었으므로 매치 카운트 무조건 증가 
	else {
		// 해당 아이템을 가지고 있는지 검색 
		for (i = 1; i <= 6; i++) {
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE)) {
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP4;
			}
		}
	}

CCBIS_STEP4:;

	// Element4 검사 
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName4, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[4];
			
	if (iCount == 0) iMatch++; // 아이템 이름이 할당 안되었으므로 매치 카운트 무조건 증가 
	else {
		// 해당 아이템을 가지고 있는지 검색 
		for (i = 1; i <= 6; i++) {
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE)) {
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP5;
			}
		}
	}

CCBIS_STEP5:;

	// Element5 검사 
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName5, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[5];
			
	if (iCount == 0) iMatch++; // 아이템 이름이 할당 안되었으므로 매치 카운트 무조건 증가 
	else {
		// 해당 아이템을 가지고 있는지 검색 
		for (i = 1; i <= 6; i++) {
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE)) {
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP6;
			}
		}
	}

CCBIS_STEP6:;

	// Element6 검사 
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName6, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[6];
			
	if (iCount == 0) iMatch++; // 아이템 이름이 할당 안되었으므로 매치 카운트 무조건 증가 
	else {
		// 해당 아이템을 가지고 있는지 검색 
		for (i = 1; i <= 6; i++) {
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE)) {
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP7;
			}
		}
	}

CCBIS_STEP7:; 

	iCount = 0;
	for (i = 1; i <= 6; i++) 
	if (m_pDispBuildItemList[iIndex]->m_iElementCount[i] != 0) iCount++;

	iCount2 = 0;
	for (i = 1; i <= 6; i++) 
	if (iItemIndex[i] != -1) iCount2++;	

	if ((iMatch == 6) && (iCount == iCount2)) return TRUE;

	return FALSE;
}

void CGame::NoticementHandler(char * pData)
{
 char * cp;
 FILE * pFile;
 WORD * wp; 

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

	switch (*wp) {
	case DEF_MSGTYPE_CONFIRM:
		// 공지사항 변경사항이 없다.
		break;

	case DEF_MSGTYPE_REJECT:
		// 공지사항 변경되었다. 갱신한다.
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		pFile = fopen("contents\\contents1000.txt", "wt");
		if (pFile == NULL) return;
		fwrite(cp, strlen(cp), 1, pFile);
		fclose(pFile);
		break;
	}


#ifdef DEF_HTMLCOMMOM	//	웹 공지창을 게시..mando 021031
	WebDialog();
#else
	// 파일을 읽어 공지사항을 게시한다.
	EnableDialogBox(18, 1000, NULL, NULL);
	
	//2003.01.15 정진광.
	#if DEF_LANGUAGE == 3
	m_stDialogBoxInfo[5].sX  =  150;
    m_stDialogBoxInfo[5].sY  =  100;
	EnableDialogBox(5,  NULL, NULL, NULL);
	#endif
	
#endif

	// 헬프창 연다.
	if (m_iLevel < 42) EnableDialogBox(35, NULL, NULL, NULL);

}

int CGame::_iGetFOE(short sStatus)
{
	BOOL bPK, bCitizen, bAresden, bHunter;

	if( m_iPKCount != 0 ) return -1;

	if( sStatus & 0x8000 ) bPK = TRUE;
	else bPK = FALSE;
	if( sStatus & 0x4000 ) bCitizen = TRUE;
	else bCitizen = FALSE;
	if( sStatus & 0x2000 ) bAresden = TRUE;
	else bAresden = FALSE;
	if( sStatus & 0x1000 ) bHunter = TRUE;
	else bHunter = FALSE;

	if( bPK == TRUE ) return -2;//카오인 놈은 무조건 적이지.
	if( bCitizen == FALSE ) return 0;//중립은 중립.

	//여기까지 왔으면 카오가 아니고 시민권이 있는 놈이다.
	if( m_bCitizen == FALSE ) return 0;//시민권있는 앤데 내가 중립이면 중립.

	if( (m_bAresden == TRUE) && (bAresden == TRUE) ) return 1;//같은 마을이면 우리편.
	if( (m_bAresden == FALSE) && (bAresden == FALSE) ) return 1;//같은 마을이면 우리편.

	if( m_bIsCrusadeMode == TRUE ) return -1;//전면전일때는 마을이 틀리면 무조건 적..민간인같은거 신경안쓴다.
	else
	{
		if( (m_bHunter == FALSE) && (bHunter == FALSE) ) return -1;//서로 전쟁모드이면 적이다.
		else return 0;//둘중 하나라도 민간인이면 중립이다.
	}
}

void CGame::_SetIlusionEffect(int iOwnerH)
{
 char cDir;

	m_iIlusionOwnerH = iOwnerH;

	ZeroMemory(m_cName_IE, sizeof(m_cName_IE));
	m_pMapData->GetOwnerStatusByObjectID(iOwnerH, &m_cIlusionOwnerType, &cDir, &m_sAppr1_IE, &m_sAppr2_IE, &m_sAppr3_IE, &m_sAppr4_IE, &m_sStatus_IE, &m_iApprColor_IE, m_cName_IE);
}

void CGame::ResponsePanningHandler(char *pData)
{
 char * cp, cDir;
 short * sp, sX, sY;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE +2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	switch (cDir) {
	case 1: m_sViewDstY -= 32; m_sPlayerY--; break;
	case 2: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX += 32; m_sPlayerX++; break;
	case 3: m_sViewDstX += 32; m_sPlayerX++; break;
	case 4: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX += 32; m_sPlayerX++; break;
	case 5: m_sViewDstY += 32; m_sPlayerY++;break;
	case 6: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX -= 32; m_sPlayerX--; break;
	case 7: m_sViewDstX -= 32; m_sPlayerX--; break;
	case 8: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX -= 32; m_sPlayerX--; break;
	}
	
	m_pMapData->ShiftMapData(cDir);
	_ReadMapData(sX, sY, cp);

	m_bIsRedrawPDBGS = TRUE;

	m_bIsObserverCommanded = FALSE;
}

BOOL CGame::bReadItemNameConfigFile()
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "=\n";
 int iIndex;
 
	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile("contents\\ItemName.cfg", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen("contents\\ItemName.cfg", "rt");
	if (pFile == NULL) return FALSE;
	else {
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		
		token = strtok( cp, seps );   
		while( token != NULL )   {
			
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						m_pItemNameList[iIndex] = new class CItemName;
						strcpy(m_pItemNameList[iIndex]->m_cOriginName, token);
						cReadModeB = 2;
						break;	

					case 2:
						strcpy(m_pItemNameList[iIndex]->m_cName, token);
						cReadModeA = 0;
						cReadModeB = 0;
						iIndex++;
						break;
					}
				}
			}	
			else {
				if (memcmp(token, "Item", 4) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = strtok( NULL, seps );
		}
		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::DrawDialogBox_Map()
{
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 double dV1, dV2, dV3;
 int    tX, tY, szX, szY, dX, dY;
	
	sX = m_stDialogBoxInfo[22].sX;
	sY = m_stDialogBoxInfo[22].sY;

	szX = 0;
	szY = 0;

	switch (m_stDialogBoxInfo[22].sV1) {
	case 1:
		switch (m_stDialogBoxInfo[22].sV2) {
		case 0: // aresden
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 19;
			dY = 20;
			szX = 260;
			szY = 260;
			break;

		case 1: // elvine
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 20;
			dY = 18;
			szX = 260;
			szY = 260;
			break;

		case 2: // middleland
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 11;
			dY = 31;
			szX = 280;
			szY = 253;
			break;

		case 3: // default
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 52;
			dY = 42;
			szX = 200;
			szY = 200;
			break;

		case 4: // aresden 초보
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 40;
			dY = 40;
			szX = 220;
			szY = 220;
			break;

		case 5: // elvine 초보 
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 40;
			dY = 40;
			szX = 220;
			szY = 220;
			break;

		case 6: // aresden 고렙
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 40;
			dY = 40;
			szX = 220;
			szY = 220;
			break;

		case 7: // elvine 고렙
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 40;
			dY = 40;
			szX = 220;
			szY = 220;
			break;
		case 8: // aresden 농경지
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 40;
			dY = 32;
			szX = 220;
			szY = 220;
			break;

		case 9: // elvine 농경지 
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 40;
			dY = 38;
			szX = 220;
			szY = 220;
			break;
		
		}
	
		// 위치를 그린다.
		dV1 = (double)m_pMapData->m_sMapSizeX;
		dV2 = (double)m_sPlayerX;
		dV3 = (dV2*(double)szX)/dV1;
		tX  = (int)dV3 +dX;

		dV1 = (double)m_pMapData->m_sMapSizeY;
		if( dV1 == 752 ) dV1 = 680;
		dV2 = (double)m_sPlayerY;
		dV3 = (dV2*(double)szY)/dV1;
		tY  = (int)dV3 +dY;
	

		//m_pSprite[DEF_SPRID_INTERFACE_MAPS1]->PutSpriteFast(sX +tX, sY +tY, 4, dwTime);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX +tX, sY +tY, 43); 
		wsprintf(G_cTxt, "%d,%d", m_sPlayerX, m_sPlayerY);
		PutString_SprFont3(sX + 10 +tX -5, sY + 10 + tY -6, G_cTxt, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
		break;		   
   	}
}

/////////////////

void CGame::NotifyMsg_SetExchangeItem(char *pData)
{
 short * sp, sDir, sSprite, sSpriteFrame, sCurLife, sMaxLife, sPerformance;
 int * ip, iAmount;
 char * cp, cColor, cItemName[24], cCharName[12];
 DWORD * dwp, dwAttribute;


	ZeroMemory(cItemName, sizeof(cItemName));
	ZeroMemory(cCharName, sizeof(cCharName));

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sDir = *sp;
	cp += 2;
	
	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;
	
	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;
	
	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	cColor = *cp;
	cp++;

	sp = (short *)cp;
	sCurLife = *sp;
	cp += 2;

	sp = (short *)cp;
	sMaxLife = *sp;
	cp += 2;

	sp = (short *)cp;
	sPerformance = *sp;
	cp += 2;
	
	memcpy(cItemName, cp, 20);
	cp += 20;
	
	memcpy(cCharName, cp, 10);
	cp += 10;

	// v1.42
	dwp = (DWORD *)cp;
	dwAttribute = *dwp;
	cp += 4;
	
	if (sDir == 0) {
		m_stDialogBoxInfo[27].sV1 = sSprite;
		m_stDialogBoxInfo[27].sV2 = sSpriteFrame;
		m_stDialogBoxInfo[27].sV3 = iAmount;
		m_stDialogBoxInfo[27].sV4 = cColor;
		m_stDialogBoxInfo[27].sV9  = (int)sCurLife;
		m_stDialogBoxInfo[27].sV10 = (int)sMaxLife;
		m_stDialogBoxInfo[27].sV11 = (int)sPerformance;

		memcpy(m_stDialogBoxInfo[27].cStr, cItemName, 20);
		memcpy(m_stDialogBoxInfo[27].cStr2, cCharName, 10);

		m_stDialogBoxInfo[27].dwV1 = dwAttribute;
	}
	else {
		m_stDialogBoxInfo[27].sV5 = sSprite;
		m_stDialogBoxInfo[27].sV6 = sSpriteFrame;
		m_stDialogBoxInfo[27].sV7 = iAmount;
		m_stDialogBoxInfo[27].sV8 = cColor;
		m_stDialogBoxInfo[27].sV12 = (int)sCurLife;
		m_stDialogBoxInfo[27].sV13 = (int)sMaxLife;
		m_stDialogBoxInfo[27].sV14 = (int)sPerformance;

		memcpy(m_stDialogBoxInfo[27].cStr3, cItemName, 20);
		memcpy(m_stDialogBoxInfo[27].cStr4, cCharName, 10);

		m_stDialogBoxInfo[27].dwV2 = dwAttribute;
	}
}

void CGame::NotifyMsg_DismissGuildApprove(char * pData)
{
 char * cp, cName[24], cLocation[12];
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cLocation, sizeof(cLocation));
	// 길드 오퍼레이션 다이얼로그박스를 활성화 시킨다.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;

	cp += 2;

	// 플레이어 소속 마을의 이름
	memcpy(cLocation, cp, 10);
	cp += 10;

	// 길드 이름과 랭크를 초기화한다.
	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	m_iGuildRank = -1;

	// 환원된 마을 이름 저장 
	ZeroMemory(m_cLocation, sizeof(m_cLocation));
	memcpy(m_cLocation, cLocation, 10);
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{
		m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter = FALSE;
	}
	else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{
		m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter = TRUE;
	}
	else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{
		m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter = FALSE;
	}
	else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{
		m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter = TRUE;
	}
	else
	{
		m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter = TRUE;
	}

	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 5);
}

void CGame::NotifyMsg_DismissGuildReject(char * pData)
{
 char * cp, cName[21];
 	
	ZeroMemory(cName, sizeof(cName));
	// 길드 오퍼레이션 다이얼로그박스를 활성화 시킨다.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;

	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 6);
}

void CGame::NotifyMsg_DownSkillIndexSet(char *pData)
{
 WORD * wp;
 short sSkillIndex;
 char * cp;
 
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
	sSkillIndex = (short)*wp;
	cp += 2;

	m_iDownSkillIndex = sSkillIndex;

	// 플래그를 재 설정해 변경 가능한 상태로 만든다.
	m_stDialogBoxInfo[15].bFlag = FALSE;
}

void CGame::NotifyMsg_FishChance(char * pData)
{
 int iFishChance;
 char * cp;
 WORD * wp;
	// 낚시 모드 다이얼로그 박스내의 값을 변경 시킨다. 
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;

	iFishChance = (int)*wp;
	cp += 2;

	m_stDialogBoxInfo[24].sV1 = iFishChance;
}

void CGame::NotifyMsg_GuildDisbanded(char * pData)
{
 char * cp, cName[24], cLocation[12];
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cLocation, sizeof(cLocation));

	// 길드 오퍼레이션 다이얼로그박스를 활성화 시킨다.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;

	memcpy(cLocation, cp, 10);
	cp += 10;

	m_Misc.ReplaceString(cName, '_', ' ');
	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 7);

	// 길드 이름과 랭크를 초기화한다.
	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	ZeroMemory(m_cLocation, sizeof(m_cLocation));
	memcpy(m_cLocation, cLocation, 10);
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{
		m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter = FALSE;
	}
	else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{
		m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter = TRUE;
	}
	else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{
		m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter = FALSE;
	}
	else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{
		m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter = TRUE;
	}
	else
	{
		m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter = TRUE;
	}
}

void CGame::NotifyMsg_WhetherChange(char * pData)
{
 char * cp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	m_cWhetherStatus = *cp;
	cp++;

	if (m_cWhetherStatus != NULL) 
		 SetWhetherStatus(TRUE,  m_cWhetherStatus);
	else SetWhetherStatus(FALSE, NULL);
}

void CGame::NotifyMsg_TimeChange(char * pData)
{
 char * cp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	G_cSpriteAlphaDegree = *cp;

	switch (G_cSpriteAlphaDegree) {
	case 1:	PlaySound('E', 32, 0); break;
	case 2: PlaySound('E', 31, 0); break;
	}

	m_cGameModeCount = 1;

	m_bIsRedrawPDBGS = TRUE;
}

void CGame::NotifyMsg_RepairItemPrice(char * pData)
{
 char * cp, cName[21];
 DWORD * dwp, wV1, wV2, wV3, wV4;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	dwp = (DWORD *)cp;
  	wV1 = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
  	wV2 = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
  	wV3 = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
  	wV4 = *dwp;
	cp += 4;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	// 이제 아이템 수리 동의 다이얼로그 박스를 활성화 시킨다. 
	// sV1은 ItemID, sV2는 RemainLife, sV3는 가격 
	
	EnableDialogBox(23, 2, wV1, wV2);
	m_stDialogBoxInfo[23].sV3 = wV3;

}

void CGame::NotifyMsg_SellItemPrice(char * pData)
{
 char * cp, cName[21];
 DWORD * dwp, wV1, wV2, wV3, wV4;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	dwp = (DWORD *)cp;
  	wV1 = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
  	wV2 = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
  	wV3 = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
  	wV4 = *dwp;
	cp += 4;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	// 이제 아이템 팔기 동의 다이얼로그 박스를 활성화 시킨다. 
	// sV1은 ItemID, sV2는 RemainLife, sV3는 가격, sV4는 수량 
	EnableDialogBox(23, 1, wV1, wV2);
	m_stDialogBoxInfo[23].sV3 = wV3;
	m_stDialogBoxInfo[23].sV4 = wV4;
}


void CGame::NotifyMsg_QueryDismissGuildPermission(char * pData)
{
 char * cp, cName[12];
 	
	ZeroMemory(cName, sizeof(cName));
	// 길드 오퍼레이션 다이얼로그박스를 활성화 시킨다.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 10);
	cp += 10;

	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 2);
}


void CGame::NotifyMsg_QueryJoinGuildPermission(char * pData)
{
 char * cp, cName[12];
 	
	ZeroMemory(cName, sizeof(cName));
	// 길드 오퍼레이션 다이얼로그박스를 활성화 시킨다.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 10);
	cp += 10;

	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 1);
}


void CGame::NotifyMsg_QuestContents(char *pData)
{
 short * sp;
 char  * cp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	sp = (short *)cp;
	m_stQuest.sWho = *sp;
	cp += 2;

	sp = (short *)cp;
	m_stQuest.sQuestType = *sp;
	cp += 2;

	sp = (short *)cp;
	m_stQuest.sContribution = *sp;
	cp += 2;

	sp = (short *)cp;
	m_stQuest.sTargetType = *sp;
	cp += 2;

	sp = (short *)cp;
	m_stQuest.sTargetCount = *sp;
	cp += 2;

	sp = (short *)cp;
	m_stQuest.sX = *sp;
	cp += 2;

	sp = (short *)cp;
	m_stQuest.sY = *sp;
	cp += 2;

	sp = (short *)cp;
	m_stQuest.sRange = *sp;
	cp += 2;

	sp = (short *)cp;
	m_stQuest.bIsQuestCompleted = (BOOL)*sp;
	cp += 2;
	
	ZeroMemory(m_stQuest.cTargetName, sizeof(m_stQuest.cTargetName));
	memcpy(m_stQuest.cTargetName, cp, 20);
	cp += 20;

	// v2.05
	//AddEventList(m_pGameMsgList[92]->m_pMsg, 10);
}

void CGame::NotifyMsg_PlayerProfile(char * pData)
{
 char * cp;
 char cTemp[500];
 int i;

	ZeroMemory(cTemp, sizeof(cTemp));
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	strcpy(cTemp, cp);

	for (i = 0; i < 500; i++)
	if (cTemp[i] == '_') cTemp[i] = ' ';

	AddEventList(cTemp, 10);
}

void CGame::NotifyMsg_NoticeMsg(char * pData)
{
 char * cp, cMsg[1000];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	strcpy(cMsg, cp);
	AddEventList(cMsg, 10);
}

void CGame::NotifyMsg_OpenExchageWindow(char *pData)
{
 short * sp, sDir, sSprite, sSpriteFrame, sCurLife, sMaxLife, sPerformance;
 int * ip, iAmount;
 char * cp, cColor, cItemName[24], cCharName[12];
 DWORD * dwp, dwAttribute;

	ZeroMemory(cItemName, sizeof(cItemName));
	ZeroMemory(cCharName, sizeof(cCharName));

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sDir = *sp;
	cp += 2;
	
	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;
	
	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;
	
	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	cColor = *cp;
	cp++;

	sp = (short *)cp;
	sCurLife = *sp;
	cp += 2;

	sp = (short *)cp;
	sMaxLife = *sp;
	cp += 2;

	sp = (short *)cp;
	sPerformance = *sp;
	cp += 2;

	
	memcpy(cItemName, cp, 20);
	cp += 20;
	
	memcpy(cCharName, cp, 10);
	cp += 10;

	// v1.42
	dwp = (DWORD *)cp;
	dwAttribute = *dwp;
	cp += 4;

	EnableDialogBox(27, 1, 0, 0, NULL);
	if (sDir == 0) {
		m_stDialogBoxInfo[27].sV1 = sSprite;
		m_stDialogBoxInfo[27].sV2 = sSpriteFrame;
		m_stDialogBoxInfo[27].sV3 = iAmount;
		m_stDialogBoxInfo[27].sV4 = (int)cColor;
		m_stDialogBoxInfo[27].sV9  = (int)sCurLife;
		m_stDialogBoxInfo[27].sV10 = (int)sMaxLife;
		m_stDialogBoxInfo[27].sV11 = (int)sPerformance;
		
		memcpy(m_stDialogBoxInfo[27].cStr, cItemName, 20);
		memcpy(m_stDialogBoxInfo[27].cStr2, cCharName, 10);

		m_stDialogBoxInfo[27].dwV1 = dwAttribute;
	}
	else {
		m_stDialogBoxInfo[27].sV5 = sSprite;
		m_stDialogBoxInfo[27].sV6 = sSpriteFrame;
		m_stDialogBoxInfo[27].sV7 = iAmount;
		m_stDialogBoxInfo[27].sV8 = (int)cColor;
		m_stDialogBoxInfo[27].sV12 = (int)sCurLife;
		m_stDialogBoxInfo[27].sV13 = (int)sMaxLife;
		m_stDialogBoxInfo[27].sV14 = (int)sPerformance;
		
		memcpy(m_stDialogBoxInfo[27].cStr3, cItemName, 20);
		memcpy(m_stDialogBoxInfo[27].cStr4, cCharName, 10);

		m_stDialogBoxInfo[27].dwV2 = dwAttribute;
	}
}

void CGame::NotifyMsg_JoinGuildApprove(char * pData)
{
 char * cp, cName[21];
 short * sp;
	
	ZeroMemory(cName, sizeof(cName));
	// 길드 오퍼레이션 다이얼로그박스를 활성화 시킨다.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;

	sp = (short *)cp;
	cp += 2;

	// 길드 이름과 랭크를 초기화한다.
	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	strcpy(m_cGuildName, cName);
	m_iGuildRank = *sp;

	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 3);
}


void CGame::NotifyMsg_JoinGuildReject(char * pData)
{
 char * cp, cName[21];
	ZeroMemory(cName, sizeof(cName));
	// 길드 오퍼레이션 다이얼로그박스를 활성화 시킨다.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;

	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 4);
}

void CGame::DlgBoxClick_Help(int msX, int msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[35].sX;
	sY = m_stDialogBoxInfo[35].sY;

	
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*0) && (msY < sY +50+15*1)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 900, NULL, NULL); // 헬브레스 세계관 
	}
	
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*1) && (msY < sY +50+15*2)) {
		DisableDialogBox(18);

		#ifdef DEF_HTMLCOMMOM	//	Html 다이얼로그 부분..
			WebDialog();
		#else
			EnableDialogBox(18, 1000, NULL, NULL); // 공지사항
		#endif
	}
	
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*2) && (msY < sY +50+15*3)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 901, NULL, NULL); // 이동 방법
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*3) && (msY < sY +50+15*4)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 902, NULL, NULL); // 공격과 방어 
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*4) && (msY < sY +50+15*5)) {
		// 게임 인터페이스 
		DisableDialogBox(18);
		EnableDialogBox(18, 903, NULL, NULL); // 인터페이스
		m_bIsF1HelpWindowEnabled = TRUE;
	} 
		
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*5) && (msY < sY +50+15*6)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 904, NULL, NULL); // 마법 배우고 사용하기
	} 

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*6) && (msY < sY +50+15*7)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 905, NULL, NULL); // 무기 사용과 스킬
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*7) && (msY < sY +50+15*8)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 906, NULL, NULL); // 길드 조직과 
	} 

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*8) && (msY < sY +50+15*9)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 907, NULL, NULL); // 아이템 사고 팔기
	}  

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*9) && (msY < sY +50+15*10)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 908, NULL, NULL); // 플레이어간 의사소통
	}  

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*10) && (msY < sY +50+15*11)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 909, NULL, NULL); // 전면전
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*11) && (msY < sY +50+15*12)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 910, NULL, NULL); // 고급 명령어
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*12) && (msY < sY +50+15*13)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 911, NULL, NULL); // FAQ
	} 

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*13) && (msY < sY +50+15*14)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 912, NULL, NULL); // 초보 사용자 가이드
	} 
#if DEF_LANGUAGE == 3
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*14) && (msY < sY +50+15*15)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 913, NULL, NULL); // 헬브레스에서 살아가기 1
	} 

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*15) && (msY < sY +50+15*16)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 914, NULL, NULL); // 헬브레스에서 살아가기 2
	} 
#endif
	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		PlaySound('E', 14, 5);
		DisableDialogBox(35);
	}
} 

void CGame::CreateScreenShot()
{
 int i;
 FILE * pFile;
 char cFn[24];

	for (i = 0; i < 1000; i++) {
		ZeroMemory(cFn, sizeof(cFn));
		wsprintf(cFn, "Save\\HelShot%03d.bmp", i);
		_mkdir("SAVE");
		pFile = fopen(cFn, "rb");
		if (pFile == NULL)
		{
			m_DDraw.Screenshot(cFn, m_DDraw.m_lpBackB4);
			wsprintf(G_cTxt, NOTIFYMSG_CREATE_SCREENSHOT1, cFn);
			AddEventList(G_cTxt, 10);
			return;
		}
		fclose(pFile);
	}
	AddEventList(NOTIFYMSG_CREATE_SCREENSHOT2, 10);
}

void CGame::UpdateScreen_OnConnecting()
{
 short sX, sY, msX, msY, msZ;
 char cLB, cRB;
 DWORD dwTime = timeGetTime();
 static class CMouseInterface * pMI;
 static DWORD dwMTime, dwCTime;
   
	if (m_cGameModeCount == 0) {
		m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
		dwCTime = dwMTime = timeGetTime();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE) {
		
		if ((dwTime - m_dwTime) > 1000) {
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			if (m_pLSock != NULL) {
				delete m_pLSock;
				m_pLSock = NULL;
			}
			if (m_pGSock != NULL) {
				delete m_pGSock;
				m_pGSock = NULL;
			}
		}

		m_bEscPressed = FALSE;
		return;
	}

	if ((dwTime - dwMTime) > 150) dwMTime = dwTime;

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	m_DDraw.ClearBackB4();

	m_bIsHideLocalCursor = TRUE;
	switch (m_cMsg[0]) {
	case '0':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;

	case '1':
		sX = 146; 
		sY = 114;
// for Terra
#ifdef DEF_ACCOUNTLONG
		_Draw_OnLogin(m_cAccountLong, m_cAccountPassword, 0, 0);
#else
		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
#endif
		break;

	case '2':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;

	case '3':
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
		break;

	case '4':
		// Change Password
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, TRUE);
		break;

	case '5':
		m_DDraw.ClearBackB4();
		break;
	}
	m_bIsHideLocalCursor = FALSE;
		
	m_DDraw.DrawShadowBox(0,0,639,479);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);
	wsprintf(G_cTxt, "Connecting to Server... %3dSec", (dwTime - m_dwTime)/1000);
	PutString_SprFont(172 + 35, 190, G_cTxt, 7,0,0);
	
	if ((dwTime - m_dwTime) > 7000) {
		PutAlignedString(180, 463, 195+30, UPDATE_SCREEN_ON_CONNECTING1);//"오랫동안 연결이 안되는 경우 ESC키를 누르면"
		PutAlignedString(180, 463, 195+45, UPDATE_SCREEN_ON_CONNECTING2);//"접속을 취소하고 초기화면으로 돌아갑니다."
	}
	else PutAlignedString(180, 463, 195+30, UPDATE_SCREEN_ON_CONNECTING3);//"  서버로 연결중입니다. 기다려 주세요..."

	DrawVersion();

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 8, dwTime);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnWaitInitData()
{
 short msX, msY, msZ;
 char cLB, cRB;
 DWORD dwTime = timeGetTime();

	if (m_cGameModeCount == 0) {
		m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE) {
		if ((dwTime - m_dwTime) > 7000) {
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			if (m_pLSock != NULL) {
				delete m_pLSock;
				m_pLSock = NULL;
			}
			if (m_pGSock != NULL) {
				delete m_pGSock;
				m_pGSock = NULL;
			}
		}
		m_bEscPressed = FALSE;
		return;
	}

	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);

	wsprintf(G_cTxt,"Waiting for response... %dsec", (dwTime - m_dwTime)/1000);
	PutString_SprFont(172+ 44, 190, G_cTxt, 7,0,0);
	if ((dwTime - m_dwTime) > 7000) {
		PutAlignedString(174, 467, 190+30, UPDATE_SCREEN_ON_WAIT_INIT_DATA1);//"오랫동안 연결이 안되는 경우 ESC키를 누르면"
		PutAlignedString(174, 467, 190+45, UPDATE_SCREEN_ON_WAIT_INIT_DATA2);//"접속을 취소하고 초기화면으로 돌아갑니다." 
	}
	else PutAlignedString(174, 467, 195+30, UPDATE_SCREEN_ON_WAIT_INIT_DATA3);//"  서버로 연결중입니다. 기다려 주세요..."

	DrawVersion();

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 8, dwTime);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnConnectionLost()
{
 short msX, msY, msZ;
 char cLB, cRB;
 static DWORD dwTime;

	if (m_cGameModeCount == 0) {
		dwTime = timeGetTime();
		// 비소리 루핑 스톱 
		if (m_bSoundFlag) m_pESound[38]->bStop();
		// 배경음악 스톱
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE)) {
			if (m_pBGM != NULL) m_pBGM->bStop();
		}
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	m_DDraw.ClearBackB4();
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);
	PutString_SprFont(172 + 54, 180, "Connection Lost!", 7,0,0);
	PutString(172+50, 180+30, UPDATE_SCREEN_ON_CONNECTION_LOST, RGB(0,0,0));//"서버와의 연결이 끊어졌습니다."

	DrawVersion();

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();

	if ((timeGetTime() - m_dwTime) > 5000) {		
		if (strlen(G_cCmdLineTokenA) != 0)
			 ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else 
		{
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
		}
	}
}

BOOL CGame::_bDraw_OnCreateNewCharacter(char * pName, short msX, short msY, int iPoint)
{
 BOOL bFlag = TRUE;
 DWORD dwTime = timeGetTime();
 int i=0;

	m_DDraw.ClearBackB4();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWCHAR, 0, 0, 0, TRUE);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0, 0, 69, TRUE);
	PutAlignedString(64, 282, 90, _BDRAW_ON_CREATE_NEW_CHARACTER1, 5,5,5);//"게임상의 캐릭터 이름을 정하십시오."
	PutAlignedString(57, 191, 110, DEF_MSG_CHARACTERNAME, 5,5,5);//"Character Name"
	if (m_cCurFocus != 1) PutString(197, 112, pName, RGB(25,35,25));
	PutAlignedString(64, 282, 140, _BDRAW_ON_CREATE_NEW_CHARACTER2, 5,5,5);//"캐릭터의 겉모습을 결정하십시오."
	PutString(100, 160, DEF_MSG_GENDER, RGB(5,5,5));//"Gender"
	PutString(100, 175, DEF_MSG_SKINCOLOR, RGB(5,5,5));//"Skin Color"
	PutString(100, 190, DEF_MSG_HAIRSTYLE, RGB(5,5,5));//"Hair Style"
	PutString(100, 205, DEF_MSG_HAIRCOLOR, RGB(5,5,5));//"Hair Color"
	PutString(100, 220, DEF_MSG_UNDERWEARCOLOR, RGB(5,5,5));//"Underwear Color"
	PutAlignedString(64, 282, 245, _BDRAW_ON_CREATE_NEW_CHARACTER3, 5,5,5);//"캐릭터의 특성치를 배당하십시오."
	wsprintf(G_cTxt, _BDRAW_ON_CREATE_NEW_CHARACTER4,  iPoint);//"남은 특성치 포인트: %d points"
	PutAlignedString(64, 282, 260, G_cTxt, 15,10,10);
	PutString(100, 275, DEF_MSG_STRENGTH, RGB(5,5,5));//"Strength"
	PutString(100, 292, DEF_MSG_VITALITY, RGB(5,5,5));//"Vitality"
	PutString(100, 309, DEF_MSG_DEXTERITY, RGB(5,5,5));//"Dexterity"
	PutString(100, 326, DEF_MSG_INTELLIGENCE, RGB(5,5,5));//"Intelligence"
	PutString(100, 343, DEF_MSG_MAGIC, RGB(5,5,5));//"Magic"
	PutString(100, 360, DEF_MSG_CHARISMA, RGB(5,5,5));//"Charisma"

	wsprintf(G_cTxt, "%d", m_ccStr);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccVit);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccDex);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccInt);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccMag);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccChr);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	PutAlignedString(64, 295, 380, _BDRAW_ON_CREATE_NEW_CHARACTER5, 5,5,5);//"각각 10~14사이의 값을 가질 수 있습니다."

	if (strlen(pName) <= 0) bFlag = FALSE;
	if (iPoint > 0) bFlag = FALSE;
	if (m_Misc.bCheckValidName(pName) == FALSE) bFlag = FALSE;
	if (_bCheckBadWords(pName) == TRUE) bFlag = FALSE;

	if ( (bFlag == TRUE) && (m_cCurFocus == 2) ) m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(384, 445, 25, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(384, 445, 24, dwTime);
	if (m_cCurFocus == 3) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(500, 445, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(500, 445, 16, dwTime);
	if (m_cCurFocus == 4) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60, 445, 68, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60, 445, 67, dwTime);
	if (m_cCurFocus == 5)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145, 445, 66, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145, 445, 65, dwTime);
	if (m_cCurFocus == 6) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230, 445, 64, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230, 445, 63, dwTime);

	ShowReceivedString();

	switch (m_cGender) {
	case 1:	_tmp_sOwnerType = 1; break;
	case 2:	_tmp_sOwnerType = 4; break; //@@@@@@@@@@@@@@@@@!!!!!!!!!!!!!!!!!
	}
	_tmp_sOwnerType += m_cSkinCol - 1;
	_tmp_cDir   = m_cMenuDir;
	_tmp_sAppr1 = 0;
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cUnderCol);
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cHairStyle << 8);
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cHairCol << 4);
	_tmp_sAppr2 = 0;
	_tmp_sAppr3 = 0;
	_tmp_sAppr4 = 0;
	ZeroMemory(_tmp_cName, sizeof(_tmp_cName));
	memcpy(_tmp_cName, m_cPlayerName,10);
	_tmp_cAction = DEF_OBJECTMOVE;
	_tmp_cFrame = m_cMenuFrame;

	_Draw_CharacterBody( 507 , 267, _tmp_sOwnerType);

	DrawObject_OnMove_ForMenu(0, 0, 500 , 174, FALSE, dwTime, msX, msY);
	
    i = 0 ;

	PutString(445, 192, DEF_MSG_HITPOINT, RGB(5,5,5));//"Hit Point"
	wsprintf(G_cTxt, "%d", m_ccVit*3 + 2 + m_ccStr/2);
	PutString(550, 192 + 16*i++, G_cTxt, RGB(25,35,25));

	PutString(445, 208, DEF_MSG_MANAPOINT, RGB(5,5,5));//"Mana Point"
	wsprintf(G_cTxt, "%d", m_ccMag*2 + 2 + m_ccInt/2);
	PutString(550, 192 + 16*i++, G_cTxt, RGB(25,35,25));

	PutString(445, 224, DEF_MSG_STAMINARPOINT, RGB(5,5,5));//"Staminar Point"
	wsprintf(G_cTxt, "%d", m_ccStr*2 + 2);
	PutString(550, 192 + 16*i++, G_cTxt, RGB(25,35,25));

	return bFlag;
}

void CGame::UpdateScreen_OnCreateNewCharacter()
{
 static class CMouseInterface * pMI;
//short sX, sY;
 int i=0;	

 int iMIbuttonNum;
 static int iPoint;
 char cLB, cRB, cMIresult; 
 static char cName[12];
 static char cPrevFocus;
 short msX, msY, msZ;
 BOOL bFlag;
 static DWORD dwMTime;
 DWORD dwTime = timeGetTime();

//	sX = 0 ;
//	sY = 0;
	
	if (m_cGameModeCount == 0) {
		pMI = new class CMouseInterface;
		pMI->AddRect(65+4, 65+45, 275+4, 82+45);
		
		pMI->AddRect(232+4, 111+45, 274+4 -21, 124+45);
		pMI->AddRect(255+4, 111+45, 289+4 -13, 124+45);

		pMI->AddRect(232+4, 126+45, 274+4 -21, 139+45);
		pMI->AddRect(255+4, 126+45, 289+4 -13, 139+45);

		pMI->AddRect(232+4, 141+45, 274+4 -21, 154+45);
		pMI->AddRect(255+4, 141+45, 289+4 -13, 154+45);

		pMI->AddRect(232+4, 156+45, 274+4 -21, 169+45);
		pMI->AddRect(255+4, 156+45, 289+4 -13, 169+45);

		pMI->AddRect(232+4, 171+45, 274+4 -21, 184+45);
		pMI->AddRect(255+4, 171+45, 289+4 -13, 184+45);


		pMI->AddRect(232+4, 231+45, 253+4, 244+45);
		pMI->AddRect(255+4, 231+45, 276+4, 244+45);

		pMI->AddRect(232+4, 246+45, 253+4, 259+45);
		pMI->AddRect(255+4, 246+45, 276+4, 259+45);

		pMI->AddRect(232+4, 261+45, 253+4, 274+45);
		pMI->AddRect(255+4, 261+45, 276+4, 274+45);

		pMI->AddRect(232+4, 276+45, 253+4, 289+45);
		pMI->AddRect(255+4, 276+45, 276+4, 289+45);
		
		pMI->AddRect(232+4, 291+45, 253+4, 304+45);
		pMI->AddRect(255+4, 291+45, 276+4, 304+45);

		pMI->AddRect(232+4, 306+45, 253+4, 319+45);
		pMI->AddRect(255+4, 306+45, 276+4, 319+45);

		pMI->AddRect(384, 445, 384+72, 445+15);
		pMI->AddRect(500, 445, 500+72, 445+15);

		pMI->AddRect(60, 445, 60+72, 445+15);
		pMI->AddRect(145, 445, 145+72, 445+15);
		pMI->AddRect(230, 445, 230+72, 445+15);
	
		iPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
		iPoint  = 70 - iPoint;

		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 6;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;

		dwMTime = timeGetTime();

		StartInputString(193+4, 65+45, 11, cName);
		ClearInputString();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(193+4, 65+45, 11, cName);
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	bFlag = _bDraw_OnCreateNewCharacter(cName, msX, msY, iPoint);
	
	if ((dwTime - dwMTime) > 100) {
		m_cMenuFrame++;
		dwMTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	DrawVersion();
	// 마우스 커서를 그린다.
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스클릭. 
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
			m_cCurFocus = 1;
			break;
		case 2:
			m_cGender--;
			if (m_cGender < 1) m_cGender = 2;
			break;
		case 3:
			m_cGender++;
			if (m_cGender > 2) m_cGender = 1; 
			break;
		case 4: 
			m_cSkinCol--;
			if (m_cSkinCol < 1) m_cSkinCol = 3; 
			break;
		case 5: 
			m_cSkinCol++;
			if (m_cSkinCol > 3) m_cSkinCol = 1; 
			break;
		case 6: 
			m_cHairStyle--;
			if (m_cHairStyle < 0) m_cHairStyle = 7; 
			break;
		case 7: 
			m_cHairStyle++;
			if (m_cHairStyle > 7) m_cHairStyle = 0; 
			break;
		case 8: 
			m_cHairCol--;
			if (m_cHairCol < 0) m_cHairCol = 15; 
			break;
		case 9: 
			m_cHairCol++;
			if (m_cHairCol > 15) m_cHairCol = 0; 
			break;
		case 10: 
			m_cUnderCol--;
			if (m_cUnderCol < 0) m_cUnderCol = 7; 
			break;
		case 11: 
			m_cUnderCol++;
			if (m_cUnderCol > 7) m_cUnderCol = 0; 
			break;
		case 12:
			if (iPoint > 0) {
				if (m_ccStr < 14) {
					m_ccStr++;
					iPoint--;
				}
			}
			break;
		case 13:
			if (m_ccStr > 10) {
				m_ccStr--;
				iPoint++;
			}
			break;
		case 14:
			if (iPoint > 0) {
				if (m_ccVit < 14) {
					m_ccVit++;
					iPoint--;
				}
			}
			break;
		case 15:
			if (m_ccVit > 10) {
				m_ccVit--;
				iPoint++;
			}
			break;
		case 16:
			if (iPoint > 0) {
				if (m_ccDex < 14) {
					m_ccDex++;
					iPoint--;
				}
			}
			break;
		case 17:
			if (m_ccDex > 10) {
				m_ccDex--;
				iPoint++;
			}
			break;
		case 18:
			if (iPoint > 0) {
				if (m_ccInt < 14) {
					m_ccInt++;
					iPoint--;
				}
			}
			break;
		case 19:
			if (m_ccInt > 10) {
				m_ccInt--;
				iPoint++;
			}
			break;
		case 20:
			if (iPoint > 0) {
				if (m_ccMag < 14) {
					m_ccMag++;
					iPoint--;
				}
			}
			break;
		case 21:
			if (m_ccMag > 10) {
				m_ccMag--;
				iPoint++;
			}
			break;
		case 22:
			if (iPoint > 0) {
				if (m_ccChr < 14) {
					m_ccChr++;
					iPoint--;
				}
			}
			break;
		case 23:
			if (m_ccChr > 10) {
				m_ccChr--;
				iPoint++;
			}
			break;

		case 24:
			if (m_cCurFocus != 2) {
				m_cCurFocus = 2;
				return;
			}
			if (bFlag == FALSE) return;
			// 캐릭터 생성 요청 메시지를 전송한다.
			//if (m_Misc.bCheckValidName(m_cPlayerName) == FALSE) break;
			if (m_Misc.bCheckValidName(cName) == FALSE) break;
			
			ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
			strcpy(m_cPlayerName, cName);
			
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWCHARACTER;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg,"22");
			delete pMI;
			return;


		case 25:
			if (m_cCurFocus != 3) {
				m_cCurFocus = 3;
				return;
			}
			// 캐릭터 선택메뉴로 돌아간다.
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			return;
		

		case 26:
			if (m_cCurFocus != 4) {
				m_cCurFocus = 4;
				return;
			}
		
			m_ccMag = 10 ;
			m_ccInt = 10 ;
			m_ccChr = 10 ;
			m_ccStr = 14 ;
			m_ccVit = 12 ;
			m_ccDex = 14 ;
			iPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			iPoint  = 70 - iPoint;
			break;

		case 27:
			if (m_cCurFocus != 5) {
				m_cCurFocus = 5;
				return;
			}
		
			m_ccMag = 14 ;
			m_ccInt = 14 ;
			m_ccChr = 10 ;
			m_ccStr = 10 ;
			m_ccVit = 12 ;
			m_ccDex = 10 ;
			iPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			iPoint  = 70 - iPoint;
			break;

		case 28:
			if (m_cCurFocus != 6) {
				m_cCurFocus = 6;
				return;
			}
		
			m_ccMag = 10 ;
			m_ccInt = 10 ;
			m_ccChr = 14 ;
			m_ccStr = 14 ;
			m_ccVit = 10 ;
			m_ccDex = 12 ;
			iPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			iPoint  = 70 - iPoint;
			break;
		}	


	}

	if ((msX >= 65+4-127) && (msX <= 275+4) && (msY >= 65+45) && (msY <= 82+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER1);
		                                //"캐릭터 이름을 입력합니다."
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 111+45) && (msY <= 124+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER2);
		                                //"캐릭터의 성별을 선택합니다."
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 126+45) && (msY <= 139+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER3);
		                                //"캐릭터의 피부색을 선택합니다."
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 141+45) && (msY <= 154+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER4);
		                                //"캐릭터의 머리카락 모양을 선택합니다."
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 156+45) && (msY <= 169+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER5);
		                               //"캐릭터의 머리카락 색상을 선택합니다."
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 171+45) && (msY <= 184+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER6);
		                                //"캐릭터의 속옷 색상을 선택합니다."
	}
	else
	if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 231+45) && (msY <= 244+45)) {
		// Str
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER7);//"캐릭터의 힘(Str)특성 초기치를"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER8);//"할당합니다. Str특성치가 높을수록"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER9);//"캐릭터의 체력(HP)과 스테미너(SP)의"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER10);//"최대값이 높아지며 보다 무거운"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER11);//"무기나 방어구를 장착할 수 있습니다."
	}
	else
	if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 246+45) && (msY <= 259+45)) {
		// Vit
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER12);//"캐릭터의 생명력(Vit) 초기치를"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER13);//"할당합니다. Vit특성치가 높을수록"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER14);//"체력의 회복 포인트가 많아지며 HP의"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER15);//"최대값이 높아집니다. 또한 물리적"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER16);//"대미지를 흡수하는 효과가 추가됩니다." 
	}
	else
	if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 261+45) && (msY <= 274+45)) {
		// Dex
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER17);//"캐릭터의 민첩성(Dex) 초기치를"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER18);//"할당합니다. Dex특성치가 높을수록" 
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER19);//"물리공격에 대한 회피력이 증가되며"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER20);//"무기 사용시의 명중률이 높아집니다."
	}
	else
	if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 276+45) && (msY <= 289+45)) {
		// Int
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER21);//"캐릭터의 지능(Int) 초기치를"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER22);//"할당합니다. Int특성치가 높을수록"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER23);//"배울 수 있는 마법이 많아지며 Mana의" 
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER24);//"최대값이 높아집니다."
	}
	else
	if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 291+45) && (msY <= 304+45)) {
		// Mag
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER25);//"캐릭터의 마력(Mag) 초기치를" 
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER26);//"할당합니다. Mag특성치가 높을수록"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER27);//"마법 관련 능력이 향상되며 Mana의"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER28);//"최대값이 높아집니다."
	}
	else
	if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 306+45) && (msY <= 319+45)) {
		// Charisma
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER29);//"캐릭터의 카리스마(Chr) 초기치를"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER30);//"할당합니다. Chr특성치가 일정수준"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER31);//"이상되면 길드를 조직할 수"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER32);//"있습니다."
	}
	else 	
		

	if ((msX >= 384) && (msX <= 384+72) && (msY >= 445) && (msY <= 445+15))  {
		m_cCurFocus = 2;  
		if (strlen(cName) <= 0) {
			i= 0 ;
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER33);//"캐릭터 이름이 지정되지 않아 캐릭터를"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER34);//"만들 수 없습니다. 캐릭터의 이름을"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER35);//"입력해 주십시오."
		}
		else if (iPoint > 0) {
			i= 0 ;
#if DEF_LANGUAGE == 5
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER36);//"할당된 특성치 포인트를 모두 할당하지"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER37);//"않아 만들 수 없습니다. 남은 특성치"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER38);//"포인트를 모두 할당해 주십시오."
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER38_1);//"포인트를 모두 할당해 주십시오."
#else
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER36);//"할당된 특성치 포인트를 모두 할당하지"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER37);//"않아 만들 수 없습니다. 남은 특성치"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER38);//"포인트를 모두 할당해 주십시오."
#endif
		} 
		else if (m_Misc.bCheckValidName(cName) == FALSE) {
			i= 0 ;
#if DEF_LANGUAGE == 5
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER39);//"캐릭터 이름에 사용될 수 없는"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER40);//"특수문자가 섞여 있습니다. 다른 캐릭터"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER41);//"이름을 입력해 주십시오."
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER41_1);//"이름을 입력해 주십시오."
#else
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER39);//"캐릭터 이름에 사용될 수 없는"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER40);//"특수문자가 섞여 있습니다. 다른 캐릭터"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER41);//"이름을 입력해 주십시오."
#endif
		}
		else if (_bCheckBadWords(cName) == TRUE) {
			i= 0 ;
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER42);//"캐릭터 이름이 적절하지 않습니다."
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER43);//"다른 이름을 입력해 주십시오."
		}
		else {
			i= 0 ;
//2002.09.26 정진광 수정. 일본어 표현이 겹치므로....
#if DEF_LANGUAGE == 5			
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER44);//"위의 내용으로 캐릭터를 만듭니다."
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER45);//"일단 만들어진 캐릭터의 초기 특성치의"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER46);//"변경은 불가능하므로 특성치 배분에"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER47);//"주의를 기울여 주십시오. 이 설정대로"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER48);//"캐릭터를 만들려면 버튼을 눌러주세요."
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER48_1);//"캐릭터를 만들려면 버튼을 눌러주세요."
#else			
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER44);//"위의 내용으로 캐릭터를 만듭니다."
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER45);//"일단 만들어진 캐릭터의 초기 특성치의"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER46);//"변경은 불가능하므로 특성치 배분에"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER47);//"주의를 기울여 주십시오. 이 설정대로"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER48);//"캐릭터를 만들려면 버튼을 눌러주세요."
#endif
		}
	}
	else

	if ((msX >= 500) && (msX <= 500+72) && (msY >= 445) && (msY <= 445+15)) {
		m_cCurFocus = 3; 
		PutAlignedString(370, 580, 345 , UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER49);//"캐릭터 선택 메뉴로 돌아갑니다."
	}

	if ((msX >= 60) && (msX <= 60+72) && (msY >= 445) && (msY <= 445+15)) {
		m_cCurFocus = 4; 
		PutAlignedString(370, 580, 345 , UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER50);//"전사형 특성치를 배당합니다."
	}

	if ((msX >= 145) && (msX <= 145+72) && (msY >= 445) && (msY <= 445+15)) {
		m_cCurFocus = 5; 
		PutAlignedString(370, 580, 345 , UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER51);//"마법사형 특성치를 배당합니다." 
	}

	if ((msX >= 230) && (msX <= 230+72) && (msY >= 445) && (msY <= 445+15)) {
		m_cCurFocus = 6; 
		PutAlignedString(370, 580, 345 , UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER52);//"마스터형 특성치를 배당합니다."
	}

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#ifdef DEF_MAKE_ACCOUNT

void CGame::_LoadAgreementTextContents(char cType)
{
 char * pContents, * token, cTemp[120], cFileName[120];
 char   seps[] = "\n";
 int    iIndex = 0, i;
 class  CStrTok * pStrTok;
 DWORD  dwFileSize;
 HANDLE hFile;
 FILE * pFile;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pAgreeMsgTextList[i] != NULL) 
			delete m_pAgreeMsgTextList[i];
		m_pAgreeMsgTextList[i] = NULL;
	}

	//// cType에 따라 맞는 내용을 로드한다. 
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", cType);

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return;
	else {
		pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
	}

	fclose(pFile);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		m_pAgreeMsgTextList[iIndex] = new class CMsg(NULL, token, NULL);
		token = pStrTok->pGet();
		iIndex++;
	}	
	delete pStrTok;
	delete[] pContents;
}

void CGame::UpdateScreen_OnAgreement()
{
 short sX, sY, msX, msY, msZ;
 char  cLB, cRB;
 char  cMIresult;
 static class CMouseInterface * pMI; 
 int i, iTotalLines, iPointerLoc;
 DWORD dwTime = timeGetTime();
 double d1,d2,d3;
 int iMIbuttonNum;
	
	sX = 121;
	sY = 22;
	
	if (m_cGameModeCount == 0) {
		m_iAgreeView = 0;
		_LoadAgreementTextContents(0);

		pMI = new class CMouseInterface;
		pMI->AddRect(sX+82 -105, sY+355,sX+131 -105,sY+374);
		pMI->AddRect(sX+235 -105, sY+355,sX+303 -105,sY+375);
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;
	if (m_bEnterPressed == TRUE) {
		PlaySound('E', 14, 5);
		ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
		ClearContents_OnCreateNewAccount();
		delete pMI;
		return;
	}
	if (m_bEscPressed == TRUE) {
		PlaySound('E', 14, 5);
		#ifdef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
		#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		#endif
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		switch (iMIbuttonNum) {
		case 1:
			// Agree
			PlaySound('E', 14, 5);
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
			ClearContents_OnCreateNewAccount();
			delete pMI;
			return;
			
		case 2:
			// DisAgree
			PlaySound('E', 14, 5);
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			delete pMI;
			return;
		}
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_AGREEMENT, 0,0,0, TRUE);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, 43, 38,12, FALSE);

	iTotalLines = 0;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) 
	if (m_pAgreeMsgTextList[i] != NULL) iTotalLines++;

	d1 = (double)m_iAgreeView;
	d2 = (double)(iTotalLines - 20);
	d3 = (double)d1 / d2;
	d1 = 338.0f * d3;
	iPointerLoc = (int)d1;
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX +361 -112, sY +37 +13 +iPointerLoc, 7, dwTime);

	for (i = 0; i < 20; i++)
	if (m_pAgreeMsgTextList[i + m_iAgreeView] != NULL) {
		PutAlignedString(60, 360, sY + 65 +i*13, m_pAgreeMsgTextList[i + m_iAgreeView]->m_pMsg, 45,25,25);
	}

	if( msZ != 0 )
	{
		m_iAgreeView = m_iAgreeView - msZ/60;
		m_DInput.m_sZ = 0;
	}
	if (cLB != 0 && iTotalLines > 20) { 
		// 스크롤 슬라이드 
		if ((msX >= sX +345 -112) && (msX <= sX +380 -112) && (msY >= sY +50) && (msY <= sY +395)) {
			d1 = (double)(msY - (sY + 37 +13));
			d2 = (double)(iTotalLines - 17);
			d3 = (double)(d1 * d2)/(338.0f);
			m_iAgreeView = (int)d3;

			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutTransSprite(sX +361 -112, sY +37 +13 +iPointerLoc, 4, dwTime);
		}
	}
	if( m_iAgreeView < 0 ) m_iAgreeView = 0;
	if( iTotalLines > 20 && m_iAgreeView > iTotalLines-20 ) m_iAgreeView = iTotalLines-20;

	if ((msX > sX + 82 -105) && (msX < sX + 131 -105) && (msY > sY + 355 -3) && (msY < sY + 374 +3)) 
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 43 + 20 -23 +45 -105,  sY + 265 +90, 13);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 43 + 20 -23 +45 -105,  sY + 265 +90, 12);

	if ((msX > sX + 235 -105) && (msX < sX + 303 -105) && (msY > sY + 355 -3) && (msY < sY + 375 +3))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 158 + 57 -23 +45 -105, sY + 265 +90, 15);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 158 + 57 -23 +45 -105, sY + 265 +90, 14);

	DrawVersion(); 
	// 마우스 커서 그린다.
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#if DEF_LANGUAGE == 2	// 언어:Chinese
void CGame::UpdateScreen_OnCreateNewAccount() //for CHINESE
{
 short msX, msY, msZ;
 char cLB, cRB;
 
 char cMIresult;
 int  iMIbuttonNum;
	
 static class CMouseInterface * pMI;
 static char cName[12], cPassword[12], cConfirm[12], cPrevFocus, cSSN[20], cQuiz[44] ,cAnswer[20], cTempQuiz[44] ;
 
 DWORD dwTime = timeGetTime();

 int iFlag = 0;

	if (m_cGameModeCount == 0) {
		pMI = new class CMouseInterface;
		pMI->AddRect(310, 80,560,100);
		pMI->AddRect(310,101,558,122);
		pMI->AddRect(310,123,558,145);
		pMI->AddRect(310,146,558,167);
		pMI->AddRect(310,168,558,191);

		pMI->AddRect(300,192,560,231);
		pMI->AddRect(300,232,560,268);   // Quiz 8  // +41
		pMI->AddRect(300,269,560,306);   // Answer 9  
		
		pMI->AddRect(297, 399, 367, 417);  // Create 10
		pMI->AddRect(392, 399, 462, 417);  // Clear  11
		pMI->AddRect(488, 399, 558, 417);  // Cancel  12 버튼 Size 73 x 15
		
		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 11; //9
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
		
		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cPassword, sizeof(cPassword));
		ZeroMemory(cConfirm, sizeof(cConfirm));
		ZeroMemory(cSSN, sizeof(cSSN));
		ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
		ZeroMemory(cQuiz, sizeof(cQuiz));
		ZeroMemory(cTempQuiz, sizeof(cTempQuiz));        // Quiz의 공백을 '_' 로 바꾼 내용을 저장하기 위한 변수
		ZeroMemory(cAnswer, sizeof(cAnswer));

		StartInputString(427, 84, 11, cName);
		ClearInputString();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI; 
		m_bEscPressed = FALSE;
		return;
	}

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(427, 84, 11, cName);
			break;
		case 2:
			StartInputString(427, 106, 11, cPassword);
			break;
		case 3:
			StartInputString(427, 129, 11, cConfirm);
			break;
		case 4:
			StartInputString(427, 153, 15, m_cAccountCountry);
			break;
		case 5:
			StartInputString(427, 176, 19, cSSN);
			break;
		case 6:
			StartInputString(311, 215, 31, m_cEmailAddr);
			break;
		case 7:
			StartInputString(311, 253, 44, cQuiz);
			break;
		case 8:
			StartInputString(311, 291 , 19, cAnswer);
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWACCOUNT, 0,0,0, TRUE);

	if ((m_cCurFocus == 2) || (m_cCurFocus == 3))
		 ShowReceivedString(TRUE);
	else if ((m_cCurFocus == 1) || (m_cCurFocus == 4) || (m_cCurFocus == 5) || (m_cCurFocus == 6) || (m_cCurFocus == 7) || (m_cCurFocus == 8)|| (m_cCurFocus == 9))
		ShowReceivedString();

	if (m_cCurFocus != 1) {
		if (m_Misc.bCheckValidName(cName) != FALSE)
			 PutString2(427, 84, cName, 200,200,200);
		else PutString2(427, 84, cName, 200,100,100);
	}
	if (m_cCurFocus != 2) {
		if ((m_Misc.bCheckValidName(cPassword) != FALSE) && (strlen(cPassword) >= 8))
			 PutString(427, 106, cPassword, RGB(200,200,200), TRUE, 1);
		else PutString(427, 106, cPassword, RGB(200,100,100), TRUE, 1);
	}
	
	if (m_cCurFocus != 3) {
		if (memcmp(cPassword, cConfirm, 10) == 0)
			 PutString(427, 129, cConfirm,  RGB(200,200,200), TRUE, 1);
		else PutString(427, 129, cConfirm,  RGB(200,100,100), TRUE, 1);
	}
	if (memcmp(cPassword, cConfirm, 10) != 0) iFlag = 9;
	if (m_cCurFocus != 4) PutString2(427, 153, m_cAccountCountry, 200,200,200);
	if (m_cCurFocus != 5) PutString2(427, 176, cSSN, 200,200,200);
	if (m_cCurFocus != 5) {
		ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
		strcpy( m_cAccountSSN, cSSN );
		if (m_Misc.bIsValidSSN(m_cAccountSSN) == TRUE) PutString2(427, 176, cSSN, 200,200,200);
		else PutString2(427, 176, cSSN, 200,100,100);
	}
	if (m_cCurFocus != 6) {
		if( m_Misc.bIsValidEmail( m_cEmailAddr ) )
			PutString2(311, 48 + 190 -25 +2, m_cEmailAddr, 200,200,200);
		else PutString2(311, 48 + 190 -25 +2, m_cEmailAddr, 200,100,100);
	}

	wsprintf(cTempQuiz,"%s",cQuiz) ;
	m_Misc.ReplaceString(cTempQuiz, ' ', '_');

	if (m_cCurFocus != 7) {
		if((m_Misc.bCheckValidName(cTempQuiz) != FALSE) && (strlen(cTempQuiz) >= 10))
			PutString2(311, 48 + 226 -25 +4, cQuiz, 200,200,200);
		else PutString2(311, 48 + 226 -25 +4, cQuiz, 200,100,100);
	}

	if (m_cCurFocus != 8) {
		if ((m_Misc.bCheckValidName(cAnswer) != FALSE) && (strlen(cAnswer) >= 4))
			 PutString2(311, 291, cAnswer, 200,200,200);
		else PutString2(311, 291, cAnswer, 200,100,100);
	}

	if (m_Misc.bCheckValidName(cAnswer) == FALSE)		iFlag = 13;
	if (m_Misc.bCheckValidName(cTempQuiz) == FALSE)		iFlag = 12;
	if (strlen(cAnswer) < 4)							iFlag = 11;
	if (strlen(cTempQuiz) < 10)							iFlag = 10;
	if (m_Misc.bIsValidSSN(cSSN) == FALSE)				iFlag = 8;
	if (m_Misc.bCheckValidName(cPassword) == FALSE)		iFlag = 7;
	if (m_Misc.bCheckValidName(cName) == FALSE)			iFlag = 6;
	if (m_Misc.bIsValidEmail(m_cEmailAddr) == FALSE)	iFlag = 5;
	if (strlen(m_cAccountCountry) == 0)					iFlag = 4;
	if (strlen(cConfirm) == 0)							iFlag = 3;
	if (strlen(cPassword) < 8)							iFlag = 2;
	if ((strlen(cName) == 0 ))							iFlag = 1;

// v1.4334 Quiz 추가 

	switch (m_cCurFocus) {
	case 1:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT1);//"사용자의 계정 이름을 입력합니다."
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT2);//"계정이름은 특수문자를 제외한 영문,숫자,"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT3);//"한글의 조합으로 이루어져야 합니다. "
		break;

	case 2:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT4);//"계정의 패스워드를 입력합니다." 
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT5);//"패스워드는 특수문자를 제외한 영문,숫자,"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT6);//"한글의 조합으로 최소 8문자 이상 입력"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT7);//"하셔야 합니다."
		break;

	case 3:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT8);//"패스워드를 한번 더 입력합니다."
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT9);//"전에 입력한 패스워드와 정확하게 일치해야"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT10);//"합니다."
		break;

	case 4:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT11);//"본래 이름을 입력합니다."
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT12);//"입력된 실명은 계정관련 처리시에 계정의"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT13);//"주인임을 확인하는 데 사용되므로 정확히"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT14);//"입력해야 합니다."
		break;

	case 5:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT15);//" 주민등록번호의 윗자리를 입력합니다. "
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT16);//"잘못된 주민등록번호를 입력하면 계정을 만들"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT17);//"수 없으니 주의하세요."
		break;

	case 6:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT21);//"본인의 E-Mail주소를 입력합니다."  
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT22);//"입력된 E-Mail 주소는 계정관련 처리시에"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT23);//"계정의 주인임을 확인하는 데 사용되므로"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT24);//"정확히 입력해야 합니다."
		break;

	case 7:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT25);//"패스워드 분실시 찾을 수 있도록"
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT26);//"질문을 입력합니다. 질문은 특수문자를 제외한"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT27);//"영문,숫자,한글의 조합으로 최소 10문자 이상"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT28);//"입력 하셔야 합니다."
		break;

	case 8:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT29);//"위에 질문의 답을 입력합니다."
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT30);//"답은 특수문자를 제외한 영문,숫자,"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT31);//"한글의 조합으로 최소 4문자 이상 입력"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT32);//"하셔야 합니다."
		break;

	case 9:
		switch (iFlag) {
		case 0:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT33);//"입력된 내용으로 계정을 만듭니다."
			break;

		case 1:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT34);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT35);//"수 없습니다. 계정의 이름이 입력되지 않았"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT36);//"습니다. 계정이름을 입력해 주십시오."
			break;

		case 2:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT37);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT38);//"수 없습니다. 패스워드의 문자수가 8자리 미만"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT39);//"입니다. 패스워드를 8문자 이상 입력해 주십"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT40);//"시오. "
			break;

		case 3:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT41);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT42);//"수 없습니다. Pass-confirm 항목이 입력"  
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT43);//"되지 않았습니다. Pass-confirm 항목을"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT44);//"입력해 주십시오."
			break;

		case 4:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT45);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT46);//"수 없습니다. 실제 이름이 입력되지 않았"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT47);//"습니다. 실제 이름을 입력해 주십시오."
			break;

		case 5:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT48);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT49);//"수 없습니다. E-Mail 주소가 입력되지 않았"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT50);//"습니다. E-Mail 주소를 입력해 주십시오."
			break;

		case 6:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT51);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT52);//"수 없습니다. 계정 이름에 특수 문자가 섞여"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT53);//"있습니다. 특수문자를 사용하지 않은 새로운 "
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT54);//"계정 이름을 입력해 주십시오."
			break;

		case 7:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT55);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT56);//"수 없습니다. 패스워드에 특수 문자가 섞여"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT57);//"있습니다. 특수문자를 사용하지 않은 새로운"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT58);//"패스워드를 입력해 주십시오."
			break;

		case 8:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT59);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT60);//"수 없습니다. 잘못된 주민등록번호 입니다."
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT61);//"올바른 주민등록번호를 입력해 주십시오."
			break;

		case 9:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT62);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT63);//"수 없습니다. 패스워드와 확인 패스워드"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT64);//"항목의 내용이 서로 다릅니다. 패스워드가 "
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT65);//"서로 일치하도록 다시 입력 하십시오"
			break;
		case 10:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT66);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT67);///"수 없습니다. Quiz의 내용은 10자 이상이"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT68);//"되어야 합니다."
			break;
		case 11:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT69);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT70);//"수 없습니다. Answer의 내용은 4자 이상이"   
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT71);//"되어야 합니다."
			break;
		case 12:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT72);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT73);//"수 없습니다. Quiz에 특수 문자가 섞여"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT74);//"있습니다. 특수문자를 사용하지 않은 새로운"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT75);//"Quiz를 입력해 주십시오."
			break;

		case 13:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT76);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT77);//"수 없습니다. Answer에 특수 문자가 섞여"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT78);//"있습니다. 특수문자를 사용하지 않은 새로운"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT79);//"Answer를 입력해 주십시오."
			break;

		}
		break;

	case 10:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT80);
		                                              //"입력된 모든 내용을 지웁니다."
		break;

	case 11:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT81);
			                                              //"메인 메뉴 화면으로 돌아갑니다."
		break;
	}


	if ( (iFlag == 0) && (m_cCurFocus == 9) ) m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(199+98, 398, 25, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(199+98, 398, 24, dwTime);

	if (m_cCurFocus == 10) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(294+98, 398, 27, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(294+98, 398, 26, dwTime);

	if (m_cCurFocus == 11) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(390+98, 398, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(390+98, 398, 16, dwTime);
	
	DrawVersion();
	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다.
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 9:
			// 입력조건이 다 완성되지 않았다면 접속할 수 없다.
			if (iFlag != 0) return;
			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));

			ZeroMemory(m_cAccountQuiz, sizeof(m_cAccountQuiz));
			ZeroMemory(m_cAccountAnswer, sizeof(m_cAccountAnswer));
			
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);

			strcpy(m_cAccountQuiz, cTempQuiz);
			strcpy(m_cAccountAnswer, cAnswer);
			m_cAccountQuiz[45] = ' ' ;
			m_cAccountAnswer[20] = ' ' ;
		
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			strcpy(m_cAccountSSN, cSSN);

			if (memcmp(cPassword, cConfirm, 10) != 0) {
				// 패스워드와 확인코드가 일치하지 않는다.
				ChangeGameMode(DEF_GAMEMODE_ONMSG);
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT82);
				               //"Cannot create account! - password not match!"
				delete pMI;
				return;
			}

			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWACCOUNT;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "00");
			delete pMI;
			return;

		case 10:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cPassword, sizeof(cPassword));
			ZeroMemory(cConfirm, sizeof(cConfirm));
			ZeroMemory(m_cAccountAge, sizeof(m_cAccountAge));
			ZeroMemory(m_cAccountCountry, sizeof(m_cAccountCountry));
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			ZeroMemory(m_cEmailAddr, sizeof(m_cEmailAddr));
			ZeroMemory(cSSN, sizeof(cSSN));
			ZeroMemory(cQuiz, sizeof(cQuiz));
			ZeroMemory(cTempQuiz, sizeof(cTempQuiz));
			ZeroMemory(cAnswer, sizeof(cAnswer));

			break;

		case 11:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
		m_bEnterPressed = FALSE;
	}

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		default:
			m_cCurFocus = iMIbuttonNum;
			break;
				
		case 9:
			// 입력조건이 다 완성되지 않았다면 접속할 수 없다.
			if (iFlag != 0) return;
			// 새 캐릭터 생성을 요구한다.
			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));

			ZeroMemory(m_cAccountQuiz, sizeof(m_cAccountQuiz));
			ZeroMemory(m_cAccountAnswer, sizeof(m_cAccountAnswer));
			

			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			strcpy(m_cAccountQuiz, cTempQuiz);
			strcpy(m_cAccountAnswer, cAnswer);
			
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			strcpy(m_cAccountSSN, cSSN);

			if (memcmp(cPassword, cConfirm, 10) != 0) {
				// 패스워드와 확인코드가 일치하지 않는다.
				ChangeGameMode(DEF_GAMEMODE_ONMSG);
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT82);
				               //"Cannot create account! - password not match!"
				delete pMI;
				return;
			}

			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);

			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWACCOUNT;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "00");
			delete pMI;
			return;
		
		case 10:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cPassword, sizeof(cPassword));
			ZeroMemory(cConfirm, sizeof(cConfirm));
			ZeroMemory(m_cAccountAge, sizeof(m_cAccountAge));
			ZeroMemory(m_cAccountCountry, sizeof(m_cAccountCountry));
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			ZeroMemory(m_cEmailAddr, sizeof(m_cEmailAddr));
			ZeroMemory(cSSN, sizeof(cSSN));
			ZeroMemory(cQuiz, sizeof(cQuiz));
			ZeroMemory(cTempQuiz, sizeof(cTempQuiz));
			ZeroMemory(cAnswer, sizeof(cAnswer));
			break;
		
		case 11:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}
	
	if ((msX >= 297) && (msX <= 370) && (msY >= 396) && (msY <= 417))  m_cCurFocus = 9;  //12
	if ((msX >= 392) && (msX <= 465) && (msY >= 396) && (msY <= 417)) m_cCurFocus = 10;  //13
	if ((msX >= 488) && (msX <= 561) && (msY >= 396) && (msY <= 417)) m_cCurFocus = 11; //14

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);
   	
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#else

void CGame::UpdateScreen_OnCreateNewAccount() // for KOREAN
{
 short msX, msY, msZ;
 char cLB, cRB;
 
 char cMIresult;
 int  iMIbuttonNum;
	
 static class CMouseInterface * pMI;
 static char cName[12], cPassword[12], cConfirm[12], cPrevFocus, cSSN_A[8], cSSN_B[8], cQuiz[44] ,cAnswer[20], cTempQuiz[44] ;
 
 DWORD dwTime = timeGetTime();

 int iFlag = 0;

	if (m_cGameModeCount == 0) {
		pMI = new class CMouseInterface;
		pMI->AddRect(310, 80,560,100);
		pMI->AddRect(310,101,558,122);
		pMI->AddRect(310,123,558,145);
		pMI->AddRect(310,146,558,167);
		pMI->AddRect(310,168,477,191);
		pMI->AddRect(488,168,557,191);

		pMI->AddRect(300,192,560,231);
		pMI->AddRect(300,232,560,268);   // Quiz 8  // +41
		pMI->AddRect(300,269,560,306);   // Answer 9  
		
		pMI->AddRect(297, 399, 367, 417);  // Create 10
		pMI->AddRect(392, 399, 462, 417);  // Clear  11
		pMI->AddRect(488, 399, 558, 417);  // Cancel  12 버튼 Size 73 x 15
		
		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 12; //9
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
		
		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cPassword, sizeof(cPassword));
		ZeroMemory(cConfirm, sizeof(cConfirm));
		ZeroMemory(cSSN_A, sizeof(cSSN_A));
		ZeroMemory(cSSN_B, sizeof(cSSN_B));
		ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
		ZeroMemory(cQuiz, sizeof(cQuiz));
		ZeroMemory(cTempQuiz, sizeof(cTempQuiz));        // Quiz의 공백을 '_' 로 바꾼 내용을 저장하기 위한 변수
		ZeroMemory(cAnswer, sizeof(cAnswer));

		StartInputString(427, 84, 11, cName);
		ClearInputString();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEscPressed == TRUE) {
		#ifdef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
		#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		#endif
		delete pMI; 
		m_bEscPressed = FALSE;
		return;
	}

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(427, 84, 11, cName);
			break;
		case 2:
			StartInputString(427, 106, 11, cPassword);
			break;
		case 3:
			StartInputString(427, 129, 11, cConfirm);
			break;
		case 4:
			StartInputString(427, 153, 15, m_cAccountCountry);
			break;
		case 5:
			StartInputString(427, 176, 7, cSSN_A);
			break;
		case 6:
			StartInputString(506, 176, 8, cSSN_B);
			break;
		case 7:
			StartInputString(311, 215, 31, m_cEmailAddr);
			break;
		case 8:
			StartInputString(311, 253, 44, cQuiz);
			break;
		case 9:
			StartInputString(311, 291 , 19, cAnswer);
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWACCOUNT, 0,0,0, TRUE);
	PutString2(485, 175, "-", 5,5,5);

	if ((m_cCurFocus == 2) || (m_cCurFocus == 3))
		 ShowReceivedString(TRUE);
	else if ((m_cCurFocus == 1) || (m_cCurFocus == 4) || (m_cCurFocus == 5) || (m_cCurFocus == 6) || (m_cCurFocus == 7) || (m_cCurFocus == 8)|| (m_cCurFocus == 9))
		ShowReceivedString();

	if (m_cCurFocus != 1) {
		if (m_Misc.bCheckValidName(cName) != FALSE)
			 PutString2(427, 84, cName, 200,200,200);
		else PutString2(427, 84, cName, 200,100,100);
	}
	if (m_cCurFocus != 2) {
		if ((m_Misc.bCheckValidName(cPassword) != FALSE) && (strlen(cPassword) >= 8))
			 PutString(427, 106, cPassword, RGB(200,200,200), TRUE, 1);
		else PutString(427, 106, cPassword, RGB(200,100,100), TRUE, 1);
	}
	
	if (m_cCurFocus != 3) {
		if (memcmp(cPassword, cConfirm, 10) == 0)
			 PutString(427, 129, cConfirm, RGB(200,200,200), TRUE, 1);
		else PutString(427, 129, cConfirm, RGB(200,100,100), TRUE, 1);
	}
	if (memcmp(cPassword, cConfirm, 10) != 0) iFlag = 9;
	if (m_cCurFocus != 4) PutString2(427, 153, m_cAccountCountry, 200,200,200);
	if (m_cCurFocus != 5) PutString2(427, 176, cSSN_A, 200,200,200);
	if (m_cCurFocus != 6) PutString2(506, 176, cSSN_B, 200,200,200);
	if ((m_cCurFocus != 5) && (m_cCurFocus != 6)) {
		ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
		wsprintf(m_cAccountSSN, "%s-%s", cSSN_A, cSSN_B);
		
		if (m_Misc.bIsValidSSN(m_cAccountSSN) == TRUE) {
			 PutString2(427, 176, cSSN_A, 200,200,200);
			 PutString2(506, 176, cSSN_B, 200,200,200);
		}
		else {
			PutString2(427, 176, cSSN_A, 200,100,100);
			PutString2(506, 176, cSSN_B, 200,100,100);
		}
	}

	if (m_cCurFocus != 7) {
		if( m_Misc.bIsValidEmail(m_cEmailAddr) )
			PutString2(311, 48 + 190 -25 +2, m_cEmailAddr, 200,200,200);
		else PutString2(311, 48 + 190 -25 +2, m_cEmailAddr, 200,100,100);
	}

	wsprintf(cTempQuiz,"%s",cQuiz) ;
	m_Misc.ReplaceString(cTempQuiz, ' ', '_');

	if (m_cCurFocus != 8) {
		if((m_Misc.bCheckValidName(cTempQuiz) != FALSE) && (strlen(cTempQuiz) >= 10))
			PutString2(311, 48 + 226 -25 +4, cQuiz, 200,200,200);
		else PutString2(311, 48 + 226 -25 +4, cQuiz, 200,100,100);
	}

	if (m_cCurFocus != 9) {
		if ((m_Misc.bCheckValidName(cAnswer) != FALSE) && (strlen(cAnswer) >= 4))
			 PutString2(311, 291, cAnswer, 200,200,200);
		else PutString2(311, 291, cAnswer, 200,100,100);
	}

	if (m_Misc.bCheckValidName(cAnswer) == FALSE)		iFlag = 13;
	if (m_Misc.bCheckValidName(cTempQuiz) == FALSE)		iFlag = 12;
	if (strlen(cAnswer) < 4)							iFlag = 11;
	if (strlen(cTempQuiz) < 10)							iFlag = 10;
	if (m_Misc.bIsValidSSN(m_cAccountSSN) == FALSE)	iFlag = 8;
	if (m_Misc.bCheckValidName(cPassword) == FALSE)		iFlag = 7;
	if (m_Misc.bCheckValidName(cName) == FALSE)			iFlag = 6;
	if (m_Misc.bIsValidEmail(m_cEmailAddr) == FALSE)	iFlag = 5;
	if (strlen(m_cAccountCountry) == 0)					iFlag = 4;
	if (strlen(cConfirm) == 0)							iFlag = 3;
	if (strlen(cPassword) < 8)							iFlag = 2;
	if ((strlen(cName) == 0 ))							iFlag = 1;


// v1.4334 Quiz 추가 

	switch (m_cCurFocus) {
	case 1:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT1);//"사용자의 계정 이름을 입력합니다."
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT2);//"계정이름은 특수문자를 제외한 영문,숫자,"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT3);//"한글의 조합으로 이루어져야 합니다. "
		break;

	case 2:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT4);//"계정의 패스워드를 입력합니다." 
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT5);//"패스워드는 특수문자를 제외한 영문,숫자,"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT6);//"한글의 조합으로 최소 8문자 이상 입력"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT7);//"하셔야 합니다."
		break;

	case 3:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT8);//"패스워드를 한번 더 입력합니다."
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT9);//"전에 입력한 패스워드와 정확하게 일치해야"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT10);//"합니다."
		break;

	case 4:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT11);//"본래 이름을 입력합니다."
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT12);//"입력된 실명은 계정관련 처리시에 계정의"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT13);//"주인임을 확인하는 데 사용되므로 정확히"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT14);//"입력해야 합니다."
		break;

	case 5:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT15);//" 주민등록번호의 윗자리를 입력합니다. "
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT16);//"잘못된 주민등록번호를 입력하면 계정을 만들"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT17);//"수 없으니 주의하세요."
		break;

	case 6:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT18);//"주민등록번호의 아랫자리를 입력합니다."
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT19);//"잘못된 주민등록번호를 입력하면 계정을 만들"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT20);//"수 없으니 주의하세요."
		break;

	case 7:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT21);//"본인의 E-Mail주소를 입력합니다."  
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT22);//"입력된 E-Mail 주소는 계정관련 처리시에"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT23);//"계정의 주인임을 확인하는 데 사용되므로"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT24);//"정확히 입력해야 합니다."
		break;

	case 8:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT25);//"패스워드 분실시 찾을 수 있도록"
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT26);//"질문을 입력합니다. 질문은 특수문자를 제외한"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT27);//"영문,숫자,한글의 조합으로 최소 10문자 이상"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT28);//"입력 하셔야 합니다."
		break;

	case 9:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT29);//"위에 질문의 답을 입력합니다."
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT30);//"답은 특수문자를 제외한 영문,숫자,"
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT31);//"한글의 조합으로 최소 4문자 이상 입력"
		PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT32);//"하셔야 합니다."
		break;

	case 10:
		switch (iFlag) {
		case 0:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT33);//"입력된 내용으로 계정을 만듭니다."
			break;

		case 1:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT34);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT35);//"수 없습니다. 계정의 이름이 입력되지 않았"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT36);//"습니다. 계정이름을 입력해 주십시오."
			break;

		case 2:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT37);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT38);//"수 없습니다. 패스워드의 문자수가 8자리 미만"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT39);//"입니다. 패스워드를 8문자 이상 입력해 주십"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT40);//"시오. "
			break;

		case 3:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT41);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT42);//"수 없습니다. Pass-confirm 항목이 입력"  
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT43);//"되지 않았습니다. Pass-confirm 항목을"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT44);//"입력해 주십시오."
			break;

		case 4:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT45);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT46);//"수 없습니다. 실제 이름이 입력되지 않았"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT47);//"습니다. 실제 이름을 입력해 주십시오."
			break;

		case 5:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT48);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT49);//"수 없습니다. E-Mail 주소가 입력되지 않았"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT50);//"습니다. E-Mail 주소를 입력해 주십시오."
			break;

		case 6:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT51);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT52);//"수 없습니다. 계정 이름에 특수 문자가 섞여"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT53);//"있습니다. 특수문자를 사용하지 않은 새로운 "
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT54);//"계정 이름을 입력해 주십시오."
			break;

		case 7:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT55);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT56);//"수 없습니다. 패스워드에 특수 문자가 섞여"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT57);//"있습니다. 특수문자를 사용하지 않은 새로운"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT58);//"패스워드를 입력해 주십시오."
			break;

		case 8:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT59);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT60);//"수 없습니다. 잘못된 주민등록번호 입니다."
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT61);//"올바른 주민등록번호를 입력해 주십시오."
			break;

		case 9:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT62);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT63);//"수 없습니다. 패스워드와 확인 패스워드"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT64);//"항목의 내용이 서로 다릅니다. 패스워드가 "
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT65);//"서로 일치하도록 다시 입력 하십시오"
			break;
		case 10:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT66);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT67);///"수 없습니다. Quiz의 내용은 10자 이상이"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT68);//"되어야 합니다."
			break;
		case 11:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT69);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT70);//"수 없습니다. Answer의 내용은 4자 이상이"   
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT71);//"되어야 합니다."
			break;
		case 12:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT72);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT73);//"수 없습니다. Quiz에 특수 문자가 섞여"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT74);//"있습니다. 특수문자를 사용하지 않은 새로운"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT75);//"Quiz를 입력해 주십시오."
			break;

		case 13:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT76);//"입력된 내용이 올바르지 않아 계정을 만들"
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT77);//"수 없습니다. Answer에 특수 문자가 섞여"
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT78);//"있습니다. 특수문자를 사용하지 않은 새로운"
			PutAlignedString(290, 575, 375, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT79);//"Answer를 입력해 주십시오."
			break;

		}
		break;

	case 11:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT80);
		                                              //"입력된 모든 내용을 지웁니다."
		break;

	case 12:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT81);
			                                              //"메인 메뉴 화면으로 돌아갑니다."
		break;
	}


	if ( (iFlag == 0) && (m_cCurFocus == 10) )
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(199+98, 398, 25, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(199+98, 398, 24, dwTime);
	
	if (m_cCurFocus == 11) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(294+98, 398, 27, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(294+98, 398, 26, dwTime);

	if (m_cCurFocus == 12) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(390+98, 398, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(390+98, 398, 16, dwTime);
	
	DrawVersion();
	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다.
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 10:
			// 입력조건이 다 완성되지 않았다면 접속할 수 없다.
			if (iFlag != 0) return;
			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));

			ZeroMemory(m_cAccountQuiz, sizeof(m_cAccountQuiz));
			ZeroMemory(m_cAccountAnswer, sizeof(m_cAccountAnswer));
			
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);

			strcpy(m_cAccountQuiz, cTempQuiz);
			strcpy(m_cAccountAnswer, cAnswer);
			m_cAccountQuiz[45] = ' ' ;
			m_cAccountAnswer[20] = ' ' ;
		
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			wsprintf(m_cAccountSSN, "%s-%s", cSSN_A, cSSN_B);

			if (memcmp(cPassword, cConfirm, 10) != 0) {
				// 패스워드와 확인코드가 일치하지 않는다.
				ChangeGameMode(DEF_GAMEMODE_ONMSG);
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT82);
				               //"Cannot create account! - password not match!"
				delete pMI;
				return;
			}

			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWACCOUNT;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "00");
			delete pMI;
			return;

		case 11:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cPassword, sizeof(cPassword));
			ZeroMemory(cConfirm, sizeof(cConfirm));
			ZeroMemory(m_cAccountAge, sizeof(m_cAccountAge));
			ZeroMemory(m_cAccountCountry, sizeof(m_cAccountCountry));
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			ZeroMemory(m_cEmailAddr, sizeof(m_cEmailAddr));
			ZeroMemory(cSSN_A, sizeof(cSSN_A));
			ZeroMemory(cSSN_B, sizeof(cSSN_B));
			ZeroMemory(cQuiz, sizeof(cQuiz));
			ZeroMemory(cTempQuiz, sizeof(cTempQuiz));
			ZeroMemory(cAnswer, sizeof(cAnswer));

			break;

		case 12:
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			delete pMI;
			return;
		}
		m_bEnterPressed = FALSE;
	}

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		default:
			m_cCurFocus = iMIbuttonNum;
			break;
				
		case 10:
			// 입력조건이 다 완성되지 않았다면 접속할 수 없다.
			if (iFlag != 0) return;
			// 새 캐릭터 생성을 요구한다.
			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));

			ZeroMemory(m_cAccountQuiz, sizeof(m_cAccountQuiz));
			ZeroMemory(m_cAccountAnswer, sizeof(m_cAccountAnswer));
			

			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			strcpy(m_cAccountQuiz, cTempQuiz);
			strcpy(m_cAccountAnswer, cAnswer);
			
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			wsprintf(m_cAccountSSN, "%s-%s", cSSN_A, cSSN_B);

			if (memcmp(cPassword, cConfirm, 10) != 0) {
				// 패스워드와 확인코드가 일치하지 않는다.
				ChangeGameMode(DEF_GAMEMODE_ONMSG);
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT82);
				               //"Cannot create account! - password not match!"
				delete pMI;
				return;
			}

			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);

			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWACCOUNT;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "00");
			delete pMI;
			return;
		
		case 11:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cPassword, sizeof(cPassword));
			ZeroMemory(cConfirm, sizeof(cConfirm));
			ZeroMemory(m_cAccountAge, sizeof(m_cAccountAge));
			ZeroMemory(m_cAccountCountry, sizeof(m_cAccountCountry));
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			ZeroMemory(m_cEmailAddr, sizeof(m_cEmailAddr));
			ZeroMemory(cSSN_A, sizeof(cSSN_A));
			ZeroMemory(cSSN_B, sizeof(cSSN_B));
			ZeroMemory(cQuiz, sizeof(cQuiz));
			ZeroMemory(cTempQuiz, sizeof(cTempQuiz));
			ZeroMemory(cAnswer, sizeof(cAnswer));
			break;
		
		case 12:
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			delete pMI;
			return;
		}
	}
	
	if ((msX >= 297) && (msX <= 370) && (msY >= 396) && (msY <= 417))  m_cCurFocus = 10;  //12
	if ((msX >= 392) && (msX <= 465) && (msY >= 396) && (msY <= 417)) m_cCurFocus = 11;  //13
	if ((msX >= 488) && (msX <= 561) && (msY >= 396) && (msY <= 417)) m_cCurFocus = 12; //14

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);
   	
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#endif

#endif //endif from #ifdef DEF_MAKE_ACCOUNT

void CGame::UpdateScreen_OnLogin()
{
 short msX, msY, msZ, sX, sY;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI; 
 static char  cPassword[12], cPrevFocus;

 //for Terra
#ifdef DEF_ACCOUNTLONG
 static char cName[DEF_ACCOUNTLEN+1];
#else
 static char cName[12];
#endif


	sX = 146; 
	sY = 114;
	if (m_cGameModeCount == 0) {
		EndInputString();
		
		pMI = new class CMouseInterface;
		pMI->AddRect(80, 151, 337, 179);
		pMI->AddRect(80, 180, 337, 205);
		pMI->AddRect(80, 280, 163, 302);
		pMI->AddRect(258, 280, 327, 302);
		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 4;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cPassword, sizeof(cPassword));
//for Terra
#ifdef DEF_ACCOUNTLONG
		StartInputString(180, 162, DEF_ACCOUNTLEN + 1, cName);
#else
		StartInputString(180, 162, 11, cName);
#endif
		ClearInputString();

		// v2.05 가장 부하가 적은 게이트웨이의 정보를 알아내기 위해 일차 접속
#ifdef DEF_USING_GATEWAY		
		m_bIsCheckingGateway = TRUE;
		// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
		m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
		m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
		m_pLSock->bInitBufferSize(30000);

#else
		m_bIsCheckingGateway = FALSE;
#endif
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		
		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다. 
		m_bEnterPressed = FALSE;
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
			m_cCurFocus++;
			if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 2:
		case 3:
			if ((strlen(cName) == 0) || (strlen(cPassword) == 0)) break;

			// 2002-9-24 계정에 특수 문자가 있으면 접속하지 않는다. 
#if DEF_LANGUAGE == 2	//언어:Chinese
			if ((m_Misc.bCheckValidName(cName) == FALSE) ||  (m_Misc.bCheckValidName(cPassword) == FALSE)) break;
#endif 			

			// v2.05 가장 부하가 적은 게이트웨이를 선택하는 옵션이 켜져 있다면 접속하지 않는다.
			if (m_bIsCheckingGateway == FALSE) {
			
//for Terra
#ifdef DEF_ACCOUNTLONG
				// Connect 버튼이 선택된 상태에서 Enter키가 눌렸다.
				// 이름을 초기화한다. 
				ZeroMemory(m_cAccountLong, sizeof(m_cAccountLong));
				ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
				strcpy(m_cAccountLong, cName);
				strcpy(m_cAccountPassword, cPassword);
				// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
				m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
				m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
				m_pLSock->bInitBufferSize(30000);
				// 게임모드 변환 
				ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
				m_dwConnectMode = MSGID_REQUEST_LOGIN;
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, "11");
				delete pMI;
#else
				// Connect 버튼이 선택된 상태에서 Enter키가 눌렸다.
				// 이름을 초기화한다. 
				ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
				ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
				strcpy(m_cAccountName, cName);
				strcpy(m_cAccountPassword, cPassword);
				// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
				m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
				m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
				m_pLSock->bInitBufferSize(30000);
				// 게임모드 변환 
				ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
				m_dwConnectMode = MSGID_REQUEST_LOGIN;
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, "11");
				delete pMI;
#endif
			}
			return;
		
		case 4:
			// Cancel 버튼이 선택된 상태에서 Enter키가 눌렸다.
#ifdef DEF_SELECTSERVER
	#ifdef DEF_FUCK_USA
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU); // ONMAINMENU
	#else
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER); // ONMAINMENU
	#endif
#else
		#ifdef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
		#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		#endif
#endif
			delete pMI;
			return;
		}
	}

	if (m_bEscPressed == TRUE) {
		EndInputString();
		#ifdef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
		#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		#endif
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
#ifdef DEF_ACCOUNTLONG
			StartInputString(180, 162, DEF_ACCOUNTLEN + 1, cName);
#else
			StartInputString(180, 162, 11, cName);
#endif
			break;
		case 2:
#ifdef DEF_ACCOUNTLONG
			StartInputString(180, 185, 8 + 1, cPassword, TRUE);
#else
			StartInputString(180, 185, 11, cPassword, TRUE);
#endif
			break;
		case 3:
		case 4:
			break;
		}
		cPrevFocus = m_cCurFocus;
	}
	

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스클릭. 
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
			m_cCurFocus = 1;
			break;
		
		case 2:
			m_cCurFocus = 2;
			break;
		
		case 3:
			if ((strlen(cName) == 0) || (strlen(cPassword) == 0)) break;
			// v2.05 가장 부하가 적은 게이트웨이를 선택하는 옵션이 켜져 있다면 접속하지 않는다.
			if (m_bIsCheckingGateway == FALSE) {
				EndInputString();

#if defined(DEF_ACCOUNTLONG)
				// 이름을 초기화한다. 
				ZeroMemory(m_cAccountLong, sizeof(m_cAccountLong));
				ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
				strcpy(m_cAccountLong, cName);
				strcpy(m_cAccountPassword, cPassword);
			
				// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
				m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
				m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
				m_pLSock->bInitBufferSize(30000);
				// 게임모드 변환 
				ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
				m_dwConnectMode = MSGID_REQUEST_LOGIN;
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, "11");
				delete pMI;
#else
				// 이름을 초기화한다. 
				ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
				ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
				strcpy(m_cAccountName, cName);
				strcpy(m_cAccountPassword, cPassword);
			
				// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
				m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
				m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
				m_pLSock->bInitBufferSize(30000);
				// 게임모드 변환 
				ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
				m_dwConnectMode = MSGID_REQUEST_LOGIN;
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, "11");
				delete pMI;
#endif

			}
			return;

		case 4:
#ifdef DEF_SELECTSERVER
	#ifdef DEF_FUCK_USA
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU); // ONMAINMENU
	#else
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER); // ONMAINMENU
	#endif
#else
		#ifdef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
		#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		#endif
#endif
			delete pMI;
			return;
		}
	}
	
	if ((msX >= 80) && (msX <= 163) && (msY >= 280) && (msY <= 302)) m_cCurFocus = 3;
	if ((msX >= 258) && (msX <= 327) && (msY >= 280) && (msY <= 302)) m_cCurFocus = 4;

	_Draw_OnLogin(cName, cPassword, msX, msY, m_cGameModeCount);
	if (m_bIsCheckingGateway == TRUE) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);
		PutAlignedString(175, 458, 160+30, UPDATE_SCREEN_ON_LOGIN1);//"가장 빠른 인터넷 접속 경로를 검색하는 중입니다."
		PutAlignedString(175, 458, 160+45, UPDATE_SCREEN_ON_LOGIN2);//"잠시만 기다려 주십시오..."
	}

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();

}

#if DEF_LANGUAGE == 3	//언어:Korean
void CGame::UpdateScreen_OnSelectServer() // for KOREAN
{
 short msX, msY, msZ, sX, sY;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI; 
 static char  cPrevFocus;
 DWORD dwTime = timeGetTime();	

	sX = 146; 
	sY = 114;
	if (m_cGameModeCount == 0) {
		EndInputString();
		
		pMI = new class CMouseInterface;
		pMI->AddRect(80,163,316,186);
		pMI->AddRect(95,187,316,207);
		pMI->AddRect(95,208,316,229);
		pMI->AddRect(256,279,331,308);
		
		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 4;

		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
			
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다. 
		m_bEnterPressed = FALSE;
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
			ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, "WS1");
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;

		case 2:
			ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, "WS2");
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;

		case 3:
			ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, "WS3");
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			break;
					
		case 4:
			// Cancel 버튼이 선택된 상태에서 Enter키가 눌렸다.
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	} 

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0,0,0, TRUE);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 40,121,1, TRUE);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->PutTransSprite25(40,121,1, TRUE);
		
	if (m_cGameModeCount > 20) {
		if (m_cCurFocus == 1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 138, 165, 5, TRUE);
		if (m_cCurFocus == 2) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 137, 189, 6, TRUE);
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 137, 213, 7, TRUE);
		if (m_cCurFocus == 4) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256, 282, 4, TRUE);
	}

	DrawVersion();

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스클릭. 
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
			if (m_cCurFocus == 1) {
				ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, "WS1");
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 1;
			break;
		
		case 2:
			if (m_cCurFocus == 2) {
				ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, "WS2");
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 2;
			break;
			
		case 3:
			if (m_cCurFocus == 3) {
				ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, "WS3");
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 3;
			break;

		case 4:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	if ((msX >= 80) && (msX <= 316) && (msY >= 163) && (msY <= 186)) m_cCurFocus = 1;
	if ((msX >= 95) && (msX <= 316) && (msY >= 187) && (msY <= 207)) m_cCurFocus = 2;
	if ((msX >= 95) && (msX <= 316) && (msY >= 208) && (msY <= 229)) m_cCurFocus = 3;
	if ((msX >= 256) && (msX <= 331) && (msY >= 279) && (msY <= 308)) m_cCurFocus = 4;

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#elif DEF_LANGUAGE == 2	//언어:Chinese
void CGame::UpdateScreen_OnSelectServer() // for CHINESE
{
 short msX, msY, msZ, sX, sY;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI; 
 static char  cPrevFocus;
 DWORD dwTime = timeGetTime();	
 BOOL bFlag = TRUE;

	sX = 146; 
	sY = 114;
	if (m_cGameModeCount == 0) {
		EndInputString();
		
		pMI = new class CMouseInterface;
//		pMI->AddRect(90,150,190,175);
//		pMI->AddRect(90,176,190,202);
//		pMI->AddRect(90,203,190,227);
//		pMI->AddRect(90,228,190,253);
//		pMI->AddRect(90,254,190,279);
//		pMI->AddRect(90,280,190,305);
//		pMI->AddRect(90,306,190,332);
//		pMI->AddRect(90,333,190,358);
//		pMI->AddRect(191,150,290,175);
//		pMI->AddRect(191,176,290,202);
//		pMI->AddRect(191,203,290,227);
//		pMI->AddRect(191,228,290,253);
//		pMI->AddRect(191,254,290,279);
//		pMI->AddRect(191,280,290,305);
//		pMI->AddRect(191,306,290,332);
//		pMI->AddRect(191,333,290,358);
//		pMI->AddRect(275,377,312,400);

		pMI->AddRect(140,165,185,180);
		pMI->AddRect(140,190,185,208);
		pMI->AddRect(140,215,185,235);
		pMI->AddRect(140,245,185,263);

		pMI->AddRect(216,165,263,180);
		pMI->AddRect(216,190,263,208);
		pMI->AddRect(216,215,263,235);
		pMI->AddRect(216,245,263,263);

		pMI->AddRect(270,275,305,295);
		
		cPrevFocus  = 1;
		m_cCurFocus = 1;
		//m_cMaxFocus = 17;
		m_cMaxFocus = 9;

		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 2:
			//if (m_cCurFocus < 9) m_cCurFocus += 8;
			if (m_cCurFocus < 5) m_cCurFocus += 4;
			//else if(m_cCurFocus < m_cMaxFocus ) m_cCurFocus = m_cCurFocus-7;
			else if(m_cCurFocus < m_cMaxFocus ) m_cCurFocus = m_cCurFocus-4;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			//if (m_cCurFocus < 9) m_cCurFocus += 7;
			if (m_cCurFocus < 5) m_cCurFocus += 4;
			//else if(m_cCurFocus < m_cMaxFocus ) m_cCurFocus -= 8;
			else if(m_cCurFocus < m_cMaxFocus ) m_cCurFocus -= 4;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다. 
		m_bEnterPressed = FALSE;
		PlaySound('E', 14, 5);
		if( m_cCurFocus == m_cMaxFocus ) ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		else
		{
			ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
			wsprintf(m_cWorldServerName, "WS%d", m_cCurFocus);
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
		}
		delete pMI;
		return;
	}

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	} 

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0,0,0, TRUE);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 20+19,123,1, TRUE);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->PutTransSprite25(20,123,1, TRUE);
		
	if (m_cGameModeCount > 20) {
//		if (m_cCurFocus == 1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109, 155, 6, TRUE);
//		if (m_cCurFocus == 2) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 108, 182, 7, TRUE);
//		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109, 207, 8, TRUE);
//		if (m_cCurFocus == 4) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109, 234, 9, TRUE);
//		if (m_cCurFocus == 5) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109, 259, 10, TRUE);
//		if (m_cCurFocus == 6) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109, 284, 11, TRUE);
//		if (m_cCurFocus == 7) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 110, 311, 12, TRUE);
//		if (m_cCurFocus == 8) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 110, 336, 13, TRUE);
//		if (m_cCurFocus == 9) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 220, 156, 14, TRUE);
//		if (m_cCurFocus == 10) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 219, 183, 15, TRUE);
//		if (m_cCurFocus == 11) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 220, 209, 16, TRUE);
//		if (m_cCurFocus == 12) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 218, 235, 17, TRUE);
//		if (m_cCurFocus == 13) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 220, 259, 18, TRUE);
//		if (m_cCurFocus == 14) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 220, 285, 19, TRUE);
//		if (m_cCurFocus == 15) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 220, 312, 20, TRUE);
//		if (m_cCurFocus == 16) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 219, 338, 21, TRUE);
//		if (m_cCurFocus == m_cMaxFocus) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 270,378,5, TRUE);

		if (m_cCurFocus == 1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109+11+19, 155+8, 5, TRUE);
		if (m_cCurFocus == 2) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 108+11+19, 182+8, 6, TRUE);
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109+11+19, 207+8, 7, TRUE);
		if (m_cCurFocus == 4) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109+11+19, 234+10, 8, TRUE);
		if (m_cCurFocus == 5) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109+88+19, 259-98, 9, TRUE);
		if (m_cCurFocus == 6) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 109+88+19, 284-97, 10, TRUE);
		if (m_cCurFocus == 7) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 110+88+19, 311-96, 11, TRUE);
		if (m_cCurFocus == 8) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 110+88+19, 336-92, 12, TRUE);
		if (m_cCurFocus == m_cMaxFocus) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 267,274,4, TRUE);
	}

	DrawVersion();

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{
		// 마우스클릭. 
		PlaySound('E', 14, 5);
		if( iMIbuttonNum == m_cMaxFocus )
		{
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
		else
		{
			if( iMIbuttonNum == m_cCurFocus )
			{
				ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
				wsprintf(m_cWorldServerName, "WS%d", m_cCurFocus);
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = iMIbuttonNum;
		}
	}


//	if ((msX >= 90) && (msX <= 190) && (msY >= 150) && (msY <= 175)) m_cCurFocus = 1;
//	if ((msX >= 90) && (msX <= 190) && (msY >= 176) && (msY <= 202)) m_cCurFocus = 2;
//	if ((msX >= 90) && (msX <= 190) && (msY >= 203) && (msY <= 227)) m_cCurFocus = 3;
//	if ((msX >= 90) && (msX <= 190) && (msY >= 228) && (msY <= 253)) m_cCurFocus = 4;
//	if ((msX >= 90) && (msX <= 190) && (msY >= 254) && (msY <= 279)) m_cCurFocus = 5;
//	if ((msX >= 90) && (msX <= 190) && (msY >= 280) && (msY <= 305)) m_cCurFocus = 6;
//	if ((msX >= 90) && (msX <= 190) && (msY >= 306) && (msY <= 332)) m_cCurFocus = 7;
//	if ((msX >= 90) && (msX <= 190) && (msY >= 333) && (msY <= 358)) m_cCurFocus = 8;
//	if ((msX >= 190) && (msX <= 290) && (msY >= 150) && (msY <= 175)) m_cCurFocus = 9;
//	if ((msX >= 190) && (msX <= 290) && (msY >= 176) && (msY <= 202)) m_cCurFocus = 10;
//	if ((msX >= 190) && (msX <= 290) && (msY >= 203) && (msY <= 227)) m_cCurFocus = 11;
//	if ((msX >= 190) && (msX <= 290) && (msY >= 228) && (msY <= 253)) m_cCurFocus = 12;
//	if ((msX >= 190) && (msX <= 290) && (msY >= 254) && (msY <= 279)) m_cCurFocus = 13;
//	if ((msX >= 190) && (msX <= 290) && (msY >= 280) && (msY <= 305)) m_cCurFocus = 14;
//	if ((msX >= 190) && (msX <= 290) && (msY >= 306) && (msY <= 332)) m_cCurFocus = 15;
//	if ((msX >= 190) && (msX <= 290) && (msY >= 333) && (msY <= 358)) m_cCurFocus = 16;
//	if ((msX >= 275) && (msX <= 312) && (msY >= 377) && (msY <= 400)) m_cCurFocus = m_cMaxFocus;

	if ((msX >= 140) && (msX <= 185) && (msY >= 165) && (msY <= 180)) m_cCurFocus = 1;
	if ((msX >= 140) && (msX <= 185) && (msY >= 190) && (msY <= 208)) m_cCurFocus = 2;
	if ((msX >= 140) && (msX <= 185) && (msY >= 215) && (msY <= 235)) m_cCurFocus = 3;
	if ((msX >= 140) && (msX <= 185) && (msY >= 245) && (msY <= 263)) m_cCurFocus = 4;
	
	if ((msX >= 216) && (msX <= 263) && (msY >= 165) && (msY <= 180)) m_cCurFocus = 5;
	if ((msX >= 216) && (msX <= 263) && (msY >= 190) && (msY <= 208)) m_cCurFocus = 6;
	if ((msX >= 216) && (msX <= 263) && (msY >= 215) && (msY <= 235)) m_cCurFocus = 7;
	if ((msX >= 216) && (msX <= 263) && (msY >= 245) && (msY <= 263)) m_cCurFocus = 8;

	if ((msX >= 270) && (msX <= 305) && (msY >= 275) && (msY <= 295)) m_cCurFocus = m_cMaxFocus;



#ifdef _DEBUG
	wsprintf(G_cTxt, "msX:%d  msY:%d Focus:%d %d", msX, msY, m_cCurFocus, iMIbuttonNum);
	PutString_SprNum(90, 363, G_cTxt, 140, 140, 140);
#endif

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#else

void CGame::UpdateScreen_OnSelectServer() // for ENGLISH, JAPANESE 
{
 short msX, msY, msZ, sX, sY;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI; 
 static char  cPrevFocus;
 DWORD dwTime = timeGetTime();	
 BOOL bFlag = TRUE;

	sX = 146; 
	sY = 114;
	if (m_cGameModeCount == 0) {
		EndInputString();
		
		pMI = new class CMouseInterface;
		pMI->AddRect(130,177,270,198);
		pMI->AddRect(130,199,270,225);
		pMI->AddRect(256,279,331,308);
		
		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 3;

		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
			
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다. 
		m_bEnterPressed = FALSE;
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
			ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, "WS1");
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;

		case 2:
			ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, "WS2");
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;

		case 3:
			// Cancel 버튼이 선택된 상태에서 Enter키가 눌렸다.
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			delete pMI;
			return;
		}
	}

	if (m_bEscPressed == TRUE) {
		#ifdef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		#endif
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	} 

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0,0,0, TRUE);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 40,121,1, TRUE);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->PutTransSprite25(40,121,1, TRUE);
		
	if (m_cGameModeCount > 20) {
#ifdef DEF_JAPAN_FOR_TERRA
     	if (m_cCurFocus == 1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 147, 177, 5, TRUE);
		if (m_cCurFocus == 2) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 147, 205, 6, TRUE);
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256,282,4, TRUE);
#else
		if (m_cCurFocus == 1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 130, 177, 5, TRUE);
		if (m_cCurFocus == 2) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 130, 205, 6, TRUE);
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256,282,4, TRUE);
#endif
	}

	DrawVersion();

	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스클릭. 
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
			if (m_cCurFocus == 1) {
				ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, "WS1");
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 1;
			break;
		
		case 2:
			if (m_cCurFocus == 2) {
				ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, "WS2");
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 2;
			break;
			
		case 3:
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			delete pMI;
			return;
		}
	}

	if ((msX >= 130) && (msX <= 295) && (msY >= 175) && (msY <= 198)) m_cCurFocus = 1;
	if ((msX >= 130) && (msX <= 295) && (msY >= 199) && (msY <= 225)) m_cCurFocus = 2;
	if ((msX >= 256) && (msX <= 331) && (msY >= 279) && (msY <= 308)) m_cCurFocus = 3;

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#endif

void CGame::OnSysKeyDown(WPARAM wParam)
{
	switch( wParam )
	{
	case VK_SHIFT:
		m_bShiftPressed = TRUE;
		break;
	case VK_CONTROL:
		m_bCtrlPressed = TRUE;
		break;
	case VK_RETURN:
		m_bEnterPressed = TRUE;
		break;
	}
}

void CGame::OnSysKeyUp(WPARAM wParam)
{
	switch( wParam )
	{
	case VK_SHIFT:
		m_bShiftPressed = FALSE;
		break;
	case VK_CONTROL:
		m_bCtrlPressed = FALSE;
		break;
	case VK_RETURN:
		m_bEnterPressed = FALSE;
		if( m_bToggleScreen == TRUE )
		{
			m_bIsRedrawPDBGS = TRUE;
			m_DDraw.ChangeDisplayMode(G_hWnd);
		}
		break;
	case VK_ESCAPE:
		m_bEscPressed = FALSE;
#ifdef DEF_SHORTCUT
	case VK_F10:
		if (m_bIsDialogEnabled[15] == FALSE) //스킬창
			EnableDialogBox(15, NULL, NULL, NULL);
		else DisableDialogBox(15);
		break;
#endif
	}
}

void CGame::OnKeyUp(WPARAM wParam)
{
 int i=0;
 DWORD dwTime = timeGetTime();
 
	switch (wParam) {
	case VK_SHIFT:
		m_bShiftPressed = FALSE;
		break;
	case VK_CONTROL:
		m_bCtrlPressed = FALSE;
		break;
	case 65://'A'
		if (m_bCtrlPressed && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{
			if( m_bForceAttack )
			{
				m_bForceAttack = FALSE;
				AddEventList( DEF_MSG_FORCEATTACK_OFF, 10 );
			}
			else
			{
				m_bForceAttack = TRUE;
				AddEventList( DEF_MSG_FORCEATTACK_ON, 10 );
			}
		}
		break;

	case 68://'D'
		if (m_bCtrlPressed == TRUE && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) ) {
			m_cDetailLevel++;
			if( m_cDetailLevel > 2 ) m_cDetailLevel = 0;
			switch( m_cDetailLevel )
			{
			case 0:
				AddEventList( NOTIFY_MSG_DETAIL_LEVEL_LOW, 10 );
				break;
			case 1:
				AddEventList( NOTIFY_MSG_DETAIL_LEVEL_MEDIUM, 10 );
				break;
			case 2:
				AddEventList( NOTIFY_MSG_DETAIL_LEVEL_HIGH, 10 );
				break;
			}
		}
		break;

	case 77://'M'
		if( m_cGameMode == DEF_GAMEMODE_ONMAINGAME )
		{
			if( m_bCtrlPressed )
			{
				if( m_bIsDialogEnabled[9] == TRUE ) DisableDialogBox(9);
				else EnableDialogBox(9, 0, 0, 0, NULL);
			}
		}
		break;

#ifdef _DEBUG
	case 81://'Q'
		if( ( m_bCtrlPressed == TRUE ) && ( m_cGameMode == DEF_GAMEMODE_ONMAINGAME ) ) {
			ZeroMemory(m_cChatMsg, sizeof(m_cChatMsg) );
			strcpy(m_cChatMsg, "/enableadmincommand 0909114 ");
			StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg); 
			//ClearInputString();
		}
		break;
#endif

	case 82://'R'
		if (m_bCtrlPressed == TRUE && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{
			if( m_bRunningMode ) {
				m_bRunningMode = FALSE;
				AddEventList( NOTIFY_MSG_CONVERT_WALKING_MODE, 10 );
			}
			else {
				m_bRunningMode = TRUE;
				AddEventList( NOTIFY_MSG_CONVERT_RUNNING_MODE, 10 );
			}
		}
		break;

	case 83://'S'
		if (m_bCtrlPressed == TRUE && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{
			if (m_bMusicStat == TRUE) {
				// Music Off
				m_bMusicStat = FALSE;
				if (m_bSoundFlag) {
					if (m_pBGM != NULL) {
						m_pBGM->bStop();
						delete m_pBGM;
						m_pBGM = NULL;
					}
				}
				AddEventList( NOTIFY_MSG_MUSIC_OFF, 10 );
				break;
			}
			else if( m_bSoundStat == TRUE ) {
				m_pESound[38]->bStop();
				m_bSoundStat = FALSE;
				AddEventList( NOTIFY_MSG_SOUND_OFF, 10 );
				break;
			}
			else {
				// Music On 상하천재
				if( m_bSoundFlag ) {
				m_bMusicStat = TRUE;
				AddEventList( NOTIFY_MSG_MUSIC_ON, 10 );
				}
				if( m_bSoundFlag ) {
				m_bSoundStat = TRUE;
				AddEventList( NOTIFY_MSG_SOUND_ON, 10 );
				}
				StartBGM();
			}
		}
		break;

	case 84: //'T'
		if (m_bCtrlPressed == TRUE && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{
			char tempid[100], cLB, cRB;
			short sX, sY, msX, msY, msZ;
			sX = m_stDialogBoxInfo[10].sX;
			sY = m_stDialogBoxInfo[10].sY;
			ZeroMemory( tempid, sizeof( tempid ) );
			m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
			if( m_bIsDialogEnabled[10] == TRUE && (msX >= sX + 20) && (msX <= sX + 360) && (msY >= sY + 35) && (msY <= sY + 139) )
			{
				CStrTok *pStrTok;
				char   * token, cBuff[64];
				char   seps[] = ":";
				int i = (139-msY+sY)/13;
				if( m_pChatScrollList[i + m_stDialogBoxInfo[10].sView] == NULL ) return;
				if( m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg[0] == ' ' ) i++;
				strcpy(cBuff, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg);
				pStrTok = new class CStrTok(cBuff, seps);
				token = pStrTok->pGet();
				wsprintf( tempid, "/to %s", token );
				bSendCommand(MSGID_COMMAND_CHATMSG, NULL, NULL, NULL, NULL, NULL, tempid);
				delete pStrTok;
			}
			else if( _tmp_sOwnerType < 7 && (strlen(_tmp_cName)>0) && (m_iIlusionOwnerH==NULL) && ((m_bIsCrusadeMode == FALSE) || _iGetFOE(_tmp_sStatus) >= 0))
			{
				wsprintf( tempid, "/to %s", _tmp_cName );
				bSendCommand(MSGID_COMMAND_CHATMSG, NULL, NULL, NULL, NULL, NULL, tempid);
			}
			else
			{
				EndInputString();
				wsprintf( m_cChatMsg, "/to " );
				StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg); 
			}
		}
		break;
	case 107: //'+'
		if(m_bInputStatus == FALSE) m_bZoomMap = TRUE;
#ifdef DEF_COLOR	//	mando 030125	색상 테스트 부분.
		G_iColor++;
		if(G_iColor > G_iColorMax)
			G_iColor = 0;
#endif
		break;
	case 109: //'-'
		if(m_bInputStatus == FALSE) m_bZoomMap = FALSE;
#ifdef DEF_COLOR	//	mando 030125	색상 테스트 부분.
		G_iColor--;
		if(G_iColor < 0)
			G_iColor = G_iColorMax;
#endif
		break;

	case VK_F2:
#if DEF_LANGUAGE == 5
		if(m_bInputStatus) return;
#endif
		UseShortCut( 1 );
		break;

	case VK_F3:
#if DEF_LANGUAGE == 5
		if(m_bInputStatus) return;
#endif
		UseShortCut( 2 );
		break; 
	
	case VK_INSERT:
		// 빨간색시약이 있으면 먹는다. 
		if (m_iHP <= 0) return;
		if (m_bItemUsingStatus == TRUE) {
			AddEventList(USE_RED_POTION1, 10);//"다른 아이템 사용이 끝난 후 아이템을 사용할 수 있습니다."
			return;	
		}
		if (m_bIsDialogEnabled[27] == TRUE) {
			AddEventList(USE_RED_POTION2, 10);//"교환중에는 시약을 먹을 수 없습니다."
			return;	
		}
		// 붉은색시약이 있다면 먹는다. 
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pItemList[i] != NULL) && (m_bIsItemDisabled[i] != TRUE) && 
			 (m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 1)) {
			
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, i, NULL, NULL, NULL); 
						
			m_bIsItemDisabled[i] = TRUE;
			m_bItemUsingStatus = TRUE;

			return;
		}

		// 큰붉은색시약이 있다면 먹는다. 
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pItemList[i] != NULL) && (m_bIsItemDisabled[i] != TRUE) && 
			 (m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 2)) {
			
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, i, NULL, NULL, NULL); 
						
			m_bIsItemDisabled[i] = TRUE;
			m_bItemUsingStatus = TRUE;

			return;
		}

		break;

	case VK_DELETE:
		if (m_iHP <= 0) return;
		if (m_bItemUsingStatus == TRUE) {
			AddEventList(USE_BLUE_POTION1, 10);//"다른 아이템 사용이 끝난 후 아이템을 사용할 수 있습니다."
			return;	
		}
		if (m_bIsDialogEnabled[27] == TRUE) {
			AddEventList(USE_BLUE_POTION2, 10);//"교환중에는 시약을 먹을 수 없습니다."
			return;	
		}

		// 푸른색시약이 있다면 먹는다. 
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pItemList[i] != NULL) && (m_bIsItemDisabled[i] != TRUE) && 
			 (m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 3)) {
			
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, i, NULL, NULL, NULL); 
						
			m_bIsItemDisabled[i] = TRUE;
			m_bItemUsingStatus = TRUE;

			return;
		}

		// 큰푸른색시약이 있다면 먹는다. 
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pItemList[i] != NULL) && (m_bIsItemDisabled[i] != TRUE) && 
			 (m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 4)) {
			
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, i, NULL, NULL, NULL); 
						
			m_bIsItemDisabled[i] = TRUE;
			m_bItemUsingStatus = TRUE;

			return;
		}

		break;
				
	case VK_END:
		if ( ((m_bIsDialogEnabled[7] == TRUE) && (m_stDialogBoxInfo[7].cMode == 1) && (iGetTopDialogBoxIndex() == 7)) ||
			((m_bIsDialogEnabled[17] == TRUE) && (m_stDialogBoxInfo[17].cMode == 1) && (iGetTopDialogBoxIndex() == 17)) ) { 
			// 특정 입력 모드이면 효과 없음.
		}
		else if ((!m_bInputStatus) && (m_cBackupChatMsg[0] != '!') && (m_cBackupChatMsg[0] != '~') && (m_cBackupChatMsg[0] != '^') &&
				 (m_cBackupChatMsg[0] != '@')) {
			// 만약 채팅입력모드가 아니였는데 키가 눌려지면 채팅모드로 들어간다.
			ZeroMemory(m_cChatMsg, sizeof(m_cChatMsg));
			strcpy(m_cChatMsg, m_cBackupChatMsg);
			StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg); 
		}
		break;
	
	case VK_F4:
#if DEF_LANGUAGE == 5
		if(m_bInputStatus) return;
#endif
		if(m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
		UseMagic(m_sMagicShortCut);
		break;

	case VK_F5:
#if DEF_LANGUAGE == 5
		if(m_bInputStatus) return;
#endif
#ifdef DEF_SHORTCUT
		UseShortCut( 3 );
#else
		if (m_bIsDialogEnabled[1] == FALSE)
			EnableDialogBox(1, NULL, NULL, NULL);
		else DisableDialogBox(1);
#endif
		break;

	case VK_F6:
#if DEF_LANGUAGE == 5
		if(m_bInputStatus) return;
#endif
#ifdef DEF_SHORTCUT
		UseShortCut( 4 );
#else
		if (m_bIsDialogEnabled[2] == FALSE) //가방창
			EnableDialogBox(2, NULL, NULL, NULL);
		else DisableDialogBox(2);
#endif
		break;

	case VK_F7:
#if DEF_LANGUAGE == 5
		if(m_bInputStatus) return;
#endif
#ifdef DEF_SHORTCUT
		if (m_bIsDialogEnabled[1] == FALSE) //캐릭창
			EnableDialogBox(1, NULL, NULL, NULL);
		else DisableDialogBox(1);
#else
		if (m_bIsDialogEnabled[3] == FALSE) //마법창
			EnableDialogBox(3, NULL, NULL, NULL);
		else DisableDialogBox(3);
#endif
		break;

	case VK_F8:
#if DEF_LANGUAGE == 5
		if(m_bInputStatus) return;
#endif
#ifdef DEF_SHORTCUT
		if (m_bIsDialogEnabled[2] == FALSE) //가방창
			EnableDialogBox(2, NULL, NULL, NULL);
		else DisableDialogBox(2);
#else
		if (m_bIsDialogEnabled[15] == FALSE) //스킬창
			EnableDialogBox(15, NULL, NULL, NULL);
		else DisableDialogBox(15);
#endif
		break;

	case VK_F9:
#if DEF_LANGUAGE == 5
		if(m_bInputStatus) return;
#endif
#ifdef DEF_SHORTCUT
		if (m_bIsDialogEnabled[3] == FALSE) //마법창
			EnableDialogBox(3, NULL, NULL, NULL);
		else DisableDialogBox(3);
#else
		if (m_bIsDialogEnabled[10] == FALSE) //채팅창
			EnableDialogBox(10, NULL, NULL, NULL);
		else DisableDialogBox(10);
#endif
		break;

	case VK_F11:
#if DEF_LANGUAGE == 5
		if(m_bInputStatus) return;
#endif
#ifdef DEF_SHORTCUT
		if( m_bCtrlPressed ) m_bDialogTrans = !m_bDialogTrans;
		else
		{
			if (m_bIsDialogEnabled[10] == FALSE)
				EnableDialogBox(10, NULL, NULL, NULL);
			else DisableDialogBox(10);
		}
#else
		m_bDialogTrans = !m_bDialogTrans;
#endif
		break;

	case VK_F12:
		if(m_bInputStatus) return;
		if (m_bIsDialogEnabled[19] == FALSE)
			EnableDialogBox(19, NULL, NULL, NULL);
		else DisableDialogBox(19);
		break;

	case VK_F1:
		if (m_bInputStatus) return;
#ifdef DEF_SHORTCUT
		UseShortCut( 0 );
#else
		if (m_bIsDialogEnabled[35] == FALSE)
			EnableDialogBox(35, NULL, NULL, NULL);
		else 
		{
			DisableDialogBox(35);
			DisableDialogBox(18);
		}
#endif
		break;

	case 72:
		if (m_bInputStatus) return;
		if (m_bCtrlPressed == TRUE) EnableDialogBox(35, NULL, NULL, NULL);//Help Request
		break;

	case VK_UP:	
		m_cArrowPressed	= 1;
#if DEF_LANGUAGE < 5 //언어가 일본어가 아니라면...일본이 5이므로
		if( m_cGameMode == DEF_GAMEMODE_ONMAINGAME ) // v2.15 채팅 스크롤용 변수 추가...상하
		{
			int iTotalMsg=0;
			for( int i=DEF_MAXWHISPERMSG-1 ; i>=0 ; i-- )
			{
				if( m_pWhisperMsg[i] != NULL )
				{
					iTotalMsg = i;
					break;
				}
			}
			m_cWhisperIndex ++;
			if( m_cWhisperIndex > iTotalMsg ) m_cWhisperIndex = 0;
			if( m_cWhisperIndex < 0 ) m_cWhisperIndex = iTotalMsg;
			if( m_pWhisperMsg[m_cWhisperIndex] != NULL ) {
			EndInputString();
			wsprintf( m_cChatMsg, "/to %s", m_pWhisperMsg[m_cWhisperIndex]->m_pMsg );
			StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg); 
			}
		}
#endif
		break;

	case VK_RIGHT:	
		m_cArrowPressed	= 2;
		break;

	case VK_DOWN:	
		m_cArrowPressed	= 3;
#if DEF_LANGUAGE < 5 //언어가 일본어가 아니라면...일본이 5이므로
		if( m_cGameMode == DEF_GAMEMODE_ONMAINGAME ) // v2.15 채팅 스크롤용 변수 추가...상하
		{
			int iTotalMsg=0;
			for( int i=DEF_MAXWHISPERMSG-1 ; i>=0 ; i-- )
			{
				if( m_pWhisperMsg[i] != NULL )
				{
					iTotalMsg = i;
					break;
				}
			}
			m_cWhisperIndex --;
			if( m_cWhisperIndex < 0 ) m_cWhisperIndex = iTotalMsg;
			if( m_cWhisperIndex > iTotalMsg ) m_cWhisperIndex = 0;
			if( m_pWhisperMsg[m_cWhisperIndex] != NULL ) {
			EndInputString();
			wsprintf( m_cChatMsg, "/to %s", m_pWhisperMsg[m_cWhisperIndex]->m_pMsg );
			StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg); 
			}
		}
#endif
		break;

	case VK_LEFT:	
		m_cArrowPressed	= 4;
		break;

	case VK_SNAPSHOT:
		CreateScreenShot();
		break;
	
#ifndef DEF_USING_WIN_IME
	case VK_TAB:
		if( m_bShiftPressed )
		{
			m_cCurFocus--;
			if( m_cCurFocus < 1 ) m_cCurFocus = m_cMaxFocus;
		}
		else
		{
			m_cCurFocus++;
			if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		}
		
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, NULL, NULL, NULL, NULL, NULL); 
		}
		break;
	
	case VK_RETURN:
		m_bEnterPressed = TRUE; 
		break;
#endif
	
	case VK_HOME:
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLESAFEATTACKMODE, NULL, NULL, NULL, NULL, NULL); 
		}
		break;
	
	case VK_ESCAPE:
		m_bEscPressed = TRUE;
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{
			if ((m_bIsObserverMode == TRUE) && (m_bShiftPressed)) { //ObserverMode에서 Shift+Esc를 누르면 접속 종료
				// Log Out
				if (m_cLogOutCount == -1) m_cLogOutCount = 1;
				DisableDialogBox(19);
				PlaySound('E', 14, 5);
			}
			else if(m_cLogOutCount != -1) {
				if (m_bForceDisconn == FALSE) { //로그아웃중 Esc를 누르면 강제종료가 아니면 카운트를 취소한다.
					m_cLogOutCount = -1;
					AddEventList(DLGBOX_CLICK_SYSMENU2, 10);//"접속 종료 카운트가 중지되었습니다."
				}
			}
			if (m_bIsGetPointingMode == TRUE) {
				// 포인트를 얻어 행동을 취하는 모드였다. (마법이라든지 아이템 사용 등등)
				// 취소한다. 
				m_bIsGetPointingMode = FALSE;
				AddEventList(COMMAND_PROCESSOR1, 10);//"취소되었습니다."
			}
			m_bIsF1HelpWindowEnabled = FALSE;
		}
		break;
	
	case 33: 
		if (m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
		if (m_bInputStatus) return;
		
		if (m_bIsSpecialAbilityEnabled == TRUE) {
			if (m_iSpecialAbilityType != 0) {
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY, NULL, NULL, NULL, NULL, NULL);
				m_bIsSpecialAbilityEnabled = FALSE;
			}
			else AddEventList(ON_KEY_UP26, 10);//"설정된 특수 능력이 없습니다." 
		}
		else {
			if (m_iSpecialAbilityType == 0) AddEventList(ON_KEY_UP26, 10);//"설정된 특수 능력이 없습니다."
			else {
				if ((m_sPlayerAppr4 & 0x00F0) != 0) {
					AddEventList(ON_KEY_UP28, 10);//"이미 특수 능력을 사용하고 있습니다."
					return;
				}

				i = (dwTime - m_dwSpecialAbilitySettingTime)/1000;
				i = m_iSpecialAbilityTimeLeftSec - i;
				if (i < 0) i = 0;
										
				ZeroMemory(G_cTxt, sizeof(G_cTxt));
				if (i < 60) {
					switch (m_iSpecialAbilityType) {
					case 1: wsprintf(G_cTxt, ON_KEY_UP29, i); break;//"공격한 캐릭터의 HP를 50%%씩 감소시키는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 2: wsprintf(G_cTxt, ON_KEY_UP30, i); break;//"공격한 캐릭터를 냉동 시키는 특수 능력: 약 %d초 후에 사용 가능합니다." 
					case 3: wsprintf(G_cTxt, ON_KEY_UP31, i); break;//"공격한 캐릭터를 마비 시키는 특수 능력: 약 %d초 후에 사용 가능합니다."  
					case 4: wsprintf(G_cTxt, ON_KEY_UP32, i); break;//"공격한 캐릭터를 한번에 살상하는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 5: wsprintf(G_cTxt, ON_KEY_UP33, i); break;//"공격한 캐릭터에게 입힌 타격치 포인트 만큼의 HP를 얻는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 50:wsprintf(G_cTxt, ON_KEY_UP34, i); break;//"공격을 가한 캐릭터의 무기를 부수는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 51:wsprintf(G_cTxt, ON_KEY_UP35, i); break;//"특수 방어 아이템이 장착된 부분은 물리 공격을 받지 않는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 52:wsprintf(G_cTxt, ON_KEY_UP36, i); break;//"일정 시간 동안 플레이어로부터 공격을 받지 않는 특수 능력: 약 %d초 후에 사용 가능합니다."
					}
				}
				else {
					switch (m_iSpecialAbilityType) {
					case 1: wsprintf(G_cTxt, ON_KEY_UP37, i/60); break;//"공격한 캐릭터의 HP를 50%%씩 감소시키는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 2: wsprintf(G_cTxt, ON_KEY_UP38, i/60); break;//"공격한 캐릭터를 냉동 시키는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 3: wsprintf(G_cTxt, ON_KEY_UP39, i/60); break;//"공격한 캐릭터를 마비 시키는 특수 능력: 약 %d분 후에 사용 가능합니다." 
					case 4: wsprintf(G_cTxt, ON_KEY_UP40, i/60); break;//"공격한 캐릭터를 한번에 살상하는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 5: wsprintf(G_cTxt, ON_KEY_UP41, i/60); break;//"공격한 캐릭터에게 입힌 타격치 포인트 만큼의 HP를 얻는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 50:wsprintf(G_cTxt, ON_KEY_UP42, i/60); break;//"공격을 가한 캐릭터의 무기를 부수는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 51:wsprintf(G_cTxt, ON_KEY_UP43, i/60); break;//"특수 방어 아이템이 장착된 부분은 물리 공격을 받지 않는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 52:wsprintf(G_cTxt, ON_KEY_UP44, i/60); break;//"일정 시간 동안 플레이어로부터 공격을 받지 않는 특수 능력: 약 %d분 후에 사용 가능합니다."
					}
				}
				AddEventList(G_cTxt, 10);
			}
		}
		break;
	}
}

void CGame::OnKeyDown(WPARAM wParam)
{
	switch (wParam) {
	case VK_CONTROL:
		m_bCtrlPressed = TRUE;
		break;
	case VK_SHIFT:
		m_bShiftPressed = TRUE;
		break;
	case VK_INSERT:
	case VK_DELETE:
	case VK_TAB:
	case VK_RETURN:
	case VK_ESCAPE:
	case VK_END: 
	case VK_HOME:
	case VK_F1:
	case VK_F2:
	case VK_F3:
	case VK_F4:
	case VK_F5:
	case VK_F6:
	case VK_F7:
	case VK_F8:
	case VK_F9:
	case VK_F10:
	case VK_F11:
	case VK_F12:
	case VK_PRIOR: // Page-Up
	case VK_NEXT: // Page-Down
	case VK_LWIN:
	case VK_RWIN: 
	case VK_MULTIPLY:
	case VK_ADD: //'+'
	case VK_SEPARATOR:
	case VK_SUBTRACT: //'-'
	case VK_DECIMAL:
	case VK_DIVIDE:
	case VK_NUMLOCK:
	case VK_SCROLL:
		break;

	default:
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME) {
			if (m_bCtrlPressed) {
				// 마법 써클 선택 단축키 
				switch (wParam) {
				case 48: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 9; break; // 0
				case 49: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 0; break; // 1
				case 50: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 1; break; // 2 
				case 51: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 2; break; // 3
				case 52: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 3; break; // 4 
				case 53: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 4; break; // 5
				case 54: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 5; break; // 6
				case 55: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 6; break; // 7
				case 56: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 7; break; // 8
				case 57: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 8; break; // 9
				}
			}
			else if ((m_bInputStatus == FALSE) && (GetAsyncKeyState(VK_MENU)>>15 == FALSE)) {
				// 채팅 모드 켠다.
				StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg); 
				ClearInputString();
			}
		}
		break;
	}
}

void CGame::UpdateScreen_OnQuit()
{
 short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
	
 static class CMouseInterface * pMI; 

 DWORD dwTime = timeGetTime();
	
	if (m_cGameModeCount == 0) {
		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		if (m_pGSock != NULL) {
			delete m_pGSock;
			m_pGSock = NULL;
		}
		m_bEscPressed = FALSE;
		m_bEnterPressed = FALSE;
		pMI = new class CMouseInterface;
		pMI->AddRect(0,0,640,480);
		m_bEnterPressed = FALSE;
	}

    m_cGameModeCount++;
	if (m_cGameModeCount > 120) m_cGameModeCount = 120;

	m_DDraw.ClearBackB4();
	
	if (m_bEscPressed == TRUE || m_bEnterPressed == TRUE) {
		m_bEscPressed = FALSE;
		m_bEnterPressed = FALSE;
		delete pMI;
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		return;
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 0,0,0, TRUE);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 255,123,1, TRUE);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_QUIT]->PutTransSprite25(255,123,1, TRUE);
	
	DrawVersion();

	
	// 테라 부분은, 좀 더..오랫동안 딜레이 시간을 주는 처리가 필요~

	if(m_cGameModeCount == 100) {
		ChangeGameMode(DEF_GAMEMODE_NULL);
		delete pMI;
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		return;
	}


	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if ((cMIresult == DEF_MIRESULT_CLICK) && (iMIbuttonNum == 1)) {
		// 마우스 버튼이 눌렸으므로 프로그램을 종료한다.
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		delete pMI;
		return;
	}

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnQueryForceLogin()
{
 short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;

 static class CMouseInterface * pMI; 
 static DWORD dwCTime;
 DWORD dwTime = timeGetTime();

	if (m_cGameModeCount == 0) {
		pMI = new class CMouseInterface;
		pMI->AddRect(200,244,200+DEF_BTNSZX,244+DEF_BTNSZY);
		pMI->AddRect(370,244,370+DEF_BTNSZX,244+DEF_BTNSZY);
		m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
		m_cArrowPressed = 0;
		
		dwCTime = timeGetTime();

		PlaySound('E', 25, 0);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6)) {
		m_DDraw.DrawShadowBox(0,0,639,479);
	}
	else if (m_cGameModeCount >= 6) {
		m_DDraw.DrawShadowBox(0,0,639,479);
		m_DDraw.DrawShadowBox(0,0,639,479);
	}
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162, 130, 2);

	PutString_SprFont(172 + 86, 160, "Character on Use", 7,0,0);
	PutAlignedString(178, 453, 195, UPDATE_SCREEN_ON_QUERY_FORCE_LOGIN1);//"계정이 사용중입니다. 현재의 연결을"
	PutAlignedString(178, 453, 215, UPDATE_SCREEN_ON_QUERY_FORCE_LOGIN2);//"강제로 끊으시겠습니까?" 
	
	if ((msX >= 200) && (msX <= 200 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY)) 
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200, 244, 19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200, 244, 18);

	if ((msX >= 370) && (msX <= 370 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY)) 
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 2);

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스 버튼이 클릭되었다.
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
			// 강제 접속한다. 
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
			m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NOENTER_FORCEDISCONN;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg,"33");
			delete pMI;
			return;

		case 2:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			break;
		}
	}

	DrawVersion();
	// 마우스 커서 그린다.
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnSelectCharacter(short sX, short sY, short msX, short msY, BOOL bIgnoreFocus)
{
 int i;
 int iYear, iMonth, iDay, iHour, iMinute;
 __int64 iTemp1, iTemp2;
 char cTotalChar = 0;
 DWORD dwTime = timeGetTime();



	sY = 10;

	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_SELECTCHAR, 0, 0, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0, 0, 50);

	iTemp1 = 0;
	iTemp2 = 0;
	iYear = iMonth = iDay = iHour = iMinute = 0;
	
	for (i = 0; i < 4; i++) {
		
		if ((m_cCurFocus - 1 == i) && (bIgnoreFocus == FALSE)) 
			 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(sX + 110 + i*109 -7, 63 -9, 62, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(sX + 110 + i*109 -7, 63 -9, 61, dwTime);
		
		if (m_pCharList[i] != NULL) {
		
			cTotalChar++;

			switch (m_pCharList[i]->m_sSex) {
			case 1:	_tmp_sOwnerType = 1; break;
			case 2:	_tmp_sOwnerType = 4; break; 
			}
			_tmp_sOwnerType += m_pCharList[i]->m_sSkinCol - 1;
			_tmp_cDir   = m_cMenuDir;
			_tmp_sAppr1 = m_pCharList[i]->m_sAppr1;
			_tmp_sAppr2 = m_pCharList[i]->m_sAppr2;
			_tmp_sAppr3 = m_pCharList[i]->m_sAppr3;
			_tmp_sAppr4 = m_pCharList[i]->m_sAppr4;
			_tmp_iApprColor = m_pCharList[i]->m_iApprColor; // v1.4

			ZeroMemory(_tmp_cName, sizeof(_tmp_cName));
			memcpy(_tmp_cName, m_pCharList[i]->m_cName, 10);
			_tmp_cAction = DEF_OBJECTMOVE;
			_tmp_cFrame = m_cMenuFrame;

			if (m_pCharList[i]->m_sSex != NULL) {
				
				if (m_Misc.bCheckValidString(m_pCharList[i]->m_cName) == TRUE) {
					
					m_pEffectSpr[0]->PutTransSprite(sX +157 +i*109, sY +138, 1, dwTime);
					DrawObject_OnMove_ForMenu(0, 0, sX +157 +i*109, sY +138, FALSE, dwTime, 0, 0);
					
					PutString(sX +112 +i*109, sY +179 -9, m_pCharList[i]->m_cName, RGB(51,0,51));//25,35,25);
					int	_sLevel = m_pCharList[i]->m_sLevel;
					wsprintf(G_cTxt, "%d", _sLevel);
					PutString(sX + 138 +i*109, sY +196 -10, G_cTxt, RGB(51,0,51)); //25,35,25);
										
					wsprintf(G_cTxt, "%d", m_pCharList[i]->m_iExp);
					PutString(sX + 138 +i*109, sY +211 -10, G_cTxt, RGB(51,0,51)); //25,35,25);
				}
				else {
					
				}

				// v1.4 가장 최근에 접속한 날짜를 구한다.
				iTemp2 = m_pCharList[i]->m_iYear*1000000 + m_pCharList[i]->m_iMonth*60000 + m_pCharList[i]->m_iDay*1700 + m_pCharList[i]->m_iHour*70 + m_pCharList[i]->m_iMinute;  
				if (iTemp1 < iTemp2) {
					iYear   = m_pCharList[i]->m_iYear;
					iMonth  = m_pCharList[i]->m_iMonth;
					iDay    = m_pCharList[i]->m_iDay;
					iHour   = m_pCharList[i]->m_iHour;
					iMinute = m_pCharList[i]->m_iMinute;  
					iTemp1 = iTemp2;
				}
			}
			else {
			}
		}
		else {
		}
	}

    i = 0 ;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,51);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,52);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,53);

#ifndef DEF_JAPAN_FOR_TERRA
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,54);
#endif

#if DEF_LANGUAGE != 1
	#ifndef DEF_JAPAN_FOR_TERRA
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,55);
	#endif
#endif
	if ((msX > 360) && (msY >= 283) && (msX < 545) & (msY <= 315)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,56);
		PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER1);//"선택된 캐릭터로 게임에 접속합니다."
		PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER2);//"접속하고자 하는 캐릭터를 선택한 후"
		PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER3);//"엔터키를 누르거나 커서로 클릭해도"
		PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER4);//"접속할 수 있습니다."
	} else
	if ((msX > 360) && (msY >= 316) && (msX < 545) & (msY <= 345)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,57);
		PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER5);//"새로운 캐릭터를 만듭니다."

	} else
	if ((msX > 360) && (msY >= 346) && (msX < 545) & (msY <= 375)) {

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,58);
		PutAlignedString(98, 357, 275 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER6);//"선택된 캐릭터를 지웁니다. 지워진 캐릭터는"
		PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER7);//"복구가 불가능하며, 30레벨 이상의 캐릭터는"
		PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER8);//"이 방법으로 지울 수 없습니다."
		PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER9);//"30레벨 이상의 캐릭터를 지울려면 운영자에게"
		PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER10);//"계정 이름과 캐릭터 이름, 주민번호를"
		PutAlignedString(98, 357, 350 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER11);//"E-mail로 알려 주셔야 합니다."

	} else
#if DEF_LANGUAGE == 1
	if ((msX > 360) && (msY >= 376) && (msX < 545) & (msY <= 405)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,59);
		PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER13);//"초기 메뉴로 돌아갑니다."
	} else {
#else
	#ifndef DEF_JAPAN_FOR_TERRA
		if ((msX > 360) && (msY >= 376) && (msX < 545) & (msY <= 405)) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,59);
			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER12);//"계정의 패스워드를 변경합니다."
		} else if ((msX > 360) && (msY >= 406) && (msX < 545) & (msY <= 435)) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,60);
			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER13);//"초기 메뉴로 돌아갑니다."
		} else {
	#else
		if ((msX > 360) && (msY >= 376) && (msX < 545) & (msY <= 405)) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,-30,60);
			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER13);//"초기 메뉴로 돌아갑니다."
		} else {
	#endif

//		if ((msX > 360) && (msY >= 406) && (msX < 545) & (msY <= 435)) {
//			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,60);
//			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER13);//"초기 메뉴로 돌아갑니다."
//		} else {
#endif

		if (cTotalChar == 0) {
			PutAlignedString(98, 357, 275 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER14);//"계정이 소유하고 있는 캐릭터가 없습니다."
			PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER15);//"하나의 계정은 최대 4명의 캐릭터를 소유할 수"
			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER16);//"있으며 좌측 스크롤의 빈곳을 클릭하거나"
			PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER17);//"상단의 New Character 버튼을 눌러 새로운"
			PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER18);//"캐릭터를 만들 수 있습니다."
		}
		else if (cTotalChar < 4) {
			PutAlignedString(98, 357, 275 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER19);//"플레이하고자 하는 캐릭터를 선택한 후"
			PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER20);//"Play버튼을 눌러 게임을 시작하거나 새로운"
			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER21);//"캐릭터를 만들 수 있습니다. 만약 존재하는"
			PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER22);//"캐릭터를 삭제하고자 한다면 캐릭터를"
			PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER23);//"선택한 다음 Delete Character버튼을"
			PutAlignedString(98, 357, 350 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER24);//"누릅니다."
		}
		if (cTotalChar == 4) {
			PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER25);//"플레이하고자 하는 캐릭터를 선택한 후"   
			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER26);//"Play버튼을 눌러 게임을 시작하거나"
			PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER27);//"Delete Character버튼을 눌러 선택된"
			PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER28);//"캐릭터를 삭제할 수 있습니다."
		}
	}
	
#if DEF_LANGUAGE >= 3	//언어:Korean
#ifndef DEF_JAPAN_FOR_TERRA
	// v1.4331
	int iTempMon, iTempDay, iTempHour, iTempMin ;
	iTempMon = iTempDay = iTempHour =iTempMin = 0;

	if (m_iAccntYear != 0){
		 iTempMin =  (m_iTimeLeftSecAccount / 60 ) ;
		 wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER37, m_iAccntYear, m_iAccntMonth, m_iAccntDay, iTempMin);
	}else {
		if (m_iTimeLeftSecAccount > 0){
			iTempDay =   (m_iTimeLeftSecAccount /(60*60*24)) ;
			iTempHour =  (m_iTimeLeftSecAccount /(60*60)) % 24;
			iTempMin =   (m_iTimeLeftSecAccount / 60 ) % 60;
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER38, iTempDay, iTempHour, iTempMin);
		}
		else strcpy(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER39);
		                     
	}
	PutAlignedString(98, 357, 385 +10, G_cTxt);
	
	if (m_iIpYear != 0) {
		iTempHour =  (m_iTimeLeftSecIP / (60*60)) ;
		iTempMin =   (m_iTimeLeftSecIP / 60 ) % 60;
		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER40, m_iIpYear, m_iIpMonth, m_iIpDay, iTempHour, iTempMin) ;
	} else {
		if (m_iTimeLeftSecIP > 0) {
 			iTempDay =   (m_iTimeLeftSecIP / (60*60*24)) ;
			iTempHour =  (m_iTimeLeftSecIP / (60*60)) % 24;
			iTempMin =   (m_iTimeLeftSecIP / 60 ) % 60;
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER41, iTempDay, iTempHour, iTempMin);
			
		} else strcpy(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER42);
		                     
	}          

	PutAlignedString(98, 357, 400 +10, G_cTxt);
	
	if (iYear != 0) {
		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER43, iYear, iMonth, iDay, iHour, iMinute);
		PutAlignedString(98, 357, 415 +10, G_cTxt);
	}
#endif
#endif

#if DEF_LANGUAGE == 2	//언어:DEF_CHINESE
//	// v1.4331
//	int iTempMon, iTempDay, iTempHour, iTempMin ;
//	iTempMon = iTempDay = iTempHour =iTempMin = 0;
//
//	if (m_iAccntYear != 0){
//		 iTempMin =  (m_iTimeLeftSecAccount / 60 ) ;
//		 wsprintf(G_cTxt,UPDATE_SCREEN_ON_SELECT_CHARACTER37, m_iAccntYear, m_iAccntMonth, m_iAccntDay, iTempMin);
//	}else {
//		iTempMin =  (m_iTimeLeftSecAccount / 60 ) ;
//		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER38, iTempMin);
//               
//	}
//	PutAlignedString(98, 357, 385 +10, G_cTxt);

	//	mando 20021128..
	int iTempMon, iTempDay, iTempHour, iTempMin ;
	iTempMon = iTempDay = iTempHour =iTempMin = 0;

	if (m_iAccntYear != 0){
		 iTempMin =  (m_iTimeLeftSecAccount / 60 ) ;
		 wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER37, m_iAccntYear, m_iAccntMonth, m_iAccntDay, iTempMin);
	}else {
		if (m_iTimeLeftSecAccount > 0){
			iTempDay =   (m_iTimeLeftSecAccount /(60*60*24)) ;
			iTempHour =  (m_iTimeLeftSecAccount /(60*60)) % 24;
			iTempMin =   (m_iTimeLeftSecAccount / 60 ) % 60;
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER38, iTempDay, iTempHour, iTempMin);
		}
		else strcpy(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER39);
		                     
	}
	PutAlignedString(98, 357, 385 +10, G_cTxt);

#endif

#ifdef DEF_TESTSERVER
	PutAlignedString(122, 315, 456, UPDATE_SCREEN_ON_SELECT_CHARACTER36);//"테스트 서버 : Test Server"
#else
	if (strcmp(m_cWorldServerName, "WS1") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME1);//"이프리트 서버 : EFREET Server"
	else if (strcmp(m_cWorldServerName, "WS2") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME2);//"운디네 서버 : UNDINE Server"
	else if (strcmp(m_cWorldServerName, "WS3") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME3);//"제리마 서버 : XELIMA Server"
	else if (strcmp(m_cWorldServerName, "WS4") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME4);//"네번째 서버 : 4th Server"
	else if (strcmp(m_cWorldServerName, "WS5") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME5);//"다섯번째 서버 : 5th Server"
	else if (strcmp(m_cWorldServerName, "WS6") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME6);//"여섯번째 서버 : 6th Server"
	else if (strcmp(m_cWorldServerName, "WS7") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME7);//"일곱번째 서버 : 7th Server"
	else if (strcmp(m_cWorldServerName, "WS8") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME8);//"여덟번째 서버 : 8th Server"
	else if (strcmp(m_cWorldServerName, "WS9") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME9);//"아홉번째 서버 : 9th Server"
	else if (strcmp(m_cWorldServerName, "WS10") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME10);//"10번째 서버 : 10th Server"
	else if (strcmp(m_cWorldServerName, "WS11") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME11);//"11째 서버 : 11th Server"
	else if (strcmp(m_cWorldServerName, "WS12") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME12);//"12번째 서버 : 12th Server"
	else if (strcmp(m_cWorldServerName, "WS13") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME13);//"13번째 서버 : 13th Server"
	else if (strcmp(m_cWorldServerName, "WS14") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME14);//"14번째 서버 : 14th Server"
	else if (strcmp(m_cWorldServerName, "WS15") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME15);//"15번째 서버 : 15th Server"
	else if (strcmp(m_cWorldServerName, "WS16") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME16);//"16번째 서버 : 16th Server"
#endif


   
}

void CGame::UpdateScreen_OnWaitingResponse()
{
 short sX, sY, msX, msY, msZ;
 char cLB, cRB;

 DWORD dwTime = timeGetTime();
 //static class CMouseInterface * pMI;
 static DWORD dwCTime;

	if (m_cGameModeCount == 0) {
		m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
		dwCTime = timeGetTime();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE) {
		
		if ((dwTime - m_dwTime) > 7000) {
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			if (m_pLSock != NULL) {
				delete m_pLSock;
				m_pLSock = NULL;
			}
			if (m_pGSock != NULL) {
				delete m_pGSock;
				m_pGSock = NULL;
			}
		}

		m_bEscPressed = FALSE;
		return; 
	}

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	m_bIsHideLocalCursor = TRUE;
	m_DDraw.ClearBackB4();
	switch (m_cMsg[0]) {
	case '0':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;

	case '1':
		sX = 146; 
		sY = 114;
		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;

	case '2':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;

	case '3':
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
		break;

	case '4':
		// Change Password
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, TRUE);
		break;

	case '5':
		m_DDraw.ClearBackB4();
		break;
	}
	m_bIsHideLocalCursor = FALSE;

	m_DDraw.DrawShadowBox(0,0, 639,479);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);
	PutString_SprFont(172 + 44 -17, 190, "Connected. Waiting for response...", 7,0,0);
	
	if ((dwTime - m_dwTime) > 7000) {
		PutAlignedString(180, 463, 195+30, UPDATE_SCREEN_ON_WATING_RESPONSE1);
		                                    //"오랫동안 연결이 안되는 경우 ESC키를 누르면"
		PutAlignedString(180, 463, 195+45, UPDATE_SCREEN_ON_WATING_RESPONSE2);
		                                    //"접속을 취소하고 초기화면으로 돌아갑니다."
	}
	else PutAlignedString(180, 463, 195+30, UPDATE_SCREEN_ON_WATING_RESPONSE3);
	                                         //"서버로 연결중입니다. 기다려 주세요..."

	DrawVersion();
	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 8, dwTime);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnQueryDeleteCharacter()
{
 short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;

 static class CMouseInterface * pMI; 
 static DWORD dwCTime;
 DWORD dwTime = timeGetTime();

	if (m_cGameModeCount == 0) {
		pMI = new class CMouseInterface;
		pMI->AddRect(200, 244, 200 + DEF_BTNSZX, 244 + DEF_BTNSZY);
		pMI->AddRect(370, 244, 370 + DEF_BTNSZX, 244 + DEF_BTNSZY);
		//m_cCurFocus = 1;
		//m_cMaxFocus = 2;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
		
		dwCTime = timeGetTime();

		PlaySound('E', 25, 0);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	UpdateScreen_OnSelectCharacter(0, 0, 500, 70);
	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6)) {
		m_DDraw.DrawShadowBox(0,0,639,479);
	}
	else if (m_cGameModeCount >= 6) {
		m_DDraw.DrawShadowBox(0,0,639,479);
		m_DDraw.DrawShadowBox(0,0,639,479);
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);

	PutString_SprFont(172 + 86, 160, "Delete Character", 7,0,0);
	PutString(215, 195, UPDATE_SCREEN_ON_QUERY_DELETE_CHARACTER1, RGB(5,5,5));
	                   //"Character Name"
	PutString(335, 199, "__________", RGB(5,5,5));
	PutString(335, 195, m_pCharList[m_wEnterGameType - 1]->m_cName, RGB(25,35,25));
	PutAlignedString(178, 453, 220, UPDATE_SCREEN_ON_QUERY_DELETE_CHARACTER2);
	                                //"위 캐릭터를 삭제하시겠습니까?"
	
	// v2.05
	if ((msX >= 200) && (msX <= 200 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200, 244, 19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200, 244, 18);

	if ((msX >= 370) && (msX <= 370 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 2);

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스 버튼이 클릭되었다.
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
			// 캐릭터를 삭제를 요청한다. 
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode  = MSGID_REQUEST_DELETECHARACTER;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg,"33");
			delete pMI;
			return;
		
		case 2:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			break;
		}
	}

	DrawVersion();
	// 마우스 커서 그린다.
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::NotifyMsgHandler(char * pData)
{
 DWORD * dwp, dwTime, dwTemp;
 WORD  * wp, wEventType;
 char  * cp, cTemp[510], cTxt[120];
 short * sp, sX, sY, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9;
 int   * ip, i, iV1, iV2, iV3, iV4;
	
	dwTime = timeGetTime();

	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wEventType = *wp;

	switch (wEventType) {
	case DEF_NOTIFY_AGRICULTURENOAREA:
		AddEventList( DEF_MSG_NOTIFY_AGRICULTURENOAREA, 10 );
		break;
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT:
		AddEventList( DEF_MSG_NOTIFY_AGRICULTURESKILLLIMIT, 10 );
		break;
	case DEF_NOTIFY_NOMOREAGRICULTURE:
		AddEventList( DEF_MSG_NOTIFY_NOMOREAGRICULTURE, 10 );
		break;
	case DEF_NOTIFY_MONSTEREVENT_POSITION:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		m_sMonsterID = (short)(*cp);
		cp++;

		sp  = (short *)cp;
		m_sEventX = *sp;
		cp+=2;

		sp  = (short *)cp;
		m_sEventY = *sp;
		cp+=2;
		m_dwMonsterEventTime = dwTime;
		break;

	case DEF_NOTIFY_RESPONSE_HUNTMODE:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		memcpy(m_cLocation, cp, 10);
		cp += 10;
		if (memcmp(m_cLocation, "aresden", 7) == 0)
		{
			m_bAresden = TRUE;
			m_bCitizen = TRUE;
			m_bHunter = FALSE;
		}
		else if (memcmp(m_cLocation, "arehunter", 9) == 0)
		{
			m_bAresden = TRUE;
			m_bCitizen = TRUE;
			m_bHunter = TRUE;
		}
		else if (memcmp(m_cLocation, "elvine", 6) == 0)
		{
			m_bAresden = FALSE;
			m_bCitizen = TRUE;
			m_bHunter = FALSE;
		}
		else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
		{
			m_bAresden = FALSE;
			m_bCitizen = TRUE;
			m_bHunter = TRUE;
		}
		else
		{
			m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter = TRUE;
		}
		AddEventList( DEF_MSG_GAMEMODE_CHANGED, 10 );//"게임모드가 바뀌었습니다."
		break;

	// v2.171
	case DEF_NOTIFY_REQGUILDNAMEANSWER:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		sp  = (short *)cp;
		sV2 = *sp;
		cp += 2;
		ZeroMemory(cTemp, sizeof(cTemp));
		memcpy(cTemp, cp, 20);
		cp += 20;

		ZeroMemory( m_stGuildName[sV2].cGuildName, sizeof(m_stGuildName[sV2].cGuildName) );
		strcpy(m_stGuildName[sV2].cGuildName, cTemp);
		m_stGuildName[sV2].iGuildRank = sV1;
		for (i = 0; i < 20; i++) if (m_stGuildName[sV2].cGuildName[i] == '_') m_stGuildName[sV2].cGuildName[i] = ' ';
		break;

	// v2.17 2002-7-15
	case DEF_NOTIFY_FORCERECALLTIME:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		

		if ( (int)(sV1/20) > 0)
			wsprintf(G_cTxt,NOTIFY_MSG_FORCERECALLTIME1,(int) (sV1/20)) ;
		else 
			wsprintf(G_cTxt,NOTIFY_MSG_FORCERECALLTIME2) ;

		AddEventList(G_cTxt, 10);
		break;


	case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		m_iGizonItemUpgradeLeft = sV1;
		dwp = (DWORD *)cp;
		switch (*dwp) {
		case 1: // 지존 아이템 업그레이드 포인트 1상승!
			AddEventList(NOTIFY_MSG_HANDLER_GIZONITEMUPGRADELEFT1, 10);
			break;
		}
		cp += 4;
		break;
	// v2.15 지존아이템 모양 바꿔지는 루틴 추가 
	case DEF_NOTIFY_GIZONEITEMCHANGE:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;

		m_pItemList[sV1]->m_cItemType = *cp ;
		cp++ ;

		wp  = (WORD *)cp;
		m_pItemList[sV1]->m_wCurLifeSpan = *wp;
		cp += 2;

		sp  = (short *)cp;
		m_pItemList[sV1]->m_sSprite = *sp;
		cp += 2;

		sp  = (short *)cp;
		m_pItemList[sV1]->m_sSpriteFrame = *sp;
		cp += 2;

		m_pItemList[sV1]->m_cItemColor = *cp ;
		cp++ ;
		
		m_pItemList[sV1]->m_sItemSpecEffectValue2 = *cp ;
		cp++ ;

		dwp = (DWORD *) cp ;
		m_pItemList[sV1]->m_dwAttribute =  *dwp ;
		cp +=4 ;

		ZeroMemory( m_pItemList[sV1]->m_cName, sizeof(m_pItemList[sV1]->m_cName) );
		memcpy(m_pItemList[sV1]->m_cName,cp,20) ;
		cp += 20 ;
		// 변화가 있다. 업그레이드 성공 
		if (m_bIsDialogEnabled[34] == TRUE) {  
			m_stDialogBoxInfo[34].cMode = 3;
		}
		PlaySound('E', 23, 5);
		// 사운드 효과
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;

		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}

		break;

	// v2.16 2002-5-22 고광현 수정
	case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;

		sV1 = *sp;
		cp += 2;

		dwTemp = m_pItemList[sV1]->m_dwAttribute;
		dwp  = (DWORD *)cp;
		m_pItemList[sV1]->m_dwAttribute = *dwp;
		cp += 4;
		// v2.16 2002-5-21 고광현수정
		dwp  = (DWORD *)cp;
		if (*dwp != 0) m_pItemList[sV1]->m_sItemSpecEffectValue1 = (short)*dwp;
		cp += 4;
		dwp  = (DWORD *)cp;
		if (*dwp != 0) m_pItemList[sV1]->m_sItemSpecEffectValue2 = (short)*dwp;
		cp += 4;

		if (dwTemp == m_pItemList[sV1]->m_dwAttribute) {
			// 변동사항 없다. 업그레이드 실패 
			if (m_bIsDialogEnabled[34] == TRUE) {
				m_stDialogBoxInfo[34].cMode = 4;
			}
			PlaySound('E', 24, 5);
		}
		else {
			// 변화가 있다. 업그레이드 성공 
			if (m_bIsDialogEnabled[34] == TRUE) {  
				m_stDialogBoxInfo[34].cMode = 3;
			}
			PlaySound('E', 23, 5);
			// 사운드 효과
			switch (m_sPlayerType) {
			case 1:
			case 2:
			case 3:
				PlaySound('C', 21, 0);
				break;

			case 4:
			case 5:
			case 6:
				PlaySound('C', 22, 0);
				break;
			}
		}
		break;

	// v2.17 2002-7-21 
	case DEF_NOTIFY_ITEMUPGRADEFAIL:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;

		sV1 = *sp;
		cp += 2;


		if (m_bIsDialogEnabled[34] == FALSE) return ;

		PlaySound('E', 24, 5);

		switch(sV1){
			case 1:
				m_stDialogBoxInfo[34].cMode = 8 ;
				break ;
			case 2:
				m_stDialogBoxInfo[34].cMode = 9 ;
				break ;
			case 3:
				m_stDialogBoxInfo[34].cMode = 10 ;
				break ;
		}
		break;


	case DEF_NOTIFY_PARTY:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		sp  = (short *)cp;
		sV2 = *sp;
		cp += 2;
		sp  = (short *)cp;
		sV3 = *sp;
		cp += 2;
		switch (sV1) {
		case 1: // 파티 생성 관련 
			switch (sV2) {
			case 0:
				EnableDialogBox(32, NULL, NULL, NULL);
				m_stDialogBoxInfo[32].cMode = 9;
				break;

			case 1:
				m_iPartyStatus = 1;
				m_iTotalPartyMember = NULL;
				EnableDialogBox(32, NULL, NULL, NULL);
				m_stDialogBoxInfo[32].cMode = 8;
				for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
				// 처음 파티가 만들어 졌으면 멤버 리스트를 요청한다.
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, NULL, 2, NULL, NULL, m_cMCName);
				break;
			}
			break;

		case 2: // 파티 해산됨 
			m_iPartyStatus = 0;
			m_iTotalPartyMember = NULL;
			EnableDialogBox(32, NULL, NULL, NULL);
			m_stDialogBoxInfo[32].cMode = 10;
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
			break;
		
		case 4:
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, cp, 10);
			cp += 10;

			switch (sV2) {
			case 0: // 파티 가입 실패 
				EnableDialogBox(32, NULL, NULL, NULL);
				m_stDialogBoxInfo[32].cMode = 9;
				break;

			case 1: // 파티 가입 성공 
				if (strcmp(cTxt, m_cPlayerName) == 0) {
					m_iPartyStatus = 2;
					EnableDialogBox(32, NULL, NULL, NULL);
					m_stDialogBoxInfo[32].cMode = 8;
				}
				else {
					wsprintf(G_cTxt, NOTIFY_MSG_HANDLER1, cTxt);
					                //"%s님이 당신의 파티에 참가 했습니다."
					AddEventList(G_cTxt, 10);
				}

				m_iTotalPartyMember++;
				for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
				if (strlen(m_stPartyMemberNameList[i].cName) == 0) {
					ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
					memcpy(m_stPartyMemberNameList[i].cName, cTxt, 10);
					goto NMH_LOOPBREAK1;
				}
NMH_LOOPBREAK1:;
				break;

			case 2: // 파티 가입신청을 받았다.
				
				break;
			}
			break;

		case 5: // 파티 멤버 이름 리스트
			m_iTotalPartyMember = NULL;
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
			
			m_iTotalPartyMember = sV3;
			for (i = 1; i <= sV3; i++) {
				ZeroMemory(m_stPartyMemberNameList[i-1].cName, sizeof(m_stPartyMemberNameList[i-1].cName));
				memcpy(m_stPartyMemberNameList[i-1].cName, cp, 10);
				cp += 11;
			}
			break;

		default:
			sp  = (short *)cp;
			sV4 = *sp;
			cp += 2;
			break;

		case 6:
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, cp, 10);
			cp += 10;

			switch (sV2) {
			case 0: // 파티 탈퇴 실패
				EnableDialogBox(32, NULL, NULL, NULL);
				m_stDialogBoxInfo[32].cMode = 7;
				break;

			case 1: // 파티 탈퇴 성공
				if (strcmp(cTxt, m_cPlayerName) == 0) {
					m_iPartyStatus = 0;
					EnableDialogBox(32, NULL, NULL, NULL);
					m_stDialogBoxInfo[32].cMode = 6;
				}
				else {
					wsprintf(G_cTxt, NOTIFY_MSG_HANDLER2 , cTxt);
					                 //"%s가 당신의 파티를 탈퇴했습니다."
					AddEventList(G_cTxt, 10);
				}
				for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
				if (strcmp(m_stPartyMemberNameList[i].cName, cTxt) == 0) {
					ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
					m_iTotalPartyMember--;
					goto NMH_LOOPBREAK2;
				}
NMH_LOOPBREAK2:;
				break;
			}
			break;
		
		case 7: // 파티 가입이 거부되었음.
			EnableDialogBox(32, NULL, NULL, NULL);
			m_stDialogBoxInfo[32].cMode = 9;
			break;

		case 8: // 어떤 원인에 의해 파티 정보가 클리어되었다.
			m_iPartyStatus = 0;
			m_iTotalPartyMember = NULL;
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
			break;
		}
		break;
	
	case DEF_NOTIFY_CANNOTCONSTRUCT:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;

		CannotConstruct(sV1);
		PlaySound('E', 25, 0, 0);
		break;

	case DEF_NOTIFY_TCLOC:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		sp  = (short *)cp;
		m_iTeleportLocX = *sp;
		cp += 2;

		sp  = (short *)cp;
		m_iTeleportLocY = *sp;
		cp += 2;

		ZeroMemory(m_cTeleportMapName, sizeof(m_cTeleportMapName));
		memcpy(m_cTeleportMapName, cp, 10);
		cp += 10;

		sp  = (short *)cp;
		m_iConstructLocX = *sp;
		cp += 2;

		sp  = (short *)cp;
		m_iConstructLocY = *sp;
		cp += 2;

		ZeroMemory(m_cConstructMapName, sizeof(m_cConstructMapName));
		memcpy(m_cConstructMapName, cp, 10);
		cp += 10;
		break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;

		sp  = (short *)cp;
		sV2 = *sp;
		cp += 2;

		sp  = (short *)cp;
		sV3 = *sp;
		cp += 2;

		if (sV3 == 0) {
			if ((sV1 > m_iConstructionPoint) && (sV2 > m_iWarContribution)) {
				// 건설 포인트, 전쟁 공헌도 모두 올랐을때 
				wsprintf(G_cTxt, "%s +%d, %s +%d", m_pGameMsgList[13]->m_pMsg, (sV1 - m_iConstructionPoint), m_pGameMsgList[21]->m_pMsg, (sV2 - m_iWarContribution));
				SetTopMsg(G_cTxt, 5);
				PlaySound('E', 23, 0, 0);
			}
			
			if ((sV1 > m_iConstructionPoint) && (sV2 == m_iWarContribution)) {
				// 건설 포인트만 올랐다.
				if (m_iCrusadeDuty == 3) {
					// 지휘관인 경우에만 알려준다.
					wsprintf(G_cTxt, "%s +%d", m_pGameMsgList[13]->m_pMsg, sV1 - m_iConstructionPoint);
					SetTopMsg(G_cTxt, 5);
					PlaySound('E', 23, 0, 0);
				}
			}
			
			if ((sV1 == m_iConstructionPoint) && (sV2 > m_iWarContribution)) {
				// 전쟁 공헌도만 올랐다.
				wsprintf(G_cTxt, "%s +%d", m_pGameMsgList[21]->m_pMsg, sV2 - m_iWarContribution);
				SetTopMsg(G_cTxt, 5);
				PlaySound('E', 23, 0, 0);
			}

			if (sV1 < m_iConstructionPoint) {
				if (m_iCrusadeDuty == 3) {
					// 지휘관인 경우에만 알려준다.
					wsprintf(G_cTxt, "%s -%d", m_pGameMsgList[13]->m_pMsg, m_iConstructionPoint - sV1);
					SetTopMsg(G_cTxt, 5);
					PlaySound('E', 25, 0, 0);
				}
			}

			if (sV2 < m_iWarContribution) {
				// 전쟁 공헌도가 하락했다.
				wsprintf(G_cTxt, "%s -%d", m_pGameMsgList[21]->m_pMsg, m_iWarContribution - sV2);
				SetTopMsg(G_cTxt, 5);
				PlaySound('E', 24, 0, 0);
			}
		}

		m_iConstructionPoint = sV1;
		m_iWarContribution   = sV2;
		break;
	
	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
		// 더이상 크루세이드용 건축물을 지을 수 없다.
		SetTopMsg(m_pGameMsgList[12]->m_pMsg, 5);
		PlaySound('E', 25, 0, 0);
		break;

	case DEF_NOTIFY_GRANDMAGICRESULT:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		wp  = (WORD *)cp;
		sV1 = *wp;
		cp += 2;

		wp  = (WORD *)cp;
		sV2 = *wp;
		cp += 2;

		wp  = (WORD *)cp;
		sV3 = *wp;
		cp += 2;

		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, cp, 10);
		cp += 10;

		wp  = (WORD *)cp;
		sV4 = *wp;
		cp += 2;

		// v2.15 건물의 HP를 보여주기 위한 루틴 추가
		wp  = (WORD *)cp; 
		sV5 = *wp;  // 건물의 갯수 
		cp += 2;
		
		// 건물의 갯수 0 보다 크면 건물의 HP를 받는다.
		if (sV5  > 0 ) {
			wp  = (WORD *)cp;
			sV6 = *wp;
			cp += 2;
			sV5-- ;
		}
		else sV6 = 0 ;

		if ( sV5  > 0 ) {
			wp  = (WORD *)cp;
			sV7 = *wp;
			cp += 2;
			sV5-- ;
		}
		else sV7 = 0 ;

		if ( sV5  > 0 ) {
			wp  = (WORD *)cp;
			sV8 = *wp;
			cp += 2;
			sV5-- ;
		}
		else sV8 = 0 ;

		if ( sV5  > 0 ) {
			wp  = (WORD *)cp;
			sV9 = *wp;
			cp += 2;
			sV5-- ;
		}
		else sV9 = 0 ;

		GrandMagicResult(cTxt, sV1, sV2, sV3, sV4, sV6, sV7, sV8, sV9);
		break;
	
	case DEF_NOTIFY_METEORSTRIKECOMING:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		sV1 = *wp;
		cp += 2;
		MeteorStrikeComing(sV1);
		PlaySound('E', 25, 0, 0);
		break;

	case DEF_NOTIFY_METEORSTRIKEHIT:
		SetTopMsg(m_pGameMsgList[17]->m_pMsg, 5);
		//StartMeteorStrikeEffect
		for( i=0 ; i<36 ; i++ ) bAddNewEffect(60, m_sViewPointX +(rand() % 640), m_sViewPointY +(rand() % 480), NULL, NULL, -(rand() % 80));
		break;
	
	case DEF_NOTIFY_MAPSTATUSNEXT:
		AddMapStatusInfo(pData, FALSE);
		break;

	case DEF_NOTIFY_MAPSTATUSLAST:
		AddMapStatusInfo(pData, TRUE);
		break;
	
	case DEF_NOTIFY_LOCKEDMAP:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;

		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, cp, 10);
		cp += 10;

		GetOfficialMapName(cTxt, cTemp);
		wsprintf( G_cTxt, NOTIFY_MSG_HANDLER3, sV1, cTemp );
		SetTopMsg(G_cTxt, 10);
		PlaySound('E', 25, 0, 0);
		break;

	case DEF_NOTIFY_CRUSADE:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		iV1 = *ip;
		cp += 4;

		ip = (int *)cp;
		iV2 = *ip;
		cp += 4;

		ip = (int *)cp;
		iV3 = *ip;
		cp += 4;

		ip = (int *)cp;
		iV4 = *ip;
		cp += 4;

		if (m_bIsCrusadeMode == FALSE) {
			// 클라이언트의 상태는 전면전 종료 상태.
			if (iV1 != 0) {
				// 전면전 크루세이드 모드 시작 
				m_bIsCrusadeMode = TRUE;
				m_iCrusadeDuty = iV2;

				// v2.15 전면전시 군인이나 건축가도 마나스톤의 위치를 알게 하기 위해 
                // 중립이나 길드 마스터는 필요 없다.
				if( (m_iCrusadeDuty != 3) && (m_bCitizen==TRUE) )
					_RequestMapStatus("middleland", 3);

				if (m_iCrusadeDuty != NULL)
					 EnableDialogBox(33, 2, iV2, NULL);
				else EnableDialogBox(33, 1, NULL, NULL);

				// 크루세이드가 시작되었음을 알리는 메시지를 출력한다.
				if( m_bCitizen == FALSE ) EnableDialogBox(18, 800, NULL, NULL);
				else if( m_bAresden == TRUE ) EnableDialogBox(18, 801, NULL, NULL);
				else if( m_bAresden == FALSE ) EnableDialogBox(18, 802, NULL, NULL);

				// 전면전 개시 톱 메시지 출력 
				// v2.15 전면전시 중립은 마을 못간다는 메세지를 상단에 뿌려준다.
				if (m_bCitizen == FALSE) SetTopMsg(NOTIFY_MSG_CRUSADESTART_NONE, 10);
				else SetTopMsg(m_pGameMsgList[9]->m_pMsg, 10);

				PlaySound('E', 25, 0, 0);
			}
			
			if (iV3 != 0) {
				// 전면전 종료에 따른 포상 내역이다.
				// 이 값이 양수이면 포상. 음수이면 패전으로 인한 포상 무효화를 의미. 
				CrusadeContributionResult(iV3);
			}

			if (iV4 == -1) {
				// 0이면 크루세이드 포상 기간 종료로 인하여 포상 불가.
				CrusadeContributionResult(0);
			}
		}
		else {
			// 클라이언트의 상태는 전면전 개시 상태 
			if (iV1 == 0) {
				// 전면전 종료
				m_bIsCrusadeMode = FALSE;
				m_iCrusadeDuty   = NULL;

				// 전면전에서 이긴 Side는 sV4
				CrusadeWarResult(iV4);
				SetTopMsg(m_pGameMsgList[57]->m_pMsg, 8); 
			}
			else {
				// 전면전 역할이 부여되었다. 
				if (m_iCrusadeDuty != iV2) {
					// 역할이 변경되었다.
					m_iCrusadeDuty = iV2;
					EnableDialogBox(33, 2, iV2, NULL);
					PlaySound('E', 25, 0, 0);
				}
			}

			if (iV4 == -1) {
				// 0이면 크루세이드 포상 기간 종료로 인하여 포상 불가.
				CrusadeContributionResult(0);
			}
		}
		break;

	case DEF_NOTIFY_SPECIALABILITYSTATUS:
		// sV1은 작동 여부 
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;

		sp = (short *)cp;
		sV2 = *sp;
		cp += 2;

		sp = (short *)cp;
		sV3 = *sp;
		cp += 2;
		
		if (sV1 == 1) {
			// 특수 능력이 사용 되었다. sV2은 특수 능력 종류, sV3는 지속시간 
			PlaySound('E', 35, 0);
			AddEventList(NOTIFY_MSG_HANDLER4, 10);//"특수 능력을 사용합니다!"
			switch (sV2) {
			case 1: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER5,sV3); break;//"공격한 캐릭터의 HP를 50%%씩 감소시킵니다! 지속시간은 %d초 입니다."
			case 2: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER6, sV3); break;//"공격한 캐릭터를 냉동 시킵니다! 지속시간은 %d초 입니다."
			case 3: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER7, sV3); break;//"공격한 캐릭터를 마비 시킵니다! 지속시간은 %d초 입니다."
			case 4: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER8, sV3); break;//"공격한 캐릭터를 한번에 사망 시킵니다! 지속시간은 %d초 입니다."
			case 5: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER9, sV3); break;//"공격한 캐릭터에게 입힌 타격치 포인트 만큼의 HP를 얻습니다! 지속시간은 %d초 입니다."
			case 50:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER10, sV3); break;//"공격을 가한 캐릭터의 무기를 부숴 버립니다. 지속시간은 %d초 입니다!"
			case 51:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER11, sV3); break;//"특수 방어 아이템이 장착된 부분은 물리 공격을 받지 않습니다! 지속시간은 %d초 입니다."
			case 52:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER12, sV3); break;//"%d초동안 플레이어로부터 공격을 받지 않습니다!"
			}
			AddEventList(G_cTxt, 10);
		}
		else if (sV1 == 2) {
			// 특수 능력이 준비되었다. sV2은 특수 능력 종류, sV3는 사용 가능 시간 
			if (m_iSpecialAbilityType != (int)sV2) {
				// 설정된 능력과 다르면 메시지 출력
				PlaySound('E', 34, 0);
				AddEventList(NOTIFY_MSG_HANDLER13, 10);//"특수 능력이 설정되었습니다!"
				
				if (sV3 >= 60) {
					switch (sV2) {
					case 1: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER14, sV3/60); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터의 HP를 50%%씩 감소시키는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 2: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER15, sV3/60); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터를 냉동 시키는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 3: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER16, sV3/60); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터를 마비 시키는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 4: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER17, sV3/60); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터를 한번에 살상하는 특수 능력: 약 %분 후에 사용 가능합니다."
					case 5: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER18, sV3/60); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터에게 입힌 타격치 포인트 만큼의 HP를 얻는 특수 능력: 약 %분 후에 사용 가능합니다."
					case 50:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER19, sV3/60); AddEventList(G_cTxt, 10); break;//"공격을 가한 캐릭터의 무기를 부수는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 51:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER20, sV3/60); AddEventList(G_cTxt, 10); break;//"특수 방어 아이템이 장착된 부분은 물리 공격을 받지 않는 특수 능력: 약 %d분 후에 사용 가능합니다."
					case 52:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER21, sV3/60); AddEventList(G_cTxt, 10); break;//"일정 시간 동안 플레이어로부터 공격을 받지 않는 특수 능력: 약 %d분 후에 사용 가능합니다."
					}
				}
				else {
					switch (sV2) {
					case 1: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER22, sV3); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터의 HP를 50%%씩 감소시키는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 2: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER23, sV3); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터를 냉동 시키는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 3: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER24, sV3); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터를 마비 시키는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 4: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER25, sV3); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터를 한번에 살상하는 특수 능력: 약 %초 후에 사용 가능합니다."
					case 5: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER26, sV3); AddEventList(G_cTxt, 10); break;//"공격한 캐릭터에게 입힌 타격치 포인트 만큼의 HP를 얻는 특수 능력: 약 %초 후에 사용 가능합니다."
					case 50:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER27, sV3); AddEventList(G_cTxt, 10); break;//"공격을 가한 캐릭터의 무기를 부수는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 51:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER28, sV3); AddEventList(G_cTxt, 10); break;//"특수 방어 아이템이 장착된 부분은 물리 공격을 받지 않는 특수 능력: 약 %d초 후에 사용 가능합니다."
					case 52:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER29, sV3); AddEventList(G_cTxt, 10); break;//"일정 시간 동안 플레이어로부터 공격을 받지 않는 특수 능력: 약 %d초 후에 사용 가능합니다."
					}
				}
			}
			m_iSpecialAbilityType = (int)sV2;
			m_dwSpecialAbilitySettingTime = dwTime;
			m_iSpecialAbilityTimeLeftSec  = (int)sV3;
		}
		else if (sV1 == 3) {
			// 특수 능력의 지속 시간이 끝났다.
			m_bIsSpecialAbilityEnabled = FALSE;
			AddEventList(NOTIFY_MSG_HANDLER30, 10);//"특수 능력 사용 시간이 끝났습니다! 약 20분후에 사용이 가능해 집니다."

			m_dwSpecialAbilitySettingTime = dwTime;
			m_iSpecialAbilityTimeLeftSec  = 1200;
		}
		else if (sV1 == 4) {
			// 특수 능력의 설정이 해제되었다.
			AddEventList(NOTIFY_MSG_HANDLER31, 10);//"특수 능력 설정이 해제되었습니다."
			m_iSpecialAbilityType = 0;
		}
		break;

	case DEF_NOTIFY_SPECIALABILITYENABLED:
		// 특수 능력이 사용 가능해 졌다.
		if (m_bIsSpecialAbilityEnabled == FALSE) {
			PlaySound('E', 30, 5);
			// v1.4334 잘못된 표현 수정 
			AddEventList(NOTIFY_MSG_HANDLER32, 10);//"특수 능력을 사용할 수 있습니다!"
		}
		m_bIsSpecialAbilityEnabled = TRUE;
		break;
	
	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
		// sV1은 넣은 결과, sV2는 넣은 사람의 Side, sV3는 넣은 골의 Side 문자열은 골 넣은 사람 이름
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;

		sp = (short *)cp;
		sV2 = *sp;
		cp += 2;

		sp = (short *)cp;
		sV3 = *sp;
		cp += 2;
		
		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, cp, 20);

		if (sV2 == sV3) {
			// 골을 넣은 플레이어와 골의 사이드가 같다. 자살골
			PlaySound('E', 24, 0);
			if (strcmp(cTxt, m_cPlayerName) == 0) {
				// 본인이 자살골을 넣었다.
				AddEventList(NOTIFY_MSG_HANDLER33, 10);//"에너지 스피어를 적국의 에너지 포탈에 넣어 버렸습니다! 공헌도가 10 떨어집니다..."
				m_iContribution -= 10;
				if (m_iContribution < 0) m_iContribution = 0;
			}
			else {
				ZeroMemory(G_cTxt, sizeof(G_cTxt));
				if( m_bAresden == TRUE ) wsprintf(G_cTxt, NOTIFY_MSG_HANDLER34, cTxt);//"아레스덴 소속 %s: 에너지 스피어를 적국의 에너지 포탈에 넣어 버렸습니다..."
				else if (m_bAresden == FALSE) wsprintf(G_cTxt, NOTIFY_MSG_HANDLER34_ELV, cTxt);//"엘바인 소속 %s: 에너지 스피어를 적국의 에너지 포탈에 넣어 버렸습니다..."
				AddEventList(G_cTxt, 10);
			}
		}
		else {
			// 적국에 골이 들어갔다.
			PlaySound('E', 23, 0); 
			if (strcmp(cTxt, m_cPlayerName) == 0) {
				// 본인이 골을 넣었다.
				switch (m_sPlayerType) {
				case 1:
				case 2:
				case 3:	PlaySound('C', 21, 0); break;
				case 4:
				case 5:
				case 6:	PlaySound('C', 22, 0); break;
				}
				AddEventList(NOTIFY_MSG_HANDLER35, 10);//"축하합니다! 에너지 스피어를 에너지 포탈로 가져와 경험치와 공헌도 5포인트를 얻었습니다!"

				m_iContribution += 5;
				if (m_iContribution < 0) m_iContribution = 0;
			}
			else {
				ZeroMemory(G_cTxt, sizeof(G_cTxt));
				if (sV3 == 1) {
					// 골이 들어간 곳은 아레스덴 : 엘바인 플레이어가 골을 넣었다.
					wsprintf(G_cTxt, NOTIFY_MSG_HANDLER36, cTxt);//"엘바인 소속 %s : 에너지 스피어를 엘바인 국가 에너지 포탈에 넣었습니다!"
					AddEventList(G_cTxt, 10);
				}
				else if (sV3 == 2) {
					// 골이 들어간 곳은 엘바인 : 아레스덴 플레이어가 골을 넣었다.
					wsprintf(G_cTxt, NOTIFY_MSG_HANDLER37, cTxt);//"아레스덴 소속 %s : 에너지 스피어를 아레스덴 국가 에너지 포탈에 넣었습니다!"
					AddEventList(G_cTxt, 10);
				}
			}
		}
		break;
	
	case DEF_NOTIFY_ENERGYSPHERECREATED:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;

		sp = (short *)cp;
		sV2 = *sp;
		cp += 2;

		wsprintf(G_cTxt, NOTIFY_MSG_HANDLER38, sV1, sV2);//"에너지 스피어가 좌표(%d, %d)에 생성되었습니다!"
		AddEventList(G_cTxt, 10);
		AddEventList(NOTIFY_MSG_HANDLER39, 10);//"에너지 스피어를 소속 국가의 에너지 포탈에 넣은 플레이어는 많은 경험치와 공헌도를 얻을 수 있습니다."
		break;
	
	case DEF_NOTIFY_QUERY_JOINPARTY: // 파티에 가입하겠다고 물어 봤다.
		EnableDialogBox(32, NULL, NULL, NULL);
		m_stDialogBoxInfo[32].cMode = 1;

		ZeroMemory(m_stDialogBoxInfo[32].cStr, sizeof(m_stDialogBoxInfo[32].cStr));
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		strcpy(m_stDialogBoxInfo[32].cStr, cp);
		break;
	
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;

		if ((BOOL)*sp == TRUE) {
			// 파티 생성에 성공했다.
			m_stDialogBoxInfo[32].cMode = 2;
		}
		else {
			// 파티 생성에 실패했다.
			m_stDialogBoxInfo[32].cMode = 3;
		}
		break;
	
	case DEF_NOTIFY_DAMAGEMOVE:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		m_sDamageMove = *sp;
		cp += 2;

		sp = (short *)cp;
		m_sDamageMoveAmount = *sp;
		cp += 2;
		break;
	
	case DEF_NOTIFY_OBSERVERMODE:
		
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		if (*sp == 1) {
			AddEventList(NOTIFY_MSG_HANDLER40);//"Observer Mode On. Press 'SHIFT + ESC' to Log Out..."  
			m_bIsObserverMode = TRUE;
			m_dwObserverCamTime = timeGetTime();
			// 플레이어를 맵에서 제거해야 한다.
			char cName[12];
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, m_cPlayerName, 10);
			m_pMapData->bSetOwner(m_sPlayerObjectID, -1, -1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, cName, NULL, NULL, NULL, NULL);
		}
		else {
			AddEventList(NOTIFY_MSG_HANDLER41);//"Observer Mode Off"
			m_bIsObserverMode = FALSE;
			// 플레이어를 맵에 설치한다.
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, m_sPlayerStatus, m_cPlayerName, DEF_OBJECTSTOP, NULL, NULL, NULL);
		}
		break;
	
	case DEF_NOTIFY_BUILDITEMSUCCESS:
		DisableDialogBox(26);
		
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;

		sp = (short *)cp;
		sV2 = *sp;
		cp += 2;
							
		if (sV1 < 10000) {
			// 아이템 가중치 양수 
			EnableDialogBox(26, 6, 1, sV1, NULL);
			m_stDialogBoxInfo[26].sV1 = sV2;		// 아이템의 성질을 입력 
		}
		else {
			// 아이템 가중치 음수 
			EnableDialogBox(26, 6, 1, -1*(sV1 - 10000), NULL);
			m_stDialogBoxInfo[26].sV1 = sV2;
		}

		
		AddEventList(NOTIFY_MSG_HANDLER42, 10);//"아이템 제작에 성공하였습니다!"
		PlaySound('E', 23, 5);
		
		// 성공한 감탄사!
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;

		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
		break;

	case DEF_NOTIFY_BUILDITEMFAIL:
		DisableDialogBox(26);
		EnableDialogBox(26, 6, 0, NULL);
		AddEventList(NOTIFY_MSG_HANDLER43, 10);
		             //"아이템 제작에 실패하였습니다." 
		PlaySound('E', 24, 5);
		break;
	
	case DEF_NOTIFY_QUESTREWARD:
		NotifyMsg_QuestReward(pData);
		break;
	
	case DEF_NOTIFY_QUESTCOMPLETED:
		m_stQuest.bIsQuestCompleted = TRUE;
		DisableDialogBox(28);
		EnableDialogBox(28, 1, NULL, NULL);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:	PlaySound('C', 21, 0); break;
		case 4:
		case 5:
		case 6:	PlaySound('C', 22, 0); break;
		}
		PlaySound('E', 23, 0); 
		AddEventList(NOTIFY_MSG_HANDLER44, 10);//"축하합니다! 당신의 퀘스트를 완수했습니다!"
		break;
	
	case DEF_NOTIFY_QUESTABORTED:
		m_stQuest.sQuestType = NULL;
		DisableDialogBox(28);
		EnableDialogBox(28, 2, NULL, NULL);
		break;

	case DEF_NOTIFY_QUESTCONTENTS:
		NotifyMsg_QuestContents(pData);
		break;
	
	case DEF_NOTIFY_ITEMCOLORCHANGE:
		NotifyMsg_ItemColorChange(pData);
		break;
	
	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
		NotifyMsg_DropItemFin_CountChanged(pData);
		break;
	
	case DEF_NOTIFY_CANNOTGIVEITEM:
		NotifyMsg_CannotGiveItem(pData);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		NotifyMsg_GiveItemFin_CountChanged(pData);
		break;
	
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
		AddEventList(NOTIFYMSG_EXCHANGEITEM_COMPLETE1, 10);//"아이템을 교환했습니다!"
		DisableDialogBox(27);
		PlaySound('E', 23, 5);
		break;
	
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
		PlaySound('E', 24, 5);
		AddEventList(NOTIFYMSG_CANCEL_EXCHANGEITEM1, 10);//"아이템 교환이 취소되었습니다!"
		AddEventList(NOTIFYMSG_CANCEL_EXCHANGEITEM2, 10);//"상대방이 교환을 취소했거나 교환할 수 있는 상황이 되지 않는 경우입니다."
		DisableDialogBox(27);
		break;
	
	case DEF_NOTIFY_SETEXCHANGEITEM:
		NotifyMsg_SetExchangeItem(pData);
		break;
	
	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		NotifyMsg_OpenExchageWindow(pData);
		break;
		
	case DEF_NOTIFY_NOTFLAGSPOT:
		AddEventList(NOTIFY_MSG_HANDLER45, 10);//"지정된 위치에 깃발을 설치할 수 없습니다!"
		break;
	
	case DEF_NOTIFY_ITEMPOSLIST:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		for (i = 0; i < DEF_MAXITEMS; i++) {
			sp = (short *)cp;
			sX = *sp;
			cp += 2;
			sp = (short *)cp;
			sY = *sp;
			cp += 2;
			if (m_pItemList[i] != NULL) {
				if (sY < -10) sY = -10;
				if (sX < 0)   sX = 0;
				if (sX > 170) sX = 170;
				if (sY > 95)  sY = 95;
							
				m_pItemList[i]->m_sX = sX;
				m_pItemList[i]->m_sY = sY;
			}
		}
		break;
	
	case DEF_NOTIFY_ENEMYKILLS:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		m_iEnemyKillCount = *ip;
		break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
		NotifyMsg_DownSkillIndexSet(pData);
		break;

	case DEF_NOTIFY_ADMINIFO:
		NotifyMsg_AdminInfo(pData);
		break;
	
	case DEF_NOTIFY_NPCTALK:
		NpcTalkHandler(pData);
		break;
	
	case DEF_NOTIFY_PORTIONSUCCESS:
		AddEventList(NOTIFY_MSG_HANDLER46, 10);//"시약 제조에 성공하였습니다!"
		break;
	
	case DEF_NOTIFY_PORTIONFAIL:
		AddEventList(NOTIFY_MSG_HANDLER47, 10);//"시약 제조에 실패하였습니다!"
		break;

	case DEF_NOTIFY_LOWPORTIONSKILL:
		AddEventList(NOTIFY_MSG_HANDLER48, 10);//"연금술 수준이 낮아 시약을 만들 수 없습니다."
		break;

	case DEF_NOTIFY_NOMATCHINGPORTION:
		AddEventList(NOTIFY_MSG_HANDLER49, 10);//"현재 재료의 조합으로 만들 수 있는 시약이 없습니다."
		break;
	
	case DEF_NOTIFY_SUPERATTACKLEFT:
		sp = (short *)(pData + DEF_INDEX2_MSGTYPE + 2);
		m_iSuperAttackLeft = (int)*sp;
		break;
	
	case DEF_NOTIFY_SAFEATTACKMODE:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		switch (*cp) {
		case 1:
			if(!m_bIsSafeAttackMode) AddEventList(NOTIFY_MSG_HANDLER50, 10);//"안전 공격 모드가 활성화 되었습니다."
			m_bIsSafeAttackMode = TRUE;
			break;
		case 0:
			if(m_bIsSafeAttackMode) AddEventList(NOTIFY_MSG_HANDLER51, 10);//"안전 공격 모드가 비활성화 되었습니다."
			m_bIsSafeAttackMode = FALSE;
			break;
		}
		break;
	
	case DEF_NOTIFY_IPACCOUNTINFO:
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		strcpy(cTemp, cp);
		AddEventList(cTemp);
		break;
	
	case DEF_NOTIFY_REWARDGOLD:
		dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
		m_iRewardGold = *dwp;
		break;
	
	case DEF_NOTIFY_SERVERSHUTDOWN:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		if (m_bIsDialogEnabled[25] == FALSE)
			 EnableDialogBox(25, *cp, NULL, NULL);
		else m_stDialogBoxInfo[25].cMode = *cp;
		PlaySound('E', 27, NULL);
		break;
	
	case DEF_NOTIFY_GLOBALATTACKMODE:
		NotifyMsg_GlobalAttackMode(pData);
		break;

	case DEF_NOTIFY_WHETHERCHANGE:
		NotifyMsg_WhetherChange(pData);
		break;
	
	case DEF_NOTIFY_FISHCANCELED:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		wp = (WORD *)cp;
		switch (*wp) {
		case NULL:
			AddEventList(NOTIFY_MSG_HANDLER52, 10);//"움직이거나 방해를 받아 더이상 낚시를 할 수 없습니다!"
			DisableDialogBox(24);
			break;

		case 1:
			AddEventList(NOTIFY_MSG_HANDLER53, 10);//"다른 플레이어가 먼저 물고기를 낚아 버렸습니다! 아쉽군요..."
			DisableDialogBox(24);
			break;

		case 2:
			AddEventList(NOTIFY_MSG_HANDLER54, 10);//"물고기가 사라져버려 더이상 낚시를 할 수 없습니다!"
			DisableDialogBox(24);
			break;
		}
		break;
	
	case DEF_NOTIFY_FISHSUCCESS:
		AddEventList(NOTIFY_MSG_HANDLER55, 10);//"낚시 성공!!!" 		
		PlaySound('E', 23, 5);
		PlaySound('E', 17, 5);
		// 낚시를 성공한 감탄사!
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;

		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
		break;

	case DEF_NOTIFY_FISHFAIL:
		AddEventList(NOTIFY_MSG_HANDLER56, 10);//"낚시 실패!!!"
		PlaySound('E', 24, 5);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		NotifyMsg_FishChance(pData);
		break;
	
	case DEF_NOTIFY_EVENTFISHMODE:
		NotifyMsg_EventFishMode(pData);
		break;
	
	case DEF_NOTIFY_NOTICEMSG:
		NotifyMsg_NoticeMsg(pData);
		break;
	
	case DEF_NOTIFY_RATINGPLAYER:
		NotifyMsg_RatingPlayer(pData);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		NotifyMsg_CannotRating(pData);
		break;
	
	case DEF_NOTIFY_ADMINUSERLEVELLOW:
		//AddEventList(NOTIFY_MSG_HANDLER58, 10);//"관리자 명령을 사용할 권한이 없습니다."
		break;

	// v1.4311-3 추가 길드 마스터가 아닌 유저가 길드마스터 명령을 사용하는 경우. 
	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
		AddEventList(NOTIFY_MSG_HANDLER59, 10);//"길드 마스터 명령을 사용할 권한이 없습니다."
		break;
	// v1.4311-3 추가 길드 마스터가 길드원 추방에 성공 
	case DEF_NOTIFY_SUCCESSBANGUILDMAN:
		AddEventList(NOTIFY_MSG_HANDLER60, 10);//"길드원을 길드에서 추방하는데 성공했습니다."
		break;
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		AddEventList(NOTIFY_MSG_HANDLER61, 10);//"당신의 길드원이 아닙니다."
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		NotifyMsg_PlayerShutUp(pData);
		break;
	
	case DEF_NOTIFY_TIMECHANGE:
		NotifyMsg_TimeChange(pData);
		break;
	
	case DEF_NOTIFY_TOBERECALLED:
		AddEventList(NOTIFY_MSG_HANDLER62, 10);//"머물 수 있는 시간이 다 되어 리콜됩니다."
		break;

	case DEF_NOTIFY_HUNGER:
		NotifyMsg_Hunger(pData);
		break;
		
	case DEF_NOTIFY_PLAYERPROFILE:
		NotifyMsg_PlayerProfile(pData);
		break;

	case DEF_NOTIFY_WHISPERMODEON:
		NotifyMsg_WhisperMode(TRUE, pData);
		break;

	case DEF_NOTIFY_WHISPERMODEOFF:
		NotifyMsg_WhisperMode(FALSE, pData);
		break;
 
	case DEF_NOTIFY_PLAYERONGAME:
		NotifyMsg_PlayerStatus(TRUE, pData);
		break;
	
	case DEF_NOTIFY_PLAYERNOTONGAME:
		NotifyMsg_PlayerStatus(FALSE, pData);
		break;

	case DEF_NOTIFY_CHARISMA:
		NotifyMsg_Charisma(pData);
		break;
	
	case DEF_NOTIFY_ITEMSOLD:
		DisableDialogBox(23);
		break;
	
	case DEF_NOTIFY_ITEMREPAIRED:
		DisableDialogBox(23);
		NotifyMsg_ItemRepaired(pData);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
		NotifyMsg_CannotRepairItem(pData);
		break;
	
	case DEF_NOTIFY_CANNOTSELLITEM:
		NotifyMsg_CannotSellItem(pData);
		break;
	
	case DEF_NOTIFY_REPAIRITEMPRICE:
		NotifyMsg_RepairItemPrice(pData);
		break;

	case DEF_NOTIFY_SELLITEMPRICE:
		NotifyMsg_SellItemPrice(pData);
		break;
	
	case DEF_NOTIFY_SHOWMAP:
		NotifyMsg_ShowMap(pData);
		break;
	
	case DEF_NOTIFY_SKILLUSINGEND:
		NotifyMsg_SkillUsingEnd(pData);
		break;
	
	case DEF_NOTIFY_TOTALUSERS:
		NotifyMsg_TotalUsers(pData);
		break;

	case DEF_NOTIFY_MAGICEFFECTOFF:
		NotifyMsg_MagicEffectOff(pData);
		break;

	case DEF_NOTIFY_MAGICEFFECTON:
		NotifyMsg_MagicEffectOn(pData);
		break;

	case DEF_NOTIFY_CANNOTITEMTOBANK:
		AddEventList(NOTIFY_MSG_HANDLER63, 10);//"더 이상 아이템을 보관할 수 없습니다."
		break;

	case DEF_NOTIFY_SERVERCHANGE:
		NotifyMsg_ServerChange(pData);
		break;
	
	case DEF_NOTIFY_SKILL:
		NotifyMsg_Skill(pData);
		break;
	
	case DEF_NOTIFY_SETITEMCOUNT:
		NotifyMsg_SetItemCount(pData);
		break;
	
	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		NotifyMsg_ItemDepleted_EraseItem(pData);
		break;
	
	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		NotifyMsg_DropItemFin_EraseItem(pData);
		break;
	
	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		NotifyMsg_GiveItemFin_EraseItem(pData);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		NotifyMsg_EnemyKillReward(pData);
		break;
	
	case DEF_NOTIFY_PKCAPTURED:
		NotifyMsg_PKcaptured(pData);
		break;
	
	case DEF_NOTIFY_PKPENALTY:
		NotifyMsg_PKpenalty(pData);
		break;

	case DEF_NOTIFY_ITEMTOBANK:
		NotifyMsg_ItemToBank(pData);
		break;
	
	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
		AddEventList(NOTIFY_MSG_HANDLER64, 10);//"여행자 신분으로는 레벨 19이상 성장할 수 없습니다. 시청에서 시민권을 획득하십시오."
		break;

	case DEF_NOTIFY_LIMITEDLEVEL:
		AddEventList(NOTIFYMSG_LIMITED_LEVEL1, 10);//"체험판 사용자는 더 이상의 경험치를 얻을 수 없습니다!"
		break;

	case DEF_NOTIFY_ITEMLIFESPANEND:
		NotifyMsg_ItemLifeSpanEnd(pData);
		break;

	case DEF_NOTIFY_ITEMRELEASED:
		NotifyMsg_ItemReleased(pData);
		break;

	case DEF_NOTIFY_ITEMOBTAINED:
		NotifyMsg_ItemObtained(pData);
		break;

	case DEF_NOTIFY_ITEMPURCHASED:
		NotifyMsg_ItemPurchased(pData);
		break;
	
	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
		NotifyMsg_QueryJoinGuildPermission(pData);
		break;

	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
		NotifyMsg_QueryDismissGuildPermission(pData);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		NotifyMsg_JoinGuildApprove(pData);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:
		NotifyMsg_JoinGuildReject(pData);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		NotifyMsg_DismissGuildApprove(pData);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		NotifyMsg_DismissGuildReject(pData);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		AddEventList(NOTIFY_MSG_HANDLER65, 10);//"더이상 아이템을 소지할 수 없습니다."
		AddEventList(NOTIFY_MSG_HANDLER66, 10);//" 아이템을 소지할 공간이 없거나 한계중량을 초과합니다."
		// Bank dialog Box의 상태를 변환시킨다.
		m_stDialogBoxInfo[14].cMode = 0;
		break;

	case DEF_NOTIFY_NOTENOUGHGOLD:
		DisableDialogBox(23);
		AddEventList(NOTIFY_MSG_HANDLER67, 10);//"Gold가 부족합니다."
		// 수리를 시도한 아이템을 활성화 시킨다. 
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		if (*cp >= 0) {
			m_bIsItemDisabled[*cp] = FALSE;
		}
		break;

	case DEF_NOTIFY_HP:
		NotifyMsg_HP(pData);
		break;
	case DEF_NOTIFY_MP:
		NotifyMsg_MP(pData);
		break;
	case DEF_NOTIFY_SP:
		NotifyMsg_SP(pData);
		break;
	case DEF_NOTIFY_LEVELUP:
		NotifyMsg_LevelUp(pData);
		break;
	case DEF_NOTIFY_KILLED:
		NotifyMsg_Killed(pData);
		break;
	case DEF_NOTIFY_EXP:
		NotifyMsg_Exp(pData);
		break;
	case DEF_NOTIFY_GUILDDISBANDED:
		NotifyMsg_GuildDisbanded(pData);
		break;
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
		NotifyMsg_CannotJoinMoreGuildsMan(pData);
		break;
	case DEF_NOTIFY_NEWGUILDSMAN:
		NotifyMsg_NewGuildsMan(pData);
		break;
	case DEF_NOTIFY_DISMISSGUILDSMAN:
		NotifyMsg_DismissGuildsMan(pData);
		break;
	case DEF_NOTIFY_MAGICSTUDYSUCCESS:
		// 새로운 마법을 배웠다. 
		NotifyMsg_MagicStudySuccess(pData);
		break;
	case DEF_NOTIFY_MAGICSTUDYFAIL:
		// 마법을 배우는데 실패했다. 
		NotifyMsg_MagicStudyFail(pData);
		break;
	case DEF_NOTIFY_SKILLTRAINSUCCESS:
		// 새로운 기술을 익혔다. 
		NotifyMsg_SkillTrainSuccess(pData);
		break;
	case DEF_NOTIFY_SKILLTRAINFAIL:
		// 기술을 익히는데 실패했다. 
		break;
	case DEF_NOTIFY_FORCEDISCONN:
		NotifyMsg_ForceDisconn(pData);
		break;
	//v1.4311-3 추가  메세지 처리  시간이 지나 사투장 예약이 취소됨 case DEF_NOTIFY_FIGHTZONERESERVE
	case DEF_NOTIFY_FIGHTZONERESERVE:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		switch (*ip) {
		case -5:
			AddEventList(NOTIFY_MSG_HANDLER68, 10);//" 사투장 강제 리콜모드가 취소되었습니다."
			break;
		case -4:
			AddEventList(NOTIFY_MSG_HANDLER69, 10);//" 사투장 강제 리콜모드가 설정되었습니다."  
			break;
		case -3:
			AddEventList(NOTIFY_MSG_HANDLER70, 10);//" 운영자가 예약한 사투장의 예약을 취소하였습니다."
			break;
		case -2:
			m_iFightzoneNumber = 0;
			AddEventList(NOTIFY_MSG_HANDLER71, 10);//" 사투장 예약시간이 지나 사투장 예약이 취소되었습니다."
			break;
		case -1:
			m_iFightzoneNumber = m_iFightzoneNumber * -1 ;
			AddEventList(NOTIFY_MSG_HANDLER72, 10);//" 입장권을 모두 다 받으셨습니다."
			break;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
			wsprintf(cTxt, NOTIFY_MSG_HANDLER73, *ip);//" %d번 사투장 예약에 성공하였습니다."			
			AddEventList(cTxt, 10);
			break;

		}
		break;
	}
}



// v1.4311-3 변경 사투장 예약에 대한 응답 처리 함수 CGame::ReserveFightzoneResponseHandler
void CGame::ReserveFightzoneResponseHandler(char * pData)
{
 	WORD * wpResult;	
	char * cp ;
	int * ip ;
 	wpResult = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

	// 사투장 예약에 대한 응답이 왔다.
	switch (*wpResult) {
	case DEF_MSGTYPE_CONFIRM:
		// 성공했다. 
		AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER1, 10);
		             //"사투장 예약이 이루어 졌습니다!"
		m_stDialogBoxInfo[7].cMode = 14;
		m_iFightzoneNumber = m_iFightzoneNumberTemp ;
		break;

	case DEF_MSGTYPE_REJECT:
		// 실패했다.
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ip   = (int *)cp;
		cp += 4;
		AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER2, 10);
		             //"사투장 예약에 실패 했습니다."
		m_iFightzoneNumberTemp = 0 ;

		if (*ip == 0) {
			// 사투장이 예약 가능한 시간이 아니다.
		 	m_stDialogBoxInfo[7].cMode = 15;
		}else if (*ip == -1){
			//  사투장이 예약 되어 있다.
			m_stDialogBoxInfo[7].cMode = 16; 
		} else if (*ip == -2) { 
			// 플레이어가 갖고있는 Gold가 입장권 가격에 비해 적다.
			m_stDialogBoxInfo[7].cMode = 17; 	 
		}else if (*ip == -3) { 
			// 오늘 사용이 불가능한 사투장이다.
			m_stDialogBoxInfo[7].cMode = 21; 	 
		}else if (*ip == -4) { 
			// 이미 다른곳의 사투장을 예약했다.
			m_stDialogBoxInfo[7].cMode = 22; 	 
		}
		break;
	}
}

void CGame::UpdateScreen_OnLogResMsg()
{
 short msX, msY, msZ, sX, sY;
 char  cLB, cRB;
 DWORD dwTime = timeGetTime();
 static DWORD dwCTime;
 static class CMouseInterface * pMI;
 int   iMIbuttonNum;
 char  cMIresult;


	if (m_cGameModeCount == 0) {
		pMI = new class CMouseInterface;
		pMI->AddRect(370, 240, 370 + DEF_BTNSZX, 240 + DEF_BTNSZY);
		
		m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
		m_cArrowPressed = 0;
		dwCTime = timeGetTime();

		// 비소리 루핑 스톱 
		if (m_bSoundFlag) m_pESound[38]->bStop();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE || m_bEnterPressed) {
		switch (m_cMsg[0]) {
		case '0':
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
			break;
		case '1':
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			break;
		case '2':
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			break;
		case '3':
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			break;
		case '4':
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			break;
		case '5':
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			break;
		case '6':
			switch (m_cMsg[1]) {
			case 'B':
				#ifdef DEF_JAPAN_FOR_TERRA
					ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
				#else
					ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				#endif
				break;
			case 'C': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
			case 'M': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
			}
			break;
		case '7':
		case '8':
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
			break;
		}
		
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);

	m_DDraw.ClearBackB4();
	
	switch (m_cMsg[0]) {
	case '0':
	case '5':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;

	case '1':
	case '7':
		sX = 146; 
		sY = 114;
		
		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;
	
	case '2':
	case '4':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;

	case '3':
		sX = 0;
		sY = 0;
		UpdateScreen_OnSelectCharacter(sX, sY, 0, 0);
		break;

	case '6':
		sX = 146; 
		sY = 114;	

		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, TRUE);
		break;
	case '8':
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, -1, -1, 0, TRUE);
		break;
	}

	m_DDraw.DrawShadowBox(0,0,639,479);
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);
	
	if ((msX >= 370) && (msX <= 370 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY)) 	
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 0);

	switch (m_cMsg[1]) {
	case '1':		
		PutString_SprFont(172 + 70, 165, "Password is not correct!", 7,0,0); 
		PutAlignedString(198, 453, 195, UPDATE_SCREEN_ON_LOG_MSG5);//"패스워드가 정확하지 않습니다."
		break;

	case '2':		
		PutString_SprFont(172 + 70, 165, "Not existing account!", 7,0,0);
		PutAlignedString(198, 453, 195, UPDATE_SCREEN_ON_LOG_MSG6);//"존재하지 않는 계정입니다."
		PutAlignedString(198, 453, 215, UPDATE_SCREEN_ON_LOG_MSG7);//"계정이름을 확인하십시오."		
		break;

	case '3':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG8);//"게임서버가 동작하고 있지 않아 접속이" 
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG9);//"불가능한 상태입니다. 잠시 후에 다시"
		PutAlignedString(198, 453, 225,  UPDATE_SCREEN_ON_LOG_MSG10);//"시도해 보십시오."		
		break;

	case '4':
		PutString_SprFont(172 + 58, 165, "New account created.", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG11);//"새로운 계정이 만들어졌습니다."
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG12);//"새로 만든 계정으로 로그인 할 수 있습니다."		
		break;

	case '5':
		PutString_SprFont(172 + 58, 165, "Can not create new account!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG13);//"계정을 만들수 없습니다."		
		break;

	case '6':
		PutString_SprFont(172 + 36, 165, "Can not create new account!", 7,0,0);
		PutString_SprFont(172 + 24, 180, "Already existing account name.", 7,0,0);
		PutAlignedString(198, 453, 205,  UPDATE_SCREEN_ON_LOG_MSG14);//"이미 존재하는 계정 이름입니다."
		PutAlignedString(198, 453, 220,  UPDATE_SCREEN_ON_LOG_MSG15);//"다른 계정 이름을 입력하여 주십시오."		
		break;

	case '7':
		PutString_SprFont(172 + 58, 165, "New character created.", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG16);//"새로운 캐릭터가 만들어졌습니다."		
		break;

	case '8':
		PutString_SprFont(172 + 58, 165, "Can not create new character!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG17);//"캐릭터를 만들 수 없습니다."
		break;

	case '9':
		PutString_SprFont(172 + 36, 165, "Can not create new character!", 7,0,0);
		PutString_SprFont(172 + 24, 180, "Already existing character name.", 7,0,0);
		PutAlignedString(198, 453, 205,  UPDATE_SCREEN_ON_LOG_MSG18);//"이미 존재하는 캐릭터 이름입니다."
		PutAlignedString(198, 453, 220,  UPDATE_SCREEN_ON_LOG_MSG19);//"다른 캐릭터 이름을 입력하여 주십시오."		
		break;

	case 'A':
		PutString_SprFont(172 + 36 +45, 165, "Character deleted.", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG20);//"캐릭터가 성공적으로 삭제되었습니다."
		
		break;
	case 'B':
		PutString_SprFont(172 + 36 +45, 165, "Password changed.", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG21);//"패스워드가 성공적으로 변경되었습니다."
		break;
	case 'C':
		PutString_SprFont(172 + 36, 165, "Can not change password!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG22);//"패스워드를 바꿀수 없습니다."
		break;

	case 'D':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG23);//"계정과 캐릭터의 정보가 달라 접속이 불가능"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG24);//"합니다. 관리자에게 문의하십시오."
		break;

	case 'E':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG25);//"개인계정을 등록하지 않은 체험판 레벨 이상의"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG26);//"캐릭터는 접속할 수 없습니다. 등록된 IP에서"
		PutAlignedString(198, 453, 225,  UPDATE_SCREEN_ON_LOG_MSG27);//"접속하거나 개인계정등록이 필요합니다."
		break;

	case 'F':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG28);//"현재 등록된 IP 주소군에 할당된 최대사용자를"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG29);//"초과하여 접속할 수 없습니다."
		break;

	case 'G':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG30);//"현재 게임 서버가 셧다운중이라 접속할 수 없습"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG31);//"니다. 서버가 재부팅 된 후에 접속해 주십시오."
		break;

	case 'H':		
		PutString_SprFont(172 + 68, 165, "Connection Rejected!", 7,0,0);
		if (m_iBlockYear == 0) {
			PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG32);//"계정이 임시로 블록된 상태입니다."
			PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG33);//"잠시후에 다시 접속을 시도해 주십시오."
		}
		else {
			PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG34);//"계정이 블록되어 접속할 수 없습니다."
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_LOG_MSG35, m_iBlockYear, m_iBlockMonth, m_iBlockDay);//"블록된 기간: %d년 %d월 %d일 까지"
			PutAlignedString(198, 453, 210,  G_cTxt);
		}
		
		break;

	case 'I': // v2.11 성후니 추가 중문 과금용 에라 메세지 글씨 깨져 있어도 안심할것 ㅡㅡ ;		
		PutString_SprFont(172 + 68, 165, "Not Enough Point!", 7,0,0);	
		PutAlignedString(198, 453, 210,  "I셕ⓒΞ늑w뎡, 싻╁GD2S.gamania.com㈄敗嘔灌젱");
	
		break; 

	case 'J': // v2.15 2002-5-21		
		PutString_SprFont(172 + 68, 165, "World Server Full", 7,0,0);
		PutAlignedString(198, 453, 210,  "Please ! Try Other World Server");
		break; 

	case 'M': 	// v2.18 인터네셔널 서버 강제 패스워드 변경	
		PutString_SprFont(172 + 68, 165, "Your password expired", 7,0,0);
		PutAlignedString(198, 453, 210,  "Please! Change password");
		break; 


	case 'U': // v2.15 상하추가 중국 과금용 에라 메세지		
		PutString_SprFont(172 + 68, 165, "Keycode input Success!", 7,0,0);	
		PutAlignedString(198, 453, 210,  "Keycode Registration successed.");
	
		break; 

	case 'X':		
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG38);//"현재 계정의 접속 종료를 요청하였습니다."
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG39);//"잠시 후에 다시 접속을 시도해 주십시오." 		
		break;

	case 'Y':		
		PutAlignedString(178, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG40);//"현재 월드 서버가 작동중이 아닙니다."
		PutAlignedString(178, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG41);//"잠시 후에 다시 접속을 시도해 주십시오."  
		break;

	case 'Z':
		PutAlignedString(178, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG42);//"서버의 최대 사용자를 초과하였습니다."     
		PutAlignedString(178, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG41);//"잠시 후에 다시 접속을 시도해 주십시오."		
		break;

#if DEF_LANGUAGE == 3
	case 'a':
		PutAlignedString(190, 460, 165,  UPDATE_SCREEN_ON_LOG_MSG43, 200,200,45);//"* 부정확한 주민등록번호 소지 *"
		PutAlignedString(190, 460, 195,  UPDATE_SCREEN_ON_LOG_MSG44, 200,200,45);//"본 계정은 부정확한 주민등록번호 갖고있습니다."
		PutAlignedString(190, 460, 210,  UPDATE_SCREEN_ON_LOG_MSG45, 200,200,45);//"운영팀으로 연락주시면 감사하겠습니다."
		PutAlignedString(190, 460, 225,  UPDATE_SCREEN_ON_LOG_MSG46, 200,200,45);//"(02-3424-4582~3)"
		break;

	case 'b':
		PutAlignedString(190, 460, 165,  UPDATE_SCREEN_ON_LOG_MSG47, 200,200,45);//"* 만15세 미만의 계정 *"
		PutAlignedString(190, 460, 185,  UPDATE_SCREEN_ON_LOG_MSG48, 200,200,45);//"영상물등급위원회의 결정에 따라 본게임은,"
		PutAlignedString(190, 460, 200,  UPDATE_SCREEN_ON_LOG_MSG49, 200,200,45);//" 만 15세 미만의 사용자는 할 수 없습니다."
		PutAlignedString(190, 460, 215,  UPDATE_SCREEN_ON_LOG_MSG50, 200,200,45);//"이미 결재한 과금에 대한 보상은 운영팀으로"
		PutAlignedString(190, 460, 230,  UPDATE_SCREEN_ON_LOG_MSG51, 200,200,45);//"연락주시기 바랍니다.(02-3424-4582~3)"
		break;
#endif

	}

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스 버튼이 클릭되었다.
		switch (iMIbuttonNum) {
		case 1:
			switch (m_cMsg[0]) {
			case '0':
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
				break;
			case '1':
				#ifdef DEF_JAPAN_FOR_TERRA
					ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
				#else
					ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				#endif
				break;
			case '2':
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				break;
			case '3':
				ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
				break;
			case '4':
				ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
				break;
			case '5':
				#ifdef DEF_JAPAN_FOR_TERRA
					ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
				#else
					ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				#endif
				break;
			case '6':
				switch (m_cMsg[1]) {
					case 'B':
						#ifdef DEF_JAPAN_FOR_TERRA
							ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
						#else
							ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
						#endif
						break;
					case 'C': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
					case 'M': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
				}
				break;
			case '7':
			case '8':
				#ifdef DEF_JAPAN_FOR_TERRA
					ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
				#else
					ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				#endif
				break;
			}
			delete pMI;
			return;
		}
	}

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	DrawVersion();

	// 마우스 커서 그린다.
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::RetrieveItemHandler(char *pData)
{
 char * cp, cBankItemIndex, cItemIndex, cTxt[120];
 WORD * wp;
 int j;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

	if (*wp != DEF_MSGTYPE_REJECT) {
		// 아이템을 성공적으로 되찾았다. 
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		cBankItemIndex = *cp;
		cp++;
		cItemIndex = *cp;
		cp++;

		if (m_pBankList[cBankItemIndex] != NULL) {
			// v1.42
			char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pBankList[cBankItemIndex], cStr1, cStr2, cStr3);
			
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, RETIEVE_ITEM_HANDLER4, cStr1);//"보관중인 아이템 %s을 되찾았습니다."
			AddEventList(cTxt, 10);
			
			if ( (m_pBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				 (m_pBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
				// 수량개념이 있는 아이템을 되찾았다. 
				
				// 이미 갖고 있는 아이템이 아니었다. 새로 추가한다. 
				if (m_pItemList[cItemIndex]	== NULL) goto RIH_STEP2;

				// 수량을 여기서 더할 필요가 없다. 따로 SetItemCount가 날라옴.
				//m_pItemList[cItemIndex]->m_dwCount += m_pBankList[cBankItemIndex]->m_dwCount;

				delete m_pBankList[cBankItemIndex];
				m_pBankList[cBankItemIndex] = NULL;
			
				// 빈 공간을 없앤다. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pBankList[j+1] != NULL) && (m_pBankList[j] == NULL)) {
						m_pBankList[j] = m_pBankList[j+1];	
												
						m_pBankList[j+1] = NULL;
					}
				}
			}
			else {
RIH_STEP2:;
				// 수량 개념이 없는 아이템을 되찾았다.
				if (m_pItemList[cItemIndex] != NULL) return;
				// 정진광 추가.. 아이템 찾을 때, 이미 갖고 있는 동일 아이템의 위치로 옮기기 위해..
				short nX, nY;  // 정진광 추가 변수...이미 있는 아이템의 좌표를 받기위해.
				nX = 40;
				nY = 30;
				for (j = 0; j < DEF_MAXITEMS; j++)
				{
					if ( ( m_pItemList[j] != NULL) && (memcmp(m_pItemList[j]->m_cName, cStr1, 20) == 0))
					{
						nX = m_pItemList[j]->m_sX+1;
						nY = m_pItemList[j]->m_sY+1;
						break;  // 아이템을 찾았으므로..루프 벗어남
					}
				}
				// 정진광 추가  여가까지..
				m_pItemList[cItemIndex] = m_pBankList[cBankItemIndex];
				//m_pItemList[cItemIndex]->m_sX =	40;
				//m_pItemList[cItemIndex]->m_sY =	30;
				m_pItemList[cItemIndex]->m_sX =	nX; //정진광 수정.
				m_pItemList[cItemIndex]->m_sY =	nY;
                bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, cItemIndex, nX, nY, NULL, NULL); 
				
				for (j = 0; j < DEF_MAXITEMS; j++) 
				if (m_cItemOrder[j] == -1) {
					m_cItemOrder[j] = cItemIndex;
					break;
				}
				//m_cItemOrder[cItemIndex] = cItemIndex;
				
				m_bIsItemEquipped[cItemIndex] = FALSE;
				m_bIsItemDisabled[cItemIndex] = FALSE;

				m_pBankList[cBankItemIndex] = NULL;
							
				// 빈 공간을 없앤다. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pBankList[j+1] != NULL) && (m_pBankList[j] == NULL)) {
						m_pBankList[j] = m_pBankList[j+1];	
												
						m_pBankList[j+1] = NULL;
					}
				}
			}
			
		}
	}
	
	// 다이얼로그 박스의 모드를 회복한다.
	m_stDialogBoxInfo[14].cMode = 0;
}

void CGame::EraseItem(char cItemID)
{
 int i;
 char cStr1[64], cStr2[64], cStr3[64];

	ZeroMemory(cStr1, sizeof(cStr1));
	ZeroMemory(cStr2, sizeof(cStr2));
	ZeroMemory(cStr3, sizeof(cStr3));
	for( i=0 ; i<5 ; i++ )
	{
		if (m_sShortCut[i] == cItemID) {
			GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
			if( i < 3 ) wsprintf(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i+1);
			else wsprintf(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i+2);
			//"아이템(%s %s %s): [F2] 단축키에서 해제됩니다."
			AddEventList(G_cTxt, 10);
			m_sShortCut[i] = -1;
		}
	}
	
	if (cItemID == m_sRecentShortCut)
		m_sRecentShortCut = -1;
	
	// ItemOrder에서 Item을 삭제한다.
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_cItemOrder[i] == cItemID) 
			m_cItemOrder[i] = -1;
	// 재 정렬 
	for (i = 1; i < DEF_MAXITEMS; i++)
	if ((m_cItemOrder[i-1] == -1) && (m_cItemOrder[i] != -1)) {
		m_cItemOrder[i-1] = m_cItemOrder[i];	
		m_cItemOrder[i]   = -1;
	}

	// ItemList에서 Item을 삭제한다.
	delete m_pItemList[cItemID];
	m_pItemList[cItemID] = NULL;
	m_bIsItemEquipped[cItemID] = FALSE;
	m_bIsItemDisabled[cItemID] = FALSE;
}

void CGame::DlbBoxDoubleClick_Character(short msX, short msY)
{
	char cEquipPosStatus[DEF_MAXITEMEQUIPPOS], cItemID = -1;
	short sX, sY, sSprH, sFrame;
	int i;
	if (m_bIsDialogEnabled[17] == TRUE) return;
	sX = m_stDialogBoxInfo[1].sX;
	sY = m_stDialogBoxInfo[1].sY;

	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		cEquipPosStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++) {
		if ((m_pItemList[i] != NULL) && (m_bIsItemEquipped[i] == TRUE))	cEquipPosStatus[ m_pItemList[i]->m_cEquipPos ] = i;
	}
	// 몸통 
	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		if (cEquipPosStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison( sX + 41, sY + 137, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_BACK];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_PANTS];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_ARMS];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_BODY];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_FULLBODY];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_LHAND];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_RHAND];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_TWOHAND];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_NECK];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_RFINGER];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_HEAD];
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6)) {
		if (cEquipPosStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_BACK];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_PANTS];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_ARMS];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_BODY];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_FULLBODY];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_LHAND];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_RHAND];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_TWOHAND];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_NECK];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_RFINGER];
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY ) )
				cItemID = cEquipPosStatus[DEF_EQUIPPOS_HEAD];
		}
	}

	if( cItemID == -1 || m_pItemList[cItemID] == NULL ) return;
	if ( (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW) || (m_pItemList[cItemID]->m_dwCount > 1) ) return;
//	if (m_bIsDialogEnabled[11] == FALSE) return FALSE; //상점이나 대장간 메뉴가 켜저있을때만 반응한다.
//	if (m_bIsDialogEnabled[23] == TRUE) return FALSE; //Repair Menu가 활성화되어있으면 일 안한다.
	if ( (m_bIsDialogEnabled[11]==TRUE) && (m_bIsDialogEnabled[23] == FALSE) && (m_stDialogBoxInfo[39].sV3 == 24))
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, NULL, cItemID, m_stDialogBoxInfo[39].sV3, NULL, m_pItemList[cItemID]->m_cName, m_stDialogBoxInfo[39].sV4); // v1.4
	else {
		if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == TRUE) {			
			char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
			ZeroMemory(G_cTxt, sizeof(G_cTxt) );
			wsprintf(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"아이템 %s: 장착 해제 되었습니다."
			AddEventList(G_cTxt, 10);
			
			PlaySound('E', 29, 0);

			// 아이템 장착 해제 메시지를 서버로 전송한다.
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_RELEASEITEM, NULL, m_stMCursor.sSelectedObjectID, NULL, NULL, NULL);
			// 장착위치에서 해제시킨다.
			m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = FALSE;
			m_sItemEquipmentStatus[	m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos ] = -1;
			m_stMCursor.cSelectedObjectType	= NULL;
			m_stMCursor.sSelectedObjectID   = NULL;
		}
	}
}

void CGame::DlbBoxDoubleClick_GuideMap(short msX, short msY)
{
	//2003.03.03 정진광 추가, 마법 캐스팅 후에 가이드맵 더블 클릭으로 이동금지.
	short si = m_stMCursor.sCursorFrame;
	if( si != 0 ) return;

	if( m_cMapIndex < 0 ) return;
	short sX, sY, shX, shY, szX, szY;
	sX = m_stDialogBoxInfo[9].sX;
	sY = m_stDialogBoxInfo[9].sY;
	szX = m_stDialogBoxInfo[9].sSizeX;
	szY = m_stDialogBoxInfo[9].sSizeY;
	if( sX < 20 ) sX = 0;
	if( sY < 20 ) sY = 0;
	if( sX > 640-128-20 ) sX = 640-128;
	if( sY > 427-128-20 ) sY = 427-128;
	if( m_bZoomMap )
	{
		shX = m_sPlayerX-64;
		shY = m_sPlayerY-64;
		if( shX < 0 ) shX = 0;
		if( shY < 0 ) shY = 0;
		if( shX > m_pMapData->m_sMapSizeX-128 ) shX = m_pMapData->m_sMapSizeX-128;
		if( shY > m_pMapData->m_sMapSizeY-128 ) shY = m_pMapData->m_sMapSizeY-128;
		shX = shX + msX - sX;
		shY = shY + msY - sY;
	}
	else
	{
		shX = (m_pMapData->m_sMapSizeX*(msX-sX))/128;
		shY = (m_pMapData->m_sMapSizeX*(msY-sY))/128;
	}

	if( shX < 30 || shY < 30 ) return;
	if( shX > m_pMapData->m_sMapSizeX-30 || shY > m_pMapData->m_sMapSizeY-30 ) return;
	if( (m_bRunningMode==TRUE) && (m_iSP>0) )
		m_cCommand = DEF_OBJECTRUN;
	else m_cCommand = DEF_OBJECTMOVE;
	m_sCommX = shX;
	m_sCommY = shY;
	GetPlayerTurn();
}

void CGame::DlbBoxDoubleClick_Inventory(short msX, short msY)
{
 register int i;
 char  cItemID, cTxt[120];
 short sX, sY, x1, x2, y1, y2;
 char cStr1[64], cStr2[64], cStr3[64];

 
	
	// 죽은 상태에서는 아이템을 사용할 수 없다.
	if (m_iHP <= 0) return;
	// 다른 아이템을 사용중이라면 동시에 두개를 사용할 수는 없다. 
	if (m_bItemUsingStatus == TRUE) {
		AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY1, 10);//"현재 아이템 사용이 끝난 후 사용할 수 있습니다."
		return;
	}

	sX = m_stDialogBoxInfo[2].sX;
	sY = m_stDialogBoxInfo[2].sY;

	//정진광 추가..연금술...
//연금술 다이얼록이 열려 있다면...
#if DEF_LANGUAGE == 3
	int iConsumeNum; // 정진광 추가 변수.
	if ( m_bIsDialogEnabled[26] == TRUE) 
	{
		//AddEventList("연금술 그릇이 열려 x네욤", 10);
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if (m_cItemOrder[DEF_MAXITEMS - 1 - i] == -1) continue;
		cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];		
		if (m_pItemList[cItemID] == NULL) continue;

		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + 32 + m_pItemList[cItemID]->m_sX,
														   sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame);
		// 좌표를 검색하여 선택되었는지를 검사한다. 만약 선택되었다면 Order를 맨 앞(배열상으로는 뒤)으로 옮긴다.
		x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;   
		y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;    
		x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;  
		y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom; 
		
		if ((m_bIsItemDisabled[cItemID] == FALSE) && (m_bIsItemEquipped[cItemID] == FALSE) && (msX > x1) && (msX < x2) && (msY > y1) && (msY < y2)) {

		switch (m_stDialogBoxInfo[26].cMode) 
		{
		case 1:
			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) {
				iConsumeNum = 0;
				if (m_stDialogBoxInfo[26].sV1 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV2 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV3 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV4 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV5 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV6 == cItemID) iConsumeNum++;
				if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
			}
			if ((m_pItemList[cItemID]->m_cItemType != DEF_ITEMTYPE_EAT) && 
				(m_pItemList[cItemID]->m_cItemType != DEF_ITEMTYPE_CONSUME) &&
				(m_pItemList[cItemID]->m_cItemType != DEF_ITEMTYPE_NONE)) return;
		
			// 조건을 만족한다면 빈 자리에 놓는다. 
			if (m_stDialogBoxInfo[26].sV1 == -1) {
				m_stDialogBoxInfo[26].sV1 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV2 == -1) {
				m_stDialogBoxInfo[26].sV2 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV3 == -1) {
				m_stDialogBoxInfo[26].sV3 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV4 == -1) {
				m_stDialogBoxInfo[26].sV4 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV5 == -1) {
				m_stDialogBoxInfo[26].sV5 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV6 == -1) {
				m_stDialogBoxInfo[26].sV6 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			// 빈 슬롯이 없다. 
			AddEventList(BITEMDROP_SKILLDIALOG4, 10);//"더이상 재료를 놓을 공간이 없습니다."
			break;

		case 4:
			// 무기/아이템 제작 창 
			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) {
				iConsumeNum = 0;
				if (m_stDialogBoxInfo[26].sV1 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV2 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV3 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV4 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV5 == cItemID) iConsumeNum++;
				if (m_stDialogBoxInfo[26].sV6 == cItemID) iConsumeNum++;
				if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
			}
			
			// 조건을 만족한다면 빈 자리에 놓는다. 
			if (m_stDialogBoxInfo[26].sV1 == -1) {
				m_stDialogBoxInfo[26].sV1 = cItemID;
				// 아이템 제작 조건이 만족되는지 검사 
				m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV2 == -1) {
				m_stDialogBoxInfo[26].sV2 = cItemID;
				// 아이템 제작 조건이 만족되는지 검사 
				m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV3 == -1) {
				m_stDialogBoxInfo[26].sV3 = cItemID;
				// 아이템 제작 조건이 만족되는지 검사 
				m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV4 == -1) {
				m_stDialogBoxInfo[26].sV4 = cItemID;
				// 아이템 제작 조건이 만족되는지 검사 
				m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV5 == -1) {
				m_stDialogBoxInfo[26].sV5 = cItemID;
				// 아이템 제작 조건이 만족되는지 검사 
				m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			else if (m_stDialogBoxInfo[26].sV6 == -1) {
				m_stDialogBoxInfo[26].sV6 = cItemID;
				// 아이템 제작 조건이 만족되는지 검사 
				m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
					// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
				}
				else m_bIsItemDisabled[cItemID] = TRUE;
				return;
			}
			// 빈 슬롯이 없다. 
			AddEventList(BITEMDROP_SKILLDIALOG4, 10);//"더이상 재료를 놓을 공간이 없습니다."
			break;
		default:
			break;
		} // Close switch block
	} // Close ..아이템 선택여부에 대한 if 블럭
	} // Close for loop
	} // Close 무기제작/연금술 다이얼록 열려있는지 여부..
#endif
	//정진광 추가 여기까지...
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	{
		if (m_cItemOrder[DEF_MAXITEMS - 1 - i] == -1) continue;
		cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];		
		if (m_pItemList[cItemID] == NULL) continue;

		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + 32 + m_pItemList[cItemID]->m_sX, sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame);
		// 좌표를 검색하여 선택되었는지를 검사한다. 만약 선택되었다면 Order를 맨 앞(배열상으로는 뒤)으로 옮긴다.
		x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;   
		y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;    
		x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;  
		y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom; 
		
		if ((m_bIsItemDisabled[cItemID] == FALSE) && (m_bIsItemEquipped[cItemID] == FALSE) && (msX > x1) && (msX < x2) && (msY > y1) && (msY < y2)) {
			// 선택되었다.
			// Order를 맨 앞으로 (배열상으로는 맨 뒤)
			_SetItemOrder(0, cItemID);
			GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
							
			if ( m_bIsDialogEnabled[11] && (m_bIsDialogEnabled[23] == FALSE) && (m_bIsDialogEnabled[23] == FALSE) && (m_stDialogBoxInfo[39].sV3 == 24) )
			{
				if (m_pItemList[cItemID]->m_cEquipPos != DEF_EQUIPPOS_NONE) {
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, NULL, cItemID, m_stDialogBoxInfo[39].sV3, NULL, m_pItemList[cItemID]->m_cName, m_stDialogBoxInfo[39].sV4); // v1.4
					return;
				}
			}

	//2003.06.09 정진광 진정피드백...
	#ifdef DEF_FEEDBACKCARD
		DisableDialogBox(5);
		if( !strcmp(m_pItemList[cItemID]->m_cName, "Realfeedbackcard1"))
			m_iFeedBackCardIndex = 1;
		if( !strcmp(m_pItemList[cItemID]->m_cName, "Realfeedbackcard2"))
			m_iFeedBackCardIndex = 2;
		if( !strcmp(m_pItemList[cItemID]->m_cName, "Realfeedbackcard3"))
			m_iFeedBackCardIndex = 3;
		if( !strcmp(m_pItemList[cItemID]->m_cName, "Realfeedbackcard4"))
			m_iFeedBackCardIndex = 4;
		if( !strcmp(m_pItemList[cItemID]->m_cName, "Realfeedbackcard5"))
			m_iFeedBackCardIndex = 5;
		if( !strcmp(m_pItemList[cItemID]->m_cName, "Realfeedbackcard6"))
			m_iFeedBackCardIndex = 6;
		if( !strcmp(m_pItemList[cItemID]->m_cName, "Realfeedbackcard7"))
			m_iFeedBackCardIndex = 7;
		
		if (m_iFeedBackCardIndex > 0 )
		{
			m_stDialogBoxInfo[5].sX  =  150;
			m_stDialogBoxInfo[5].sY  =  100;
			EnableDialogBox(5, NULL, NULL, NULL);
		}
		else
			m_iFeedBackCardIndex = -1;
	//	return;
	#endif



			// 만약 사용하여 효과를 보는 아이템이라면 서버로 전송한다. 
			if ( (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
				 (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_PERM) || 
				 (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW) || 
				 (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) ) {


				// 아이템 관련 연산이 가능한 상태인지 판별
				if (bCheckItemOperationEnabled(cItemID) == FALSE) return;
		
				// v1.42 스크롤류 아이템이라면 대미지를 먹은 상태에서 사용할 수 없다.
				if ((timeGetTime() - m_dwDamagedTime) < 10000) {
					// 충격을 받은 다음 
					if ((m_pItemList[cItemID]->m_sSprite == 6) && (m_pItemList[cItemID]->m_sSpriteFrame == 9)) {
						wsprintf(G_cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY3, cStr1);//"아이템 %s: 스크롤류의 아이템은 HP가 감소된 다음 10초 내에는 사용할 수 없습니다."
						AddEventList(G_cTxt, 10);
						return;
					}

					// v2.04
					if ((m_pItemList[cItemID]->m_sSprite == 6) && (m_pItemList[cItemID]->m_sSpriteFrame == 89)) {
						wsprintf(G_cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY3, cStr1);//"아이템 %s: 스크롤류의 아이템은 HP가 감소된 다음 10초 내에는 사용할 수 없습니다."
						AddEventList(G_cTxt, 10);
						return;
					}
				}

				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, cItemID, NULL, NULL, NULL); 

				if ( (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
					 (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) ) {
					// 아이템을 사용하겠다는 메시지를 전송했으므로 소모성 아이템이라면 Disable 시킨다. 
					m_bIsItemDisabled[cItemID] = TRUE;
					m_bItemUsingStatus = TRUE;
 				}
			}

			if ( m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL ) {
				// 스킬을 사용하는 아이템이라면 
				if (_bIsItemOnHand() == TRUE) {
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"이 아이템을 사용하기 위해서는 두손이 자유로와야 합니다."
					return;
				}

				if (m_bSkillUsingStatus == TRUE) {
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//"이미 다른 기술을 쓰고 있습니다."
					return;
				}
				
				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0) {
					// 수명이 다 된 아이템이다. 
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"수명이 다 된 아이템이라 사용할 수 없습니다."
				}
				else {
					m_bIsGetPointingMode = TRUE;
					m_iPointCommandType  = cItemID; // (0~49번 까지는 아이템 사용) 0~99 까지는 마법외의 Effect, 100~199까지는 마법 Effect 때문에 100을 머법 번호에 더한다.
					wsprintf(cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY7, cStr1);//"아이템 (%s): 사용할 위치를 선택하십시오."
					AddEventList(cTxt, 10);
				}
			}

			if ( m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST ) {
				// 한번 쓰고 없어지는 아이템인데 목표점을 지정한다.
				if (_bIsItemOnHand() == TRUE) {
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"이 아이템을 사용하기 위해서는 두손이 자유로와야 합니다."
					return;
				}

				if (m_bSkillUsingStatus == TRUE) {
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY13, 10);//"기술 사용중에는 사용할 수 없습니다."
					return;
				}
				
				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0) {
					// 수명이 다 된 아이템이다. 
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"수명이 다 된 아이템이라 사용할 수 없습니다."
				}
				else {
					m_bIsGetPointingMode = TRUE;
					m_iPointCommandType  = cItemID; // (0~49번 까지는 아이템 사용) 0~99 까지는 마법외의 Effect, 100~199까지는 마법 Effect 때문에 100을 머법 번호에 더한다.
					wsprintf(cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY8, cStr1);//"아이템 (%s): 사용할 대상을 선택하십시오."
					AddEventList(cTxt, 10);
				}
			}

			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) {
				// 연금술과 같이 별도의 다이얼로그 박스를 띄어야 하는 경우 
				if (_bIsItemOnHand() == TRUE) {
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"이 아이템을 사용하기 위해서는 두손이 자유로와야 합니다."
					return;
				}

				if (m_bSkillUsingStatus == TRUE) {
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//"이미 다른 기술을 쓰고 있습니다."
					return;
				}
				
				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0) {
					// 수명이 다 된 아이템이다. 
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"수명이 다 된 아이템이라 사용할 수 없습니다."
				}
				else {
					// 여기서 아이템의 스프라이트 번호로 해당 기술 창을 연다. 
					
					switch (m_pItemList[cItemID]->m_sSpriteFrame) {
					case 55:
						// 연금술그릇
						if (m_cSkillMastery[12] == 0) {
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY9, 10);//"이 아이템을 사용하기 위해서는 연금술을 배워야 합니다."
						}
						else {
							EnableDialogBox(26, 1, NULL, NULL, NULL);
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY10, 10);//"연금술을 사용합니다..."
						}
						break;

					case 113:
						// 강철모루
						if (m_cSkillMastery[13] == 0) {
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY11, 10);//"이 아이템을 사용하기 위해서는 무기-방어구 제작 기술을 배워야 합니다."
						}
						else {
							EnableDialogBox(26, 3, NULL, NULL, NULL);
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY12, 10);//"무기-방어구 제작 기술을 사용합니다..."
						}
						break;
					}
				}
			}

			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EQUIP) {
				// 장착하는 아이템이라면 
				m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = (short)cItemID;
				bItemDrop_Character();
				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
			}
			return;
		}
	}
}

#if DEF_LANGUAGE == 2

void CGame::UpdateScreen_OnChangePassword()
{
 short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI; 
 static char  cName[12], cPassword[12], cSSN[20], cNewPassword[12], cNewPassConfirm[12], cPrevFocus;
 static DWORD dwCTime;
 DWORD dwTime = timeGetTime();	
 BOOL bFlag = TRUE;

	if (m_cGameModeCount == 0) {
		EndInputString();
		
		pMI = new class CMouseInterface;
		pMI->AddRect(300, 148, 425, 170);
		pMI->AddRect(300, 172, 425, 194);
		pMI->AddRect(300, 196, 425, 218);
		pMI->AddRect(300, 220, 425, 242);
		pMI->AddRect(300, 244, 425, 264);

		pMI->AddRect(197, 320, 197 + DEF_BTNSZX, 320 + DEF_BTNSZY);
		pMI->AddRect(370, 320, 370 + DEF_BTNSZX, 320 + DEF_BTNSZY);

		cPrevFocus  = 2;
		m_cCurFocus = 2;//1;
		m_cMaxFocus = 7;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cPassword, sizeof(cPassword));
		ZeroMemory(cSSN, sizeof(cSSN));
		ZeroMemory(cNewPassword, sizeof(cNewPassword));
		ZeroMemory(cNewPassConfirm, sizeof(cNewPassConfirm));
		ClearInputString();
		strcpy( cName, m_cAccountName );
		StartInputString(314, 179, 11, cPassword);
		dwCTime = dwTime;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		
		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다. 	
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			m_cCurFocus++;
			if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		
		case 6:
			if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) < 1) || (m_Misc.bIsValidSSN(cSSN) == FALSE) ||
				 (m_Misc.bCheckValidName(cNewPassword) == FALSE) || (m_Misc.bCheckValidName(cNewPassConfirm) == FALSE) ||
				 (strlen(cNewPassword) < 8) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ) break;

			// Connect 버튼이 선택된 상태에서 Enter키가 눌렸다.
			// 이름을 초기화한다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			ZeroMemory(m_cNewPassword, sizeof(m_cNewPassword));
			ZeroMemory(m_cNewPassConfirm, sizeof(m_cNewPassConfirm));
			
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			strcpy(m_cAccountSSN, cSSN);
			strcpy(m_cNewPassword, cNewPassword);
			strcpy(m_cNewPassConfirm, cNewPassConfirm);

			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete pMI;
			return;
		
		case 7:
			// Cancel 버튼이 선택된 상태에서 Enter키가 눌렸다.
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			//m_dwLoginMode = MSGID_REQUEST_LOGIN;
			delete pMI;
			return;
		}
		// (!)
		m_bEnterPressed = FALSE;
	}

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(314, 155, 11, cName);
			break;
		case 2:
			StartInputString(314, 179, 11, cPassword);
			break;
		case 3:
			StartInputString(314, 203, 19, cSSN);
			break;
		case 4:
			StartInputString(314, 227, 11, cNewPassword);
			break;
		case 5:
			StartInputString(314, 251, 11, cNewPassConfirm);
		}
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();

	UpdateScreen_OnSelectCharacter(0, 0, 0, 0, TRUE);

	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6)) {
		m_DDraw.DrawShadowBox(0,0,639,479);
	}
	else if (m_cGameModeCount >= 6) {
		m_DDraw.DrawShadowBox(0,0,639,479);
		m_DDraw.DrawShadowBox(0,0,639,479);
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153, 112, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT , 153, 112, 13);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153 + 157, 112 + 109, 7);//Blank 하나 더 띄워주기 위해..
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153 + 157, 112 + 133, 7);//Blank 하나 더 띄워주기 위해..

	PutString(206, 155, UPDATE_SCREEN_ON_CHANGE_PASSWORD1, RGB(25,35,25));
	PutString(206, 179, UPDATE_SCREEN_ON_CHANGE_PASSWORD2, RGB(25,35,25));
	PutString(206, 203, "疵佛", RGB(25,35,25));
	PutString(206, 227, UPDATE_SCREEN_ON_CHANGE_PASSWORD3, RGB(25,35,25));
	PutString(206, 251, UPDATE_SCREEN_ON_CHANGE_PASSWORD4, RGB(25,35,25));

	if (m_cCurFocus != 1) {
		if (m_Misc.bCheckValidString(cName) != FALSE)
			 PutString(314, 155, cName, RGB(25,35,25));
		else PutString(314, 155, cName, RGB(55,18,13));
	}
	if ((m_Misc.bCheckValidString(cName) == FALSE) || (strlen(cName) == 0)) bFlag = FALSE;

	if (m_cCurFocus != 2) {
		if ((m_Misc.bCheckValidString(cPassword) != FALSE))
			 PutString(314, 179, cPassword, RGB(25,35,25), TRUE, 3);
		else PutString(314, 179, cPassword, RGB(55,18,13), TRUE, 3);
	}

	if (m_cCurFocus != 3) {
		if ((m_Misc.bIsValidSSN(cSSN) != FALSE))
			 PutString(314, 203, cSSN, RGB(25,35,25));
		else PutString(314, 203, cSSN, RGB(200,100,100));
	}

	if (m_cCurFocus != 4) {
		if ((m_Misc.bCheckValidName(cNewPassword) != FALSE))
			 PutString(314, 227, cNewPassword, RGB(25,35,25), TRUE, 3);
		else PutString(314, 227, cNewPassword, RGB(55,18,13), TRUE, 3);
	}

	if (m_cCurFocus != 5) {
		if ((m_Misc.bCheckValidName(cNewPassConfirm) != FALSE))
			 PutString(314, 251, cNewPassConfirm, RGB(25,35,25), TRUE, 3);
		else PutString(314, 251, cNewPassConfirm, RGB(55,18,13), TRUE, 3);
	}

	if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) < 1) || (m_Misc.bIsValidSSN(cSSN)==FALSE) ||
		 (strlen(cNewPassword) < 8) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ) bFlag = FALSE;

	if ((m_cCurFocus == 1) || (m_cCurFocus == 3))
		ShowReceivedString();
	else
	if ((m_cCurFocus == 2) || (m_cCurFocus == 4) || (m_cCurFocus == 5))	
		ShowReceivedString(TRUE);
	
//	PutAlignedString(153, 487, 258, UPDATE_SCREEN_ON_CHANGE_PASSWORD5);//"변경하고자 하는 계정 이름과  패스워"
	PutAlignedString(153, 487, 273, UPDATE_SCREEN_ON_CHANGE_PASSWORD6);//"드를 입력하시고 새 패스워드를 대소문"
	PutAlignedString(153, 487, 288, UPDATE_SCREEN_ON_CHANGE_PASSWORD7);//"자를 구분하여 8글자 이상 입력하십시오."
	
	if ( (bFlag == TRUE) && (m_cCurFocus == 6) )
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 320, 21, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 320, 20, dwTime);
	
	if (m_cCurFocus == 7) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(370, 320, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(370, 320, 16, dwTime);

	DrawVersion();
	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스클릭. 
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			m_cCurFocus = iMIbuttonNum;
			break;
		
		case 6:
			if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) < 1) || 
				 (m_Misc.bCheckValidName(cNewPassword) == FALSE) || (m_Misc.bCheckValidName(cNewPassConfirm) == FALSE) ||
				 (strlen(cNewPassword) == 0) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ) break;

			EndInputString();
			
			// 이름을 초기화한다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			ZeroMemory(m_cNewPassword, sizeof(m_cNewPassword));
			ZeroMemory(m_cNewPassConfirm, sizeof(m_cNewPassConfirm));
			ZeroMemory(m_cAccountSSN, sizeof(cSSN));
			
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);

			strcpy(m_cAccountSSN, cSSN);
			
			strcpy(m_cNewPassword, cNewPassword);
			strcpy(m_cNewPassConfirm, cNewPassConfirm);
			
			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete pMI;
			return;

		case 7:
			// Cancel 버튼이 눌렸다.
			
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			//m_dwLoginMode = MSGID_REQUEST_LOGIN;
			delete pMI;
			return;
		}
	}

	if ((msX >= 197) && (msX <= 197 + DEF_BTNSZX) && (msY >= 320) && (msY <= 320 + DEF_BTNSZY)) m_cCurFocus = m_cMaxFocus-1;
	if ((msX >= 370) && (msX <= 370 + DEF_BTNSZX) && (msY >= 320) && (msY <= 320 + DEF_BTNSZY)) m_cCurFocus = m_cMaxFocus;

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#else

void CGame::UpdateScreen_OnChangePassword()
{
 short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI; 
 static char  cName[12], cPassword[12], cNewPassword[12], cNewPassConfirm[12], cPrevFocus;
 static DWORD dwCTime;
 DWORD dwTime = timeGetTime();
 BOOL bFlag = TRUE;

	if (m_cGameModeCount == 0) {
		EndInputString();
		
		pMI = new class CMouseInterface;
		pMI->AddRect(300, 148, 425, 170);
		pMI->AddRect(300, 172, 425, 194);
		pMI->AddRect(300, 196, 425, 218);
		pMI->AddRect(300, 220, 425, 242);

		pMI->AddRect(197, 320, 197 + DEF_BTNSZX, 320 + DEF_BTNSZY);
		pMI->AddRect(370, 320, 370 + DEF_BTNSZX, 320 + DEF_BTNSZY);

		cPrevFocus  = 2; //1
		m_cCurFocus = 2; //1
		m_cMaxFocus = 6;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cPassword, sizeof(cPassword));
		ZeroMemory(cNewPassword, sizeof(cNewPassword));
		ZeroMemory(cNewPassConfirm, sizeof(cNewPassConfirm));

		strcpy( cName, m_cAccountName );
		//StartInputString(314, 155, 11, cName);
		StartInputString(314, 179, 11, cPassword);
		ClearInputString();
		dwCTime = dwTime;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		
		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다. 	
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
		case 2:
		case 3:
		case 4:
			m_cCurFocus++;
			if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		
		case 5:
			if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) == 0) || 
				 (m_Misc.bCheckValidName(cNewPassword) == FALSE) || (m_Misc.bCheckValidName(cNewPassConfirm) == FALSE) ||
				 (strlen(cNewPassword) == 0) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ) break;

			// Connect 버튼이 선택된 상태에서 Enter키가 눌렸다.
			// 이름을 초기화한다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			ZeroMemory(m_cNewPassword, sizeof(m_cNewPassword));
			ZeroMemory(m_cNewPassConfirm, sizeof(m_cNewPassConfirm));
			
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			strcpy(m_cNewPassword, cNewPassword);
			strcpy(m_cNewPassConfirm, cNewPassConfirm);

			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete pMI;
			return;
		
		case 6:
			// Cancel 버튼이 선택된 상태에서 Enter키가 눌렸다.
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			//m_dwLoginMode = MSGID_REQUEST_LOGIN;
			delete pMI;
			return;
		}
		// (!)
		m_bEnterPressed = FALSE;
	}

	if (m_bEscPressed == TRUE) {
		#ifdef DEF_JAPAN_FOR_TERRA
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
		#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		#endif
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(314, 155, 11, cName);
			break;
		case 2:
			StartInputString(314, 179, 11, cPassword);
			break;
		case 3:
			StartInputString(314, 203, 11, cNewPassword);
			break;
		case 4:
			StartInputString(314, 227, 11, cNewPassConfirm);
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();

	UpdateScreen_OnSelectCharacter(0, 0, 0, 0, TRUE);
	m_DDraw.DrawShadowBox(0,0,639,479);//SelectCharacter뒷배경은 흐리게 하구..

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153, 112, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT , 153, 112, 13);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153 + 157, 112 + 109, 7);//Blank 하나 더 띄워주기 위해..

	PutString(206, 155, UPDATE_SCREEN_ON_CHANGE_PASSWORD1, RGB(25,35,25));
	PutString(206, 179, UPDATE_SCREEN_ON_CHANGE_PASSWORD2, RGB(25,35,25));
	PutString(206, 203, UPDATE_SCREEN_ON_CHANGE_PASSWORD3, RGB(25,35,25));
	PutString(206, 227, UPDATE_SCREEN_ON_CHANGE_PASSWORD4, RGB(25,35,25));

	if (m_cCurFocus != 1) {
		if (m_Misc.bCheckValidString(cName) != FALSE)
			 PutString(314, 155, cName, RGB(25,35,25));
		else PutString(314, 155, cName, RGB(55,18,13));
	}
	if ((m_Misc.bCheckValidString(cName) == FALSE) || (strlen(cName) == 0)) bFlag = FALSE;

	if (m_cCurFocus != 2) {
		if ((m_Misc.bCheckValidString(cPassword) != FALSE))
			 PutString(314, 179, cPassword, RGB(25,35,25), TRUE, 3);
		else PutString(314, 179, cPassword, RGB(55,18,13), TRUE, 3);
	}

	if (m_cCurFocus != 3) {
		if ((m_Misc.bCheckValidName(cNewPassword) != FALSE))
			 PutString(314, 203, cNewPassword, RGB(25,35,25), TRUE, 3);
		else PutString(314, 203, cNewPassword, RGB(55,18,13), TRUE, 3);
	}

	if (m_cCurFocus != 4) {
		if ((m_Misc.bCheckValidName(cNewPassConfirm) != FALSE))
			 PutString(314, 227, cNewPassConfirm, RGB(25,35,25), TRUE, 3);
		else PutString(314, 227, cNewPassConfirm, RGB(55,18,13), TRUE, 3);
	}

#if DEF_LANGUAGE == 4	//언어:English
	if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) == 0) || 
		 (strlen(cNewPassword) < 8) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ||
		  // 2002-10-18 #1 인터섭 암호 변경시 기존 암호와 달라야 한다.
		 ( memcmp(cPassword, cNewPassword, 10) == 0 ) ) bFlag = FALSE;
#else
	if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) == 0) || 
		 (strlen(cNewPassword) < 8) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ) bFlag = FALSE;
#endif

	if (m_cCurFocus == 1) ShowReceivedString();
	else if ((m_cCurFocus == 2) || (m_cCurFocus == 3) || (m_cCurFocus == 4)) ShowReceivedString(TRUE);
	
	PutAlignedString(153, 487, 258, UPDATE_SCREEN_ON_CHANGE_PASSWORD5);//"변경하고자 하는 계정 이름과  패스워"
	PutAlignedString(153, 487, 273, UPDATE_SCREEN_ON_CHANGE_PASSWORD6);//"드를 입력하시고 새 패스워드를 대소문"
	PutAlignedString(153, 487, 288, UPDATE_SCREEN_ON_CHANGE_PASSWORD7);//"자를 구분하여 8글자 이상 입력하십시오."
	
	if ( (bFlag == TRUE) && (m_cCurFocus == 5) )
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 320, 21, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 320, 20, dwTime);
	
	if (m_cCurFocus == 6) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(370, 320, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(370, 320, 16, dwTime);

	DrawVersion();
	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스클릭. 
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			m_cCurFocus = iMIbuttonNum;
			break;
		
		case 5:
			if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) == 0) || 
				 (m_Misc.bCheckValidName(cNewPassword) == FALSE) || (m_Misc.bCheckValidName(cNewPassConfirm) == FALSE) ||
				 (strlen(cNewPassword) == 0) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ) break;

			EndInputString();
			
			// 이름을 초기화한다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			ZeroMemory(m_cNewPassword, sizeof(m_cNewPassword));
			ZeroMemory(m_cNewPassConfirm, sizeof(m_cNewPassConfirm));
			
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			
			strcpy(m_cNewPassword, cNewPassword);
			strcpy(m_cNewPassConfirm, cNewPassConfirm);
			
			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete pMI;
			return;

		case 6:
			// Cancel 버튼이 눌렸다.
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			return;
		}
	}

	if ((msX >= 197) && (msX <= 197 + DEF_BTNSZX) && (msY >= 320) && (msY <= 320 + DEF_BTNSZY)) m_cCurFocus = 5;
	if ((msX >= 370) && (msX <= 370 + DEF_BTNSZX) && (msY >= 320) && (msY <= 320 + DEF_BTNSZY)) m_cCurFocus = 6;

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}
#endif

void CGame::DlgBoxClick_SysMenu(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[19].sX;
	sY = m_stDialogBoxInfo[19].sY;

	if ((msX >= sX + 120) && (msX <= sX + 150) && (msY >= sY + 63) && (msY <= sY + 74)) {
		m_cDetailLevel = 0; // v1.41
		AddEventList( NOTIFY_MSG_DETAIL_LEVEL_LOW, 10 );
		PlaySound('E', 14, 5);
   	}

	if ((msX >= sX + 151) && (msX <= sX + 200) && (msY >= sY + 63) && (msY <= sY + 74)) {
		m_cDetailLevel = 1;
		AddEventList( NOTIFY_MSG_DETAIL_LEVEL_MEDIUM, 10 );
		PlaySound('E', 14, 5);
	}

	if ((msX >= sX + 201) && (msX <= sX + 234) && (msY >= sY + 63) && (msY <= sY + 74)) {
		m_cDetailLevel = 2;
		AddEventList( NOTIFY_MSG_DETAIL_LEVEL_HIGH, 10 );
		PlaySound('E', 14, 5);
	}

	if ((msX >= sX + 24) && (msX <= sX + 115) && (msY >= sY + 81) && (msY <= sY + 100)) {
		if( m_bSoundFlag ) {
			if (m_bSoundStat == TRUE) {
				m_pESound[38]->bStop();
				m_bSoundStat = FALSE;
				AddEventList( NOTIFY_MSG_SOUND_OFF, 10 );
			}
			else {
				m_bSoundStat = TRUE;
				AddEventList( NOTIFY_MSG_SOUND_ON, 10 );
			}
		}
	}

	if ((msX >= sX + 116) && (msX <= sX + 202) && (msY >= sY + 81) && (msY <= sY + 100)) {
		if( m_bSoundFlag ) {
			if (m_bMusicStat == TRUE) {
				// Music Off
				m_bMusicStat = FALSE;
				AddEventList( NOTIFY_MSG_MUSIC_OFF, 10 );
				if (m_bSoundFlag) {
					if (m_pBGM != NULL) {
						m_pBGM->bStop();
						delete m_pBGM;
						m_pBGM = NULL;
					}
				}
			}
			else {
				// Music On
				if (m_bSoundFlag) {
					m_bMusicStat = TRUE;
					AddEventList( NOTIFY_MSG_MUSIC_ON, 10 );
					StartBGM();
				}
			}
		}
	}

	//2002.10.19 정진광. 귓속말가 외치기 부분..On Off
	if ((msX >= sX + 23) && (msX <= sX + 108) && (msY >= sY + 108) && (msY <= sY + 119)) {
		 if (m_bWhisper == TRUE) {
			m_bWhisper = FALSE;
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND7, 10 );
		 } 
		 else {
			m_bWhisper = TRUE;
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND6, 10 );
		 } 
	}

	if ((msX >= sX + 123) && (msX <= sX + 203) && (msY >= sY + 108) && (msY <= sY + 119)) {
		 if (m_bShout == TRUE) {
			m_bShout = FALSE;
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND9, 10 );
		 } 
		 else {
			m_bShout = TRUE;
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND8, 10 );
		 } 
	}
	////여기까지...

	//Transparency Change
	if ((msX >= sX + 28) && (msX <= sX + 235) && (msY >= sY + 156) && (msY <= sY + 171)) m_bDialogTrans = !m_bDialogTrans;

	//Guide Map Toggle
	if ((msX >= sX + 28) && (msX <= sX + 235) && (msY >= sY + 178) && (msY <= sY + 193))
	{
		if( m_bIsDialogEnabled[9] ) DisableDialogBox(9);
		else EnableDialogBox(9, 0, 0, 0, NULL);
	}

	if (m_bForceDisconn) return; //강제 접속 종료시에는 무시한다..
	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY)) {
		if( m_cLogOutCount == -1 )
#ifdef _DEBUG
			m_cLogOutCount = 1;
#else
			m_cLogOutCount = 11;
#endif
		else {
			m_cLogOutCount = -1;
			AddEventList(DLGBOX_CLICK_SYSMENU2, 10);//"접속 종료 카운트가 중지되었습니다."
			DisableDialogBox(19);
		}
		PlaySound('E', 14, 5);
	}

	if ((m_iHP <= 0) && (m_cRestartCount == -1)) {
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY)) {
			// 서버로 리스타트를 요청하고 버튼은 비활성화한다.
			m_cRestartCount = 5;
			m_dwRestartCountTime = timeGetTime();
			DisableDialogBox(19);
			wsprintf(G_cTxt, DLGBOX_CLICK_SYSMENU1, m_cRestartCount);//"게임을 다시 시작합니다...%d"
			AddEventList(G_cTxt, 10);
			PlaySound('E', 14, 5);
		}
	}
}

void CGame::DrawNpcName(short sX, short sY, short sOwnerType, short sStatus)
{
	char cTxt[32], cTxt2[64];
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTxt2, sizeof(cTxt2));

	GetNpcName(sOwnerType, cTxt);
	if ((sStatus & 0x20) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk" 
	if ((sStatus & 0x40) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"

	PutString2(sX, sY, cTxt, 255,255,255);

	if (m_bIsObserverMode == TRUE) PutString2(sX, sY+14, cTxt, 50,50,255);// 관람자 모드일때는 적, 아군 구분을 하지 않는다.
	else if (m_bIsConfusion || (m_iIlusionOwnerH != NULL)) {
		ZeroMemory(cTxt, sizeof(cTxt));
		strcpy(cTxt, DRAW_OBJECT_NAME87);//"알수없음(Unknown)"
		PutString2(sX, sY+14, cTxt, 150,150,150); // v2.171
	}
	else
	{
		switch( _iGetFOE(sStatus) )
		{
		case -2:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME90, 255, 0, 0);
			break;
		case -1:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME90, 255, 0, 0);
			break;
		case 0:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME88, 50,50,255);
			break;
		case 1:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME89, 30,255,30);
			break;
		}
	}

	switch ((sStatus & 0x0F00) >> 8) {
	case 0: break;
	case 1: strcpy(cTxt2, DRAW_OBJECT_NAME52); break;//"Clairvoyant"
	case 2: strcpy(cTxt2, DRAW_OBJECT_NAME53); break;//"Destruction of Magic Protection"
	case 3: strcpy(cTxt2, DRAW_OBJECT_NAME54); break;//"Anti-Physical Damage"
	case 4: strcpy(cTxt2, DRAW_OBJECT_NAME55); break;//"Anti-Magic Damage"
	case 5: strcpy(cTxt2, DRAW_OBJECT_NAME56); break;//"Poisonous"
	case 6: strcpy(cTxt2, DRAW_OBJECT_NAME57); break;//"Critical Poisonous" 
	case 7: strcpy(cTxt2, DRAW_OBJECT_NAME58); break;//"Explosive"  
	case 8: strcpy(cTxt2, DRAW_OBJECT_NAME59); break;//"Critical Explosive"
	}
	if( m_Misc.bCheckIMEString(cTxt2) ) PutString_SprFont3(sX, sY + 28, cTxt2, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
	else PutString2(sX, sY + 28, cTxt2, 240,240,70);

}

void CGame::DrawObjectName(short sX, short sY, char * pName, short sStatus)
{
	char cTxt[64], cTxt2[64];
	short sR, sG, sB;
	int i, iGuildIndex, iFOE, iAddY=0; // 기본은 중립  v2.171
	BOOL bPK, bCitizen, bAresden, bHunter;

	iFOE = _iGetFOE(sStatus);
	if( iFOE < 0 )
	{
		sR = 255; sG = 0; sB = 0;
	}
	else if( iFOE == 0 )
	{
		sR = 50; sG = 50; sB = 255;
	}
	else
	{
		sR = 30; sG = 200; sB = 30;
	}
		
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTxt2, sizeof(cTxt2));

	if (m_iIlusionOwnerH == NULL)
	{
		if (m_bIsCrusadeMode == FALSE) wsprintf(cTxt, "%s", pName);
		else
		{
			if (_tmp_wObjectID >= 10000) strcpy(cTxt, NPC_NAME_MERCENARY); //"용병"
			else
			{
				if( iFOE == -1 ) wsprintf(cTxt, "%d", _tmp_wObjectID);// 크루세이드 모드에서 적 캐릭터다. 오브젝트 아이디를 찍는다.
				else strcpy(cTxt, pName);
			}
		}
		if (m_iPartyStatus != NULL) {
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) {
				if (strcmp(m_stPartyMemberNameList[i].cName, pName) == 0) {
					strcat(cTxt, BGET_NPC_NAME23);//", 파티원"
					break;
				}
			}	
		}
	}
	else strcpy(cTxt, "?????");

	if ((sStatus & 0x20) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk" 
	if ((sStatus & 0x40) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"

	PutString2(sX, sY, cTxt, 255,255,255);
	ZeroMemory(cTxt, sizeof(cTxt));

	if( memcmp(m_cPlayerName, pName, 10) == 0 )
	{
		if( m_iGuildRank == 0 )
		{
			wsprintf( G_cTxt, DEF_MSG_GUILDMASTER, m_cGuildName );//"%s 길드마스터"
			PutString2(sX, sY+14, G_cTxt, 180,180,180);
			iAddY = 14;
		}
		if( m_iGuildRank > 0 )
		{
			wsprintf( G_cTxt, DEF_MSG_GUILDSMAN, m_cGuildName );//"%s 길드원"
			PutString2(sX, sY+14, G_cTxt, 180,180,180);
			iAddY = 14;
		}
		if( m_iPKCount != 0 )
		{
			bPK = TRUE;
			sR = 255; sG = 0; sB = 0;
		}
		else
		{
			bPK = FALSE;
			sR = 30; sG = 200; sB = 30;
		}
		bCitizen = m_bCitizen;
		bAresden = m_bAresden;
		bHunter = m_bHunter;
	}
	else
	{
		if( sStatus & 0x8000 ) bPK = TRUE;
		else bPK = FALSE;
		if( sStatus & 0x4000 ) bCitizen = TRUE;
		else bCitizen = FALSE;
		if( sStatus & 0x2000 ) bAresden = TRUE;
		else bAresden = FALSE;
		if( sStatus & 0x1000 ) bHunter = TRUE;
		else bHunter = FALSE;
		if( m_bIsCrusadeMode==FALSE || iFOE>=0 )//크루세이드 모드에서 적이라면..
		{
			if( FindGuildName(pName, &iGuildIndex) == TRUE )
			{//길드 이름을 보이기 위해 준비된 상태라면.
				if (m_stGuildName[iGuildIndex].cGuildName[0] != NULL)
				{	// 길드 이름을 알고 있다.
					if( strcmp(m_stGuildName[iGuildIndex].cGuildName, "NONE" )!=0 )
					{
						if( m_stGuildName[iGuildIndex].iGuildRank == 0 )
						{
							wsprintf( G_cTxt, DEF_MSG_GUILDMASTER, m_stGuildName[iGuildIndex].cGuildName );//"%s 길드마스터"
							PutString2(sX, sY+14, G_cTxt, 180,180,180);
							m_stGuildName[iGuildIndex].dwRefTime = m_dwCurTime;
							iAddY = 14;
						}
						else if( m_stGuildName[iGuildIndex].iGuildRank > 0 )
						{
							wsprintf( G_cTxt, DEF_MSG_GUILDSMAN, m_stGuildName[iGuildIndex].cGuildName );//"%s 길드원"
							PutString2(sX, sY+14, G_cTxt, 180,180,180);
							m_stGuildName[iGuildIndex].dwRefTime = m_dwCurTime;
							iAddY = 14;
						}
					}
					else
					{//길드가 없는 애다.
						m_stGuildName[iGuildIndex].dwRefTime = 0;
					}
				}
			}
			else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQGUILDNAME, NULL, _tmp_wObjectID, iGuildIndex, NULL, NULL); 
		}
	}

	if( bCitizen == FALSE )	strcpy(cTxt, DRAW_OBJECT_NAME60);//"여행자"
	else
	{
		if( bAresden )
		{
//#if DEF_LANGUAGE > 2		// Korea 2.19
			if( bHunter == TRUE ) strcpy(cTxt, DEF_MSG_ARECIVIL);//"아레스덴 민간인"
			else strcpy(cTxt, DEF_MSG_ARESOLDIER);//"아레스덴 병사"
//#else
//			strcpy(cTxt, DRAW_OBJECT_NAME62);//"아레스덴 소속"
//#endif
		}
		else
		{
//#if DEF_LANGUAGE > 2		// Korea 2.19
			if( bHunter == TRUE ) strcpy(cTxt, DEF_MSG_ELVCIVIL);//"엘바인 민간인"
			else strcpy(cTxt, DEF_MSG_ELVSOLDIER);
//#else
//			strcpy(cTxt, DRAW_OBJECT_NAME74);// 엘바인 소속
//#endif
		}
	}
	if( bPK == TRUE )
	{
		if( bCitizen == FALSE ) strcpy( cTxt, DEF_MSG_PK );//"범죄자"
		else
		{
			if( bAresden ) strcpy( cTxt, DEF_MSG_AREPK );//"아레스덴 범죄자"
			else strcpy( cTxt, DEF_MSG_ELVPK );//"엘바인 범죄자"
		}
	}
	PutString2(sX, sY+14 +iAddY, cTxt, sR, sG, sB);
}

BOOL CGame::FindGuildName(char* pName, int* ipIndex)
{
	int i, iRet = 0;
	DWORD dwTmpTime;
	for( i=0 ; i < DEF_MAXGUILDNAMES ; i++ )
	{
		if( memcmp(m_stGuildName[i].cCharName, pName, 10) == 0 )
		{
			m_stGuildName[i].dwRefTime = m_dwCurTime;
			*ipIndex = i;
			return TRUE;
		}
	}
	dwTmpTime = m_stGuildName[0].dwRefTime;
	for( i=0 ; i < DEF_MAXGUILDNAMES ; i++ )
	{
		if( m_stGuildName[i].dwRefTime < dwTmpTime )
		{
			iRet = i;
			dwTmpTime = m_stGuildName[i].dwRefTime;
		}
	}
	ZeroMemory( m_stGuildName[iRet].cGuildName, sizeof(m_stGuildName[iRet].cGuildName) );
	memcpy( m_stGuildName[iRet].cCharName, pName, 10 );
	m_stGuildName[iRet].dwRefTime = m_dwCurTime;
	m_stGuildName[iRet].iGuildRank = -1;
	*ipIndex = iRet;
	return FALSE;
}

void CGame::UpdateScreen_OnVersionNotMatch()
{
 short msX, msY, msZ;
 char cLB, cRB;
 
 char cMIresult;
 int  iMIbuttonNum;
	
 static class CMouseInterface * pMI; 
 DWORD dwTime = timeGetTime();
	
	if (m_cGameModeCount == 0) {
		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		if (m_pGSock != NULL) {
			delete m_pGSock;
			m_pGSock = NULL;
		}
		pMI = new class CMouseInterface;
		pMI->AddRect(0,0,640,480);
		m_bEnterPressed = FALSE;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 120) m_cGameModeCount = 120;

	m_DDraw.ClearBackB4();
	
	if (m_bEscPressed == TRUE || m_bEnterPressed == TRUE) {
		m_bEscPressed = FALSE;
		m_bEnterPressed = FALSE;
		delete pMI;
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		return;
	}
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 0,0,0, TRUE);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);

#if DEF_LANGUAGE == 5
	PutAlignedString(168, 474, 160, UPDATE_SCREEN_ON_VERSION_NO_MATCH1);//"클라이언트 프로그램의 버젼이 서버와 맞지 않습니다!"
	PutAlignedString(168, 474, 180, UPDATE_SCREEN_ON_VERSION_NO_MATCH2);//"최신버전의 클라이언트를 다운로드하여 접속하십시오."
	PutAlignedString(168, 474, 200, UPDATE_SCREEN_ON_VERSION_NO_MATCH3);//"클라이언트 프로그램의 버젼이 서버와 맞지 않습니다!"
	PutAlignedString(168, 474, 220, UPDATE_SCREEN_ON_VERSION_NO_MATCH4);//"최신버전의 클라이언트를 다운로드하여 접속하십시오."
#else
	PutAlignedString(168, 474, 160, UPDATE_SCREEN_ON_VERSION_NO_MATCH1);//"클라이언트 프로그램의 버젼이 서버와 맞지 않습니다!"
	PutAlignedString(168, 474, 180, UPDATE_SCREEN_ON_VERSION_NO_MATCH2);//"최신버전의 클라이언트를 다운로드하여 접속하십시오."
#endif


	PutAlignedString(168, 474, 250, "www.helbreath.com");
	
	DrawVersion();
	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if ((cMIresult == DEF_MIRESULT_CLICK) && (iMIbuttonNum == 1)) {
		// 마우스 버튼이 눌렸으므로 프로그램을 종료한다.
		ChangeGameMode(DEF_GAMEMODE_NULL);
		delete pMI;
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		return;
	}
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}


//void CGame::DrawVersion()
//{
//	PutString2( 15, 455, "X-Mas Version", 255, 255, 0 );
//}

void CGame::DrawVersion()
{
		DWORD dwTime = timeGetTime();
		WORD  wR, wG, wB;
		m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(140, 140, 140), &wR, &wG, &wB);
		// Ver
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(14, 463, 19, wR, wG, wB, dwTime);	
		// Upper Version
		wsprintf(G_cTxt, "%d", DEF_UPPERVERSION);
		PutString_SprNum(36, 463, G_cTxt, 140, 140, 140);
		// .
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(42, 463, 18, wR, wG, wB, dwTime);	
		// Lower Version
		wsprintf(G_cTxt, "%d", DEF_LOWERVERSION);
		PutString_SprNum(46, 463, G_cTxt, 140, 140, 140);
}

char CGame::GetOfficialMapName(char * pMapName, char * pName)
{
	//리턴값은 MapIndex를 뜻한다.
	if (strcmp(pMapName, "middleland") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME28);//"미들랜드"
		return 4;
	}
	else if (strcmp(pMapName, "huntzone3") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME31);//"데쓰 밸리" 
		return 0;
	}
	else if (strcmp(pMapName, "huntzone1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME29);//"록키 하이랜드"
		return 1;
	}
	else if (strcmp(pMapName, "elvuni") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME57);//"엘디니엘 가든"
		return 2;
	}
	else if (strcmp(pMapName, "elvine") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME24);//"엘바인"
		return 3;
	}
	else if (strcmp(pMapName, "elvfarm") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME2);//"엘바인 농경지"
		return 5;
	}
	else if (strcmp(pMapName, "arefarm") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME1);//"아레스덴 농경지"
		return 6;
	}
	else if (strcmp(pMapName, "default") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME3);//"초보존"
		return 7;
	}
	else if (strcmp(pMapName, "huntzone4") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME32);//"사일런트 우드"
		return 8;
	}
	else if (strcmp(pMapName, "huntzone2") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME30);//"이터널 필드"
		return 9;
	}
	else if (strcmp(pMapName, "areuni") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME56);//"아레시엔 가든"
		return 10;
	}
	else if (strcmp(pMapName, "aresden") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME22);//"아레스덴"
		return 11;
	}
	else if (strcmp(pMapName, "dglv2") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME25);//"던젼 지하 2층"
		return 12;
	}
	else if (strcmp(pMapName, "dglv3") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME26);//"던젼 지하 3층"
		return 13;
	}
	else if (strcmp(pMapName, "dglv4") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME53);//"던젼 지하 4층"
		return 14;
	}
	else if (strcmp(pMapName, "elvined1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME23);//"엘바인 던젼 지하 1층"
		return 15;
	}
	else if (strcmp(pMapName, "aresdend1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME21);//"아레스덴 던젼 지하 1층"
		return 16;
	}
	else if (strcmp(pMapName, "bisle") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME27);//"블리딩 아일"
		return 17;
	}
	else if (strcmp(pMapName, "toh1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME60);//"타워 오브 헬 1층"
		return 18;
	}
	else if (strcmp(pMapName, "toh2") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME61);//"타워 오브 헬 2층"
		return 19;
	}
	else if (strcmp(pMapName, "toh3") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME62);//"타워 오브 헬 3층"
		return 20;
	}
	else if (strcmp(pMapName, "middled1x") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME58);//"미들랜드 광산"
		return 21;
	}
	else if (strcmp(pMapName, "middled1n") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME59);//"미들랜드 던젼" 
		return 22;
	}
	else if (strcmp(pMapName, "2ndmiddle") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME65);//"약속의 땅"
		return 23;
	}
	else if (strcmp(pMapName, "icebound") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME66);//"아이스맵"
		return 24;
	}
	else if (strcmp(pMapName, "cityhall_1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME35);//"아레스덴 시티홀"
		return -1;
	}
	else if (strcmp(pMapName, "cityhall_2") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME36);//"엘바인 시티홀"
		return -1;
	}
	else if (strcmp(pMapName, "gldhall_1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME37);//"아레스덴 길드홀"
		return -1;
	}
	else if (strcmp(pMapName, "gldhall_2") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME38);//"엘바인 길드홀" 
		return -1;
	}
	else if (memcmp(pMapName, "bsmith_1", 8) == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME33);//"아레스덴 대장간"
		return -1;
	}
	else if (memcmp(pMapName, "bsmith_2", 8) == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME34);//"엘바인 대장간" 
		return -1;
	}
	else if (memcmp(pMapName, "gshop_1", 7) == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME39);//"아레스덴 잡화상점" 
		return -1;
	}
	else if (memcmp(pMapName, "gshop_2", 7) == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME40);//"엘바인 잡화상점"
		return -1;
	}
	else if (memcmp(pMapName, "wrhus_1", 7) == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME43);//"아레스덴 물품 보관소"
		return -1;
	}
	else if (memcmp(pMapName, "wrhus_2", 7) == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME44);//"엘바인 물품 보관소"
		return -1;
	}
	else if (strcmp(pMapName, "arewrhus") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME45);//"아레스덴 물품 보관소"
		return -1;
	}
	else if (strcmp(pMapName, "elvwrhus") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME46);//"엘바인 물품 보관소"
		return -1;
	}
	else if (strcmp(pMapName, "wzdtwr_1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME41);//"아레스덴 마법타워"
		return -1;
	}
	else if (strcmp(pMapName, "wzdtwr_2") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME42);//"엘바인 마법타워"
		return -1;
	}
	else if (strcmp(pMapName, "cath_1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME47);//"아레시엔의 성당"
		return -1;
	}
	else if (strcmp(pMapName, "cath_2") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME48);//"엘디니엘의 성당"
		return -1;
	}
	else if (strcmp(pMapName, "resurr1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME54);//"아레스덴의 부활의 공간"
		return -1;
	}
	else if (strcmp(pMapName, "resurr2") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME55);//"엘바인의 부활의 공간"
		return -1;
	}
	else if (strcmp(pMapName, "arebrk11") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME4);//"아레스덴 훈련소 지하 1층"
		return -1;
	}
	else if (strcmp(pMapName, "arebrk12") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME5);//"아레스덴 훈련소 지하 1층"
		return -1;
	}
	else if (strcmp(pMapName, "arebrk21") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME6);//"아레스덴 훈련소 지하 2층"
		return -1;
	}
	else if (strcmp(pMapName, "arebrk22") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME7);//"아레스덴 훈련소 지하 2층"
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk11") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME8);//"엘바인 훈련소 지하 1층"
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk12") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME9);//"엘바인 훈련소 지하 1층"
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk21") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME10);//"엘바인 훈련소 지하 2층"
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk22") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME11);//"엘바인 훈련소 지하 2층"
		return -1;
	}
	else if (strcmp(pMapName, "fightzone1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME12);//"1번 사투장"
		return -1;
	}
	else if (strcmp(pMapName, "fightzone2") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME13);//"2번 사투장"
		return -1;
	}
	else if (strcmp(pMapName, "fightzone3") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME14);//"3번 사투장"
		return -1;
	}
	else if (strcmp(pMapName, "fightzone4") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME15);//"4번 사투장"
		return -1;
	}
	else if (strcmp(pMapName, "fightzone5") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME16);//"5번 사투장"
		return -1;
	}
	else if (strcmp(pMapName, "fightzone6") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME17);//"6번 사투장"
		return -1;
	}
	else if (strcmp(pMapName, "fightzone7") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME18);//"7번 사투장"  
		return -1;
	}
	else if (strcmp(pMapName, "fightzone8") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME19);//"8번 사투장"
		return -1;
	}
	else if (strcmp(pMapName, "fightzone9") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME20);//"상어의 콜로세움 경기장"
		return -1;
	}
	else if (strcmp(pMapName, "arejail") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME63);//"아레스덴 감옥"
		return -1;
	}
	else if (strcmp(pMapName, "elvjail") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME64);//"엘바인 감옥"
		return -1;
	}
	else {
		strcpy(pName, pMapName);
		return -1;
	}
}

BOOL CGame::bCheckLocalChatCommand(char * pMsg)
{
 class  CStrTok * pStrTok = NULL;
 char   * token, cBuff[256], cTxt[120], cName[12], cTemp[120];
 char   seps[] = " \t\n";

	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(cName, sizeof(cName));
	strcpy(cBuff, pMsg);

	//2002.11.1 안상하 추가. 프레임 보여주기.
	if (memcmp(cBuff, "/showframe", 10)==0)
	{
		if(m_bShowFPS) m_bShowFPS = FALSE;
		else m_bShowFPS = TRUE;
		return TRUE;
	}

	//2002.12.27 안상하 추가. 화면모드 바꾸기.
	if (memcmp(cBuff, "/enabletogglescreen", 19)==0)
	{
		m_bToggleScreen = TRUE;
		return TRUE;
	}

	//2002.10.19 정진광 수정. 귓속말과 외치기 듣기/듣지 않기.
	if (memcmp(cBuff, "/whon", 5) == 0)
	{
		m_bWhisper = TRUE;
	    AddEventList(BCHECK_LOCAL_CHAT_COMMAND6, 10);//귓속말 듣기 기능이 활성화 되었습니다.
		return TRUE;
	}

	else if (memcmp(cBuff, "/whoff", 6) == 0)
	{
		m_bWhisper = FALSE;
	    AddEventList(BCHECK_LOCAL_CHAT_COMMAND7, 10);//귓속말 듣기 기능이 비활성화 되었습니다.
		return TRUE;
	}

	else if (memcmp(cBuff, "/shon", 5) == 0)
	{
		m_bShout = TRUE;
	    AddEventList(BCHECK_LOCAL_CHAT_COMMAND8, 10);//외치기 듣기 기능이 활성화 되었습니다.
		return TRUE;
	}

	else if (memcmp(cBuff, "/shoff", 6) == 0)
	{
		m_bShout = FALSE;
	    AddEventList(BCHECK_LOCAL_CHAT_COMMAND9, 10);//외치기 듣기 기능이 비활성화 되었습니다.
		return TRUE;
	}
    /////여기까지......

	// v2.11 성후니 변경 
	if (memcmp(cBuff, "/tooff", 6) == 0)
	{
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != NULL)
		{
			if (strlen(token) <= 10)
			{
				// 같은 이름을 가진 캐릭터가 리스트에 없다.
				strcpy(cName, token);
				if (memcmp(m_cPlayerName, cName, 10) == 0)
				{
					AddEventList(BCHECK_LOCAL_CHAT_COMMAND2, 10);//"자기 자신의 메시지를 수신 거부할 수는 없습니다."
					if (pStrTok != NULL) delete pStrTok;
					return TRUE;
				}
				if( m_pExID != NULL ) delete m_pExID;
				wsprintf(cTxt, BCHECK_LOCAL_CHAT_COMMAND3, token);//"캐릭터 %s: 메시지 수신 거부 리스트에 등록되었습니다."
				AddEventList(cTxt, 10);
				m_pExID = new class CMsg(NULL, token, NULL);
				if (pStrTok != NULL) delete pStrTok;
				return TRUE;
   			}
			else AddEventList(BCHECK_LOCAL_CHAT_COMMAND5, 10);//"메시지 수신을 거부하고자 하는 캐릭터 이름이 너무 깁니다."
		}
		if (pStrTok != NULL) delete pStrTok;
		return TRUE;
	}

	else if (memcmp(cBuff, "/toon", 5) == 0)
	{
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL)
		{
			if (strlen(token) <= 10)
			{
				strcpy(cName, token);
				if (m_pExID != NULL)
				{
					ZeroMemory(cTemp, sizeof(cTemp));
					strcpy(cTemp, m_pExID->m_pMsg);
					if (memcmp(cTemp, cName, 10) == 0)
					{
						// 이미 같은 이름이 리스트에 있다. 
						wsprintf(cTxt, BCHECK_LOCAL_CHAT_COMMAND1, token);//"캐릭터 %s: 메시지 수신 거부 리스트에서 제거 되었습니다."
						AddEventList(cTxt, 10);
						delete m_pExID;
						m_pExID = NULL;
						if (pStrTok != NULL) delete pStrTok;
						return TRUE;
					}
				}
   			}
			else AddEventList(BCHECK_LOCAL_CHAT_COMMAND5, 10);//"메시지 수신을 거부하고자 하는 캐릭터 이름이 너무 깁니다."
		}
		if (pStrTok != NULL) delete pStrTok;
		return TRUE;
	}

	if (pStrTok != NULL) delete pStrTok;
	return FALSE;
}

BOOL CGame::bCheckItemOperationEnabled(char cItemID)
{
	// 존재하지 않는 아이템이라면 리턴.
	if (m_pItemList[cItemID] == NULL) return FALSE;

	// 명령이 유효하지 않은 상태라면(죽었다거나) 명령을 수행할 수 없다.
	if (m_cCommand < 0) return FALSE;

	//정진광 수정, 텔레포트 요청이 들어왔다면 처리하지 않는다.
	if (m_bIsTeleportRequested == TRUE) return FALSE;
	
	// 비활성화 된 아이템은 떨어뜨릴 수 없다. 
	if (m_bIsItemDisabled[cItemID] == TRUE) return FALSE;

	// 아이템 판매 다이얼로그 활성화 되어 있다면 버릴 수 없다. 
	if ( m_bIsDialogEnabled[17] == TRUE ) {
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		            //"현재 아이템 관련 처리가 끝나지 않았습니다."
		return FALSE;
	}
	
	// v1.41
	if (m_bIsDialogEnabled[20] == TRUE) { 
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		             //"현재 아이템 관련 처리가 끝나지 않았습니다."
		return FALSE;
	}

	if (m_bIsDialogEnabled[23] == TRUE) {
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		            //"현재 아이템 관련 처리가 끝나지 않았습니다."
		return FALSE;
	}

	if (m_bIsDialogEnabled[26] == TRUE) {
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		             //"현재 아이템 관련 처리가 끝나지 않았습니다."
		return FALSE;
	}

	if (m_bIsDialogEnabled[27] == TRUE) {
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		            //"현재 아이템 관련 처리가 끝나지 않았습니다."
		return FALSE;
	}

	if (m_bIsDialogEnabled[31] == TRUE) {
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		             //"현재 아이템 관련 처리가 끝나지 않았습니다."
		return FALSE;
	}

	if (m_bIsDialogEnabled[4] == TRUE) {
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		             //"현재 아이템 관련 처리가 끝나지 않았습니다."
		return FALSE;
	}

	return TRUE;
}

void CGame::ClearSkillUsingStatus()
{
	if (m_bSkillUsingStatus == TRUE) {
		AddEventList(CLEAR_SKILL_USING_STATUS1, 10);//"기술 사용이 중지되었습니다." 
		// 스킬과 연관된 다이얼로그 박스를 모두 닫는다. 낚시, 연금술, 무기 제작 등등 
		DisableDialogBox(24);
		DisableDialogBox(26);
		// v2.14 죽은척 버그 수정중 
		if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/) {
			m_cCommand = DEF_OBJECTSTOP;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;
		}
	}
	m_bSkillUsingStatus = FALSE;
}


void CGame::NpcTalkHandler(char *pData)
{
 char  * cp, cRewardName[21], cTargetName[21], cTemp[21], cTxt[250];
 short * sp, sType, sResponse;
 int     iAmount, iIndex, iContribution, iX, iY, iRange;
 int     iTargetType, iTargetCount, iQuestionType;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	sp = (short *)cp;
	sType = *sp; // 이건 퀘스트의 Type이다. Quest의 Number가 아니다.
	cp += 2;

	sp = (short *)cp;
	sResponse = *sp;
	cp += 2;

	sp = (short *)cp;
	iAmount = *sp;
	cp += 2;

	sp = (short *)cp;
	iContribution = *sp;
	cp += 2;

	sp = (short *)cp;
	iTargetType = *sp;
	cp += 2;

	sp = (short *)cp;
	iTargetCount = *sp;
	cp += 2;

	sp = (short *)cp;
	iX = *sp;
	cp += 2;

	sp = (short *)cp;
	iY = *sp;
	cp += 2;

	sp = (short *)cp;
	iRange = *sp;
	cp += 2;

	ZeroMemory(cRewardName, sizeof(cRewardName));
	memcpy(cRewardName, cp, 20);
	cp += 20;

	ZeroMemory(cTargetName, sizeof(cTargetName));
	memcpy(cTargetName, cp, 20);
	cp += 20;

	EnableDialogBox(21, sResponse, sType, 0);

	if ((sType >= 1) && (sType <= 100)) {
		// sType이 1~100 사이이면 퀘스트 제의를 의미한다.
		// 퀘스트의 내용을 덛붙여 작성한다. 	
		iIndex = m_stDialogBoxInfo[21].sV1;
		m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
		iIndex++;

		iQuestionType = NULL;
		switch (sType) {
		case 1: //Monster Hunt
			ZeroMemory(cTemp, sizeof(cTemp));
			GetNpcName(iTargetType, cTemp);
			ZeroMemory(cTxt, sizeof(cTxt));
#if DEF_LANGUAGE == 4	//언어:English
			wsprintf(cTxt, NPC_TALK_HANDLER16, iTargetCount, cTemp);
#else
			wsprintf(cTxt, NPC_TALK_HANDLER16, cTemp, iTargetCount);//"목  표: %s %d마리 퇴치"
#endif
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
			iIndex++;
			
			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER17);//"위  치: 상관없음"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
				iIndex++;
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER18, cTemp);//"위  치: %s"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
				iIndex++;
				
				if (iX != 0) {
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, NPC_TALK_HANDLER19, iX, iY, iRange);//"좌  표: %d,%d 범위: %d 블록 이내"
					m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
					iIndex++;	
				}
				
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, NPC_TALK_HANDLER20, iContribution);//"공헌도: %dPoint"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
				iIndex++;	
			}
			iQuestionType = 1;
			break;

		case 7: // 적국 침투
			ZeroMemory(cTxt, sizeof(cTxt));
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, NPC_TALK_HANDLER21, NULL);//"목  표: 적국 침투 후 적들의 행동 관찰"  
			iIndex++;
			
			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER22);//"위  치: 상관없음"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
				iIndex++;
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER23, cTemp);//"위  치: %s"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
				iIndex++;
				
				if (iX != 0) {
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, NPC_TALK_HANDLER24, iX, iY, iRange);//"좌  표: %d,%d 범위: %d 블록 이내"
					m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
					iIndex++;	
				}
				
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, NPC_TALK_HANDLER25, iContribution);//"공헌도: %dPoint"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
				iIndex++;	
			}
			iQuestionType = 1;
			break;

		case 10: // Crusade용 일회성 임무. 후방 침투.
			ZeroMemory(cTxt, sizeof(cTxt));
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, NPC_TALK_HANDLER26, NULL);//"작전 내용: 적국 후방 침투."
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
            strcpy(cTxt, NPC_TALK_HANDLER27);//"적국의 후방 지역으로 곧바로 텔레포트"
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
            strcpy(cTxt, NPC_TALK_HANDLER28);//"하여 주요 시설 파괴를 시도하거나,"
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
            strcpy(cTxt, NPC_TALK_HANDLER29);//"게릴라 활동을 통하여 적들의 활동을"
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
            strcpy(cTxt, NPC_TALK_HANDLER30);//"방해하는 임무."
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
			strcpy(cTxt, " ");
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
			iIndex++;
			
			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER31);//"텔레포트 목적지: 예측 불가"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
				iIndex++;
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER32, cTemp);//"텔레포트 목적지: %s"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);	
				iIndex++;
			}
			iQuestionType = 2;
			break;
		}
		
		switch (iQuestionType) {
		case 1:
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, NPC_TALK_HANDLER33, NULL);//"""자네가 성공한다면 포상하겠네."
			iIndex++;
			m_pMsgTextList2[iIndex]  = new class CMsg(NULL, NPC_TALK_HANDLER34, NULL);//"어떤가, 한번 해 보겠나?"""
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
			iIndex++;
			break;

		case 2:
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, NPC_TALK_HANDLER35, NULL);//"""이 작전에 참가 하시겠습니까?"""
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
			iIndex++;
			break;

		default: break;
		}
	}
}

void CGame::GetNpcName(short sType, char *pName)
{
	switch (sType)
	{
	case 10: strcpy(pName, NPC_NAME_SLIME); break;//"슬라임"
	case 11: strcpy(pName, NPC_NAME_SKELETON); break;//"스켈레톤"
	case 12: strcpy(pName, NPC_NAME_STONEGOLEM); break;//"스톤 골렘"
	case 13: strcpy(pName, NPC_NAME_CYCLOPS); break;//"싸이클롭스"
	case 14: strcpy(pName, NPC_NAME_ORC); break;//"오크"
	case 15: strcpy(pName, NPC_NAME_SHOP_KEEPER); break;//"상점 주인"
	case 16: strcpy(pName, NPC_NAME_GIANTANT); break;//"자이안트 앤트"
	case 17: strcpy(pName, NPC_NAME_GIANTSCORPION); break;//"자이안트 스콜피온"
	case 18: strcpy(pName, NPC_NAME_ZOMBIE); break;//"좀비"
	case 19: strcpy(pName, NPC_NAME_MAGICIAN); break;//"마법사"
	case 20: strcpy(pName, NPC_NAME_WAREHOUSE_KEEPER); break;//"창고 주인"
	case 21: strcpy(pName, NPC_NAME_GUARD); break;//"경비병"
	case 22: strcpy(pName, NPC_NAME_SNAKE); break;//"쌍두뱀"
	case 23: strcpy(pName, NPC_NAME_CLAYGOLEM); break;//"클레이 골렘"
	case 24: strcpy(pName, NPC_NAME_BLACKSMITH_KEEPER); break;//"대장간 주인"
	case 25: strcpy(pName, NPC_NAME_CITYHALL_OFFICER); break;//"시청 행정관"
	case 26: strcpy(pName, NPC_NAME_GUILDHALL_OFFICER); break;//"길드조합 사무장" 
	case 27: strcpy(pName, NPC_NAME_HELHOUND); break;//"헬하운드"
	case 28: strcpy(pName, NPC_NAME_TROLL); break;//"트롤"
	case 29: strcpy(pName, NPC_NAME_OGRE); break;//"오우거"
	case 30: strcpy(pName, NPC_NAME_LICHE); break;//"리치"
	case 31: strcpy(pName, NPC_NAME_DEMON); break;//"데몬"
	case 32: strcpy(pName, NPC_NAME_UNICORN); break;//"유니콘"
	case 33: strcpy(pName, NPC_NAME_WEREWOLF); break;//"웨어울프" 
	case 34: strcpy(pName, NPC_NAME_DUMMY); break;//"더미"
	case 35: strcpy(pName, NPC_NAME_ENERGYSPHERE); break;//"에너지 스피어"
	case 36:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_ARROWGUARDTOWER_CK);//"애로우 가드 타워 컨스트럭션 키트"
		else strcpy(pName, NPC_NAME_ARROWGUARDTOWER);//"애로우 가드 타워"
		break;
	case 37:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_CANNONGUARDTOWER_CK);//"캐논 가드 타워 컨스트럭션 키트"
		else strcpy(pName, NPC_NAME_CANNONGUARDTOWER);//"캐논 가드 타워"
		break;
	case 38:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_MANACOLLECTOR_CK);//"마나 콜렉터 컨스트럭션 키트"
		else strcpy(pName, NPC_NAME_MANACOLLECTOR);//"마나 콜렉터"
		break;
	case 39:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_DETECTOR_CK);//"디텍터 컨스트럭션 키트"
		else strcpy(pName, NPC_NAME_DETECTOR);//"디텍터"
		break;
	case 40: strcpy(pName, NPC_NAME_ENERGYSHIELD); break;//"에너지 실드 제네레이터"  
	case 41: strcpy(pName, NPC_NAME_GRANDMAGICGENERATOR); break;//"그랜드 매직 제네레이터"
	case 42: strcpy(pName, NPC_NAME_MANASTONE); break;//"마나 스톤"
	case 43: strcpy(pName, NPC_NAME_LIGHTWARBEETLE); break;//"라이트 워 비틀"
	case 44: strcpy(pName, NPC_NAME_GODSHANDKNIGHT); break;//"고즈 핸드 나이트"
	case 45: strcpy(pName, NPC_NAME_GODSHANDKNIGHT_CK); break;//"고즈 핸드 나이트 기병"
	case 46: strcpy(pName, NPC_NAME_TEMPLEKNIGHT); break;//"템플 나이트"
	case 47: strcpy(pName, NPC_NAME_BATTLEGOLEM); break;//"배틀 골렘"
	case 48: strcpy(pName, NPC_NAME_STALKER); break;//"스타커"
	case 49: strcpy(pName, NPC_NAME_HELLCLAW); break;//"헬클라우"
	case 50: strcpy(pName, NPC_NAME_TIGERWORM); break;//"타이거웜"
	case 51: strcpy(pName, NPC_NAME_CATAPULT); break;//"캐터팔트"
	case 52: strcpy(pName, NPC_NAME_GARGOYLE); break;//"가고일"
	case 53: strcpy(pName, NPC_NAME_BEHOLDER); break;//"비홀더"
	case 54: strcpy(pName, NPC_NAME_DARKELF); break;//"다크 엘프"
	case 55: strcpy(pName, NPC_NAME_RABBIT); break;//"토끼"
	case 56: strcpy(pName, NPC_NAME_CAT); break;//"고양이"
	case 57: strcpy(pName, NPC_NAME_FROG); break;//"자이언트 프로그"
	case 58: strcpy(pName, NPC_NAME_MOUNTAIN_GIANT); break;//"마운틴 자이언트"
	case 59: strcpy(pName, NPC_NAME_ETTIN); break;//"에틴"
	case 60: strcpy(pName, NPC_NAME_CANNIBAL); break;//"카니발 플랜트"
	case 61: strcpy(pName, NPC_NAME_RUDOLPH); break;//"바이스루돌프"
	case 62: strcpy(pName, NPC_NAME_DIREBOAR); break;//"멧돼지"
	case 63: strcpy(pName, NPC_NAME_FROST); break;//"아이스팅커벨"
	case 64:
		{
			switch((_tmp_sAppr2 & 0xFF00)>>8)
			{
			case 1:
				strcpy(pName, NPC_NAME_WATERMELON);
				break;
			case 2:
				strcpy(pName, NPC_NAME_PUMPKIN);
				break;
			case 3:
				strcpy(pName, NPC_NAME_GARLIC);
				break;
			case 4:
				strcpy(pName, NPC_NAME_BARLEY);
				break;
			default:
				strcpy(pName, NPC_NAME_CROP);
				break;
			}
		}
		break;
	case 65: strcpy(pName, NPC_NAME_ICEGOLEM); break;//"아이스골렘"
	case 66: strcpy(pName, NPC_NAME_WYVERN); break;//"와이번"
	case 67: strcpy(pName, NPC_NAME_MCGAFFIN); break;//"청년"
	case 68: strcpy(pName, NPC_NAME_PERRY); break;//"처녀"
	case 69: strcpy(pName, NPC_NAME_DEVLIN); break;//"마을마법사"
	}
}

void CGame::GetItemName(CItem *pItem, char *pStr1, char *pStr2, char *pStr3)
{
 int i;
 char cTxt[256], cTxt2[256], cName[51];
 DWORD dwType1, dwType2, dwValue1, dwValue2, dwValue3;

 m_bIsSpecial = FALSE;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(pStr1, sizeof(pStr1));
	ZeroMemory(pStr2, sizeof(pStr2));
	ZeroMemory(pStr3, sizeof(pStr3));
	
	strcpy(cName, pItem->m_cName);
	for (i = 0; i < DEF_MAXITEMNAMES; i++)
	if ((m_pItemNameList[i] != NULL) && (strcmp(m_pItemNameList[i]->m_cOriginName, pItem->m_cName) == 0)) {
		strcpy(cName, m_pItemNameList[i]->m_cName);
		break;
	}

	if ((pItem->m_dwAttribute & 0x00000001) != 0) {
		// Custom Made Item이다.
		m_bIsSpecial = TRUE;
		strcpy(pStr1, cName);
		if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) 
			wsprintf(pStr2, GET_ITEM_NAME1, pItem->m_sItemSpecEffectValue2);//"순도:%d%% "
		else wsprintf(pStr2, GET_ITEM_NAME2, pItem->m_sItemSpecEffectValue2 +100);//"완성도:%d%% "
	}
	else
	{
		if (pItem->m_dwCount == 1)
			wsprintf(G_cTxt, "%s", cName);
#if DEF_LANGUAGE == 4	//언어:English
		else wsprintf(G_cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, pItem->m_dwCount, cName);
#else
		else wsprintf(G_cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, cName, pItem->m_dwCount);
#endif
		strcpy(pStr1, G_cTxt);
	}
		
	if ((pItem->m_dwAttribute & 0x00F0F000) != 0) {
		// 희귀 아이템이다.
		m_bIsSpecial = TRUE;
		dwType1  = (pItem->m_dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		
		dwType2  = (pItem->m_dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (pItem->m_dwAttribute & 0x00000F00) >> 8;
		
		if (dwType1 != 0) {
			
			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1) {
			case 1: strcpy(cTxt, GET_ITEM_NAME3);   break;//"필살의 "
			case 2: strcpy(cTxt, GET_ITEM_NAME4);   break;//"중독의 "
			case 3: strcpy(cTxt, GET_ITEM_NAME5);   break;//"정의의 "
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME6);   break;//"민첩의 "
			case 6: strcpy(cTxt, GET_ITEM_NAME7);   break;//"가벼운 "
			case 7: strcpy(cTxt, GET_ITEM_NAME8);   break;//"예리한 "
			case 8: strcpy(cTxt, GET_ITEM_NAME9);   break;//"강화된 "
			case 9: strcpy(cTxt, GET_ITEM_NAME10);  break;//"고대문명의 "
			case 10: strcpy(cTxt, GET_ITEM_NAME11); break;//"마법성공의 "
			case 11: strcpy(cTxt, GET_ITEM_NAME12); break;//"마나변환의 "
			case 12: strcpy(cTxt, GET_ITEM_NAME13); break;//"필살충전의 "
			}
			strcat(cTxt, pStr1);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt);
			
			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1) {
			case 1: wsprintf(cTxt, GET_ITEM_NAME14, dwValue1); break;//"필살기 타격치 +%d "
			case 2: wsprintf(cTxt, GET_ITEM_NAME15, dwValue1*5); break;//"중독 타격치 +%d "
			case 3: break;
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME16); break;//"공격속도 -1 단축 "
			case 6: wsprintf(cTxt, GET_ITEM_NAME17, dwValue1*4); break;//"무게 %d%% 경량화 "
			case 7: strcpy(cTxt, GET_ITEM_NAME18); break;//"최대 타격치 증가 "
			case 8: wsprintf(cTxt, GET_ITEM_NAME19, dwValue1*7); break;//"수명 %d%% 증가 "
			case 9: strcpy(cTxt, GET_ITEM_NAME20); break;//"최대 타격치 증가 "
			case 10: wsprintf(cTxt, GET_ITEM_NAME21, dwValue1*3); break;//"마법 성공률 +%d%% 증가"
			case 11: wsprintf(cTxt, GET_ITEM_NAME22, dwValue1); break; //"피격시 %d%% 마나로 변환"
			case 12: wsprintf(cTxt, GET_ITEM_NAME23, dwValue1); break; //"피격시 필살기 충전 %d%%"
			}
			strcat(pStr2, cTxt);
			
			if (dwType2 != 0) {
				ZeroMemory(cTxt, sizeof(cTxt));
				switch (dwType2) {
				case 1:  wsprintf(cTxt, GET_ITEM_NAME24, dwValue2*7); break;//"독성저항 +%d%%"
				case 2:  wsprintf(cTxt, GET_ITEM_NAME25, dwValue2*7); break;//"공격명중 +%d"
				case 3:  wsprintf(cTxt, GET_ITEM_NAME26, dwValue2*7); break;//"물리방어 +%d"
				case 4:  wsprintf(cTxt, GET_ITEM_NAME27, dwValue2*7); break;//"HP회복 %d%% 증가"
				case 5:  wsprintf(cTxt, GET_ITEM_NAME28, dwValue2*7); break;//"SP회복 %d%% 증가"
				case 6:  wsprintf(cTxt, GET_ITEM_NAME29, dwValue2*7); break;//"MP회복 %d%% 증가"
				case 7:  wsprintf(cTxt, GET_ITEM_NAME30, dwValue2*7); break;//"마법저항 +%d%%"
				case 8:  wsprintf(cTxt, GET_ITEM_NAME31, dwValue2*3); break;//"물리공격 타격치 흡수 %d%%"
				case 9:  wsprintf(cTxt, GET_ITEM_NAME32, dwValue2*3); break;//"마법공격 타격치 흡수 %d%%"
				case 10: wsprintf(cTxt, GET_ITEM_NAME33, dwValue2);   break;//"연속 타격치 +%d "
				case 11: wsprintf(cTxt, GET_ITEM_NAME34, dwValue2*10); break;//"경험치 +%d%% "
				case 12: wsprintf(cTxt, GET_ITEM_NAME35, dwValue2*10); break;//"Gold +%d%% "
				}
				strcpy(pStr3, cTxt);
			}
		}
	}

	dwValue3 = (pItem->m_dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0) {
		// 만약 이미 아이템 이름에 +가 붙어 있다면 
		if (pStr1[strlen(pStr1)-2] == '+') {
			dwValue3 = atoi((char *)(pStr1 + strlen(pStr1)-1)) + dwValue3;
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1)-2);
			ZeroMemory(cTxt2, sizeof(cTxt2));
			wsprintf(cTxt2, "%s+%d", cTxt, dwValue3);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt2);
		}
		else {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
		}
	}
}

void CGame::GetItemName(char * cItemName, DWORD dwAttribute, char *pStr1, char *pStr2, char *pStr3)
{
 int i;
 char cTxt[256], cTxt2[256], cName[51];
 DWORD dwType1, dwType2, dwValue1, dwValue2, dwValue3;
	
 m_bIsSpecial = FALSE;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(pStr1, sizeof(pStr1));
	ZeroMemory(pStr2, sizeof(pStr2));
	ZeroMemory(pStr3, sizeof(pStr3));
		
	strcpy(cName, cItemName);
	for (i = 0; i < DEF_MAXITEMNAMES; i++)
	if ((m_pItemNameList[i] != NULL) && (strcmp(m_pItemNameList[i]->m_cOriginName, cItemName) == 0)) {
		strcpy(cName, m_pItemNameList[i]->m_cName);
		break;
	}

	strcpy(pStr1, cName);

	if ((dwAttribute & 0x00F0F000) != 0) {
		// 희귀 아이템이다.
		m_bIsSpecial = TRUE;
		dwType1  = (dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (dwAttribute & 0x000F0000) >> 16;
		
		dwType2  = (dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (dwAttribute & 0x00000F00) >> 8;
		
		if (dwType1 != 0) {
			
			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1) {
			case 1: strcpy(cTxt, GET_ITEM_NAME3); break;//"필살의 "
			case 2: strcpy(cTxt, GET_ITEM_NAME4); break;//"중독의 "
			case 3: strcpy(cTxt, GET_ITEM_NAME5); break;//"정의의 "
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME6); break;//"민첩의 "
			case 6: strcpy(cTxt, GET_ITEM_NAME7); break;//"가벼운 "
			case 7: strcpy(cTxt, GET_ITEM_NAME8); break;//"예리한 "
			case 8: strcpy(cTxt, GET_ITEM_NAME9); break;//"강화된 "
			case 9: strcpy(cTxt, GET_ITEM_NAME10); break;//"고대문명의 "
			case 10: strcpy(cTxt, GET_ITEM_NAME11); break;//"마법성공의 "
			case 11: strcpy(cTxt, GET_ITEM_NAME12); break;//"마나변환의 "
			case 12: strcpy(cTxt, GET_ITEM_NAME13); break;//"필살충전의 "
			}
			strcat(cTxt, pStr1);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt);
			
			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1) {
			case 1: wsprintf(cTxt, GET_ITEM_NAME14, dwValue1); break;//"필살기 타격치 +%d "
			case 2: wsprintf(cTxt, GET_ITEM_NAME15, dwValue1*5); break;//"중독 타격치 +%d "
			case 3: break;
			case 4: break;
			case 5: strcpy(cTxt, GET_ITEM_NAME16); break;//"공격속도 -1 단축 "
			case 6: wsprintf(cTxt, GET_ITEM_NAME17, dwValue1*4); break;//"무게 %d%% 경량화 "
			case 7: strcpy(cTxt, GET_ITEM_NAME18); break;//"최대 타격치 증가 "
			case 8: wsprintf(cTxt, GET_ITEM_NAME19, dwValue1*7); break;//"수명 %d%% 증가 "
			case 9: strcpy(cTxt, GET_ITEM_NAME20); break;//"최대 타격치 증가 "
			case 10: wsprintf(cTxt, GET_ITEM_NAME21, dwValue1*3); break;//"마법 성공률 +%d%% 증가"
			case 11: wsprintf(cTxt, GET_ITEM_NAME22, dwValue1); break;//"피격시 %d%% 마나로 변환"
			case 12: wsprintf(cTxt, GET_ITEM_NAME23, dwValue1); break;//"피격시 필살기 충전 %d%%"
			}
			strcat(pStr2, cTxt);
			
			if (dwType2 != 0) {
				ZeroMemory(cTxt, sizeof(cTxt));
				switch (dwType2) {
				case 1:  wsprintf(cTxt, GET_ITEM_NAME24, dwValue2*7);  break;//"독성저항 +%d%%"
				case 2:  wsprintf(cTxt, GET_ITEM_NAME25, dwValue2*7);  break;//"공격명중 +%d"
				case 3:  wsprintf(cTxt, GET_ITEM_NAME26, dwValue2*7);  break;//"물리방어 +%d"
				case 4:  wsprintf(cTxt, GET_ITEM_NAME27, dwValue2*7);  break;//"HP회복 %d%% 증가"
				case 5:  wsprintf(cTxt, GET_ITEM_NAME28, dwValue2*7);  break;//"SP회복 %d%% 증가"
				case 6:  wsprintf(cTxt, GET_ITEM_NAME29, dwValue2*7);  break;//"MP회복 %d%% 증가"
				case 7:  wsprintf(cTxt, GET_ITEM_NAME30, dwValue2*7);  break;//"마법저항 +%d%%"
				case 8:  wsprintf(cTxt, GET_ITEM_NAME31, dwValue2*3);  break;//"물리공격 타격치 흡수 %d%%"
				case 9:  wsprintf(cTxt, GET_ITEM_NAME32, dwValue2*3);  break;//"마법공격 타격치 흡수 %d%%"
				case 10: wsprintf(cTxt, GET_ITEM_NAME33, dwValue2);    break;//"연속 타격치 +%d "
				case 11: wsprintf(cTxt, GET_ITEM_NAME34, dwValue2*10); break;//"경험치 +%d%% "
				case 12: wsprintf(cTxt, GET_ITEM_NAME35, dwValue2*10); break;//"Gold +%d%% "
				}
				strcpy(pStr3, cTxt);
			}
		}
	}

	dwValue3 = (dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0) {
		// 만약 이미 아이템 이름에 +가 붙어 있다면 
		if (pStr1[strlen(pStr1)-2] == '+') {
			dwValue3 = atoi((char *)(pStr1 + strlen(pStr1)-1)) + dwValue3;
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1)-2);
			ZeroMemory(cTxt2, sizeof(cTxt2));
			wsprintf(cTxt2, "%s+%d", cTxt, dwValue3);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt2);
		}
		else {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
		}
	}
}

void CGame::_CalcSocketClosed()
{
	if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME) {
		// 게임중에 과금 소켓이 끊긴것이므로 비정상적인 사용자다. 게임 접속 종료 
		delete m_pGSock;
		m_pGSock = NULL;
		m_bEscPressed = FALSE;
		PlaySound('E', 14, 5);
		// 비소리 루핑 스톱 
		if (m_bSoundFlag) m_pESound[38]->bStop();
		// 배경음악 스톱
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE)) {
			if (m_pBGM != NULL) m_pBGM->bStop();
		}
		// 과금 서비스므로 무조건 종료 		
		ChangeGameMode(DEF_GAMEMODE_ONQUIT);
	}
}

void CGame::PointCommandHandler(int indexX, int indexY, char cItemID)
{
 char cTemp[31];
// 상하천재
	if ((m_iPointCommandType >= 100) && (m_iPointCommandType < 200)) {
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_MAGIC, NULL, indexX, indexY, m_iPointCommandType, NULL);
	}
	else if ((m_iPointCommandType >= 0) && (m_iPointCommandType < 50)) {
		// m_iPointCommandType이 0보다 크고 50보다 작으면 기술과 연관된 아이템 사용이다. 
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, m_iPointCommandType, indexX, indexY, cTemp, cItemID); // v1.4 
				
		if (m_pItemList[m_iPointCommandType]->m_cItemType == DEF_ITEMTYPE_USE_SKILL)
			m_bSkillUsingStatus = TRUE; // 지금부터 기술을 사용중이다. 움직이거나 하면 무효화된다!!!!

	}
	else if (m_iPointCommandType == 200) {
		// 파티 지정 모드 : 캐릭터 이름 m_cMCName을 파티로 지정한다.
		if ((strlen(m_cMCName) == 0) || (strcmp(m_cMCName, m_cPlayerName) == 0) || (m_cMCName[0] == '_')) {
			m_stDialogBoxInfo[32].cMode = 0;
			PlaySound('E', 14, 5);

			AddEventList(POINT_COMMAND_HANDLER1, 10);//"참가하고자 하는 파티의 캐릭터가 선택되지 않았습니다. 파티 참가를 할 수 없습니다."
		}
		else {
			m_stDialogBoxInfo[32].cMode = 3;
			PlaySound('E', 14, 5);
			ZeroMemory(m_stDialogBoxInfo[32].cStr, sizeof(m_stDialogBoxInfo[32].cStr));
			strcpy(m_stDialogBoxInfo[32].cStr, m_cMCName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, NULL, 1, NULL, NULL, m_cMCName);
			return;
		}
	}
}

void CGame::UpdateScreen_OnGame()
{
 short sVal, sDivX, sModX, sDivY, sModY, sPivotX, sPivotY, sVPXsave, sVPYsave;
 static int  iUpdateRet = -1; 
 short msX, msY, msZ, absX, absY, tX, tY;
 char cLB, cRB;
 char cItemColor;
 int  i, iAmount;
 DWORD dwTime = timeGetTime();
 static DWORD dwPrevChatTime = 0;
 static int   imX = 0, imY = 0;

	// 최초로 해 주어야 할 작업 ---------------------------
	if (m_cGameModeCount == 0) {
		
#if DEF_LANGUAGE == 3
		// 과금용 소켓 연결용
		if ((strlen(G_cCmdLineTokenA) != NULL) && (G_pCalcSocket == NULL)) {
			unsigned uAddr;
			_beginthreadex(0, 0, ThreadProc, 0, 0, &uAddr);
		}
#endif
		m_DDraw.ClearBackB4();
		m_dwFPStime = m_dwCheckConnTime = m_dwCheckSprTime = m_dwCheckChatTime = dwTime;
		m_sFrameCount = 0;
		if( m_bMusicStat ) StartBGM();
		if(m_iLevel < 40) AddEventList(UPDATE_SCREEN_ONGAME12, 10);//"F1키를 누르면 도움말을 볼 수 있습니다."
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 20) m_cGameModeCount = 20;
	// ----------------------------------------------------
	
	// 마우스 커서의 좌표를 갱신한다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_dwCurTime = timeGetTime();
		
	if (m_bEnterPressed == TRUE)
	{
		// 엔터키가 눌렸다. 채팅메시지 전송할 내용이 있으면 보낸다. 
		m_bEnterPressed = FALSE;

		if ((m_bIsDialogEnabled[7] == TRUE) && (m_stDialogBoxInfo[7].cMode == 1) && (iGetTopDialogBoxIndex() == 7)) {
			// 새 길드 생성 메뉴입력중 엔터키가 눌렸다.
			// "NONE"이라는 이름은 사용할 수 없다.
			
			EndInputString();

			m_bEnterPressed = FALSE;
			if (strlen(m_cGuildName) == 0) return;
			if (strcmp(m_cGuildName, "NONE") != 0) {
				bSendCommand(MSGID_REQUEST_CREATENEWGUILD, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL); 
				m_stDialogBoxInfo[7].cMode = 2;	
				//
			}
		}
		else if ((m_bIsDialogEnabled[17] == TRUE) && (m_stDialogBoxInfo[17].cMode == 1) && (iGetTopDialogBoxIndex() == 17)) {
			// Drop Item Query 

			EndInputString();
			
			// 스킬을 사용하고 있다면 
			// 아이템 판매 다이얼로그 활성화 되어 있다면 버릴 수 없다. 
			if (m_bSkillUsingStatus == TRUE) {
				AddEventList(UPDATE_SCREEN_ONGAME1, 10);//"현재 아이템 관련 처리가 끝난 후 아이템을 버리거나 줄 수 있습니다."
				return;
			}

			if ( (m_bIsDialogEnabled[20] == TRUE) && 
				 ((m_stDialogBoxInfo[20].cMode == 1) || (m_stDialogBoxInfo[20].cMode == 2)) ) {
				AddEventList(UPDATE_SCREEN_ONGAME1, 10);//"현재 아이템 관련 처리가 끝난 후 아이템을 버리거나 줄 수 있습니다."
				return;
			}
	
			if ( (m_bIsDialogEnabled[4] == TRUE) || (m_bIsDialogEnabled[23] == TRUE) || (m_bIsDialogEnabled[26] == TRUE)) {
				AddEventList(UPDATE_SCREEN_ONGAME1, 10);//"현재 아이템 관련 처리가 끝난 후 아이템을 버리거나 줄 수 있습니다."
				return;
			}

			if (strlen(m_cAmountString) == 0) return;
			iAmount = atoi(m_cAmountString);

			// v2.1 12-22 가지고 있는 아이템 보다 팔려는 아이템이 많으면 자동 수정
			if ((int)(m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount) < iAmount){
				iAmount = m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount ;
			}

			if (iAmount != 0) {
				if ((int)(m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount) >= iAmount) {
					if (m_stDialogBoxInfo[17].sV1 != NULL) {
						// 누군가에게 아이템을 주거나, 물건을 사는 NPC라면 파는 액션을 취해야 한다.
						absX = abs(m_stDialogBoxInfo[17].sV1 - m_sPlayerX);
						absY = abs(m_stDialogBoxInfo[17].sV2 - m_sPlayerY);
						
						if ((absX == 0)	&& (absY ==0))
							AddEventList(UPDATE_SCREEN_ONGAME5, 10);	
						                //"자기 자신에게 아이템을 줄 수는 없습니다."
						else if ((absX <= 8) && (absY <= 8)) { // v1.4334 아이템 교환이나 주는 거리를 늘린다.
							// 커서가 가리키는 오브젝트 타입.
							switch (m_stDialogBoxInfo[17].sV3) {
							case 1:
							case 2:
							case 3:
							case 4:
							case 5:
							case 6:
								EnableDialogBox(20, 1, m_stDialogBoxInfo[17].sView, m_stDialogBoxInfo[17].sV3);			// 그냥준다 : 교환한다
								m_stDialogBoxInfo[20].sV3 = iAmount;			// 그냥 주거나 교환할 아이템 갯수
								m_stDialogBoxInfo[20].sV4 = m_wCommObjectID;	// v1.4
								m_stDialogBoxInfo[20].sV5 = m_stDialogBoxInfo[17].sV1;
								m_stDialogBoxInfo[20].sV6 = m_stDialogBoxInfo[17].sV2;
					
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;

								ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
								strcpy(m_stDialogBoxInfo[20].cStr, m_stDialogBoxInfo[17].cStr);
								break;

							case 20:
								// 창고 주인. 맡긴다는 메시지 박스를 띄운다.
								EnableDialogBox(20, 3, m_stDialogBoxInfo[17].sView, m_stDialogBoxInfo[17].sV3);
								m_stDialogBoxInfo[20].sV3 = iAmount;			// 맡길 아이템 갯수
								m_stDialogBoxInfo[20].sV4 = m_wCommObjectID;	// v1.4
								m_stDialogBoxInfo[20].sV5 = m_stDialogBoxInfo[17].sV1;
								m_stDialogBoxInfo[20].sV6 = m_stDialogBoxInfo[17].sV2;
					
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;

								ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
								GetNpcName(m_stDialogBoxInfo[17].sV3, m_stDialogBoxInfo[20].cStr);
								break;

							case 15: // 상점 아줌마 
		  					case 24: // 대장간 주인 
								EnableDialogBox(20, 2, m_stDialogBoxInfo[17].sView, m_stDialogBoxInfo[17].sV3);
								// 팔 아이템 갯수 
								m_stDialogBoxInfo[20].sV3 = iAmount;
								m_stDialogBoxInfo[20].sV4 = m_wCommObjectID;
								
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;

								ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
								GetNpcName(m_stDialogBoxInfo[17].sV3, m_stDialogBoxInfo[20].cStr);
								break;
							
							case 1000:
								// 이것은 교환창에 드롭된 상태다. 서버로 메시지를 전송한다. 
								
								// 일단 화면상에 아이템을 보이고
								m_stDialogBoxInfo[27].sV1 = m_pItemList[m_stDialogBoxInfo[17].sV4]->m_sSprite;
								m_stDialogBoxInfo[27].sV2 = m_pItemList[m_stDialogBoxInfo[17].sV4]->m_sSpriteFrame;
								m_stDialogBoxInfo[27].sV3 = iAmount;
								m_stDialogBoxInfo[27].sV4 = m_pItemList[m_stDialogBoxInfo[17].sV4]->m_cItemColor;
																	
								// 서버로 메시지 전송 
								bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETEXCHANGEITEM, NULL, m_stDialogBoxInfo[17].sV4, iAmount, NULL, NULL);
								break;

							case 1001:
								// Sell List 다이알로그에 드롭된 것이다.
								for (i = 0; i < DEF_MAXSELLLIST; i++)
								if (m_stSellItemList[i].iIndex == -1) {
									m_stSellItemList[i].iIndex = m_stDialogBoxInfo[17].sV4;	// 아이디 설정 
									m_stSellItemList[i].iAmount = iAmount;					// 갯수 설정
									m_bIsItemDisabled[m_stDialogBoxInfo[17].sV4] = TRUE;	// 아이템 비활성화
									break;
								}
								if( i == DEF_MAXSELLLIST ) AddEventList(UPDATE_SCREEN_ONGAME6, 10);//"12개 이상의 아이템을 동시에 팔 수 없습니다."								            
								break;

							case 1002: // 창고주인에게 수량이 있는 아이템을 맡기는 거다.
								if (_iGetBankItemCount() >= (DEF_MAXBANKITEMS-1)) AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);//"아이템을 더 맡길 공간이 없습니다."
								else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_stDialogBoxInfo[39].sV1, iAmount, m_stDialogBoxInfo[39].sV5, m_stDialogBoxInfo[39].sV6, m_pItemList[m_stDialogBoxInfo[39].sV1]->m_cName, m_stDialogBoxInfo[39].sV4); //v1.4
								break;

							default:
								bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, (char)(m_stDialogBoxInfo[17].sView), iAmount, m_stDialogBoxInfo[17].sV1, m_stDialogBoxInfo[17].sV2, m_pItemList[m_stDialogBoxInfo[17].sView]->m_cName); 
								break;
							}
														
							// 아이템 관련 응답이 오기 전까지는 이 아이템을 선택할 수 없다. 
							m_bIsItemDisabled[m_stDialogBoxInfo[17].sView] = TRUE;
		   				}
						else AddEventList(UPDATE_SCREEN_ONGAME7, 10);
						                  //"아이템을 전달하기에는 거리가 너무 멉니다."
					}
					else {
						if (iAmount <= 0) {
							AddEventList(UPDATE_SCREEN_ONGAME8, 10);
							             //"입력된 아이템의 수량이 정확하지 않습니다."
						}
						else {
							bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_ITEMDROP, NULL, m_stDialogBoxInfo[17].sView, iAmount, NULL, m_pItemList[m_stDialogBoxInfo[17].sView]->m_cName); 
							// 아이템 관련 응답이 오기 전까지는 이 아이템을 선택할 수 없다. 
							m_bIsItemDisabled[m_stDialogBoxInfo[17].sView] = TRUE;
						}
					}
				}
				else {
					// 갖고 있는 아이템의 양보다 더 많은 양은 버릴 수 없다. 
					AddEventList(UPDATE_SCREEN_ONGAME9, 10);//"입력된 갯수가 갖고 있는 아이템의 갯수보다 많습니다."
				}
			}
			else {
				// 0 값을 입력했으므로 무시. 
			}
			DisableDialogBox(17);
			//
		}
		else {
			// 일반 게임 채팅 메시지
			if (!m_bInputStatus) {
				switch( m_cBackupChatMsg[0] )
				{
				case '!':
				case '@':
				case '#':
				case '$':
				case '^':
					ZeroMemory(m_cChatMsg, sizeof(m_cChatMsg));
					m_cChatMsg[0] = m_cBackupChatMsg[0];
					StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg); 
					break;
				default:
					StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg); 
					ClearInputString();
					break;
				}
			}
			else {
				EndInputString();
				ZeroMemory(G_cTxt, sizeof(G_cTxt));
				ReceiveString((char *)G_cTxt);
				ZeroMemory(m_cBackupChatMsg, sizeof(m_cBackupChatMsg));
				strcpy(m_cBackupChatMsg, G_cTxt);
				if ((m_dwCurTime - dwPrevChatTime) < 700) {
				}
				else {
					dwPrevChatTime = m_dwCurTime;
#if DEF_LANGUAGE > 2	//한국,영문,일문에 대해 욕 컨버트한다..
					m_curse.ConvertString( G_cTxt, strlen(G_cTxt) );
#endif
					if ( strlen(G_cTxt) > 0 )
					{
#if DEF_LANGUAGE == 4
						if( (G_cTxt[0]=='!') || (G_cTxt[0]=='~'))
						{	//영문일경우 전체,같은편 외치기는 IME스트링을 쓸 수 없다.
							if( m_Misc.bCheckIMEString(G_cTxt) == FALSE ) return;
						}
#endif
						bSendCommand(MSGID_COMMAND_CHATMSG, NULL, NULL, NULL, NULL, NULL, G_cTxt);
					}
				}
			}
		}
	}

	// 카메라 시점 이동때문에 임시로 저장한다.
	sVPXsave = m_sViewPointX;
	sVPYsave = m_sViewPointY;

	// 카메라 흔들림 효과 추가 
	if ((m_iCameraShakingDegree > 0) && (iUpdateRet != 0)) {
		m_sViewPointX += m_iCameraShakingDegree - (rand() % m_iCameraShakingDegree*2);
		m_sViewPointY += m_iCameraShakingDegree - (rand() % m_iCameraShakingDegree*2);

		m_iCameraShakingDegree--;
		if (m_iCameraShakingDegree <= 0) m_iCameraShakingDegree = 0;
	}

	sPivotX = m_pMapData->m_sPivotX;
	sPivotY = m_pMapData->m_sPivotY;

	sVal = m_sViewPointX - (sPivotX*32);
	sDivX = sVal / 32;
	sModX = sVal % 32;
	
	sVal = m_sViewPointY - (sPivotY*32);
	sDivY = sVal / 32;
	sModY = sVal % 32;
		
	// 배경 타일을 그린다.
	if (iUpdateRet != 0) 
		DrawBackground(sDivX, sModX, sDivY, sModY);	
	
	if (iUpdateRet != 0)
		DrawEffectLights();

	// 오브젝트를 그린다. 
	if (iUpdateRet != 0)
		DrawObjects(sPivotX, sPivotY, sDivX, sDivY, sModX, sModY, msX, msY);

	if (iUpdateRet != 0) {
		DrawEffects();
		DrawWhetherEffects();
		DrawChatMsgs(-100, 0, 800, 600);
		WhetherObjectFrameCounter();
	}
	
	// 다이얼로그 박스를 그린다. 
	if (iUpdateRet != 0)
		DrawDialogBoxs(msX, msY, msZ, cLB);

	// 채팅 메시지가 있다면 출력한다.
	if ((iUpdateRet != 0) && m_bInputStatus) {
		if (((m_bIsDialogEnabled[7] == TRUE) && (m_stDialogBoxInfo[7].cMode == 1)) ||
			((m_bIsDialogEnabled[17] == TRUE) && (m_stDialogBoxInfo[17].cMode == 1)) ) {
		}
		else m_DDraw.DrawShadowBox(0, 413, 639, 429);
		ShowReceivedString();
	}

	// 이벤트 리스트를 출력한다.
	if (iUpdateRet != 0)
		ShowEventList(m_dwCurTime);// v1.411 글자가 가리는 것을 막기 위함.

	// 마우스 커서 처리 부분
	if ( (iUpdateRet != 0) && (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM) && 
		 (m_pItemList[m_stMCursor.sSelectedObjectID] != NULL) ) {
		// 드래깅중인 아이템이 있다면 그린다.
		
		// 아이템 이미지 그리고 
		cItemColor = m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemColor;
		
		if (cItemColor != 0) {
			if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_LHAND) ||
				(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_RHAND) ||
				(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
		
				// 무기 및 방패의 색은 다른 세트를 사용한다.
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->PutSpriteRGB(msX - m_stMCursor.sDistX, msY - m_stMCursor.sDistY,
					                                                  m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame, 
																	  m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0],
																	  dwTime);
			}
			else {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->PutSpriteRGB(msX - m_stMCursor.sDistX, msY - m_stMCursor.sDistY,
					                                                  m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame, 
																	  m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0],
																	  dwTime);
			}
		}
		else m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->PutSpriteFast(msX - m_stMCursor.sDistX, msY - m_stMCursor.sDistY,
					                                                  m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame, dwTime);
		
		// 드래깅중인 아이템 이름 그린다.
		char cStr1[64], cStr2[64], cStr3[64];
		int  iLoc;
		GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);

		iLoc = 0;
		if (strlen(cStr1) != 0) {
			if(m_bIsSpecial)
				PutString(msX, msY +25, cStr1, RGB(0,255,50), FALSE, 1); //특수 아이템은 연두색이름
			else
				PutString(msX, msY +25, cStr1, RGB(255,255,255), FALSE, 1); // 보통 아이템은 흰 색 이름
			iLoc += 15;
		}

		if (strlen(cStr2) != 0) {
			PutString(msX, msY +25 +iLoc, cStr2, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}

		if (strlen(cStr3) != 0) {
			PutString(msX, msY +25 +iLoc, cStr3, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}

		if ( (m_pItemList[m_stMCursor.sSelectedObjectID]->m_sLevelLimit != 0) && ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_dwAttribute & 0x00000001) == 0) ) {
			wsprintf(G_cTxt, "%s: %d", DRAW_DIALOGBOX_SHOP24, m_pItemList[m_stMCursor.sSelectedObjectID]->m_sLevelLimit);//"레벨 제한: %d"
			PutString(msX, msY +25 +iLoc, G_cTxt, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}

		if( (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos != DEF_EQUIPPOS_NONE) && (m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight>=1100) ) {

			//정진광 수정...
			// 정진 왈 2001도 21. 2099도 21이라는 흐흐흐..
			int		_wWeight = 0;
			if(m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight%100)				_wWeight = 1;
			wsprintf( G_cTxt, DRAW_DIALOGBOX_SHOP15, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight/100 + _wWeight);

			PutString(msX, msY +25 +iLoc, G_cTxt, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}

		if (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos != DEF_EQUIPPOS_NONE) {
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME10, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wCurLifeSpan);//"남은 수명: %d"
			PutString(msX, msY +25 +iLoc, G_cTxt, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}

#if DEF_LANGUAGE == 3
		if (!strcmp(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, "스톤오브새크리파이스")) {
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME10, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wCurLifeSpan);//"남은 수명: %d"
			PutString(msX, msY +25 +iLoc, G_cTxt, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}
#endif

#if DEF_LANGUAGE == 3
		if ( m_pItemList[m_stMCursor.sSelectedObjectID]->m_sItemSpecEffectValue2 == 113 )
		{
			wsprintf(G_cTxt, "3주년 이벤트용" );
			PutString(msX, msY +25 +iLoc, G_cTxt, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}
#endif

		if ( iLoc == 15 )
		{
			iLoc = 0;
			for ( int iTmp = 0 ; iTmp < DEF_MAXITEMS ; iTmp++ )
			{
				if( m_pItemList[iTmp] != NULL )
				{
					if( strcmp(m_pItemList[iTmp]->m_cName, m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName ) == 0 ) iLoc++;
				}
			}
			if( iLoc > 1 )
			{
				wsprintf(G_cTxt, DEF_MSG_TOTAL_NUMBER, iLoc); //"총 %d개"
				PutString(msX, msY + 40, G_cTxt, RGB(150,150,150), FALSE, 1);
			}
		}
	}

#ifdef DEF_HTMLCOMMOM	//	mando..
	// v1.432 헬프 메시지
	if (m_bIsF1HelpWindowEnabled) {
		m_pSprite[DEF_SPRID_INTERFACE_F1HELPWINDOWS]->PutSpriteFast(23,90, 0, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_F1HELPWINDOWS]->PutSpriteFast(30 -3,262, 1, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_F1HELPWINDOWS]->PutSpriteFast(62 -35,25, 2, dwTime);
	}

	//	mando	020910	다이얼로그 박스와 함께 커서 보이기?	
	GetCursorPos(&G_point);
	if(G_bDlg1)
	{

		if( m_DDraw.m_bFullMode == TRUE )
		{
			//m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
			m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(G_point.x, G_point.y, m_stMCursor.sCursorFrame, dwTime);
//			UpdateMouseCursor(iUpdateRet, G_point.x, G_point.y);
		}
		else
		{
			int cx = GetSystemMetrics(SM_CXFULLSCREEN)/2;
			int cy = GetSystemMetrics(SM_CYFULLSCREEN)/2;
			if(cy>280) cy -= 40;
			m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(G_point.x - (cx-320), G_point.y - (cy-240), m_stMCursor.sCursorFrame, dwTime);

//			G_hWnd = CreateWindowEx( 0, szAppClass, "HClient", WS_POPUP | WS_BORDER, cx-320, cy-240,
//									640, 480, NULL, NULL, hInstance, NULL );
		}


//		if (iUpdateRet == 0) {
//			if ((G_point.x != imX) || (G_point.y != imY)) UpdateMouseCursor(0, G_point.x, G_point.y);
//		}
//		else UpdateMouseCursor(iUpdateRet, G_point.x, G_point.y);
		imX = G_point.x; 
		imY = G_point.y;
	}
	else
	{
		// 마지막 마우스 커서 그림 
		m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
		if (iUpdateRet == 0) {
			if ((msX != imX) || (msY != imY)) // UpdateMouseCursor(0, msX, msY);
				m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, m_stMCursor.sCursorFrame, dwTime);
		}
		else //	UpdateMouseCursor(iUpdateRet, msX, msY);
			m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, m_stMCursor.sCursorFrame, dwTime);

		imX = msX; 
		imY = msY;
	}
#endif

	
	// 톱 메시지 
	DrawTopMsg();

#ifdef DEF_SHOWCURSORPOS
	wsprintf(G_cTxt, "M(%d,%d) T(%d,%d)", msX, msY, (m_sViewPointX + msX)/32, (m_sViewPointY + msY)/32);
	PutString(msX, msY +30, G_cTxt, RGB(255,255,255));
#endif

//	if (m_cGameModeCount <= 15) {
//		for (i = 0; i < (14 - (m_cGameModeCount-1)); i++) _DrawBlackRect(i);
		
//	}

	// LogOut process
	if (m_cLogOutCount > 0) {
		if ((dwTime - m_dwLogOutCountTime) > 1000) {
			m_cLogOutCount--;
			m_dwLogOutCountTime = dwTime;
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME13, m_cLogOutCount);//"접속을 종료하고 있습니다...%d"
			AddEventList(G_cTxt, 10);
		}
	}
	// Logout 카운트가 0이면 접속 종료한다.
	if (m_cLogOutCount == 0) {
		// 카운트 0. 접속 종료한다.
		delete m_pGSock;
		m_pGSock = NULL;
		m_bEscPressed = FALSE;

		PlaySound('E', 14, 5);
		// 비소리 루핑 스톱 
		if (m_bSoundFlag) m_pESound[38]->bStop();
		// 배경음악 스톱
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE)) {
			if (m_pBGM != NULL) m_pBGM->bStop();
		}
		
		// 과금 서비스의 경우 로그아웃시 무조건 종료
		if (strlen(G_cCmdLineTokenA) != 0) 
			 ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else 
		{
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
		}
		return;
	}

	// Restart Process
	if (m_cRestartCount > 0) {
		if ((dwTime - m_dwRestartCountTime) > 1000) {
			m_cRestartCount--;
			m_dwRestartCountTime = dwTime;
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME14, m_cRestartCount);//"게임을 다시 시작합니다...%d"
			AddEventList(G_cTxt, 10);
		}
	}
	// Restart 카운트가 0이면 재시작 메시지 전송 
	if (m_cRestartCount == 0) {
		m_cRestartCount = -1;
		bSendCommand(MSGID_REQUEST_RESTART, NULL, NULL, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_bIsObserverMode == TRUE) {
		m_DDraw.PutPixel(msX, msY,   255,255,255);
		m_DDraw.PutPixel(msX+1, msY, 255,255,255);
		m_DDraw.PutPixel(msX-1, msY, 255,255,255);
		m_DDraw.PutPixel(msX, msY+1, 255,255,255);
		m_DDraw.PutPixel(msX, msY-1, 255,255,255);
	}
	else m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, m_stMCursor.sCursorFrame, dwTime);

	if( iUpdateRet == 0 ) m_sFrameCount++;
	else m_sFrameCount+=256;

	if( dwTime - m_dwFPStime > 500 )
	{
		m_dwFPStime = dwTime;
		m_sFPS = m_sFrameCount>>7;
		if( m_sFPS < 10 ) m_sFPS += 6;
		m_sFrameCount = 0;
	}

	if( iUpdateRet != 0 ) {
		if( m_bShowFPS )
		{
			wsprintf( G_cTxt, "fps : %d", m_sFPS );
			PutString( 10, 100, G_cTxt, RGB(255,255,255) );
		}		
		if( m_DDraw.iFlip() == DDERR_SURFACELOST ) RestoreSprites();
	}

	// 맵상에 있는 오브젝트들의 프레임을 처리한다. m_sPlayerStatus 의 0x000F번째 4비트가 무기속도를 나타낸다. 
	iUpdateRet = m_pMapData->iObjectFrameCounter(m_cPlayerName, m_sViewPointX, m_sViewPointY);

	// 여기서 효과 등의 프레임을 카운팅한다. 
	if ((bEffectFrameCounter() == TRUE) && (iUpdateRet == 0)) iUpdateRet = -1;

	if (iUpdateRet == 2) {
		m_bCommandAvailable = TRUE;
		m_dwCommandTime = 0;
	}

	// 사용자의 명령을 처리한다.
#ifdef DEF_HTMLCOMMOM	//	mando..
	if(G_bDlg1 == FALSE)
#endif
		CommandProcessor( msX, msY, ((sDivX + sPivotX)*32 + sModX + msX - 17)/32 + 1, ((sDivY + sPivotY)*32 + sModY + msY - 17)/32 + 1, cLB, cRB);

	// 임시로 변경되었던 뷰포트 복구 
	m_sViewPointX = sVPXsave;
	m_sViewPointY = sVPYsave;

	// 다음 뷰포인트 시점을 계산한다. 
	if (iUpdateRet > 0) CalcViewPoint();

	if (m_bIsObserverMode) {
		if ((dwTime - m_dwObserverCamTime) > 25) {
			m_dwObserverCamTime = dwTime;
			CalcViewPoint();
			iUpdateRet = -1;
		}
	}
	
	// v1.432
	if (iUpdateRet > 0) {
		if (m_bDrawFlagDir == FALSE) {
			m_iDrawFlag++;
			if (m_iDrawFlag >= 25) {
				m_iDrawFlag = 25;
				m_bDrawFlagDir = TRUE;
			}
		}
		else {
			m_iDrawFlag--;
			if (m_iDrawFlag < 0) {
				m_iDrawFlag = 0;
				m_bDrawFlagDir = FALSE;
			}
		}
	}
	// iUpdateRet가 0이면 어떤 오브젝트의 움직임도 없는 것이다.
}

void CGame::StartBGM()
{
	if( m_bSoundFlag == FALSE )
	{
		if (m_pBGM != NULL) {
			m_pBGM->bStop();
			delete m_pBGM;
			m_pBGM = NULL;
		}
		return;
	}
	char cWavFileName[32];
	ZeroMemory( cWavFileName, sizeof(cWavFileName) );

#ifdef DEF_XMAS	//	크리스마스 캐롤 부분^^;
	if( m_cWhetherEffectType >= 4 && m_cWhetherEffectType <= 6 ) strcpy( cWavFileName, "music\\Carol.wav" );
	else
#endif
	{
		if (memcmp(m_cCurLocation, "aresden", 7) == 0) strcpy( cWavFileName, "music\\aresden.wav" );
		else if (memcmp(m_cCurLocation, "elvine", 6) == 0) strcpy( cWavFileName, "music\\elvine.wav" );
		else if (memcmp(m_cCurLocation, "dglv", 4) == 0) strcpy( cWavFileName, "music\\dungeon.wav" );
		else if (memcmp(m_cCurLocation, "middled1", 8) == 0) strcpy( cWavFileName, "music\\dungeon.wav" );
		else if (memcmp(m_cCurLocation, "middleland", 10) == 0) strcpy( cWavFileName, "music\\middleland.wav" );
		else strcpy( cWavFileName, "music\\MainTm.wav" );
	}
	if (m_pBGM != NULL) {
		if( strcmp( m_pBGM->m_cWavFileName, cWavFileName ) == 0 ) return;
		m_pBGM->bStop();
		delete m_pBGM;
		m_pBGM = NULL;
	}
	int iVolume = (m_cMusicVolume - 100)*20;
	if (iVolume > 0) iVolume = 0;
	if (iVolume < -10000) iVolume = -10000; //iVolume == Volume
	m_pBGM = new class CSoundBuffer(m_DSound.m_lpDS, m_DSound.m_DSCaps, cWavFileName, TRUE);
	// 배경음을 루핑
	m_pBGM->Play(TRUE, 0, iVolume);
}

void CGame::MotionResponseHandler(char * pData)
{
 WORD  * wp, wResponse;
 short * sp, sX, sY;
 char  * cp, cDir;
 int   * ip, iPreHP;
	
	//						          0 3        4 5						 6 7		8 9		   10	    11	
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | DEF_OBJECTMOVE_CONFIRM(2) | Loc-X(2) | Loc-Y(2) | Dir(1) | MapData ...
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | DEF_OBJECTMOVE_REJECT(2)  | Loc-X(2) | Loc-Y(2)  

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wResponse = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	switch (wResponse) {
	case DEF_OBJECTMOTION_CONFIRM:
		// 이동명령을 제외한 다른 동작의 확인 응답. 
		m_cCommandCount--;
		break;

	case DEF_OBJECTMOTION_ATTACK_CONFIRM:
		// 공격 동작의 확인 응답. 
		m_cCommandCount--;
		break;

	case DEF_OBJECTMOTION_REJECT:
	
		if (m_iHP <= 0) return;
				
		sp = (short *)cp;
		m_sPlayerX = *sp;
		cp += 2;

		sp = (short *)cp;
		m_sPlayerY = *sp;
		cp += 2;
		 
		m_cCommand = DEF_OBJECTSTOP;
		m_sCommX = m_sPlayerX;
		m_sCommY = m_sPlayerY;
		
		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, 
						                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
										  m_sPlayerStatus, m_cPlayerName, 
										  DEF_OBJECTSTOP, NULL, NULL, NULL); //v2.171
		m_cCommandCount = 0;
		// 마법등의 포인트 모드를 무효화함.
		m_bIsGetPointingMode = FALSE;

		// 뷰포인트를 재설정 
		m_sViewDstX = m_sViewPointX = (m_sPlayerX-10)*32;
		m_sViewDstY = m_sViewPointY = (m_sPlayerY-7)*32;
 
		m_bIsRedrawPDBGS = TRUE;
		break;
	
	case DEF_OBJECTMOVE_CONFIRM:
		// 맵데이터를 읽어 초기화한다.
		sp = (short *)cp;
		sX = *sp;
		cp += 2;

		sp = (short *)cp;
		sY = *sp;
		cp += 2;

		cDir = *cp;
		cp++;

		m_iSP = m_iSP - *cp;	// 이동에 따른 스테미너 감소치를 뺀다.
		cp++;
		if( m_iSP < 0 ) m_iSP = 0;

		// v1.3
		//m_iOccupyStatus = (int)*cp;
		cp++;

		// v1.4
		iPreHP = m_iHP;
		ip = (int *)cp;
		m_iHP = *ip;
		cp += 4;

		if (m_iHP != iPreHP) {
			if (m_iHP < iPreHP) {
				wsprintf(G_cTxt, NOTIFYMSG_HP_DOWN, iPreHP - m_iHP);//"HP가 %d포인트 감소했습니다."
				AddEventList(G_cTxt, 10);

				// 충격을 먹은 시간을 기록 
				m_dwDamagedTime = timeGetTime();
				
				if ((m_cLogOutCount>0) && (m_bForceDisconn==FALSE)) {
					m_cLogOutCount = -1;
					AddEventList(MOTION_RESPONSE_HANDLER2, 10);//"접속 종료 카운트 중 HP가 감소하면 카운트가 취소 됩니다."
				}
			}
			else
			{
				wsprintf(G_cTxt, NOTIFYMSG_HP_UP, m_iHP - iPreHP);//"HP가 %d포인트 증가했습니다."
				AddEventList(G_cTxt, 10);
			}
		}
		m_pMapData->ShiftMapData(cDir);
		_ReadMapData(sX, sY, cp);

		m_bIsRedrawPDBGS = TRUE;
				
		m_cCommandCount--;
		break;

	case DEF_OBJECTMOVE_REJECT:
		// 만약 죽어있는 상태라면 무시 
		if (m_iHP <= 0) return;
		
		wp = (WORD *)cp;
		if (m_sPlayerObjectID != *wp) return; // 오브젝트 아이디가 같지 않으면 리턴 
		cp += 2;
	
		sp  = (short *)cp;
		m_sPlayerX = *sp;
		cp += 2;
		
		sp  = (short *)cp;
		m_sPlayerY = *sp;
		cp += 2;
		
		sp  = (short *)cp;
		m_sPlayerType = *sp;
		cp += 2;
		
		m_cPlayerDir = *cp;
		cp++;

		//memcpy(cName, cp, 10);
		cp += 10;

		sp  = (short *)cp;
		m_sPlayerAppr1 = *sp;
		cp += 2;

		sp  = (short *)cp;
		m_sPlayerAppr2 = *sp;
		cp += 2;

		sp  = (short *)cp;
		m_sPlayerAppr3 = *sp;
		cp += 2;

		sp  = (short *)cp;
		m_sPlayerAppr4 = *sp;
		cp += 2;

		ip = (int *)cp; // v1.4
		m_iPlayerApprColor = *ip;
		cp += 4;

		sp  = (short *)cp;
		m_sPlayerStatus = *sp;
		cp += 2;

		m_cCommand = DEF_OBJECTSTOP;
		m_sCommX = m_sPlayerX;
		m_sCommY = m_sPlayerY;
		
		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, 
						                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
										  m_sPlayerStatus, m_cPlayerName, 
										  DEF_OBJECTSTOP, NULL, NULL, NULL,
										  0, 7);
		m_cCommandCount = 0;
		// 마법등의 포인트 모드를 무효화함.
		m_bIsGetPointingMode = FALSE;

		// 뷰포인트를 재설정 
		m_sViewDstX = m_sViewPointX = (m_sPlayerX-10)*32;
		m_sViewDstY = m_sViewPointY = (m_sPlayerY-7)*32;

		// v1.42
		m_bIsPrevMoveBlocked = TRUE;

		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 12, 0);
			break;

		case 4:
		case 5:
		case 6:
			PlaySound('C', 13, 0);
			break;
		}
				
		//m_bCommandAvailable = TRUE; // v1.4 에서 재활성화 되었음. 다시 비활성화 되었음 v1.41 재활성화 
		break;
	}
}


// 마우스로부터 입력된 명령을 분석하여 적절한 동작을 취한다.
void CGame::CommandProcessor(short msX, short msY, short indexX, short indexY, char cLB, char cRB)
{
 char   cDir, absX, absY, cName[12];
 short  sX, sY, sObjectType, sObjectStatus, tX, tY;
 int    iRet;
 DWORD  dwTime = timeGetTime();
 WORD   wType = 0;
 int i;//, iFOE;
 char   cTxt[120];
 
 char  pDstName[21];
 short sDstOwnerType, sDstOwnerStatus;
 BOOL  bGORet;
	if ((m_bIsObserverCommanded == FALSE) && (m_bIsObserverMode == TRUE)) {
		// 관람자 패닝 모드라면 화면 이동을 요청한다.
		if ((msX == 0) && (msY == 0) && (m_sViewDstX > 32*21) && (m_sViewDstY > 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 8, NULL, NULL, NULL, NULL); 
		else
		if ((msX == 640) && (msY == 0) && (m_sViewDstX < 32*m_pMapData->m_sMapSizeX - 32*21) && (m_sViewDstY > 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 2, NULL, NULL, NULL, NULL); 
		else
		if ((msX == 640) && (msY == 480) && (m_sViewDstX < 32*m_pMapData->m_sMapSizeX - 32*21) && (m_sViewDstY < 32*m_pMapData->m_sMapSizeY - 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 4, NULL, NULL, NULL, NULL); 
		else
		if ((msX == 0) && (msY == 480)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 6, NULL, NULL, NULL, NULL); 	
		else
		if ((msX == 0) && (m_sViewDstX > 32*21)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 7, NULL, NULL, NULL, NULL); 	
		else
		if ((msX == 640) && (m_sViewDstX < 32*m_pMapData->m_sMapSizeX - 32*21)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 3, NULL, NULL, NULL, NULL); 	
		else
		if ((msY == 0) && (m_sViewDstY > 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 1, NULL, NULL, NULL, NULL); 	
		else
		if ((msY == 480) && (m_sViewDstY < 32*m_pMapData->m_sMapSizeY - 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 5, NULL, NULL, NULL, NULL); 	
		else return;
		
		m_bIsObserverCommanded = TRUE;
		m_cArrowPressed = 0;
		return;
	}

	// v1.41 관람 모드에서는 명령이 듣지 않는다.
	if (m_bIsObserverMode == TRUE) return;

	// 슈퍼 공격 커맨드 처리 	
	if (GetAsyncKeyState(VK_MENU)>>15)
		 m_bSuperAttackMode = TRUE;
	else m_bSuperAttackMode = FALSE;
	
	// 인터페이스 처리부 
	switch (m_stMCursor.cPrevStatus) {
	case DEF_CURSORSTATUS_NULL:
		//  만약 활성화된 다이얼로그 박스나 단축아이콘위에서 버튼이 눌렸다면 
		// SELECT처리후 TRUE값을 반환한다.
		if (cLB != 0) {
			iRet = _iCheckDlgBoxFocus(msX, msY, 1);
			if (iRet == 1) {
				m_stMCursor.cPrevStatus	= DEF_CURSORSTATUS_SELECTED;
				return;
			}
			else if (iRet == 0) 
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_PRESSED;
			else if (iRet == -1) {
				// 무시해야 한다. 다이얼로그 박스의 슬라이드가 움직인 것이므로 
				return;
			}
		}
		else
		if (cRB != 0) {
			iRet = _iCheckDlgBoxFocus(msX, msY, 2);
			if (iRet == 1) return;
		}
		break;
	case DEF_CURSORSTATUS_PRESSED:
		if (cLB == 0) {
			// 버튼이 떨어졌으므로 Normal Click
			m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
		}
		break;
	case DEF_CURSORSTATUS_SELECTED:
		if (cLB == 0) {
			
			if (((dwTime - m_stMCursor.dwSelectClickTime) < DEF_DOUBLECLICKTIME) &&
				(msX == m_stMCursor.sClickX) && (msY == m_stMCursor.sClickY) ) {
				// Double Click 
				m_stMCursor.dwSelectClickTime = m_stMCursor.dwSelectClickTime;
				_bCheckDlgBoxDoubleClick(msX, msY);
			}
			else {
				// Click 
				_bCheckDlgBoxClick(msX, msY);
				m_stMCursor.sClickX = msX;
				m_stMCursor.sClickY = msY;
			}
			
			m_stMCursor.dwSelectClickTime = dwTime;
			m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
			// 만약 선택된 아이템이 있었다면 해제한다.
			if (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM) {
				// 아이템이 드래깅 되다 떨어진 것으로 간주하여 처리한다.!!!
				_bCheckDraggingItemRelease(msX, msY);

				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
			}
			return;
		}
		if (cLB != 0) {
			// v2.05 01-11-30 텔레포트 타일 위에서 정지하지 못하게 하기 위함 			
			if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == TRUE) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;
						
			if ((m_stMCursor.sPrevX != msX)	|| (m_stMCursor.sPrevY != msY))	{
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_DRAGGING;
				m_stMCursor.sPrevX = msX;
				m_stMCursor.sPrevY = msY;
				
				if ( (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					 ((m_stMCursor.sSelectedObjectID == 30) || (m_stMCursor.sSelectedObjectID == 29)) ) {
					// 아이콘 판넬은 드래깅 될 수 없다. 
					m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				}

				// 만약 텍스트 입력 원도우가 입력을 받고 있던 중이라면
				// 길드 이름 입력상태 
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 7) && (m_stDialogBoxInfo[7].cMode == 1)) {
					// Guild Menu가 입력상태에서 드래깅되기 시작했다. 입력상태를 닫는다.	
					EndInputString();
					m_stDialogBoxInfo[7].cMode = 20;
				}

				// Query Drop Item Amount 상태 
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 17) && (m_stDialogBoxInfo[17].cMode == 1)) {
					// Guild Menu가 입력상태에서 드래깅되기 시작했다. 입력상태를 닫는다.	
					EndInputString();
					m_stDialogBoxInfo[17].cMode = 20;
				}
				return;
			}
			if ((m_cCommand == DEF_OBJECTMOVE) || (m_cCommand == DEF_OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
			return;
		}
		break;
	case DEF_CURSORSTATUS_DRAGGING:
		if (cLB != 0) {
			// 드래깅 중 
			// v2.05 01-11-30 텔레포트 타일 위에서 정지하지 못하게 하기 위함 			
			if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == TRUE) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;
						
			if (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) {
				// 다이얼로그 박스를 드래깅 중이었다면 
				m_stDialogBoxInfo[m_stMCursor.sSelectedObjectID].sX = msX - m_stMCursor.sDistX;
				m_stDialogBoxInfo[m_stMCursor.sSelectedObjectID].sY = msY - m_stMCursor.sDistY;
			}
			m_stMCursor.sPrevX = msX;
			m_stMCursor.sPrevY = msY;
			
			if ((m_cCommand == DEF_OBJECTMOVE) || (m_cCommand == DEF_OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
			return;
		}
		if (cLB == 0) {
			// 드래깅이 끝났다.
			switch (m_stMCursor.cSelectedObjectType) {
			case DEF_SELECTEDOBJTYPE_DLGBOX:
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 7) && (m_stDialogBoxInfo[7].cMode == 20)) {
					// Guild Menu가 입력상태에서 드래깅되다가 놓였다. 입력창을 연다.	
					sX = m_stDialogBoxInfo[7].sX;
					sY = m_stDialogBoxInfo[7].sY;
					StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
					m_stDialogBoxInfo[7].cMode = 1;
				}

				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 17) && (m_stDialogBoxInfo[17].cMode == 20)) {
					// Query Drop Item Amount가 입력상태에서 드래깅되다가 놓였다. 입력창을 연다.	
					sX = m_stDialogBoxInfo[17].sX;
					sY = m_stDialogBoxInfo[17].sY;
					StartInputString(sX + 40, sY + 57, 11, m_cAmountString);
					m_stDialogBoxInfo[17].cMode = 1;
				}

				if ( m_stMCursor.sSelectedObjectID == 9 )
				{
					if( msX < 320 ) m_stDialogBoxInfo[9].sX = 0;
					else m_stDialogBoxInfo[9].sX = 640 - m_stDialogBoxInfo[9].sSizeX;
					if( msY < 213 ) m_stDialogBoxInfo[9].sY = 0;
					else m_stDialogBoxInfo[9].sY = 427 - m_stDialogBoxInfo[9].sSizeY;
				}
				
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
				break;

			case DEF_SELECTEDOBJTYPE_ITEM:
				// 아이템의 드래깅이 끝났다. 
				_bCheckDraggingItemRelease(msX, msY);
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
				break;

			default:
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
				break;
			}
			return;
		}				     
		break;
	}

CP_SKIPMOUSEBUTTONSTATUS:;

	// 캐릭터 행동 처리부
	if (m_bCommandAvailable == FALSE) return;
	if ( (dwTime - m_dwCommandTime) < 300 )
	{
		// 카운트 0. 접속 종료한다.
		delete m_pGSock;
		m_pGSock = NULL;
		m_bEscPressed = FALSE;

		PlaySound('E', 14, 5);
		// 비소리 루핑 스톱 
		if (m_bSoundFlag) m_pESound[38]->bStop();
		// 배경음악 스톱
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE)) {
			if (m_pBGM != NULL) m_pBGM->bStop();
		}
		
		// 과금 서비스의 경우 로그아웃시 무조건 종료
		if (strlen(G_cCmdLineTokenA) != 0) 
			 ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else 
		{
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
		}
		return;
	}
	if (m_iHP <= 0) return;

	// 공격을 받고 물러서야 하는 모드이다.
	if (m_sDamageMove != 0) {
		m_cCommand = DEF_OBJECTDAMAGEMOVE;
		goto MOTION_COMMAND_PROCESS;
	}

	// 만약 플레이어가 텔레포트 타일위에 있다면 점프한다. 
	if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == TRUE) && (m_cCommandCount == 0))
		RequestTeleportAndWaitData();
	
	// indexX, indexY는 마우스 커서가 가리키고 있는 맵상의 공간좌표이다(스크린 좌표는 msX, msY).
	if (cLB != 0) {
		
		// 마우스 왼쪽 버튼이 눌렸다. 
		if (m_bIsGetPointingMode == TRUE) {
			// 포인트를 얻어 행동을 취하는 모드였다. (마법이라든지 아이템 사용 등등)
			if ((m_sMCX != 0) || (m_sMCY != 0))
				 PointCommandHandler(m_sMCX, m_sMCY);		    
			else PointCommandHandler(indexX, indexY);
																   
			m_bCommandAvailable  = FALSE;
			m_dwCommandTime = timeGetTime();
			m_bIsGetPointingMode = FALSE;
			return;	
		}

		m_pMapData->bGetOwner(m_sMCX, m_sMCY-1, cName, &sObjectType, &sObjectStatus, &m_wCommObjectID); // v1.4
		//m_pMapData->m_pData[dX][dY].m_sItemSprite
		if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && ( sObjectType <= 6 || m_pMapData->m_pData[m_sPlayerX-m_pMapData->m_sPivotX][m_sPlayerY-m_pMapData->m_sPivotY].m_sItemSprite != 0 )) {
		//if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && ( sObjectType <= 6 || m_pMapData->m_pData[15][15].m_sItemSprite != 0 )) {
		//if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && sObjectType <= 6) {//v2.181 2002/10/25 안상하수정 정면위에 무언가 있을시 그걸 찝는걸로 한다.
			// v2.14 죽은척 버그 수정중 
			// 플레이어가 클릭되었다면 무조건 아이템 줍는 동작 
			// 변신한 상태 혹은 전투모드에서는 아이템을 주울 수 없다.
			if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/) {
				m_cCommand = DEF_OBJECTGETITEM;
				m_sCommX = m_sPlayerX;
				m_sCommY = m_sPlayerY;
			}
		}
		else {
			if( memcmp(m_cMCName, m_cPlayerName, 10) == 0 ) m_sMCY -= 1;
			// 일반적인 위치가 클릭되었다.
			if ((m_sMCX != 0) && (m_sMCY != 0)) {
				// m_sMCX, m_sMCY에 있는 캐릭터를 선택했다.
				if (m_bCtrlPressed == TRUE) { //강제 공격모드.
					// 강제 공격모드이다. 
					m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &sObjectStatus, &m_wCommObjectID); // v1.4
	
					// 몹이나 NPC이다.	창고주인이나 대장간 주인, 상점 주인에게는 공격할 수 없다.
					if ( (sObjectStatus & 0x10) != 0) return;//인비상태인 오브젝트는 공격할 수 없다.
					if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;
							
					m_stMCursor.sCursorFrame = 3;
					
					absX = abs(m_sPlayerX - m_sMCX);
					absY = abs(m_sPlayerY - m_sMCY);
					
					if ((absX <= 1) && (absY <= 1)) {
						// 인접해 있다. 무기 종류에 상관없이 공격 
						// 무기의 종류에 맞는 공격 모드, 필살기 모드까지 계산된 값이 반환된다.
						wType = _iGetAttackType();
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
					}
					else {
						// 떨어져 있으므로 원거리 공격을 하든지 접근한다.
						switch (_iGetWeaponSkillType()) {
						case 6: // 활 - 거리 상관 없이 공격가능 
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
							break;
						
						case 5: // 맨손
						case 7: // 단검
							if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
								if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
									// 대쉬 공격
									if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
										m_cCommand = DEF_OBJECTATTACKMOVE;
										wType = _iGetAttackType();
									}
									else {
										m_cCommand = DEF_OBJECTRUN;
										GetPlayerTurn();
									}
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								} 
								else {
									m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							else {
								if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
									(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
									 m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
								else m_cCommand = DEF_OBJECTMOVE;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								GetPlayerTurn();
							}
							break;

						case 8: // 장검 - 거리가 3 이내이면 필살기 공격 가능 
							if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
								// 필살기 모드일때는 근거리 공격이 가능하다.
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								// 필살기도 미치지 않는 거리. 접근한다.
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										// 대쉬 공격
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									} 
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}				
							break;

						case 9: // 펜싱검 - 거리가 4 이내이면 필살기 공격 가능 
							if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
								// 필살기 모드일때는 근거리 공격이 가능하다.
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								// 필살기도 미치지 않는 거리. 접근한다.
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										// 대쉬 공격
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									} 
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}					
							break;

						case 10: // 도끼 - 거리가 2 이내이면 필살기 공격 가능 
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
								// 필살기 모드일때는 근거리 공격이 가능하다.
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								// 필살기도 미치지 않는 거리. 접근한다.
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										// 대쉬 공격
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									} 
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}					
							break;
						case 14: // 해머 - 거리가 2 이내이면 필살기 공격 가능 
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
								// 필살기 모드일때는 근거리 공격이 가능하다.
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								// 필살기도 미치지 않는 거리. 접근한다.
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										// 대쉬 공격
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									} 
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}					
							break;
						case 21: // 지팡이 - 거리가 2 이내이면 필살기 공격 가능 
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
								// 필살기 모드일때는 근거리 공격이 가능하다.
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								// 필살기도 미치지 않는 거리. 접근한다.
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										// 대쉬 공격
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									} 
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}					
							break;
						}
					}
				}
				else {
					// 일반 공격 모드이다. NPC에 대한 공격이 가능
					m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &sObjectStatus, &m_wCommObjectID); // v1.4

					if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6))) {
						// 몹이나 NPC이다. 	
						switch (sObjectType) {
						case 15:
							// ShopKeeper-W가 클릭되었다. 이름의 Prefix에 맞는 다이얼로그 박스를 활성화 시킨다.
							switch (cName[0]) {
							case '1':
								EnableDialogBox(20, 5, 11, 1);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 15;
								break;
							}
							break;

						case 19:
							switch (cName[0]) {
							case '1':
								EnableDialogBox(20, 0, 16, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 19;
								break;
						 	}
							break;

						case 20:
							switch (cName[0]) {
							case '1':
								EnableDialogBox(20, 0, 14, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 20;
								//랄라라
								m_stDialogBoxInfo[39].sV3 = 20;
								m_stDialogBoxInfo[39].sV4 = m_wCommObjectID; // v1.4
								m_stDialogBoxInfo[39].sV5 = m_sMCX;
								m_stDialogBoxInfo[39].sV6 = m_sMCY;

								break;
						 	}
							break;
						
						case 24:
							// 대장간 주인 
							switch (cName[0]) {
							case '1':
								EnableDialogBox(20, 5, 11, 2);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 24;
								//랄라라
								m_stDialogBoxInfo[39].sV3 = 24;
								m_stDialogBoxInfo[39].sV4 = m_wCommObjectID; // v1.4
								m_stDialogBoxInfo[39].sV5 = m_sMCX;
								m_stDialogBoxInfo[39].sV6 = m_sMCY;
								break;
						 	}
							break;

						case 25:
							switch (cName[0]) {
							case '1':
								EnableDialogBox(20, 0, 13, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 25;
								break;
						 	}
							break;

						case 26:
							switch (cName[0]) {
							case '1':
								EnableDialogBox(20, 0, 7, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 26;
								break;
						 	}
							break;

						case 21:
							// Guard: 적 경비가 아닌 경우만 말을 거는게 가능 
							if ((_iGetFOE(sObjectStatus)==1) && (!m_bIsCombatMode)) {
								EnableDialogBox(20, 4, NULL, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 21;
							}
							break;
						case 67:
						case 68:
						case 69:
							// 마을 NPC에게  대화가능..^^; 20021221
							if (!m_bIsCombatMode) {
								EnableDialogBox(20, 4, NULL, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = sObjectType;
							}
							break;

						case 32:
							// Unicorn 
							if (!m_bIsCombatMode) {
								EnableDialogBox(20, 4, NULL, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 32;
							}
							break;

						default:
							// 일반 몹 - 적이 아니라면 일반모드에서는 공격하지 않는다.
							// 2002-9-24 아군은 공격하지 않는다.
							if ( _iGetFOE(sObjectStatus) >= 0 ) break;
							if ( (sObjectType>=1) && (sObjectType<=6) && (m_bForceAttack==FALSE) ) break;
							absX = abs(m_sPlayerX - m_sMCX);
							absY = abs(m_sPlayerY - m_sMCY);
							
							if ((absX <= 1) && (absY <= 1)) {
								// 인접해 있다. 무기 종류에 상관없이 공격 
								// 무기의 종류에 맞는 공격 모드, 필살기 모드까지 계산된 값이 반환된다.
								wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else {
								// 떨어져 있으므로 원거리 공격을 하든지 접근한다.
								switch (_iGetWeaponSkillType()) {
								case 6: // 활 - 거리 상관 없이 공격가능 
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
									break;
									
								case 5: // 맨손
								case 7: // 단검 - 접근
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6)) 
										m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
									break;
									
								case 8: // 장검 - 거리가 3 이내이면 필살기 공격 가능 
									if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
										// 필살기 모드일때는 근거리 공격이 가능하다.
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										// 필살기도 미치지 않는 거리. 접근한다.
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}				
									break;
									
								case 9: // 펜싱검 - 거리가 4 이내이면 필살기 공격 가능 
									if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
										// 필살기 모드일때는 근거리 공격이 가능하다.
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										// 필살기도 미치지 않는 거리. 접근한다.
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}				
									break;


								case 10: // 도끼 - 거리가 2 이내이면 필살기 공격 가능 
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
										// 필살기 모드일때는 근거리 공격이 가능하다.
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										// 필살기도 미치지 않는 거리. 접근한다.
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}				
									break;
								case 14: // 해머 - 거리가 2 이내이면 필살기 공격 가능 
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
										// 필살기 모드일때는 근거리 공격이 가능하다.
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										// 필살기도 미치지 않는 거리. 접근한다.
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}				
									break;
								case 21: // 지팡이 - 거리가 2 이내이면 필살기 공격 가능 
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
										// 필살기 모드일때는 근거리 공격이 가능하다.
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										// 필살기도 미치지 않는 거리. 접근한다.
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;	// 달리기 위해서는 Staminar가 있어야 한다.
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}				
									break;
								}
							}
							break;
						}
					}
					else {
						// 이동명령이다.
						if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
							(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
							 m_cCommand = DEF_OBJECTRUN;
						else m_cCommand = DEF_OBJECTMOVE;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						// 플레이어의 이동시 회전 방향을 결정한다.
						GetPlayerTurn();
					}
				}
			}
			else 
			{
				// 이동명령이다.
				if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) && 
					(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
					 m_cCommand = DEF_OBJECTRUN;
				else m_cCommand = DEF_OBJECTMOVE;
				m_sCommX = indexX;
				m_sCommY = indexY;
				// 플레이어의 이동시 회전 방향을 결정한다.
				GetPlayerTurn();
			}
		}
	}
	else
	if (cRB != 0) {
		// 마우스 오른쪽 버튼이 눌렸다. 
		m_cCommand = DEF_OBJECTSTOP;

		if (m_bIsGetPointingMode == TRUE) {
			// 포인트를 얻어 행동을 취하는 모드였다. (마법이라든지 아이템 사용 등등)
			// 취소한다. 
			m_bIsGetPointingMode = FALSE;
			AddEventList(COMMAND_PROCESSOR1, 10);//"취소되었습니다."
		}

		if (m_bCommandAvailable == FALSE) return;
		if (m_cCommandCount >= 6) return;

		if ((m_sMCX != 0) && (m_sMCY != 0)) {
			// 강제 정지 상태에서의 공격이다. 
			absX = abs(m_sPlayerX - m_sMCX);
			absY = abs(m_sPlayerY - m_sMCY);
			if( absX==0 && absY==0 ) return;
			
			if (m_bCtrlPressed == TRUE) {
				// 상대에 상관없이 무조건 공격. 
				m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &sObjectStatus, &m_wCommObjectID); //v1.4
				// 몹이나 NPC이다.	창고주인이나 대장간 주인, 상점 주인에게는 공격할 수 없다.
				if ( (sObjectStatus & 0x10) != 0) return;//인비상태인 오브젝트는 공격할 수 없다.
				if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;

				if ((absX <= 1) && (absY <= 1)) {
					// 인접해 있다. 무기 종류에 상관없이 공격 
					// 무기의 종류에 맞는 공격 모드, 필살기 모드까지 계산된 값이 반환된다.
					wType = _iGetAttackType();
					m_cCommand = DEF_OBJECTATTACK;
					m_sCommX = m_sMCX;
					m_sCommY = m_sMCY;
				}
				else {
					// 떨어져 있으므로 원거리 공격
					switch (_iGetWeaponSkillType()) {
					case 6: // 활 - 거리 상관 없이 공격가능 
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						wType = _iGetAttackType();
						break;
						
					case 5: // 맨손
					case 7: // 단검
						break;
						
					case 8: // 장검 - 거리가 3 이내이면 필살기 공격 가능 
						if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
							// 필살기 모드일때는 근거리 공격이 가능하다.
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
						
					case 9: // 펜싱검 - 거리가 4 이내이면 필살기 공격 가능 
						if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
							// 필살기 모드일때는 근거리 공격이 가능하다.
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
						
					case 10: // 도끼 - 거리가 2 이내이면 필살기 공격 가능 
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
							// 필살기 모드일때는 근거리 공격이 가능하다.
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;

					case 14: // 해머 - 거리가 2 이내이면 필살기 공격 가능 
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
							// 필살기 모드일때는 근거리 공격이 가능하다.
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
					case 21: // 지팡이 - 거리가 2 이내이면 필살기 공격 가능 
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
							// 필살기 모드일때는 근거리 공격이 가능하다.
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
					}
				}
			}
			else {
				//일반 공격 정지모드 
				absX = abs(m_sPlayerX - m_sMCX);
				absY = abs(m_sPlayerY - m_sMCY);
							
				m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &sObjectStatus, &m_wCommObjectID); //v1.4

				// 2002-9-24 적이나 범죄자는 강제 공격 하지 않아도 공격되게 

				if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6))) {
					switch (sObjectType) {
					case 15:
					case 19:
					case 20:
					case 24:
					case 25:
					case 26:
						break;
					
					default:
						// 일반 정지 공격 모드에서 적이 아닌 오브젝트는 공격하지 않는다.
						if ( _iGetFOE(sObjectStatus) >= 0 ) break;
						if ( (sObjectType>=1) && (sObjectType<=6) && (m_bForceAttack==FALSE) ) break;
						// 2002-9-24 아군은 공격하지 않는다.
						if ((absX <= 1) && (absY <= 1)) {
							// 인접해 있다. 무기 종류에 상관없이 공격 
							// 무기의 종류에 맞는 공격 모드, 필살기 모드까지 계산된 값이 반환된다.
							wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						else {
							// 떨어져 있으므로 원거리 공격을 하든지 접근한다.
							switch (_iGetWeaponSkillType()) {
							case 6: // 활 - 거리 상관 없이 공격가능 
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
								break;
								
							case 5: // 맨손
							case 7: // 단검
								break;
								
							case 8: // 장검 - 거리가 3 이내이면 필살기 공격 가능 
								if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
									// 필살기 모드일때는 근거리 공격이 가능하다.
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
								
							case 9: // 펜싱검 - 거리가 4 이내이면 필살기 공격 가능 
								if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
									// 필살기 모드일때는 근거리 공격이 가능하다.
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
								
							case 10: // 도끼 - 거리가 2 이내이면 필살기 공격 가능 
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
									// 필살기 모드일때는 근거리 공격이 가능하다.
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							case 14: // 해머 - 거리가 2 이내이면 필살기 공격 가능 
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
									// 필살기 모드일때는 근거리 공격이 가능하다.
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							case 21: // 지팡이 - 거리가 2 이내이면 필살기 공격 가능 
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
									// 필살기 모드일때는 근거리 공격이 가능하다.
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;

							}
						}
						break;
					}
				}
			}
		}
		else {
			cDir = m_Misc.cGetNextMoveDir(m_sPlayerX, m_sPlayerY, indexX, indexY);
			
			// 죽어있는 상태라면 명령 전송 불가능.
			if (m_iHP <= 0) return;
			if (cDir == 0) return;
			if (m_cPlayerDir  == cDir) return;
			
			// 동작 명령을 전송함과 동시에 기술 사용 상태는 무효화된다.
			ClearSkillUsingStatus();
					
			m_cPlayerDir = cDir;
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTSTOP, m_cPlayerDir, NULL, NULL, NULL, NULL);
						
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, 
							                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4 
											  m_sPlayerStatus, m_cPlayerName, 
											  m_cCommand, NULL, NULL, NULL, 0, 
											  10);
			m_bCommandAvailable = FALSE;
			m_dwCommandTime = timeGetTime();
			return;
		}
	}
	
MOTION_COMMAND_PROCESS:;

	if (m_cCommand != DEF_OBJECTSTOP) {
		
		// 죽어있는 상태라면 명령 전송 불가능.
		if (m_iHP <= 0) return;
		if (m_cCommandCount == 5) AddEventList(COMMAND_PROCESSOR2, 10, FALSE);//"네트워크 트래픽이 심합니다. 잠시 기다려 주세요."
		if (m_bCommandAvailable == FALSE) return;
		if (m_cCommandCount >= 6) return;
   
		if ((m_sPlayerType >= 0) && (m_sPlayerType > 6)) {
			// 플레이어가 변신한 상태라면 할 수 없는 동작은 하지 않는다.  
			switch (m_cCommand) {
			case DEF_OBJECTRUN:
			case DEF_OBJECTMAGIC:
			case DEF_OBJECTGETITEM:
				m_cCommand = DEF_OBJECTSTOP;
				break;
			}
		}

		// 동작 명령을 전송함과 동시에 기술 사용 상태는 무효화된다.
		ClearSkillUsingStatus();

		if (m_sDamageMove != 0) {
			m_cCommand = DEF_OBJECTDAMAGEMOVE;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;
					
			switch (m_sDamageMove) {	 // 방향이 반대다.
			case 1: m_sCommY--; break;   
			case 2: m_sCommX++; m_sCommY--; break; 
			case 3: m_sCommX++; break;
			case 4: m_sCommX++; m_sCommY++; break;
			case 5: m_sCommY++; break;
			case 6: m_sCommX--; m_sCommY++; break;
			case 7: m_sCommX--; break;
			case 8: m_sCommX--; m_sCommY--; break;
			}

			// 입은 대미지를 출력한다.
			for (i = 1; i < DEF_MAXCHATMSGS; i++) 
			if (m_pChatMsgList[i] == NULL) {
				ZeroMemory(cTxt, sizeof(cTxt));
				if (m_sDamageMoveAmount > 0)
					wsprintf(cTxt, "-%dPts", m_sDamageMoveAmount); //pts
				else strcpy(cTxt, "Critical!");
				
				int iFontType;
				if ((m_sDamageMoveAmount >= 0) && (m_sDamageMoveAmount < 12))		iFontType = 21;
				else if ((m_sDamageMoveAmount >= 12) && (m_sDamageMoveAmount < 40)) iFontType = 22;
				else if ((m_sDamageMoveAmount >= 40) || (m_sDamageMoveAmount < 0))	iFontType = 23;

				m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
				m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;

				if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == FALSE) {
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = NULL;
				}
				break;
			}
			m_sDamageMove = 0;
		}
		
		// 보내야 할 명령이 있다.	
		switch (m_cCommand) {
		case DEF_OBJECTRUN:
		case DEF_OBJECTMOVE:
		case DEF_OBJECTDAMAGEMOVE: // v1.43
			
			if( m_bParalyze ) return;
			bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &sDstOwnerStatus, &m_wCommObjectID); // v1.4

			if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY)) 
				m_cCommand = DEF_OBJECTSTOP;
			else if ( (abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) && 
				      (bGORet == TRUE) && (sDstOwnerType != NULL) ) 
				m_cCommand = DEF_OBJECTSTOP;
			// v2.15 나무나 돌같은 갈수 없는 곳을 클릭 하면 근처에 가서 멈추게 된다. 
			else if((abs(m_sPlayerX - m_sCommX) <= 2) && (abs(m_sPlayerY - m_sCommY) <= 2) && 
				(m_pMapData->m_tile[m_sCommX][m_sCommY].m_bIsMoveAllowed == FALSE))
				m_cCommand = DEF_OBJECTSTOP; 
			else {
				// v2.15 Sp 가 0 보다 적고 달리기 모드이면 자동으로 걷기 모드로 변경 
				if( m_cCommand == DEF_OBJECTMOVE )
				{
					if(m_bRunningMode || m_bShiftPressed) m_cCommand = DEF_OBJECTRUN;
				}
				if( m_cCommand == DEF_OBJECTRUN )
				{
					if( (m_bRunningMode == FALSE) && (m_bShiftPressed == FALSE) ) m_cCommand = DEF_OBJECTMOVE;
					if( m_iSP < 1 ) m_cCommand = DEF_OBJECTMOVE;
				}

				cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, TRUE);
				if (cDir != 0) {
					
					m_cPlayerDir = cDir;
					bSendCommand(MSGID_COMMAND_MOTION, m_cCommand, cDir, NULL, NULL, NULL, NULL);
					
					switch (cDir) {
					case 1:	m_sPlayerY--; break;
					case 2:	m_sPlayerY--; m_sPlayerX++;	break;
					case 3:	m_sPlayerX++; break;
					case 4:	m_sPlayerX++; m_sPlayerY++;	break;
					case 5:	m_sPlayerY++; break;
					case 6:	m_sPlayerX--; m_sPlayerY++;	break;
					case 7:	m_sPlayerX--; break;
					case 8:	m_sPlayerX--; m_sPlayerY--;	break;
					}	

					m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, 
						                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
										  m_sPlayerStatus, m_cPlayerName, 
										  m_cCommand, NULL, NULL, NULL);
					m_bCommandAvailable = FALSE;
					m_dwCommandTime = timeGetTime();

					m_iPrevMoveX = m_sPlayerX;
					m_iPrevMoveY = m_sPlayerY;
				}
			}

			if (m_cCommand == DEF_OBJECTDAMAGEMOVE) {
				// Point Mode였다면 클리어.
				m_bIsGetPointingMode = FALSE;
				m_iPointCommandType	 = -1;
				// v1.41 커서 모양 변경 
				m_stMCursor.sCursorFrame = 0;
				// 사용중이었던 스킬을 제거 
				ClearSkillUsingStatus();

				m_cCommand = DEF_OBJECTSTOP;
			}
			break;
		
		case DEF_OBJECTATTACK:
		
			cDir = m_Misc.cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY);
			if (cDir != 0) {
						
				if ((wType == 2) || (wType == 25)) {
					// 플레이어에게 화살아이템이 없다면 화살은 날아가지 않는다.
					if (_bCheckItemByType(DEF_ITEMTYPE_ARROW) == FALSE) 
						wType = 0;
				}

				// 필살기라면 카운트를 줄인다. (wType이 20~30 사이이면 각 스킬별 필살기이다) 
				if (wType >= 20) {
					m_iSuperAttackLeft--;
					if (m_iSuperAttackLeft < 0) m_iSuperAttackLeft = 0;
				}
				
				m_cPlayerDir = cDir;
				bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTATTACK, cDir, m_sCommX, m_sCommY, wType, NULL, m_wCommObjectID);
				
				m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, 
					                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, 
									  m_sPlayerStatus, m_cPlayerName, 
									  DEF_OBJECTATTACK, 
									  m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
				m_bCommandAvailable = FALSE;
				m_dwCommandTime = timeGetTime();
			}
			
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTATTACKMOVE:
			
			if( m_bParalyze ) return;
			bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &sDstOwnerStatus, &m_wCommObjectID); // v1.4

			if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY)) 
				m_cCommand = DEF_OBJECTSTOP;
			else if ( (abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) && 
				      (bGORet == TRUE) && (sDstOwnerType != NULL) ) 
				m_cCommand = DEF_OBJECTSTOP;
			else {
				cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, TRUE);
				if (cDir != 0) {
					
					m_cPlayerDir = cDir;
					bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTATTACKMOVE, cDir, m_sCommX, m_sCommY, wType, NULL, m_wCommObjectID);
					
					switch (cDir) {
					case 1:	m_sPlayerY--; break;
					case 2:	m_sPlayerY--; m_sPlayerX++;	break;
					case 3:	m_sPlayerX++; break;
					case 4:	m_sPlayerX++; m_sPlayerY++;	break;
					case 5:	m_sPlayerY++; break;
					case 6:	m_sPlayerX--; m_sPlayerY++;	break;
					case 7:	m_sPlayerX--; break;
					case 8:	m_sPlayerX--; m_sPlayerY--;	break;
					}	

					m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, 
						                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
										  m_sPlayerStatus, m_cPlayerName, 
										  m_cCommand, m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
					m_bCommandAvailable = FALSE;
					m_dwCommandTime = timeGetTime();

					m_iPrevMoveX = m_sPlayerX;
					m_iPrevMoveY = m_sPlayerY;
				}
			}

			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTGETITEM:
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTGETITEM, m_cPlayerDir, NULL, NULL, NULL, NULL);
			
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, 
				                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
								  m_sPlayerStatus, m_cPlayerName, 
								  DEF_OBJECTGETITEM, NULL, NULL, NULL);
			m_bCommandAvailable = FALSE;
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTMAGIC:
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTMAGIC, m_cPlayerDir, m_iCastingMagicType, NULL, NULL, NULL);
			
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, 
				                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
								  m_sPlayerStatus, m_cPlayerName, 
								  DEF_OBJECTMAGIC, m_iCastingMagicType, NULL, NULL);
			m_bCommandAvailable = FALSE;
			m_dwCommandTime = timeGetTime();
			m_bIsGetPointingMode = TRUE; //!!
			m_cCommand = DEF_OBJECTSTOP;
			
			// 플레이어 자신의 메시지는 반환되지 않으므로 직접 Casting Word를 할당 
			_RemoveChatMsgListByObjectID(m_sPlayerObjectID);
			
			for (i = 1; i < DEF_MAXCHATMSGS; i++) 
			if (m_pChatMsgList[i] == NULL) {
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, "%s!", m_pMagicCfgList[m_iCastingMagicType]->m_cName);
				m_pChatMsgList[i] = new class CMsg(41, cTxt, timeGetTime());
				m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
				
				m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i);
				return;
			}
			break;
		
		default:
			break;
		}
	}
}

/*
void CGame::DrawDialogBox_Bank(short msX, short msY, short msZ, char cLB)
{
 short sX, sY, szX;
 int  i, iTotalLines, iPointerLoc;
 double d1, d2, d3;
 char cItemColor;
	
	sX = m_stDialogBoxInfo[14].sX;
	sY = m_stDialogBoxInfo[14].sY;
	szX = m_stDialogBoxInfo[14].sSizeX - 5;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 21);
	char cStr1[64], cStr2[64], cStr3[64];
	ZeroMemory( cStr1, sizeof(cStr1) );
	ZeroMemory( cStr2, sizeof(cStr2) );
	ZeroMemory( cStr3, sizeof(cStr3) );

	switch (m_stDialogBoxInfo[14].cMode) {
	case -1:
		PutString(sX + 30 + 15, sY + 70, DRAW_DIALOGBOX_BANK1, RGB(0,0,0));//"아이템 반환 처리중입니다."
		PutString(sX + 30 + 15, sY + 85, DRAW_DIALOGBOX_BANK2, RGB(0,0,0));//"처리가 끝날 때까지 기다려 주십시오."
		break;
	
	case 0:
		for (i = 0; i < m_stDialogBoxInfo[14].sV1; i++)
		if ((m_pBankList[i + m_stDialogBoxInfo[14].sView] != NULL) && ((i + m_stDialogBoxInfo[14].sView) < DEF_MAXBANKITEMS)) {
			GetItemName(m_pBankList[i + m_stDialogBoxInfo[14].sView], cStr1, cStr2, cStr3);
			if ((msX > sX + 30) && (msX < sX + 210) && (msY >= sY + 50 + i*15) && (msY <= sY + 64 + i*15)) 
			{
				m_stMCursor.sCursorFrame = -1;
				if( (strlen(cStr2)==0) && (strlen(cStr3)==0) ) PutAlignedString(sX + 24, sX +240, sY + 50 + i*15, cStr1, 255,255,255);
				else
				{
					ZeroMemory( G_cTxt, sizeof(G_cTxt) );
					if( (strlen(cStr1)+strlen(cStr2)+strlen(cStr3)) < 36 )
					{
						if( (strlen(cStr2)>0) && (strlen(cStr3)>0) ) wsprintf( G_cTxt, "%s(%s, %s)", cStr1, cStr2, cStr3 );
						else wsprintf( G_cTxt, "%s(%s%s)", cStr1, cStr2, cStr3 );
						PutAlignedString(sX, sX + szX, sY + 50 + i*15, G_cTxt, 255,255,255);
					}
					else
					{
						if( (strlen(cStr2)>0) && (strlen(cStr3)>0) ) wsprintf( G_cTxt, "(%s, %s)", cStr2, cStr3 );
						else wsprintf( G_cTxt, "(%s%s)", cStr2, cStr3 );
						PutAlignedString(sX, sX + szX, sY + 50 + i*15, cStr1, 255,255,255);
						PutAlignedString(sX, sX + szX, sY + 50 + i*15 + 15, G_cTxt, 200,200,200);
						i++;
					}
				}
				cItemColor = m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cItemColor;
				if( cItemColor == 0 )
				{
					 m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSprite]->PutSpriteFast(msX, msY, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSpriteFrame, m_dwCurTime);
				}
				else
				{
					if ((m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos == DEF_EQUIPPOS_LHAND) ||
						(m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos == DEF_EQUIPPOS_RHAND) ||
						(m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
						// 무기, 방패등은 컬러 세트가 다르다. 갑옷은 이 색상 세트를 써서는 안된다.
						m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSprite]->PutSpriteRGB(msX, msY, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSpriteFrame, 
																			m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
					}
					else m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSprite]->PutSpriteRGB(msX, msY, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSpriteFrame, 
																			m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
				}
			}
			else
			{
				if( (strlen(cStr2)==0) && (strlen(cStr3)==0) ) PutAlignedString(sX + 24, sX +240, sY + 50 + i*15, cStr1);
				else
				{
					ZeroMemory( G_cTxt, sizeof(G_cTxt) );
					if( (strlen(cStr1)+strlen(cStr2)+strlen(cStr3)) < 36 )
					{
						if( (strlen(cStr2)>0) && (strlen(cStr3)>0) ) wsprintf( G_cTxt, "%s(%s, %s)", cStr1, cStr2, cStr3 );
						else wsprintf( G_cTxt, "%s(%s%s)", cStr1, cStr2, cStr3 );
						PutAlignedString(sX, sX + szX, sY + 50 + i*15, G_cTxt);
					}
					else PutAlignedString(sX, sX + szX, sY + 50 + i*15, cStr1);
				}
			}
		}

		iTotalLines = 0;
		for (i = 0; i < DEF_MAXBANKITEMS; i++) 
		if (m_pBankList[i] != NULL) iTotalLines++;

		// 스크롤 바 포인터 그린다.
		if (iTotalLines > m_stDialogBoxInfo[14].sV1) {
			d1 = (double)m_stDialogBoxInfo[14].sView;
			d2 = (double)(iTotalLines-m_stDialogBoxInfo[14].sV1);
			d3 = (274.0f * d1)/d2;
			iPointerLoc = (int)d3;
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX+242, sY + iPointerLoc + 35, 7);
		}
		else iPointerLoc = 0;

		// 스크롤바 찍기 처리 
		if (cLB != 0 && (iGetTopDialogBoxIndex() == 14) && iTotalLines > m_stDialogBoxInfo[14].sV1) {
			if ((msX >= sX + 230) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
				d1 = (double)(msY -(sY+35));
				d2 = (double)(iTotalLines-m_stDialogBoxInfo[14].sV1);
				d3 = (d1 * d2)/274.0f;
				m_stDialogBoxInfo[14].sView = (int)(d3+0.5);
			}
			else if ((msX >= sX + 230) && (msX <= sX + 260) && (msY > sY + 10) && (msY < sY + 40)) m_stDialogBoxInfo[14].sView = 0;
		}
		else m_stDialogBoxInfo[14].bIsScrollSelected = FALSE;
		if( iGetTopDialogBoxIndex() == 14 && msZ != 0 )
		{
			if( iTotalLines > 50 ) m_stDialogBoxInfo[14].sView = m_stDialogBoxInfo[14].sView - msZ/30;//창고아이템이 50개가 넘으면 한번에 두세줄씩 팍팍 스크롤..
			else {//아니면 한번에 한줄씩만 스크롤...
				if( msZ > 0 ) m_stDialogBoxInfo[14].sView--;
				if( msZ < 0 ) m_stDialogBoxInfo[14].sView++;
			}
			m_DInput.m_sZ = 0;
		}
		if( iTotalLines > m_stDialogBoxInfo[14].sV1 && m_stDialogBoxInfo[14].sView > iTotalLines-m_stDialogBoxInfo[14].sV1 ) m_stDialogBoxInfo[14].sView = iTotalLines-m_stDialogBoxInfo[14].sV1;
		if( iTotalLines <= m_stDialogBoxInfo[14].sV1 ) m_stDialogBoxInfo[14].sView = 0;
		if( m_stDialogBoxInfo[14].sView < 0 ) m_stDialogBoxInfo[14].sView = 0;
		PutAlignedString(sX, sX+szX, sY + 265, DRAW_DIALOGBOX_BANK3);//"맡기고자 하는 아이템을 가방에서 드래그"
		PutAlignedString(sX, sX+szX, sY + 280, DRAW_DIALOGBOX_BANK4);//"하여 여기에 놓으시거나 되찾고자 하는"
		PutAlignedString(sX, sX+szX, sY + 295, DRAW_DIALOGBOX_BANK5);//"아이템을 리스트에서 선택해 주세요."
		break;
	}
}
*/

void CGame::DrawDialogBox_Bank(short msX, short msY, short msZ, char cLB)
{
	short sX, sY, szX;
	int  i, iTotalLines, iPointerLoc, iLoc;
	double d1, d2, d3;
	char cItemColor, cStr1[64], cStr2[64], cStr3[64];
	BOOL bFlag = FALSE;
	
	sX = m_stDialogBoxInfo[14].sX;
	sY = m_stDialogBoxInfo[14].sY;
	szX = m_stDialogBoxInfo[14].sSizeX - 5;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 21);
	ZeroMemory( cStr1, sizeof(cStr1) );
	ZeroMemory( cStr2, sizeof(cStr2) );
	ZeroMemory( cStr3, sizeof(cStr3) );
	iLoc = 45;

	switch (m_stDialogBoxInfo[14].cMode) {
	case -1:
		PutString(sX + 30 + 15, sY + 70, DRAW_DIALOGBOX_BANK1, RGB(0,0,0));//"아이템 반환 처리중입니다."
		PutString(sX + 30 + 15, sY + 85, DRAW_DIALOGBOX_BANK2, RGB(0,0,0));//"처리가 끝날 때까지 기다려 주십시오."
		break;
	
	case 0:
		for (i = 0; i < m_stDialogBoxInfo[14].sV1; i++)
		if ((m_pBankList[i + m_stDialogBoxInfo[14].sView] != NULL) && ((i + m_stDialogBoxInfo[14].sView) < DEF_MAXBANKITEMS)) {
			GetItemName(m_pBankList[i + m_stDialogBoxInfo[14].sView], cStr1, cStr2, cStr3);
			if ((msX > sX + 30) && (msX < sX + 210) && (msY >= sY + 110 + i*15) && (msY <= sY + 124 + i*15)) 
			{
				bFlag = TRUE;
				
				PutAlignedString(sX, sX+szX, sY + 110 + i*15, cStr1, 255, 255, 255 );
				if(m_bIsSpecial)
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr1, 0, 255, 50 );
				else
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr1, 255, 255, 255 );
				
				if( strlen(cStr2) > 0 )
				{
					iLoc += 15;
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr2, 150, 150, 150 );
				}
				if( strlen(cStr3) > 0 )
				{
					iLoc += 15;
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr3, 150, 150, 150 );
				}
				if( m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sLevelLimit != 0 && m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_dwAttribute & 0x00000001 )
				{
					iLoc += 15;
					wsprintf( G_cTxt, "%s: %d", DRAW_DIALOGBOX_SHOP24, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sLevelLimit );
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, G_cTxt, 150, 150, 150 );
				}
	
	#if DEF_LANGUAGE == 3
				if( !strcmp( m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cName, "스톤오브새크리파이스"))
				{
					iLoc += 15;
					wsprintf( G_cTxt, "남은 수명: %d", m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_wCurLifeSpan );
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, G_cTxt, 150, 150, 150 );
				}
	#endif
	
				if( (m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos != DEF_EQUIPPOS_NONE) && (m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_wWeight>=1100) )
				{
					iLoc += 15;
					//2003.03.11 정진광 수정...
					// 정진 왈 2001도 21. 2099도 21이라는 흐흐흐..
					int		_wWeight = 0;
					if(m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_wWeight%100)				_wWeight = 1;
					wsprintf( G_cTxt, DRAW_DIALOGBOX_SHOP15, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_wWeight/100 + _wWeight);

					PutAlignedString(sX + 70, sX + szX, sY + iLoc, G_cTxt, 150, 150, 150 );
				}

				cItemColor = m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cItemColor;
				if( cItemColor == 0 )
				{
					 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSprite]->PutSpriteFast(sX+60, sY+68, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSpriteFrame, m_dwCurTime);
				}
				else
				{
					if ((m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos == DEF_EQUIPPOS_LHAND) ||
						(m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos == DEF_EQUIPPOS_RHAND) ||
						(m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
						// 무기, 방패등은 컬러 세트가 다르다. 갑옷은 이 색상 세트를 써서는 안된다.
						m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSprite]->PutSpriteRGB(sX+60, sY+68, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSpriteFrame, 
																			m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
					}
					else m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSprite]->PutSpriteRGB(sX+60, sY+68, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSpriteFrame, 
																			m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
				}
			}
			else
			{
				if (m_bIsSpecial)
					PutAlignedString(sX, sX+szX, sY + 110 + i*15, cStr1, 0, 255, 50 );
				else
					PutAlignedString(sX, sX+szX, sY + 110 + i*15, cStr1, 0, 0, 0 );
			}
		}

		iTotalLines = 0;
		for (i = 0; i < DEF_MAXBANKITEMS; i++) 
		if (m_pBankList[i] != NULL) iTotalLines++;

		// 스크롤 바 포인터 그린다.
		if (iTotalLines > m_stDialogBoxInfo[14].sV1) {
			d1 = (double)m_stDialogBoxInfo[14].sView;
			d2 = (double)(iTotalLines-m_stDialogBoxInfo[14].sV1);
			d3 = (274.0f * d1)/d2;
			iPointerLoc = (int)d3;
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX+242, sY + iPointerLoc + 35, 7);
		}
		else iPointerLoc = 0;

		// 스크롤바 찍기 처리 
		if (cLB != 0 && (iGetTopDialogBoxIndex() == 14) && iTotalLines > m_stDialogBoxInfo[14].sV1) {
			if ((msX >= sX + 230) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
				d1 = (double)(msY -(sY+35));
				d2 = (double)(iTotalLines-m_stDialogBoxInfo[14].sV1);
				d3 = (d1 * d2)/274.0f;
				m_stDialogBoxInfo[14].sView = (int)(d3+0.5);
			}
			else if ((msX >= sX + 230) && (msX <= sX + 260) && (msY > sY + 10) && (msY < sY + 40)) m_stDialogBoxInfo[14].sView = 0;
		}
		else m_stDialogBoxInfo[14].bIsScrollSelected = FALSE;
		if( iGetTopDialogBoxIndex() == 14 && msZ != 0 )
		{
			if( iTotalLines > 50 ) m_stDialogBoxInfo[14].sView = m_stDialogBoxInfo[14].sView - msZ/30;//창고아이템이 50개가 넘으면 한번에 두세줄씩 팍팍 스크롤..
			else {//아니면 한번에 한줄씩만 스크롤...
				if( msZ > 0 ) m_stDialogBoxInfo[14].sView--;
				if( msZ < 0 ) m_stDialogBoxInfo[14].sView++;
			}
			m_DInput.m_sZ = 0;
		}
		if( iTotalLines > m_stDialogBoxInfo[14].sV1 && m_stDialogBoxInfo[14].sView > iTotalLines-m_stDialogBoxInfo[14].sV1 ) m_stDialogBoxInfo[14].sView = iTotalLines-m_stDialogBoxInfo[14].sV1;
		if( iTotalLines <= m_stDialogBoxInfo[14].sV1 ) m_stDialogBoxInfo[14].sView = 0;
		if( m_stDialogBoxInfo[14].sView < 0 ) m_stDialogBoxInfo[14].sView = 0;
		if( bFlag == FALSE )
		{
			PutAlignedString(sX, sX+szX, sY + 45, DRAW_DIALOGBOX_BANK3);//"맡기고자 하는 아이템을 가방에서 드래그"
			PutAlignedString(sX, sX+szX, sY + 60, DRAW_DIALOGBOX_BANK4);//"하여 여기에 놓으시거나 되찾고자 하는"
			PutAlignedString(sX, sX+szX, sY + 75, DRAW_DIALOGBOX_BANK5);//"아이템을 리스트에서 선택해 주세요."
		}
		break;
	}
}

void CGame::DrawDialogBox_FeedBackCard(short msX, short msY)
{

}

void CGame::DrawDialogBox_Character(short msX, short msY)
{
 short sX, sY, sSprH, sFrame;
 int i, iR, iG, iB, iSkirtDraw = 0;
 char cTxt2[120], cEquipPosStatus[DEF_MAXITEMEQUIPPOS];
 char  cItemColor, cCollison;
	
	sX = m_stDialogBoxInfo[1].sX;
	sY = m_stDialogBoxInfo[1].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 0, FALSE, m_bDialogTrans);
		
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	strcpy(G_cTxt, m_cPlayerName);
	strcat(G_cTxt, " : ");
		
	if (m_iPKCount > 0) {
		ZeroMemory(cTxt2, sizeof(cTxt2));
		wsprintf(cTxt2, DRAW_DIALOGBOX_CHARACTER1, m_iPKCount);//"범죄자(%d) "
		strcat(G_cTxt, cTxt2);
	}

	ZeroMemory(cTxt2, sizeof(cTxt2));
	wsprintf(cTxt2, DRAW_DIALOGBOX_CHARACTER2, m_iContribution);//"공헌도(%d) "
	strcat(G_cTxt, cTxt2);

	PutAlignedString(sX +24, sX +252, sY+52, G_cTxt, 45,20,20);
	
	ZeroMemory(G_cTxt, sizeof(G_cTxt));

	if( m_bCitizen == FALSE ) strcpy( G_cTxt, DRAW_DIALOGBOX_CHARACTER7);//"여행자"
	else
	{

//#if DEF_LANGUAGE > 2		// Korea 2.19
		if(m_bHunter)
		{
			if (m_bAresden)
				 strcat(G_cTxt, DEF_MSG_ARECIVIL);//"아레스덴 민간인"
			else strcat(G_cTxt, DEF_MSG_ELVCIVIL);//"엘바인 민간인"
		}
		else
		{
			if (m_bAresden)
				 strcat(G_cTxt, DEF_MSG_ARESOLDIER);//"아레스덴 병사"
			else strcat(G_cTxt, DEF_MSG_ELVSOLDIER);//"엘바인 병사"
		}
//#else
//		if (m_bAresden)
//			 strcat(G_cTxt, DRAW_OBJECT_NAME62);//"아레스덴 소속"
//		else strcat(G_cTxt, DRAW_OBJECT_NAME74);//"엘바인 소속"
//#endif

		if( m_iGuildRank >= 0 )
		{
			strcat( G_cTxt, "(" );
			strcat( G_cTxt, m_cGuildName );
			if( m_iGuildRank == 0 ) strcat( G_cTxt, DEF_MSG_GUILDMASTER1 );//" 길드마스터)"
			else strcat( G_cTxt, DEF_MSG_GUILDSMAN1 );//" 길드원)"
		}
	}

	// 2.05 인터페이스 수정 
	PutAlignedString(sX, sX+275, sY+69, G_cTxt, 45,25,25);

	int iTemp;
	// Level
	wsprintf(G_cTxt, "%d", m_iLevel);
	PutAlignedString(sX+180, sX+250, sY + 106, G_cTxt, 45,25,25);
	// Exp
	wsprintf(G_cTxt, "%d", m_iExp);
	PutAlignedString(sX+180, sX+250, sY + 125, G_cTxt, 45,25,25);
	// Next.Exp
	wsprintf(G_cTxt, "%d", iGetLevelExp(m_iLevel+1));
	PutAlignedString(sX+180, sX+250, sY + 142, G_cTxt, 45,25,25);
	// Hp
	iTemp = m_iHP;
	wsprintf(G_cTxt, "%d/%d", iTemp, m_iVit*3 + m_iLevel*2 + m_iStr/2);
	PutAlignedString(sX+180, sX+250, sY + 173, G_cTxt, 45,25,25);
	// Mp
	iTemp = m_iMP;
	wsprintf(G_cTxt, "%d/%d", iTemp, m_iMag*2 + m_iLevel*2 + m_iInt/2);
	PutAlignedString(sX+180, sX+250, sY + 191, G_cTxt, 45,25,25);
	// Sp
	iTemp = m_iSP;
	wsprintf(G_cTxt, "%d/%d", iTemp, m_iStr*2 + m_iLevel*2);
	PutAlignedString(sX+180, sX+250, sY + 208, G_cTxt, 45,25,25);
	// Max.Load
	wsprintf(G_cTxt, "%d/%d", (_iCalcTotalWeight()/100), (m_iStr*5 + m_iLevel*5));
	PutAlignedString(sX+180, sX+250, sY + 240, G_cTxt, 45,25,25);
	// Enemy Kills
	wsprintf(G_cTxt, "%d", m_iEnemyKillCount);
	PutAlignedString(sX+180, sX+250, sY + 257, G_cTxt, 45,25,25);
	// Str
	wsprintf(G_cTxt, "%d", m_iStr);
	PutAlignedString(sX+48, sX+82, sY + 285, G_cTxt, 45,25,25);
	// Vit
	wsprintf(G_cTxt, "%d", m_iVit);
	PutAlignedString(sX+218, sX+251, sY + 285, G_cTxt, 45,25,25);
	// Dex
	wsprintf(G_cTxt, "%d", m_iDex);
	PutAlignedString(sX+48, sX+82, sY +302, G_cTxt, 45,25,25);
	// Int
	wsprintf(G_cTxt, "%d", m_iInt);
	PutAlignedString(sX+135, sX+167, sY +285, G_cTxt, 45,25,25);
	// Mag
	wsprintf(G_cTxt, "%d", m_iMag);
	PutAlignedString(sX+135, sX+167, sY +302, G_cTxt, 45,25,25);
	// Chr
	wsprintf(G_cTxt, "%d", m_iCharisma);
	PutAlignedString(sX+218, sX+251, sY +302, G_cTxt, 45,25,25);
	// 착용중인 아이템의 상태를 정리한다. 
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		cEquipPosStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++) {
		if ((m_pItemList[i] != NULL) && (m_bIsItemEquipped[i] == TRUE))	cEquipPosStatus[ m_pItemList[i]->m_cEquipPos ] = i;
	}
	// 몸통 
	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3)) {
		cCollison = -1;
		// 남자인 경우 
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0]->PutSpriteFast(sX + 171, sY + 290, m_sPlayerType-1, m_dwCurTime);

		if (cEquipPosStatus[DEF_EQUIPPOS_HEAD] == -1) {
			// 투구를 쓰고 있지 않음 머리를 그린다.
			_GetHairColorRGB(((m_sPlayerAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18]->PutSpriteRGB(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x0F00) >> 8, iR, iG, iB, m_dwCurTime);
		}

		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19]->PutSpriteFast(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x000F), m_dwCurTime);

		// 순서대로 그린다.
		if (cEquipPosStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_BACK] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 41, sY + 137, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 41, sY + 137, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 41, sY + 137, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 41, sY + 137, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison( sX + 41, sY + 137, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BACK;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_PANTS] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_PANTS;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_ARMS] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_ARMS;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_BOOTS] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BOOTS;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_BODY] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BODY;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_FULLBODY] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_FULLBODY;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_LHAND] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 90, sY + 170, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 90, sY + 170, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 90, sY + 170, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 90, sY + 170, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_LHAND;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_RHAND] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 57, sY + 186, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 57, sY + 186, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 57, sY + 186, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 57, sY + 186, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_RHAND;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_TWOHAND] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 57, sY + 186, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 57, sY + 186, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 57, sY + 186, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 57, sY + 186, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_TWOHAND;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_NECK] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 35, sY + 120, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 35, sY + 120, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 35, sY + 120, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 35, sY + 120, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_NECK;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_RFINGER] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 32, sY + 193, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 32, sY + 193, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 32, sY + 193, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 32, sY + 193, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_RFINGER;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH      = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_HEAD] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 72, sY + 135, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 72, sY + 135, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 72, sY + 135, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 72, sY + 135, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_HEAD;
		}
		if( cCollison != -1 )
		{
			sSprH      = m_pItemList[cEquipPosStatus[cCollison]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[cCollison]]->m_sSpriteFrame;
			if( cCollison == DEF_EQUIPPOS_HEAD )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 72, sY + 135, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_RFINGER )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 32, sY + 193, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_NECK )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 35, sY + 120, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_TWOHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 57, sY + 186, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_RHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 57, sY + 186, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_LHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 90, sY + 170, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BODY )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);		
			else if( cCollison == DEF_EQUIPPOS_FULLBODY )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BOOTS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_ARMS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_PANTS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);		
			else if( cCollison == DEF_EQUIPPOS_BACK )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 41, sY + 137, sFrame, m_dwCurTime);
		}
		//
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6)) {
		cCollison = -1;
		// 여자 캐릭터이다. 
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40]->PutSpriteFast(sX + 171, sY + 290, m_sPlayerType-4, m_dwCurTime);

		if (cEquipPosStatus[DEF_EQUIPPOS_HEAD] == -1) {
			_GetHairColorRGB(((m_sPlayerAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18 +40]->PutSpriteRGB(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x0F00) >> 8, iR, iG, iB, m_dwCurTime);
		}

		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19 +40]->PutSpriteFast(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x000F), m_dwCurTime);
 		
		// 스커트 그리는 모드인지 판단.
		if ((cEquipPosStatus[DEF_EQUIPPOS_PANTS] != -1)) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if ((sSprH == 12) && (sFrame == 0)) iSkirtDraw = 1;
		}

		// 순서대로 그린다.

		if (cEquipPosStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BACK]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_BACK] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 45, sY + 143, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 45, sY + 143, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 45, sY + 143, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 45, sY + 143, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BACK;
		}

		if ((cEquipPosStatus[DEF_EQUIPPOS_BOOTS] != -1) && (iSkirtDraw == 1)) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_BOOTS] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BOOTS;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_PANTS]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_PANTS] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_PANTS;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_ARMS]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_ARMS] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_ARMS;
		}
		
		if ((cEquipPosStatus[DEF_EQUIPPOS_BOOTS] != -1) && (iSkirtDraw == 0)) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BOOTS]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_BOOTS] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BOOTS;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_BODY]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_BODY] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BODY;
		}
		if (cEquipPosStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_FULLBODY]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_FULLBODY] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_FULLBODY;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_LHAND]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_LHAND] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 84, sY + 175, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 84, sY + 175, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 84, sY + 175, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 84, sY + 175, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_LHAND;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RHAND]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_RHAND] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 60, sY + 191, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 60, sY + 191, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 60, sY + 191, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 60, sY + 191, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_RHAND;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_TWOHAND]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_TWOHAND] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 60, sY + 191, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 60, sY + 191, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 60, sY + 191, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 60, sY + 191, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_TWOHAND;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_NECK]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_NECK] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 35, sY + 120, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 35, sY + 120, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 35, sY + 120, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 35, sY + 120, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_NECK;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_RFINGER]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_RFINGER] ] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 32, sY + 193, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 32, sY + 193, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 32, sY + 193, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 32, sY + 193, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_RFINGER;
		}

		if (cEquipPosStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH  = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPosStatus[DEF_EQUIPPOS_HEAD]]->m_cItemColor;
			
			if (m_bIsItemDisabled[ cEquipPosStatus[DEF_EQUIPPOS_HEAD]] == FALSE) {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 72, sY +139, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 72, sY +139, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			else {
				if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 72, sY +139, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 72, sY +139, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_HEAD;
		}
		if( cCollison != -1 )
		{
			sSprH      = m_pItemList[cEquipPosStatus[cCollison]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPosStatus[cCollison]]->m_sSpriteFrame;
			if( cCollison == DEF_EQUIPPOS_HEAD )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 72, sY + 139, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_RFINGER )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 32, sY + 193, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_NECK )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 35, sY + 120, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_TWOHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 60, sY + 191, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_RHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 60, sY + 191, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_LHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 84, sY + 175, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BODY )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_FULLBODY )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BOOTS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_ARMS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_PANTS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);		
			else if( cCollison == DEF_EQUIPPOS_BACK )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 45, sY + 143, sFrame, m_dwCurTime);
		}
	}
	
	// v2.05
	if ((msX >= sX + 15) && (msX <= sX + 15 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 15, sY +340, 5, FALSE, m_bDialogTrans); 
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 15, sY +340, 4, FALSE, m_bDialogTrans); 

	
	if ((msX >= sX + 98) && (msX <= sX + 98 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 98, sY +340, 45, FALSE, m_bDialogTrans); 
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 98, sY +340, 44, FALSE, m_bDialogTrans); 
	

	if ((msX >= sX + 180) && (msX <= sX + 180 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 180, sY +340, 11, FALSE, m_bDialogTrans); 
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 180, sY +340, 10, FALSE, m_bDialogTrans); 
}

#ifdef _DEBUG
void CGame::DrawDialogBox_LevelUpSetting(short msX, short msY)
{
 short sX, sY, szX;
 DWORD dwTime = m_dwCurTime;
 char cTxt[120];
	sX = m_stDialogBoxInfo[12].sX;
	sY = m_stDialogBoxInfo[12].sY;
	szX = m_stDialogBoxInfo[12].sSizeX;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX - 1, sY + 100, 4);

	PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_LEVELUP_SETTING1);//"레벨이 올랐을 경우 증가시키고자 하는"
	PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_LEVELUP_SETTING2);//"특성치에 포인트를 할당하십시오."

	wsprintf(cTxt, "X:%d  Y:%d, sx:%d, sy:%d", msX, msY, sX, sY);
	PutString(sX + 20,  sY + 80, cTxt, RGB(0,0,0));

	//wsprintf(cTxt, DRAW_DIALOGBOX_LEVELUP_SETTING3, m_iLU_Point);//"* 남은 포인트: %d"
	//PutString(sX + 40,  sY + 85, cTxt, RGB(0,0,0));
	PutString(sX + 20,  sY + 103, "* 남은 포인트", RGB(0,0,0));
	wsprintf(cTxt, "%d", m_iLU_Point);
	PutString(sX + 105,  sY + 103, cTxt, RGB(0,0,0));

	PutString(sX + 20, sY + 127, DRAW_DIALOGBOX_LEVELUP_SETTING4, RGB(5,5,5));//"Strength"
	wsprintf(cTxt, "%d", m_cLU_Str);
	PutString(sX + 158, sY + 127, cTxt, RGB(25,35,25));
	wsprintf(cTxt, "%d", m_iStr);
	PutString(sX + 105, sY + 127, cTxt, RGB(25,35,25));
	
	PutString(sX + 20, sY + 147, DRAW_DIALOGBOX_LEVELUP_SETTING5, RGB(5,5,5));//"Vitality"
	wsprintf(cTxt, "%d", m_cLU_Vit);
	PutString(sX + 158, sY + 147, cTxt, RGB(25,35,25));
	wsprintf(cTxt, "%d", m_iVit);
	PutString(sX + 105, sY + 147, cTxt, RGB(25,35,25));
		
	PutString(sX + 20, sY + 165, DRAW_DIALOGBOX_LEVELUP_SETTING6, RGB(5,5,5));//"Dexterity"
	wsprintf(cTxt, "%d", m_cLU_Dex);
	PutString(sX + 158, sY + 165, cTxt, RGB(25,35,25));
	wsprintf(cTxt, "%d", m_iDex);
	PutString(sX + 105, sY + 165, cTxt, RGB(25,35,25));
	
	PutString(sX + 20, sY + 185, DRAW_DIALOGBOX_LEVELUP_SETTING7, RGB(5,5,5));//"Intelligence"
	wsprintf(cTxt, "%d", m_cLU_Int);
	PutString(sX + 158, sY + 185, cTxt, RGB(25,35,25));
	wsprintf(cTxt, "%d", m_iInt);
	PutString(sX + 105, sY + 185, cTxt, RGB(25,35,25));
	
	PutString(sX + 20, sY + 203, DRAW_DIALOGBOX_LEVELUP_SETTING8, RGB(5,5,5));//"Magic"
	wsprintf(cTxt, "%d", m_cLU_Mag);
	PutString(sX + 158, sY + 203, cTxt, RGB(25,35,25));
	wsprintf(cTxt, "%d", m_iMag);
	PutString(sX + 105, sY + 203, cTxt, RGB(25,35,25));
	
	PutString(sX + 20, sY + 223, DRAW_DIALOGBOX_LEVELUP_SETTING9, RGB(5,5,5));//"Charisma"
	wsprintf(cTxt, "%d", m_cLU_Char);
	PutString(sX + 158, sY + 223, cTxt, RGB(25,35,25));
	wsprintf(cTxt, "%d", m_iCharisma);
	PutString(sX + 105, sY + 223, cTxt, RGB(25,35,25));
	
//	PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_LEVELUP_SETTING10);//"레벨이 오르는 순간 현재 설정값으로"
//	PutAlignedString(sX, sX + szX, sY + 235, DRAW_DIALOGBOX_LEVELUP_SETTING11);//"특성치가 증가하게 됩니다."
//	PutAlignedString(sX, sX + szX, sY + 250, DRAW_DIALOGBOX_LEVELUP_SETTING12);//"포인트를 모두 할당한 후"
//	PutAlignedString(sX, sX + szX, sY + 265, DRAW_DIALOGBOX_LEVELUP_SETTING13);//"Ok 버튼을 눌러주십시오."

	if (_iCheckLUS() == 0) {
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
	}

	switch (_iCheckLUS()) {
	case 0:	break;
	case 1: PutAlignedString(sX, sX + szX,  sY + 295, DRAW_DIALOGBOX_LEVELUP_SETTING14, 65,0,0);//"현재 설정이 완료되지 않았습니다."	
			break;
	case 2: PutAlignedString(sX, sX + szX,  sY + 295, DRAW_DIALOGBOX_LEVELUP_SETTING15, 65,0,0);//"현재 특성치 설정이 올바르지 않습니다."
			PutAlignedString(sX, sX + szX,  sY + 310, DRAW_DIALOGBOX_LEVELUP_SETTING16, 65,0,0);//"레벨업시에 특성치의 최대값을 초과하므로"
			PutAlignedString(sX, sX + szX,  sY + 325, DRAW_DIALOGBOX_LEVELUP_SETTING17, 65,0,0);//"현재 설정은 사용할 수 없습니다."
			break;
	}
}

#else

void CGame::DrawDialogBox_LevelUpSetting(short msX, short msY)
{
 short sX, sY, szX;
 DWORD dwTime = m_dwCurTime;
 char cTxt[120];
	sX = m_stDialogBoxInfo[12].sX;
	sY = m_stDialogBoxInfo[12].sY;
	szX = m_stDialogBoxInfo[12].sSizeX;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 2);

	PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_LEVELUP_SETTING1);//"레벨이 올랐을 경우 증가시키고자 하는"
	PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_LEVELUP_SETTING2);//"특성치에 포인트를 할당하십시오."

	wsprintf(cTxt, DRAW_DIALOGBOX_LEVELUP_SETTING3, m_iLU_Point);//"* 남은 포인트: %d"
	PutString(sX + 40,  sY + 85, cTxt, RGB(0,0,0));

	PutString(sX + 44, sY + 110, DRAW_DIALOGBOX_LEVELUP_SETTING4, RGB(5,5,5));//"Strength"
	PutString(sX + 139, sY + 112, "_____", RGB(5,5,5));
	wsprintf(cTxt, "%d", m_cLU_Str);
	PutString(sX + 139, sY + 110, cTxt, RGB(25,35,25));
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 190, sY + 115, 19, dwTime);
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 205, sY + 115, 20, dwTime);
	
	PutString(sX + 44, sY + 125, DRAW_DIALOGBOX_LEVELUP_SETTING5, RGB(5,5,5));//"Vitality"
	PutString(sX + 139, sY + 127, "_____", RGB(5,5,5));
	wsprintf(cTxt, "%d", m_cLU_Vit);
	PutString(sX + 139, sY + 125, cTxt, RGB(25,35,25));
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 190, sY + 130, 19, dwTime);
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 205, sY + 130, 20, dwTime);
	
	PutString(sX + 44, sY + 140, DRAW_DIALOGBOX_LEVELUP_SETTING6, RGB(5,5,5));//"Dexterity"
	PutString(sX + 139, sY + 142, "_____", RGB(5,5,5));
	wsprintf(cTxt, "%d", m_cLU_Dex);
	PutString(sX + 139, sY + 140, cTxt, RGB(25,35,25));
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 190, sY + 145, 19, dwTime);
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 205, sY + 145, 20, dwTime);
	
	PutString(sX + 44, sY + 155, DRAW_DIALOGBOX_LEVELUP_SETTING7, RGB(5,5,5));//"Intelligence"
	PutString(sX + 139, sY + 157, "_____", RGB(5,5,5));
	wsprintf(cTxt, "%d", m_cLU_Int);
	PutString(sX + 139, sY + 155, cTxt, RGB(25,35,25));
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 190, sY + 160, 19, dwTime);
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 205, sY + 160, 20, dwTime);
	
	PutString(sX + 44, sY + 170, DRAW_DIALOGBOX_LEVELUP_SETTING8, RGB(5,5,5));//"Magic"
	PutString(sX + 139, sY + 172, "_____", RGB(5,5,5));
	wsprintf(cTxt, "%d", m_cLU_Mag);
	PutString(sX + 139, sY + 170, cTxt, RGB(25,35,25));
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 190, sY + 175, 19, dwTime);
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 205, sY + 175, 20, dwTime);
	
	PutString(sX + 44, sY + 185, DRAW_DIALOGBOX_LEVELUP_SETTING9, RGB(5,5,5));//"Charisma"
	PutString(sX + 139, sY + 187, "_____", RGB(5,5,5));
	wsprintf(cTxt, "%d", m_cLU_Char);
	PutString(sX + 139, sY + 185, cTxt, RGB(25,35,25));
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 190, sY + 190, 19, dwTime);
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 205, sY + 190, 20, dwTime);
	
	PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_LEVELUP_SETTING10);//"레벨이 오르는 순간 현재 설정값으로"
	PutAlignedString(sX, sX + szX, sY + 235, DRAW_DIALOGBOX_LEVELUP_SETTING11);//"특성치가 증가하게 됩니다."
	PutAlignedString(sX, sX + szX, sY + 250, DRAW_DIALOGBOX_LEVELUP_SETTING12);//"포인트를 모두 할당한 후"
	PutAlignedString(sX, sX + szX, sY + 265, DRAW_DIALOGBOX_LEVELUP_SETTING13);//"Ok 버튼을 눌러주십시오."

	if (_iCheckLUS() == 0) {
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
	}

	switch (_iCheckLUS()) {
	case 0:	break;
	case 1: PutAlignedString(sX, sX + szX,  sY + 295, DRAW_DIALOGBOX_LEVELUP_SETTING14, 65,0,0);//"현재 설정이 완료되지 않았습니다."	
			break;
	case 2: PutAlignedString(sX, sX + szX,  sY + 295, DRAW_DIALOGBOX_LEVELUP_SETTING15, 65,0,0);//"현재 특성치 설정이 올바르지 않습니다."
			PutAlignedString(sX, sX + szX,  sY + 310, DRAW_DIALOGBOX_LEVELUP_SETTING16, 65,0,0);//"레벨업시에 특성치의 최대값을 초과하므로"
			PutAlignedString(sX, sX + szX,  sY + 325, DRAW_DIALOGBOX_LEVELUP_SETTING17, 65,0,0);//"현재 설정은 사용할 수 없습니다."
			break;
	}
}
#endif

void CGame::DrawDialogBox_CityHallMenu(short msX, short msY)
{
 short sX, sY, szX;
 char cTxt[120];
	
	sX = m_stDialogBoxInfo[13].sX;
	sY = m_stDialogBoxInfo[13].sY;
	szX = m_stDialogBoxInfo[13].sSizeX;	
		
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 18);//CityHall Menu Text

	switch (m_stDialogBoxInfo[13].cMode) {
	case 0:
		if (m_bCitizen == FALSE) {
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95))  
				 PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_CITYHALL_MENU1, 255,255,255);	//"시민권을 신청합니다."
			else PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_CITYHALL_MENU1, 4,0,50);		//"시민권을 신청합니다."
		}
		else PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_CITYHALL_MENU1, 65,65,65);			//"시민권을 신청합니다."
		
		if (m_iRewardGold > 0) {
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120)) 
				 PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU4, 255,255,255);	//"포상금을 받습니다."
			else PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU4, 4,0,50);		//"포상금을 받습니다."
		}
		else PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU4, 65,65,65);			//"포상금을 받습니다."

		if (m_iEnemyKillCount >= 300) {
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145))  
				 PutAlignedString(sX, sX + szX, sY + 120, DRAW_DIALOGBOX_CITYHALL_MENU8, 255,255,255);//"영웅의 망토를 받습니다."
			else PutAlignedString(sX, sX + szX, sY + 120, DRAW_DIALOGBOX_CITYHALL_MENU8, 4,0,50);//"영웅의 망토를 받습니다."
		}
		else PutAlignedString(sX, sX + szX, sY + 120, DRAW_DIALOGBOX_CITYHALL_MENU8, 65,65,65);//"영웅의 망토를 받습니다."

		if (m_stQuest.sQuestType != NULL) {
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 170))  
				 PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_CITYHALL_MENU11, 255,255,255);//"퀘스트를 취소합니다."
			else PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_CITYHALL_MENU11, 4,0,50);//"퀘스트를 취소합니다."
		}
		else PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_CITYHALL_MENU11, 65,65,65);//"퀘스트를 취소합니다."

//#if DEF_LANGUAGE > 2		// Korea 2.19
	#ifndef DEF_JAPAN_FOR_TERRA
		if ( (m_bIsCrusadeMode==FALSE) && m_bCitizen && (m_iPKCount==0)) {
			if (m_bHunter==TRUE)
			{ //민간인 이라면...
				if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 170) && (msY < sY + 195)) 
					 PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 255,255,255);//게임모드를 변경합니다.
				else
					PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 4,0,50);//게임모드를 변경합니다.
			} 
			else if(m_iLevel < 100) //레벨 100보다 작은 병사
			{
				if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 170) && (msY < sY + 195)) 
					 PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 255,255,255);//게임모드를 변경합니다.
				else
					PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 4,0,50);//게임모드를 변경합니다.
			}
			else	//	아니면 Disable...
				PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 65,65,65);//게임모드를 변경합니다.
		}
		else PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 65,65,65);//게임모드를 변경합니다.

		if ( (m_bIsCrusadeMode==FALSE) && m_bCitizen && (m_iPKCount==0)) {
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 195) && (msY < sY + 220)) 
				 PutAlignedString(sX, sX + szX, sY + 195, DRAW_DIALOGBOX_CITYHALL_MENU69, 255,255,255);//다른 지역으로 텔레포트 합니다.
			else PutAlignedString(sX, sX + szX, sY + 195, DRAW_DIALOGBOX_CITYHALL_MENU69, 4,0,50);//다른 지역으로 텔레포트 합니다.
		}
		else PutAlignedString(sX, sX + szX, sY + 195, DRAW_DIALOGBOX_CITYHALL_MENU69, 65,65,65);//다른 지역으로 텔레포트 합니다.
	#endif
//#endif

		if ( m_bIsCrusadeMode && m_bCitizen ) {
			if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 220) && (msY < sY + 220)) 
				 PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_CITYHALL_MENU14, 255,255,255);//"전면전시 맡은 역할을 변경합니다."
			else PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_CITYHALL_MENU14, 4,0,50);//"전면전시 맡은 역할을 변경합니다." 
		}
		else PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_CITYHALL_MENU14, 65,65,65);//"전면전시 맡은 역할을 변경합니다."
		
		PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU17);//"원하시는 항목을 선택해 주십시오."

		break;

	case 1:
		PutAlignedString(sX, sX + szX, sY + 80, DRAW_DIALOGBOX_CITYHALL_MENU18, 55,25,25);//"도시의 시민이 되면 여행자 신분으로서"
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU19, 55,25,25);//"의 레벨 제한이 없어지며, 도시에서 "
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_CITYHALL_MENU20, 55,25,25);//"생산되는대부분의 아이템을 사고 팔 수"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU21, 55,25,25);//"있습니다.다른 도시의 이교도들을 "
		PutAlignedString(sX, sX + szX, sY + 140,DRAW_DIALOGBOX_CITYHALL_MENU22, 55,25,25);//"격퇴함으로써 포상금을 받을 수 있으며"
		PutAlignedString(sX, sX + szX, sY + 155,DRAW_DIALOGBOX_CITYHALL_MENU23, 55,25,25);//" 길드를 만들거나 길드에 가입하여 " 
		PutAlignedString(sX, sX + szX, sY + 170,DRAW_DIALOGBOX_CITYHALL_MENU24, 55,25,25);//"집단행동을 할 수 있는 자격이 주어집니다."
		PutAlignedString(sX, sX + szX, sY + 200,DRAW_DIALOGBOX_CITYHALL_MENU25, 55,25,25);//"이 도시의 시민이 되어 시민으로서의 " 
		PutAlignedString(sX, sX + szX, sY + 215,DRAW_DIALOGBOX_CITYHALL_MENU26, 55,25,25);//"권리를 누리며 책임과 의무를 다 하시"
		PutAlignedString(sX, sX + szX, sY + 230,DRAW_DIALOGBOX_CITYHALL_MENU27, 55,25,25);//"겠습니까?"
		
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;
		
	case 2:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU28, 55,25,25);//"시민권을 신청중입니다..."
		break;

	case 3:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU29, 55,25,25);//"축하합니다! 시민권을 얻었습니다."
		
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 4:
		PutAlignedString(sX, sX + szX, sY + 80,  DRAW_DIALOGBOX_CITYHALL_MENU30, 55,25,25);//"시민권을 얻는데 실패하였습니다!"
		PutAlignedString(sX, sX + szX, sY + 100, DRAW_DIALOGBOX_CITYHALL_MENU31, 55,25,25);//"레벨이 낮거나 범죄를 저지른 상태라면"
		PutAlignedString(sX, sX + szX, sY + 115, DRAW_DIALOGBOX_CITYHALL_MENU32, 55,25,25);//"시민이 될 수 없습니다."
		
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 5:
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU33, 55,25,25);//"당신의 활동에 따른 포상금은"
		wsprintf(cTxt, DRAW_DIALOGBOX_CITYHALL_MENU34, m_iRewardGold);//"모두 합쳐서 %dGold입니다."
		PutAlignedString(sX, sX + szX, sY + 140, cTxt, 55,25,25);
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU35, 55,25,25);//"지금 포상금을 받으시겠습니까?"
		
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 7:
		PutAlignedString(sX, sX + szX, sY + 80,  DRAW_DIALOGBOX_CITYHALL_MENU46, 55,25,25);//"도시의 안전을 위해 이교도들의" 
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_CITYHALL_MENU47, 55,25,25);//"침략을 막아내는데 앞장선 용사들에게" 
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_CITYHALL_MENU48, 55,25,25);//"영웅의 망토를 수여합니다."
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU49, 55,25,25);//"영웅의 망토를 받기 위해서는 당신의"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU50, 55,25,25);//"Enemy Kill 횟수가 300 이상이" 
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU51, 55,25,25);//"되어야 하며 받고나면 Enemy Kill"
		PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU52, 55,25,25);//"횟수가 300 감소합니다."
		
		PutAlignedString(sX, sX + szX, sY + 205, DRAW_DIALOGBOX_CITYHALL_MENU53, 55,25,25);//"받으시겠습니까?"
		
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 8:
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU54, 55,25,25);//"현재 수행중인 퀘스트를"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU55, 55,25,25);//"취소하겠습니까?"
				
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 9:
		if( m_bHunter )
		{
			PutAlignedString(sX, sX + szX, sY +  53, DRAW_DIALOGBOX_CITYHALL_MENU57, 200,200,25);//"*당신은 현재 민간인 모드입니다.*"
		}
		else
		{
			PutAlignedString(sX, sX + szX, sY +  53, DRAW_DIALOGBOX_CITYHALL_MENU58, 200,200,25);//"*당신은 현재 병사 모드입니다.*"
		}
		PutAlignedString(sX, sX + szX, sY +  78, DRAW_DIALOGBOX_CITYHALL_MENU59, 55,25,25);//"(민간인모드는 전 지역에서 안전합니다)"

		PutString(sX + 35, sY + 108, DRAW_DIALOGBOX_CITYHALL_MENU60, RGB(220,130,45));//"민간인:"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU61, 55,25,25);//"타 국가의 병사로부터 안전"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU62, 55,25,25);//"합니다. 안전하게 레벨업을"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU63, 55,25,25);//"즐길 수 있는 모드입니다."
		PutString(sX + 35, sY +  177, DRAW_DIALOGBOX_CITYHALL_MENU64, RGB(220,130,45));//"병  사:"
		PutAlignedString(sX, sX + szX, sY + 194, DRAW_DIALOGBOX_CITYHALL_MENU65, 55,25,25);//"타 국가의 병사로부터 안전"
		PutAlignedString(sX, sX + szX, sY + 209, DRAW_DIALOGBOX_CITYHALL_MENU66, 55,25,25);//"하지 않습니다. 보호받을 수"
		PutAlignedString(sX, sX + szX, sY + 224, DRAW_DIALOGBOX_CITYHALL_MENU67, 55,25,25);//"없는 위험한 모드입니다."

		PutAlignedString(sX, sX + szX, sY + 252, DRAW_DIALOGBOX_CITYHALL_MENU68, 55,25,25);//"플레이모드를 변경하시겠습니까?"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 10:
		if( m_iTeleportMapCount > 0 )
		{
			PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_CITYHALL_MENU69, 55,25,25);//"다른 지역으로 텔레포트 합니다."
			PutAlignedString(sX, sX + szX, sY + 80, DRAW_DIALOGBOX_CITYHALL_MENU70, 55,25,25);//"다른 지욕으로으로 텔레포트 하기 위해"
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU71, 55,25,25);//"서는 3000Gold가 필요합니다."
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_CITYHALL_MENU72, 55,25,25);//"텔레포트 하시겠습니까?"
			
			PutString2(sX + 21, sY + 200, DRAW_DIALOGBOX_CITYHALL_MENU72_1, 55,25,25);//"일부 지역은 민간인으로 갈 수 없습니다."

			for( int i=0 ; i<m_iTeleportMapCount ; i++ )
			{
				ZeroMemory( cTxt, sizeof(cTxt) );
				GetOfficialMapName( m_stTeleportList[i].mapname, cTxt );
				wsprintf( G_cTxt, DRAW_DIALOGBOX_CITYHALL_MENU77, cTxt, m_stTeleportList[i].iCost );
				if( (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 120 + i*15) && (msY <= sY + 134 + i*15) )
					 PutAlignedString(sX, sX + szX, sY + 130 + i*15, G_cTxt, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 130 + i*15, G_cTxt,  55,  25,  25);
			}
		}
		else if( m_iTeleportMapCount == -1 )
		{
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU73, 55,25,25);//"현재 텔레포트 가능한 지역을"
			PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_CITYHALL_MENU74, 55,25,25);//"검색중입니다."
			PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_CITYHALL_MENU75, 55,25,25);//"잠시만 기다려 주세요"
		}
		else
		{
			PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_CITYHALL_MENU76, 55,25,25);//"텔레포트 할 수 있는 지역이 없습니다."
		}
		break;
	}
}


void CGame::DrawDialogBox_Exchange(short msX, short msY)
{
 short sX, sY, szX;
 DWORD dwTime = m_dwCurTime;
 char cItemColor, cTxt[120], cTxt2[128];
 char cNameStr[120], cSubStr1[120], cSubStr2[120];
 int iLoc;

	sX = m_stDialogBoxInfo[27].sX;
	sY = m_stDialogBoxInfo[27].sY ;
	szX = m_stDialogBoxInfo[27].sSizeX;

	//DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 1);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWEXCHANGE, sX, sY, 0);

//	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 9);
	
	switch (m_stDialogBoxInfo[27].cMode) {
	case 1:
		if (m_stDialogBoxInfo[27].sV1 != -1) {
			// 먼저 아이템을 그린다.
			cItemColor = m_stDialogBoxInfo[27].sV4; // v1.4
			if (cItemColor == 0)
				 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV1]->PutSpriteFast(sX + 130, sY + 100, m_stDialogBoxInfo[27].sV2, dwTime);
			else {
				switch (m_stDialogBoxInfo[27].sV1) {
				case 1:
				case 2:
				case 3:  m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV1]->PutSpriteRGB(sX + 130, sY + 100, m_stDialogBoxInfo[27].sV2,
																								           m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime); break;

				default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV1]->PutSpriteRGB(sX + 130, sY + 100, m_stDialogBoxInfo[27].sV2,
																								           m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime); break;
				}
			}
			
			// v1.42
			GetItemName(m_stDialogBoxInfo[27].cStr, m_stDialogBoxInfo[27].dwV1, cNameStr, cSubStr1, cSubStr2);

			PutAlignedString(sX + 80, sX + 180, sY + 42, m_cPlayerName, 35,55,35);

			wsprintf(cTxt, "%s", cNameStr);

			if (m_bIsSpecial)
			{
				PutAlignedString(sX + 15 , sX + 250, sY + 145, cTxt, 0,255,50);
				PutAlignedString(sX + 16, sX + 251, sY + 145, cTxt, 0,255,50);
			}
			else
			{
				PutAlignedString(sX + 15, sX + 250, sY + 145, cTxt, 35,35,35);
				PutAlignedString(sX + 16, sX + 251, sY + 145, cTxt, 35,35,35);
			}
			
			iLoc = 0;
			if (strlen(cSubStr1) != 0) {
				PutAlignedString(sX + 16, sX + 250, sY + 160 +iLoc, cSubStr1, 0,0,0);
				iLoc += 15;
			}
			if (strlen(cSubStr2) != 0) {
				PutAlignedString(sX + 16, sX + 250, sY + 160 +iLoc, cSubStr2, 0,0,0);
				iLoc += 15;
			}
			
			if (m_stDialogBoxInfo[27].sV3 != 1) {
				//2003.02.05 정진광 수정, 헬골드에 자릿수 표기 위해서				
				if(m_stDialogBoxInfo[27].sV3 > 1)
				{
					DisplayGold(m_stDialogBoxInfo[27].sV3);
					strcpy(cTxt2, G_cTxt);
				}
				else
					wsprintf(cTxt2, DRAW_DIALOGBOX_EXCHANGE2, m_stDialogBoxInfo[27].sV3);
				              //"수량: %d개"
				
				PutAlignedString(sX + 7, sX + 250, sY +160 +iLoc, cTxt2, 35,35,35);
				iLoc += 15;
			}

			if (m_stDialogBoxInfo[27].sV9 != -1) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE4, m_stDialogBoxInfo[27].sV11);
				               //"완성도: %d%%"
				PutAlignedString(sX + 7, sX + 250, sY + 160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}

			if (iLoc < 45) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxInfo[27].sV9, m_stDialogBoxInfo[27].sV10);
							   //"수명: %d/%d"
				PutAlignedString(sX + 7, sX + 250, sY + 160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}
		}

		if (m_stDialogBoxInfo[27].sV5 != -1) {
			cItemColor = m_stDialogBoxInfo[27].sV8; // v1.4
			if (cItemColor == 0)
				 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV5]->PutSpriteFast(sX + 400, sY + 100,
			                                                                                         m_stDialogBoxInfo[27].sV6, dwTime);
			else {
				switch (m_stDialogBoxInfo[27].sV5) {
				case 1:
				case 2:
				case 3:  m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV5]->PutSpriteRGB(sX + 400, sY + 100, m_stDialogBoxInfo[27].sV6,
																								           m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime); break;

				default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV5]->PutSpriteRGB(sX + 400, sY + 100, m_stDialogBoxInfo[27].sV6,
																								           m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime); break;
				}
			}

			PutAlignedString(sX + 250, sX + 540, sY + 42, m_stDialogBoxInfo[27].cStr4, 35,55,35);
			// v1.42
			GetItemName(m_stDialogBoxInfo[27].cStr3, m_stDialogBoxInfo[27].dwV2, cNameStr, cSubStr1, cSubStr2);
			
			wsprintf(cTxt, "%s", cNameStr);
			
			if(m_bIsSpecial)
			{
				PutAlignedString(sX + 270, sX + 520, sY + 145, cTxt, 0,255,50);
				PutAlignedString(sX + 271, sX + 521, sY + 145, cTxt, 0,255,50);
			}
			else
			{
				PutAlignedString(sX + 270, sX + 520, sY + 145, cTxt, 35,35,35);
				PutAlignedString(sX + 271, sX + 521, sY + 145, cTxt, 35,35,35);
			}

			iLoc = 0;
			if (strlen(cSubStr1) != 0) {
				PutAlignedString(sX + 270, sX + 520, sY + 160 +iLoc, cSubStr1, 0,0,0);
				iLoc += 15;
			}
			
			if (strlen(cSubStr2) != 0) {
				PutAlignedString(sX + 270, sX + 520, sY + 160 +iLoc, cSubStr2, 0,0,0);
				iLoc += 15;
			}

			if (m_stDialogBoxInfo[27].sV7 != 1) {
				
				//2003.02.05 정진광 수정, 헬골드에 자릿수 표기 위해서
				if(m_stDialogBoxInfo[27].sV7 > 1)
				{
					DisplayGold(m_stDialogBoxInfo[27].sV7);
					strcpy(cTxt2, G_cTxt);
				}
				else
				wsprintf(cTxt2, DRAW_DIALOGBOX_EXCHANGE2, m_stDialogBoxInfo[27].sV7);
				               //"수량: %d개"
				PutAlignedString(sX + 270, sX + 520, sY +160 +iLoc, cTxt2, 35,35,35);
				iLoc += 15;
			}

			if (m_stDialogBoxInfo[27].sV14 != -1) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE4, m_stDialogBoxInfo[27].sV14);
				                //"완성도: %d%%"
				PutAlignedString(sX + 270, sX + 520, sY + 160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}

			if (iLoc < 45) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxInfo[27].sV12, m_stDialogBoxInfo[27].sV13);
							   //"수명: %d/%d"
				PutAlignedString(sX + 270, sX + 520, sY + 160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}
		}

		// 현재 상태에 맞는 적절한 메시지 출력 
		if ((m_stDialogBoxInfo[27].sV1 != -1) && (m_stDialogBoxInfo[27].sV5 == -1)) {
			PutAlignedString(sX, sX + szX, sY + 235 +10, DRAW_DIALOGBOX_EXCHANGE9, 55,25,25);//" 상대방이 교환할 아이템을 선택할 때까지"
			PutAlignedString(sX, sX + szX, sY + 250 +10, DRAW_DIALOGBOX_EXCHANGE10, 55,25,25);//"기다려 주세요. 만약 교환을 취소하고자 "
			PutAlignedString(sX, sX + szX, sY + 265 +10, DRAW_DIALOGBOX_EXCHANGE11, 55,25,25);//"한다면 Cancel 버튼을 누릅니다."
		}
		else if ((m_stDialogBoxInfo[27].sV1 == -1) && (m_stDialogBoxInfo[27].sV5 != -1)) {
			PutAlignedString(sX, sX + szX, sY + 205 +10, DRAW_DIALOGBOX_EXCHANGE12, 55,25,25);//" 다른 플레이어가 아이템 교환을 요청"
			PutAlignedString(sX, sX + szX, sY + 220 +10, DRAW_DIALOGBOX_EXCHANGE13, 55,25,25);//"했습니다. 위의 아이템과 교환하고자 하는"
			PutAlignedString(sX, sX + szX, sY + 235 +10, DRAW_DIALOGBOX_EXCHANGE14, 55,25,25);//" 아이템을 골라 빈 칸에 놓은 후 "
			PutAlignedString(sX, sX + szX, sY + 250 +10, DRAW_DIALOGBOX_EXCHANGE15, 55,25,25);//"Exchange 버튼을 눌러 교환하거나"
			PutAlignedString(sX, sX + szX, sY + 265 +10, DRAW_DIALOGBOX_EXCHANGE16, 55,25,25);//"Cancel 버튼을 눌러 교환요청을 거절"
			PutAlignedString(sX, sX + szX, sY + 280 +10, DRAW_DIALOGBOX_EXCHANGE17, 55,25,25);//"할 수 있습니다."
		}
		else if ((m_stDialogBoxInfo[27].sV1 != -1) && (m_stDialogBoxInfo[27].sV5 != -1)) {
			PutAlignedString(sX, sX + szX, sY + 205 +10, DRAW_DIALOGBOX_EXCHANGE18, 55,25,25);//" 아이템 교환 준비가 모두 끝났습니다."
			PutAlignedString(sX, sX + szX, sY + 220 +10, DRAW_DIALOGBOX_EXCHANGE19, 55,25,25);//"위의 내용대로 아이템을 교환하고자 하면"
			PutAlignedString(sX, sX + szX, sY + 235 +10, DRAW_DIALOGBOX_EXCHANGE20, 55,25,25);//"Exchange 버튼을 누르시고, 교환을 "
			PutAlignedString(sX, sX + szX, sY + 250 +10, DRAW_DIALOGBOX_EXCHANGE21, 55,25,25);//"취소하고자 한다면 Cancel 버튼을 "
			PutAlignedString(sX, sX + szX, sY + 265 +10, DRAW_DIALOGBOX_EXCHANGE22, 55,25,25);//"누릅니다. "
			PutAlignedString(sX, sX + szX, sY + 280 +10, DRAW_DIALOGBOX_EXCHANGE23, 55,25,25);//" 일단 Exchange 버튼을 누르면 취소가"
		}

		if ((m_stDialogBoxInfo[27].sV1 != -1) && (m_stDialogBoxInfo[27].sV5 != -1)) {
		if ( (msX >= sX + 200) && (msX <= sX + 200 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY) )  
			 PutString_SprFont(sX + 220,  sY + 310, "Exchange", 6,6,20);
		else PutString_SprFont(sX + 220,  sY + 310, "Exchange", 0,0,7);
		}
		else PutString_SprFont(sX + 220,  sY + 310, "Exchange", 15,15,15);
	
		if ( (msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY) )
			 PutString_SprFont(sX + 450, sY + 310, "Cancel", 6,6,20);
		else PutString_SprFont(sX + 450, sY + 310, "Cancel", 0,0,7);
		break;

	case 2:
		if (m_stDialogBoxInfo[27].sV1 != -1) {
			// 먼저 아이템을 그린다.
			cItemColor = m_stDialogBoxInfo[27].sV4; // v1.4
			if (cItemColor == 0)
				 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV1]->PutSpriteFast(sX + 130, sY + 100,
			                                                                                         m_stDialogBoxInfo[27].sV2, dwTime);
			else {
				switch (m_stDialogBoxInfo[27].sV1) {
				case 1:
				case 2:
				case 3:  m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV1]->PutSpriteRGB(sX + 130, sY + 100, m_stDialogBoxInfo[27].sV2,
																								           m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime); break;

				default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV1]->PutSpriteRGB(sX + 130, sY + 100, m_stDialogBoxInfo[27].sV2,
																								           m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime); break;
				}
			}
			// v1.42
			GetItemName(m_stDialogBoxInfo[27].cStr, m_stDialogBoxInfo[27].dwV1, cNameStr, cSubStr1, cSubStr2);
			PutAlignedString(sX + 80, sX + 180, sY + 42, m_cPlayerName, 35,55,35);
		
			wsprintf(cTxt, "%s", cNameStr);

			if (m_bIsSpecial)
			{
				PutAlignedString(sX + 15 , sX + 250, sY + 145, cTxt, 0,255,50);
				PutAlignedString(sX + 16, sX + 251, sY + 145, cTxt, 0,255,50);
			}
			else
			{
				PutAlignedString(sX + 15, sX + 250, sY + 145, cTxt, 35,35,35);
				PutAlignedString(sX + 16, sX + 251, sY + 145, cTxt, 35,35,35);
			}
			
			iLoc = 0;
			if (strlen(cSubStr1) != 0) {
				PutAlignedString(sX + 16, sX + 250, sY + 160 +iLoc, cSubStr1, 0,0,0);
				iLoc += 15;
			}
			
			if (strlen(cSubStr2) != 0) {
				PutAlignedString(sX + 16, sX + 250, sY + 160 +iLoc, cSubStr2, 0,0,0);
				iLoc += 15;
			}

			if (m_stDialogBoxInfo[27].sV3 != 1) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE2, m_stDialogBoxInfo[27].sV3);
				              //"수량: %d개"
				PutAlignedString(sX + 7, sX + 250, sY +160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}

			if (m_stDialogBoxInfo[27].sV9 != -1) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE4, m_stDialogBoxInfo[27].sV11); 
				              //"완성도: %d%%"
				PutAlignedString(sX + 7, sX + 250, sY + 160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}

			if (iLoc < 45) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxInfo[27].sV9, m_stDialogBoxInfo[27].sV10);
							  //"수명: %d/%d"
				PutAlignedString(sX + 7, sX + 250, sY + 160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}
		}

		if (m_stDialogBoxInfo[27].sV5 != -1) {
			cItemColor = m_stDialogBoxInfo[27].sV8; // v1.4
			if (cItemColor == 0)
				 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV5]->PutSpriteFast(sX + 400, sY + 100,
			                                                                                         m_stDialogBoxInfo[27].sV6, dwTime);
			else {
				switch (m_stDialogBoxInfo[27].sV5) {
				case 1:
				case 2:
				case 3:  m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV5]->PutSpriteRGB(sX + 400, sY + 100, m_stDialogBoxInfo[27].sV6,
																								           m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime); break;

				default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[27].sV5]->PutSpriteRGB(sX + 400, sY + 100, m_stDialogBoxInfo[27].sV6,
																								           m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime); break;
				}
			}
			// v1.42
			GetItemName(m_stDialogBoxInfo[27].cStr3, m_stDialogBoxInfo[27].dwV2, cNameStr, cSubStr1, cSubStr2);
			
			PutAlignedString(sX + 250, sX + 540, sY + 42, m_stDialogBoxInfo[27].cStr4, 35,55,35);
			wsprintf(cTxt, "%s", cNameStr);

			if(m_bIsSpecial)
			{
				PutAlignedString(sX + 270, sX + 520, sY + 145, cTxt, 0,255,50);
				PutAlignedString(sX + 271, sX + 521, sY + 145, cTxt, 0,255,50);
			}
			else
			{
				PutAlignedString(sX + 270, sX + 520, sY + 145, cTxt, 35,35,35);
				PutAlignedString(sX + 271, sX + 521, sY + 145, cTxt, 35,35,35);
			}
			
			iLoc = 0;
			if (strlen(cSubStr1) != 0) {
				PutAlignedString(sX + 270, sX + 520, sY + 160 +iLoc, cSubStr1, 0,0,0);
				iLoc += 15;
			}

			if (strlen(cSubStr2) != 0) {
				PutAlignedString(sX + 270, sX + 520, sY + 160 +iLoc, cSubStr2, 0,0,0);
				iLoc += 15;
			}

			if (m_stDialogBoxInfo[27].sV7 != 1) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE2, m_stDialogBoxInfo[27].sV7);
				               //"수량: %d개"
				PutAlignedString(sX + 270, sX + 520, sY +160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}

			if (m_stDialogBoxInfo[27].sV14 != -1) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE4, m_stDialogBoxInfo[27].sV14);
				               //"완성도: %d%%"
				PutAlignedString(sX + 270, sX + 520, sY + 160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}

			if (iLoc < 45) {
				wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxInfo[27].sV12, m_stDialogBoxInfo[27].sV13);
							   //"수명: %d/%d"
				PutAlignedString(sX + 270, sX + 520, sY + 160 +iLoc, cTxt, 35,35,35);
				iLoc += 15;
			}
		}

		PutAlignedString(sX, sX + szX, sY + 205 +10, DRAW_DIALOGBOX_EXCHANGE33, 55,25,25);
		                                              //" 다른 플레이어가 교환에 동의할 때 까지"
		PutAlignedString(sX, sX + szX, sY + 220 +10, DRAW_DIALOGBOX_EXCHANGE34, 55,25,25);
		                                              //"기다려 주세요. 양측이 모두 교환에 동의"
		PutAlignedString(sX, sX + szX, sY + 235 +10, DRAW_DIALOGBOX_EXCHANGE35, 55,25,25);
		                                               //"하지 않으면 교환이 이루어지지 않습니다."
		PutAlignedString(sX, sX + szX, sY + 250 +10, DRAW_DIALOGBOX_EXCHANGE36, 55,25,25);
		                                               //" 만약 아직 상대방이 교환에 동의하지 않은"
		PutAlignedString(sX, sX + szX, sY + 265 +10, DRAW_DIALOGBOX_EXCHANGE37, 55,25,25);
		                                               //"상태라면 Cancel버튼을 눌러 교환 취소를"
		PutAlignedString(sX, sX + szX, sY + 280 +10, DRAW_DIALOGBOX_EXCHANGE38, 55,25,25);
		                                               //"시도 할 수 있지만 이미 상대방이 교환에"
	
		if ( (msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY) )
			 PutString_SprFont(sX + 450, sY + 310, "Cancel", 6,6,20);
		else PutString_SprFont(sX + 450, sY + 310, "Cancel", 0,0,7);
		break;
	}
}

void CGame::DrawDialogBox_Fishing(short msX, short msY)
{

 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 char  cTxt[120];
	
	sX = m_stDialogBoxInfo[24].sX;
	sY = m_stDialogBoxInfo[24].sY;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 2);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_stDialogBoxInfo[24].cStr, NULL, cStr1, cStr2, cStr3);

	switch (m_stDialogBoxInfo[24].cMode) {
	case 0:
		// 낚을 아이템 보여준다. 
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[24].sV3]->PutSpriteFast(sX + 18 + 35, sY + 18 + 17, m_stDialogBoxInfo[24].sV4, dwTime);
		// 아이템 이름 보여준다.
		wsprintf(cTxt, "%s", cStr1);
		PutString(sX + 98, sY + 14, cTxt, RGB(255,255,255));
		
		wsprintf(cTxt, DRAW_DIALOGBOX_FISHING1, m_stDialogBoxInfo[24].sV2);
		              //"값어치: %dGold"
		PutString(sX + 98, sY + 28, cTxt, RGB(0,0,0));
		
		PutString(sX + 97, sY + 43, DRAW_DIALOGBOX_FISHING2, RGB(0,0,0));
		                            //"낚을 확률:"

		wsprintf(cTxt, "%d %%", m_stDialogBoxInfo[24].sV1);
		PutString_SprFont(sX + 157,  sY + 40, cTxt, 10,0,0);
#if DEF_LANGUAGE == 1  // v2.11 성후니 추가된 내용 ..
		if ((msX >= sX + 160) && (msX <= sX + 253) && (msY >= sY + 70) && (msY <= sY + 90)) 
			 PutString(sX + 160, sY + 70, "{bN먼먼T", RGB(78, 64, 249));
 		else PutString(sX + 160, sY + 70, "{bN먼먼T", RGB(26,11,216));
#else
		if ((msX >= sX + 160) && (msX <= sX + 253) && (msY >= sY + 70) && (msY <= sY + 90)) 
			 PutString_SprFont(sX + 160, sY + 70, "Try Now!", 6,6,20);
		else PutString_SprFont(sX + 160, sY + 70, "Try Now!", 0, 0, 7);
#endif
		break;
	}

}

void CGame::DrawDialogBox_GuildMenu(short msX, short msY)
{
 short sX, sY, szX;
 int iAdjX, iAdjY ;
	
	sX = m_stDialogBoxInfo[7].sX;
	sY = m_stDialogBoxInfo[7].sY;
	szX = m_stDialogBoxInfo[7].sSizeX;

	iAdjX = - 13 ;
	iAdjY =  30 ;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 19);

	switch (m_stDialogBoxInfo[7].cMode) {
	case 0:
		if ( (m_iGuildRank == -1) && (m_iCharisma >= 20) && (m_iLevel >= 20) ) {
			if ((msX > sX + iAdjX +80) && (msX < sX + iAdjX +210) && (msY > sY + iAdjY + 63) && (msY < sY + iAdjY + 78)) 
				 PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 255,255,255);//"새로운 길드를 만듭니다"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 4,0,50);//"새로운 길드를 만듭니다"
		}
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 65,65,65);//"새로운 길드를 만듭니다" 

		if (m_iGuildRank == 0) {
			if ((msX > sX + iAdjX +72) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 82) && (msY < sY + iAdjY + 99)) 
				 PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 255,255,255);//"당신의 길드를 해산시킵니다"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 4,0,50);//"당신의 길드를 해산시킵니다"
		}
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 65,65,65);//"당신의 길드를 해산시킵니다"

		if ((msX > sX + iAdjX +61) && (msX < sX + iAdjX +226) && (msY > sY + iAdjY + 103) && (msY < sY + iAdjY + 120)) 
			 PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU7, 255,255,255);//"길드 가입 신청서를 구입합니다"
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU7, 4,0,50);//"길드 가입 신청서를 구입합니다"

		if ((msX > sX + iAdjX +60) && (msX < sX + iAdjX +227) && (msY > sY + iAdjY + 123) && (msY < sY + iAdjY + 139)) 
			 PutAlignedString(sX, sX + szX, sY + iAdjY + 125, DRAW_DIALOGBOX_GUILDMENU9, 255,255,255);//"길드 탈퇴 신청서를 구입합니다"
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 125, DRAW_DIALOGBOX_GUILDMENU9, 4,0,50);//"길드 탈퇴 신청서를 구입합니다"
		
		// v1.4311-3 변경  인터페이스 사투장 입장권을 구입하기 위한 변경 글자하나당 12로 잡고 계산 함 
		if (m_iGuildRank == 0 && m_iFightzoneNumber == 0) {
			// 길드 마스터이고 사투장을 예약한적이 없을때 
			if ((msX > sX + iAdjX +72) && (msX < sX + iAdjX +228) && (msY > sY + iAdjY + 143) && (msY < sY + iAdjY + 169)) 
				 PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 255,255,255);//"사투장을 예약합니다"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 4,0,50);//"사투장을 예약합니다"

		} else if (m_iGuildRank == 0 && m_iFightzoneNumber > 0) {
			// 사투장을 예약한 경우 
			if ((msX > sX + iAdjX +72) && (msX < sX + iAdjX +216) && (msY > sY + iAdjY + 143) && (msY < sY + iAdjY + 169)) 
				 PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 255,255,255);//"사투장 입장권을 받습니다"  
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 4,0,50);//"사투장 입장권을 받습니다"

		} else if (m_iFightzoneNumber < 0) {
			// 예약한 사투장 입장권을 모두 다 받은 경우 
			PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 65,65,65);//"사투장 입장권을 받습니다"
		} else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 65,65,65);//"사투장을 예약합니다"

		PutAlignedString(sX, sX + szX, sY + iAdjY + 205, DRAW_DIALOGBOX_GUILDMENU17);//"* 원하시는 항목을 선택해 주십시오."
		break;

	case 1:
		PutAlignedString(sX + 24, sX + 239, sY + 125, DRAW_DIALOGBOX_GUILDMENU18, 55,25,25);//"만들 길드의 이름을 입력하십시오."
		PutString(sX + 75, sY + 144, "____________________", RGB(25,35,25));

#if DEF_LANGUAGE == 2	//언어:China
		PutString(sX + 24, sY + 176, DRAW_DIALOGBOX_GUILDMENU82, RGB(55,25,25));
		PutString(sX + 24, sY + 192, DRAW_DIALOGBOX_GUILDMENU83, RGB(55,25,25));
#endif

		
		if (iGetTopDialogBoxIndex() != 7)
			PutString(sX + 75, sY + 140, m_cGuildName, RGB(255,255,255), 16, FALSE, 2);
				
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			if ((strcmp(m_cGuildName, "NONE") == 0) || (strlen(m_cGuildName) == 0)) {
				 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 24);//Create Gray Button
			}
			else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 25);//Create Highlight Button
		}
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 24);//Create Gray Button

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);//Red Cancel Button
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);//Gray Cancel Button
	   	break;

	case 2:
		PutAlignedString(sX, sX + szX, sY +140, DRAW_DIALOGBOX_GUILDMENU19, 55,25,25);//"새 길드 만들기 처리중입니다..."
		break;
	case 3:
		PutAlignedString(sX, sX + szX,  sY + 125, DRAW_DIALOGBOX_GUILDMENU20, 55,25,25);//"새 길드가 만들어 졌습니다."
		PutAlignedString(sX, sX + szX, sY + 140, m_cGuildName, 55,25,25);
		PutAlignedString(sX, sX + szX, sY + 144, "____________________", 25,35,25);
		PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU21, 55,25,25);//"당신은 길드마스터입니다."
				
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
	case 4:
		PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU22, 55,25,25);//"새 길드가 만들기가 실패하였습니다."
		PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU23, 55,25,25);//"같은 이름의 길드가 이미 존재합니다."
				
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 5:
		PutAlignedString(sX, sX + szX, sY + 90, DRAW_DIALOGBOX_GUILDMENU24);//"길드 해산:"
		PutAlignedString(sX, sX + szX, sY + 105, m_cGuildName, 35,35,35);
		PutAlignedString(sX, sX + szX, sY + 109, "____________________", 0,0,0);
		PutAlignedString(sX, sX + szX, sY + 130, DRAW_DIALOGBOX_GUILDMENU25);//"당신의 길드를 해산시킵니다. 당신의 "
		PutAlignedString(sX, sX + szX, sY + 145,DRAW_DIALOGBOX_GUILDMENU26);//"길드마스터로서의 자격은 사라지며"
		PutAlignedString(sX, sX + szX, sY + 160,DRAW_DIALOGBOX_GUILDMENU27);//"길드원들은 자동적으로 탈퇴됩니다."		
		PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_GUILDMENU28, 55,25,25);//"길드 해산에 동의하십니까?"
			
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;
	case 6:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU29, 55,25,25);//"길드 해산 처리중입니다..."
		break;
	case 7:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU30, 55,25,25);//"길드가 해산되었습니다."
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
	case 8:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU31, 55,25,25);//"길드 해산이 실패하였습니다."
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
	case 9:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 60,  DRAW_DIALOGBOX_GUILDMENU32);//"길드 가입 신청서의 가격은 5 Gold입니"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 75,  DRAW_DIALOGBOX_GUILDMENU33);//"다. 가입하고자하는 길드의 길드마스터"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 90,  DRAW_DIALOGBOX_GUILDMENU34);//"에게 제출하면 길드마스터의 판단에"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU35);//"따라 가입여부가 결정 됩니다." 
		PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU36);//"구입하시겠습니까?"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 31);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 30);
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;
	case 10:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU37, 55,25,25);//"길드 가입 신청서를 구입하였습니다."
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
	case 11:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 60,  DRAW_DIALOGBOX_GUILDMENU38);//"길드 탈퇴 신청서의 가격은 5 Gold입니"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 75,  DRAW_DIALOGBOX_GUILDMENU39);//"다. 가입하고자하는 길드의 길드마스터"  
		PutAlignedString(sX, sX + szX, sY + iAdjY + 90, DRAW_DIALOGBOX_GUILDMENU40);//"에게 제출하면 길드마스터의 판단에" 
		PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU41);//"따라 탈퇴여부가 결정 됩니다."
		PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU42);//"구입하시겠습니까?"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 31);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 30);
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;
	case 12:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU43, 55,25,25);//"길드 탈퇴 신청서를 구입하였습니다."
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

		// v1.4311-3 추가 인터페이스 사투장 입장권 구입 메뉴 
	case 13:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 40,  DRAW_DIALOGBOX_GUILDMENU44);//"사투장 예약하는데 드는 비용은 1500"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 55,  DRAW_DIALOGBOX_GUILDMENU45);//"Gold 입니다. 원하시는 사투장을 클릭"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 70,  DRAW_DIALOGBOX_GUILDMENU46);//"하면 사투장이 예약됩니다. 입장권은"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU47);//"50장이 지급되며 사투장은 0시부터 대략"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 100, DRAW_DIALOGBOX_GUILDMENU48);//"두시간 간격으로 소환 됩니다. 즉 현재"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 115, DRAW_DIALOGBOX_GUILDMENU49);//"시각이 11시라면 12시 이전에 자동 소환"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU50);//"됩니다."
		
		if ((msX > sX + iAdjX +65) && (msX < sX + iAdjX +137) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185)) 
			 PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU51, RGB(255,255,255));//"1번 사투장"
		else PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU51, RGB(4,0,50));//"1번 사투장"

		if ((msX > sX + iAdjX +150) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185)) 
			 PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU53, RGB(255,255,255));//"2번 사투장"
		else PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU53, RGB(4,0,50));//"2번 사투장"

		if ((msX > sX + iAdjX +65) && (msX < sX + iAdjX +137) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205)) 
			 PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU55, RGB(255,255,255));//"3번 사투장"
		else PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU55, RGB(4,0,50));//"3번 사투장"

		if ((msX > sX + iAdjX +150) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205)) 
			 PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU57, RGB(255,255,255));//"4번 사투장"
		else PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU57, RGB(4,0,50));//"4번 사투장"

		if ((msX > sX + iAdjX +65) && (msX < sX + iAdjX +137) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225)) 
			 PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU59, RGB(255,255,255));//"5번 사투장"
		else PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU59, RGB(4,0,50));//"5번 사투장" 

		if ((msX > sX + iAdjX +150) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225)) 
			 PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU61, RGB(255,255,255));//"6번 사투장"
		else PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU61, RGB(4,0,50));//"6번 사투장"

		if ((msX > sX + iAdjX +65) && (msX < sX + iAdjX +137) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245)) 
			 PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU63, RGB(255,255,255));//"7번 사투장"
		else PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU63, RGB(4,0,50));//"7번 사투장"

		if ((msX > sX + iAdjX +150) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245)) 
			 PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU65, RGB(255,255,255));//"8번 사투장"
		else PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU65, RGB(4,0,50));//"8번 사투장"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;
	// v1.4311-3 추가 인터페이스 사투장 예약 관련 
	case 14:
		// 예약 성공시 
		PutAlignedString(sX, sX + szX, sY + 130, DRAW_DIALOGBOX_GUILDMENU66, 55,25,25);//"사투장이 예약 되었습니다."
		PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_GUILDMENU67, 55,25,25);//"사투장을 한곳을 예약하시면 다른 사투장"
		PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU68, 55,25,25);//"은 예약이 불가능합니다."
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
	// v1.4311-3 추가 인터페이스 사투장 예약 관련 
	case 15:
		// 예약 실패시 예약 가능한 시간이 아닌경우 
		PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU69, 55,25,25);//"사투장 예약이 가능한 시간이 아닙니다.."
		PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU70, 55,25,25);//"잠시뒤에 시도 해주시기 바랍니다."   
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
	// v1.4311-3 추가 인터페이스 사투장 예약 관련 
	case 16:
		// 예약 실패시 이미 예약된 사투장을 선택한경우
		PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU71, 55,25,25);//"선택하신 사투장이 예약 되어 있습니다."
		PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU72, 55,25,25);//"다른 사투장을 사용하십시오."
		// 예약 실패시 사투장 번호 초기화 
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
	// v1.4311-3 추가 인터페이스 사투장 예약 관련 		
	case 17:
		// 예약 실패시 예약에 필요한 금액이 모질라는경우 
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU73, 55,25,25);//"예약에 필요한 Gold를 가지고 있지 않습니다."
		
		// 예약 실패시 사투장 번호 초기화 
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 18:
		// v1.4311-3 추가 인터페이스 사투장 예약 모드 
		// 예약 처리중입니다.
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU74, 55,25,25);//"사투장 예약 처리중입니다..."
		break;

	case 19:
		// v1.4311-3 추가 인터페이스 사투장 입장권 받기 모드 
		// 사투장 입장권이 남아 있는 경우에만 
		if( m_iFightzoneNumber >0 ) 
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET, NULL, NULL, NULL, NULL, NULL); 
		m_stDialogBoxInfo[7].cMode = 0;
		break;

	case 20:
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_GUILDMENU75, 55,25,25);//"만들 길드의 이름을 입력하십시오."
		PutString(sX + 75, sY + 144, "____________________", RGB(25,35,25));
		PutString(sX + 75, sY + 140, m_cGuildName, RGB(255,255,255), FALSE, 2);
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 25);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 24);
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 21:
		// 예약 실패시 예약 가능한 날이 아닌경우 
		PutAlignedString(sX, sX + szX, sY + iAdjY + 95,  DRAW_DIALOGBOX_GUILDMENU76, 55,25,25);//"이 사투장은 오늘 사용이 불가능합니다."
		PutAlignedString(sX, sX + szX, sY + iAdjY + 110, DRAW_DIALOGBOX_GUILDMENU77, 55,25,25);//"다른 사투장을 이용하시기 바랍니다."
		PutAlignedString(sX, sX + szX, sY + iAdjY + 135, DRAW_DIALOGBOX_GUILDMENU78, 55,25,25);//"홀수날에는 아레스덴은 2 4 6 8 경기장이"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 150, DRAW_DIALOGBOX_GUILDMENU79, 55,25,25);//"엘바인은 1 3 5 7 경기장이 사용" 
		PutAlignedString(sX, sX + szX, sY + iAdjY + 165, DRAW_DIALOGBOX_GUILDMENU80, 55,25,25);//"가능합니다."
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 22:
		// 예약 실패시 다른 사투장을 예약하는 경우 
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU81, 55,25,25);//"이미 다른 사투장을 예약하셨습니다."  
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
	}
}

//v2.171 함수 통째로 수정됨.
void CGame::DrawDialogBox_GuildOperation(short msX, short msY)
{
 short sX, sY;
	
	sX = m_stDialogBoxInfo[8].sX;
	sY = m_stDialogBoxInfo[8].sY;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 19);

	switch (m_stGuildOpList[0].cOpMode) {
	case 1:
		// 길드 가입신청이다.
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION1);
		                            //"길드 가입 신청:"
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION2);
		                            //"* 위 플레이어가 당신의 길드에 가입하려 "
		PutAlignedString(sX + 24, sX + 248, sY + 105,DRAW_DIALOGBOX_GUILD_OPERATION3);
		                            //" 합니다. 이 요청에 대해 당신은 길드마스터의"    
		PutAlignedString(sX + 24, sX + 248, sY + 120,DRAW_DIALOGBOX_GUILD_OPERATION4);
		                            //" 자격으로 승락 혹은 거부 할 수 있습니다. "

		PutAlignedString(sX + 24, sX + 248, sY + 160, DRAW_DIALOGBOX_GUILD_OPERATION5, 55,25,25);
		                             //"가입 승인 여부를 결정하십시오."
				
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 33);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 32);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 35);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 34);
		break;

	case 2:
		// 길드 탈퇴 신청이다.
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION6);
		                           //"길드 탈퇴 신청:"
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION7);
		                             //"* 위 플레이어가 당신의 길드를 탈퇴하려 " 
		PutAlignedString(sX + 24, sX + 248, sY + 105,DRAW_DIALOGBOX_GUILD_OPERATION8);
		                             //" 합니다. 이 요청에 대해 당신은 길드마스터의"
		PutAlignedString(sX + 24, sX + 248, sY + 120,DRAW_DIALOGBOX_GUILD_OPERATION9);
		                            //" 자격으로 승락 혹은 거부 할 수 있습니다. "

		PutAlignedString(sX + 24, sX + 248, sY + 160, DRAW_DIALOGBOX_GUILD_OPERATION10, 55,25,25);
		                             //"탈퇴 승인 여부를 결정하십시오."  

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 33);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 32);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 35);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 34);
		break;

	case 3:
		// 길드 가입 신청이 성공했다는 메시지 
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION11);
		                           //"길드 가입 승인:"
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION12);
		                            //"* 위 길드에 대한 당신의 가입 요구가" 
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION13);
	                             //"받아들여져 길드원이 되었습니다."
		
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 4:
		// 길드 가입 신청이 실패했다는 메시지 
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION14);
		                            //"길드 가입 실패:"
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION15);
		                            //"* 위 길드에 대한 당신의 가입 요구를"
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION16);
		                             //"길드마스터가 거부하였습니다."
		
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 5:
		// 길드 탈퇴 신청이 성공했다는 메시지 
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION17);
		                           //"길드 탈퇴 승인:"
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION18);
		                            //"* 위 길드에 대한 당신의 탈퇴 요구가" 
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION19);
		                             //"받아들여 졌습니다. 당신은 이제 길드원이"  
		PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION20);
		                             //"아니며 시민의 자격을 갖습니다." 

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 6:
		// 길드 탈퇴 신청이 실패했다는 메시지 
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION21);
		                            //"길드 탈퇴 거부:"
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION22);
		                            //"* 위 길드에 대한 당신의 탈퇴 요구가" 
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION23);
		                           //"거부되었습니다. "

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 7:
		// 길드가 해산되었다는 메시지 
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION24);
		                            //"길드 해산:"
		//PutString(sX + 60, sY + 65, m_stGuildOpList[0].cName, RGB(35,35,35));
		//PutString(sX + 60, sY + 69, "____________________", RGB(0,0,0));
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION25);
		                           //"* 당신이 소속된 길드가 해산되었습니다."
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION26);
		                             //"당신은 이제 길드원이 아니며 시민의 "
		PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION27);
		                            //"자격을 갖습니다. "

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
	}
}

int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,   10, 14, 28, 32, 36, 40};

void CGame::DrawDialogBox_Magic(short msX, short msY, short msZ)
{
	short sX, sY, sMagicCircle, sLevelMagic;
	int  iCPivot, i, iYloc, iResult, iManaCost;
	char cTxt[120], cMana[10];
	DWORD dwTime = m_dwCurTime;
	double dV1, dV2, dV3, dV4;
	
	sX = m_stDialogBoxInfo[3].sX;
	sY = m_stDialogBoxInfo[3].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 1, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 7, FALSE, m_bDialogTrans);

	if( iGetTopDialogBoxIndex() == 3 && msZ != 0 )
	{
		if( msZ > 0 ) m_stDialogBoxInfo[3].sView--;
		if( msZ < 0 ) m_stDialogBoxInfo[3].sView++;
		m_DInput.m_sZ = 0;
	}
	if( m_stDialogBoxInfo[3].sView < 0 ) m_stDialogBoxInfo[3].sView = 9;
	if( m_stDialogBoxInfo[3].sView > 9 ) m_stDialogBoxInfo[3].sView = 0;
 
	//Circle
	ZeroMemory(cTxt, sizeof(cTxt));
	switch (m_stDialogBoxInfo[3].sView) {
	case 0: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC1);  break;//"Circle One"
	case 1: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC2);  break;//"Circle Two"
	case 2: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC3);  break;//"Circle Three"
	case 3: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC4);  break;//"Circle Four"
	case 4: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC5);  break;//"Circle Five"
	case 5: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC6);  break;//"Circle Six"
	case 6: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC7);  break;//"Circle Seven"
	case 7: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC8);  break;//"Circle Eight"
	case 8: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC9);  break;//"Circle Nine"   
	case 9: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC10); break;//"Circle Ten"
	}
	PutAlignedString(sX + 3, sX + 256, sY + 50, cTxt);
	PutAlignedString(sX + 4, sX + 257, sY + 50, cTxt);

	// 보고있는 마법의 Circle기준점 
	iCPivot = m_stDialogBoxInfo[3].sView*10;   
	iYloc = 0;

	for (i = 0; i < 9; i++) {
		if ((m_cMagicMastery[iCPivot + i] != NULL) && (m_pMagicCfgList[iCPivot + i] != NULL)) {
			// 이 마법을 사용할 줄 알기 때문에 리스트에 보인다.
			wsprintf(cTxt, "%s", m_pMagicCfgList[iCPivot + i]->m_cName);
			
			m_Misc.ReplaceString(cTxt, '-', ' ');
			iManaCost = iGetManaCost(iCPivot+i);
			if (iManaCost > m_iMP)
			{
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 30, sY + 73 + iYloc, cTxt, RGB(41, 16, 41));
					PutString(sX + 31, sY + 73 + iYloc, cTxt, RGB(41, 16, 41));
				}
				else PutString_SprFont(sX + 30, sY + 70 + iYloc, cTxt, 5, 5, 5);
				wsprintf(cMana, "%3d", iManaCost);
				PutString_SprFont(sX + 206, sY + 70 + iYloc, cMana, 5, 5, 5);
			}
			else
			if ((msX >= sX + 30) && (msX <= sX + 240) && (msY >= sY + 70 + iYloc) && (msY <= sY + 70 + 14 + iYloc))
			{
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 30, sY + 73 + iYloc, cTxt, RGB(255,255,255));
					PutString(sX + 31, sY + 73 + iYloc, cTxt, RGB(255,255,255));
				}
				else PutString_SprFont(sX + 30, sY + 70 + iYloc, cTxt, 250, 250, 250);
				wsprintf(cMana, "%3d", iManaCost);
				PutString_SprFont(sX + 206, sY + 70 + iYloc, cMana, 250, 250, 250);
			}
			else
			{
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 30, sY + 73 + iYloc, cTxt, RGB(8,0,66));
					PutString(sX + 31, sY + 73 + iYloc, cTxt, RGB(8,0,66));
				}
				else PutString_SprFont(sX + 30, sY + 70 + iYloc, cTxt, 1, 1, 8);
				wsprintf(cMana, "%3d", iManaCost);
				PutString_SprFont(sX + 206, sY + 70 + iYloc, cMana, 1, 1, 8);
			}
			
			iYloc += 18;
		}

	}

	if (iYloc == 0) {
		// 배운 마법이 없다는 메시지를 보여준다.
		PutAlignedString(sX + 3, sX +256, sY + 100, DRAW_DIALOGBOX_MAGIC11);//"알고있는 마법이 없습니다."
		PutAlignedString(sX + 3, sX +256, sY + 115, DRAW_DIALOGBOX_MAGIC12);//"마법은 도시 내에 위치한 마법타워에서"
		PutAlignedString(sX + 3, sX +256, sY + 130, DRAW_DIALOGBOX_MAGIC13);//"배울 수 있습니다. 마법을 배우기"
		PutAlignedString(sX + 3, sX +256, sY + 145, DRAW_DIALOGBOX_MAGIC14);//"위해서는 배울 마법이 요구하는 Int와"
		PutAlignedString(sX + 3, sX +256, sY + 160, DRAW_DIALOGBOX_MAGIC15);//"Gold가 필요합니다. "
	}

	// 
	m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 30, sY + 250, 19, dwTime);
	
	switch (m_stDialogBoxInfo[3].sView) {
	case 0: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 30, sY + 250, 20, dwTime); break;
	case 1: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 43, sY + 250, 21, dwTime); break;
	case 2: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 61, sY + 250, 22, dwTime); break;
	case 3: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 86, sY + 250, 23, dwTime); break;
	case 4: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 106, sY + 250, 24, dwTime); break;
	case 5: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 121, sY + 250, 25, dwTime); break;
	case 6: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 142, sY + 250, 26, dwTime); break;
	case 7: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 169, sY + 250, 27, dwTime); break;
	case 8: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 202, sY + 250, 28, dwTime); break;
	case 9: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 222, sY + 250, 29, dwTime); break;
	}
	
	// v1.4 매직 써클 레이팅을 계산한다. 
	sMagicCircle = m_stDialogBoxInfo[3].sView + 1;
	if (m_cSkillMastery[4] == 0)
		 dV1 = 1.0f;
	else dV1 = (double)m_cSkillMastery[4];
	
	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];

	dV1 = dV2 * dV3;
	iResult = (int)dV1;

	// Int에 따른 추가 마법 성공률 계산 
	if (m_iInt > 50) iResult += (m_iInt - 50)/2;
	
	// v1.3 쓰고자 하는 마법의 써클과 플레이어의 레벨 관계에 따라 성공률이 가감된다. 
	sLevelMagic = (m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			// 자신의 레벨보다 큰 마법을 쓴다. 차이만큼 성공률을 감소시킨다.
			dV1 = (double)(m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			// 자신의 레벨보다 낮은 마법을 쓴다. 차이만큼 성공률을 증가시킨다.
			iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}

	// 날씨에 의한 마법 성공률 조정. 
	switch (m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break; // 비가 올 경우 성공률 4, 8, 20% 감소 
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}
	// 마법성공 아이템에 의한 성공률 조정..
	for( i=0; i<DEF_MAXITEMS ; i++ )
	{
		if( m_pItemList[i] == NULL ) continue;
		if( m_bIsItemEquipped[i] == TRUE )
		{
			if( ((m_pItemList[i]->m_dwAttribute & 0x00F00000) >> 20) == 10 )
			{
				dV1 = (double)iResult;
				dV2 = (double)(( (m_pItemList[i]->m_dwAttribute & 0x000F0000) >> 16) * 3 );
				dV3 = dV1 + dV2;
				iResult = (int)dV3;
				break;
			}
		}
	}

	// 수치 조정.
	if (iResult > 100) iResult = 100;
	if (m_iSP < 1) iResult = iResult*9/10;
	if (iResult < 1 ) iResult = 1;

	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, DRAW_DIALOGBOX_MAGIC16, iResult);//"마법 써클의 캐스팅 성공률: %d%%"
	PutAlignedString(sX, sX + 256, sY + 267, cTxt);
	PutAlignedString(sX+1, sX + 257, sY + 267, cTxt);

	// v2.15
	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 285) && (msY <= sY + 285 + DEF_BTNSZY)) 
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + 285, 49, FALSE, m_bDialogTrans);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + 285, 48, FALSE, m_bDialogTrans);
}

void CGame::DrawDialogBox_MagicShop(short msX, short msY, short msZ)
{
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 int  i;

 int  iCPivot, iYloc;
 char cTxt[120], cMana[10]; 
	
	sX = m_stDialogBoxInfo[16].sX;
	sY = m_stDialogBoxInfo[16].sY;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX, sY, 1);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 14);
	
	if( iGetTopDialogBoxIndex() == 16 && msZ != 0 )
	{
		if( msZ > 0 ) m_stDialogBoxInfo[16].sView--;
		if( msZ < 0 ) m_stDialogBoxInfo[16].sView++;
		m_DInput.m_sZ = 0;
	}
	if( m_stDialogBoxInfo[16].sView < 0 ) m_stDialogBoxInfo[16].sView = 9;
	if( m_stDialogBoxInfo[16].sView > 9 ) m_stDialogBoxInfo[16].sView = 0;

	PutString(sX -20 + 60 -17, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP11, RGB(45,25,25));//"Spell Name"
	PutString(sX -20 + 232 -20, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP12, RGB(45,25,25));//"Req.Int"
	PutString(sX -20 + 270, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP13, RGB(45,25,25));//"Cost"
 
	// 보고있는 마법의 Circle기준점 
	iCPivot = m_stDialogBoxInfo[16].sView*10;   

	iYloc = 0;
	for (i = 0; i < 9; i++) {
		if ((m_pMagicCfgList[iCPivot + i] != NULL) && (m_pMagicCfgList[iCPivot + i]->m_bIsVisible)) {
			// 해당 번호의 마법이 정의되어 있으므로 리스트에 보인다.
			wsprintf(cTxt, "%s", m_pMagicCfgList[iCPivot + i]->m_cName);
			
			m_Misc.ReplaceString(cTxt, '-', ' ');
			if (m_cMagicMastery[iCPivot + i] != 0) {
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 24, sY + 73 + iYloc, cTxt, RGB(41,16,41));
					PutString(sX + 25, sY + 73 + iYloc, cTxt, RGB(41,16,41));
				}
				else PutString_SprFont(sX + 24, sY + 70 + iYloc, cTxt, 5, 5, 5);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue2);
				PutString_SprFont(sX + 200, sY + 70 + iYloc, cMana, 5, 5, 5);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue3);
				PutString_SprFont(sX + 241, sY + 70 + iYloc, cMana, 5, 5, 5);
			}
			else
			if ((msX >= sX + 24) && (msX <= sX + 24 + 135) && (msY >= sY + 70 + iYloc) && (msY <= sY + 70 + 14 + iYloc)) {
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 24, sY + 73 + iYloc, cTxt, RGB(255,255,255));
					PutString(sX + 25, sY + 73 + iYloc, cTxt, RGB(255,255,255));
				}
				else PutString_SprFont(sX -20 + 44, sY + 70 + iYloc, cTxt, 250, 250, 250);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue2);
				PutString_SprFont(sX -20 + 220, sY + 70 + iYloc, cMana, 250, 250, 250);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue3);
				PutString_SprFont(sX -20 + 261, sY + 70 + iYloc, cMana, 250, 250, 250);
			}
			else {
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 24, sY + 73 + iYloc, cTxt, RGB(8,0,66));
					PutString(sX + 25, sY + 73 + iYloc, cTxt, RGB(8,0,66));
				}
				else PutString_SprFont(sX -20 + 44, sY + 70 + iYloc, cTxt, 1, 1, 8);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue2);
				PutString_SprFont(sX -20 + 220, sY + 70 + iYloc, cMana, 1, 1, 8);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue3);
				PutString_SprFont(sX -20 + 261, sY + 70 + iYloc, cMana, 1, 1, 8);
			}
			iYloc += 18;
		}
	}

	m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 55, sY + 250, 19, dwTime);
	
	switch (m_stDialogBoxInfo[16].sView) {
	case 0: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 44  +31, sY + 250, 20, dwTime); break;
	case 1: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 57  +31, sY + 250, 21, dwTime); break;
	case 2: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 75  +31, sY + 250, 22, dwTime); break;
	case 3: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 100 +31, sY + 250, 23, dwTime); break;
	case 4: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 120 +31, sY + 250, 24, dwTime); break;
	case 5: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 135 +31, sY + 250, 25, dwTime); break;
	case 6: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 156 +31, sY + 250, 26, dwTime); break;
	case 7: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 183 +31, sY + 250, 27, dwTime); break;
	case 8: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 216 +31, sY + 250, 28, dwTime); break;
	case 9: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 236 +31, sY + 250, 29, dwTime); break;
	}

	PutAlignedString(sX, sX+m_stDialogBoxInfo[16].sSizeX, sY + 275, DRAW_DIALOGBOX_MAGICSHOP14, 45,25,25);//"배우고자 하는 마법을 선택하십시오."
}

void CGame::DrawDialogBox_ShutDownMsg(short msX, short msY)
{
 short sX, sY, szX;

	sX = m_stDialogBoxInfo[25].sX;
	sY = m_stDialogBoxInfo[25].sY;
	szX = m_stDialogBoxInfo[25].sSizeX;
		
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX, sY,2);

	switch (m_stDialogBoxInfo[25].cMode) {
	case 1:
		ZeroMemory(G_cTxt, sizeof(G_cTxt));
		if (m_stDialogBoxInfo[25].sV1 != 0) wsprintf(G_cTxt, DRAW_DIALOGBOX_NOTICEMSG1, m_stDialogBoxInfo[25].sV1);//" 게임서버가 %d분 후 셧다운됩니다."
		else strcpy(G_cTxt, DRAW_DIALOGBOX_NOTICEMSG2);//" 게임서버가 곧 셧다운됩니다!"
		PutAlignedString(sX, sX + szX, sY + 31, G_cTxt, 100,10,10);
		PutAlignedString(sX, sX + szX, sY + 48, DRAW_DIALOGBOX_NOTICEMSG3);//"지금 접속을 끊으셔야 데이터가 안전하게 저장"
		PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_NOTICEMSG4);//"됩니다. 잠시 후 서버 셧다운 시작 메시지 이후"
		PutAlignedString(sX, sX + szX, sY + 82, DRAW_DIALOGBOX_NOTICEMSG5);//"부터의 플레이어 데이터의 안전은 보장되지"
		PutAlignedString(sX, sX + szX, sY + 99, DRAW_DIALOGBOX_NOTICEMSG6);//"않으며 복구또한 불가능하니 주의하십시오."
		if ((msX >= sX + 210) && (msX <= sX + 210 + DEF_BTNSZX) && (msY > sY + 127) && (msY < sY + 127 + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 0); 
		break;

	case 2:
		PutAlignedString(sX, sX + szX, sY + 31, DRAW_DIALOGBOX_NOTICEMSG7, 100,10,10);//"게임서버 셧다운이 시작되었습니다!"
		PutAlignedString(sX, sX + szX, sY + 48, DRAW_DIALOGBOX_NOTICEMSG8);//"잠시 후 자동적으로 접속이 끊어집니다. 중요한"
		PutAlignedString(sX, sX + szX, sY + 65,  DRAW_DIALOGBOX_NOTICEMSG9);//"아이템을 바닥에 버리거나 창고에 저장하거나"
		PutAlignedString(sX, sX + szX, sY + 82, DRAW_DIALOGBOX_NOTICEMSG10);//"다른 플레이어에게 주지 마십시오. 손실될 수"
		PutAlignedString(sX, sX + szX, sY + 99, DRAW_DIALOGBOX_NOTICEMSG11);//"있으며 복구가 불가능합니다."
		if ((msX >= sX + 210) && (msX <= sX + 210 + DEF_BTNSZX) && (msY > sY + 127) && (msY < sY + 127 + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 0); 
		break;
	}
}

void CGame::DrawDialogBox_NpcActionQuery(short msX, short msY)
{
 short sX, sY, szX;

 char cTxt[120], cTxt2[120],  cStr1[64], cStr2[64], cStr3[64];

	ZeroMemory(cStr1, sizeof(cStr1));
	ZeroMemory(cStr2, sizeof(cStr2));
	ZeroMemory(cStr3, sizeof(cStr3));
 	
	sX = m_stDialogBoxInfo[20].sX;
	sY = m_stDialogBoxInfo[20].sY;
	szX = m_stDialogBoxInfo[20].sSizeX;

	//DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5); //5번이 작은창
	//DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 6); //6번이 큰창

	switch (m_stDialogBoxInfo[20].cMode) {
	case 0:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5); //5번이 작은창
		switch (m_stDialogBoxInfo[20].sV3) {
		case 15: 
			PutString(sX +33, sY +23, NPC_NAME_SHOP_KEEPER, RGB(45,25,25));//"상점 주인"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_SHOP_KEEPER, RGB(255,255,255));//"상점 주인"
			break;
		case 19: 
			PutString(sX +33, sY +23, NPC_NAME_MAGICIAN, RGB(45,25,25));//"마법사"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_MAGICIAN, RGB(255,255,255));//"마법사"
			break;
		case 20: 
			PutString(sX +33, sY +23, NPC_NAME_WAREHOUSE_KEEPER, RGB(45,25,25));//"창고 주인"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_WAREHOUSE_KEEPER, RGB(255,255,255));//"창고 주인"
			break;
		case 24: 
			PutString(sX +33, sY +23, NPC_NAME_BLACKSMITH_KEEPER, RGB(45,25,25));//"대장간 주인"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_BLACKSMITH_KEEPER, RGB(255,255,255));//"대장간 주인"
			break;
		case 25: 
			PutString(sX +33, sY +23, NPC_NAME_CITYHALL_OFFICER, RGB(45,25,25));//"시청 행정관"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_CITYHALL_OFFICER, RGB(255,255,255));//"시청 행정관"
			break;
		case 26: 
			PutString(sX +33, sY +23, NPC_NAME_GUILDHALL_OFFICER, RGB(45,25,25));//"길드조합 사무장"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_GUILDHALL_OFFICER, RGB(255,255,255));//"길드조합 사무장"
			break;
		}
		
		// v2.11 성후니 변경 
		if ( m_stDialogBoxInfo[20].sV3 == 25 )
		{
			if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, RGB(255,255,255));//"신청 한다"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, RGB(255,255,255));//"신청 한다"
			}
			else {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, RGB(4,0,50));//"신청 한다"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, RGB(4,0,50));//"신청 한다"
			}
		}
		else if ( m_stDialogBoxInfo[20].sV3 == 20 )
		{
			if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, RGB(255,255,255));//"아이템 찾는다"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, RGB(255,255,255));//"아이템 찾는다"
			}
			else {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, RGB(4,0,50));//"아이템 찾는다"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, RGB(4,0,50));//"아이템 찾는다"
			}
		}
		else
		{
			if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255));//"거래 한다"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255));//"거래 한다"
			}
			else {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));//"거래 한다"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));//"거래 한다"
			}
		}
		
		if (m_bIsDialogEnabled[21] == FALSE)
		{
			if ((msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));//"대화 한다"
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));//"대화 한다"
			}
			else {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));//"대화 한다"
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));//"대화 한다"
			}
		}
		break;
	
	case 1:
		// 그냥 준다 / 교환한다
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 6); //6번이 큰창
		GetItemName(m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_dwAttribute, cStr1, cStr2, cStr3);
#if DEF_LANGUAGE == 4	//언어:English
		wsprintf(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_stDialogBoxInfo[20].sV3, cStr1);
		wsprintf(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_stDialogBoxInfo[20].cStr);
#else
		wsprintf(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, cStr1, m_stDialogBoxInfo[20].sV3);
		wsprintf(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_stDialogBoxInfo[20].cStr);
#endif
		PutString(sX+24, sY+25, cTxt, RGB(45,25,25));
		PutString(sX+24, sY+40, cTxt2, RGB(45,25,25));

		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, RGB(255,255,255));//"그냥 준다"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, RGB(255,255,255));//"그냥 준다"
		}
		else {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, RGB(4,0,50));//"그냥 준다"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, RGB(4,0,50));//"그냥 준다"
		}
			
		if ((msX > sX + 155) && (msX < sX + 210) && (msY > sY + 55) && (msY < sY + 70)) {
			PutString(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, RGB(255,255,255));//"교환 한다"
			PutString(sX + 156, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, RGB(255,255,255));//"교환 한다"
		}
		else {
			PutString(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, RGB(4,0,50));//"교환 한다"  
			PutString(sX + 156, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, RGB(4,0,50));//"교환 한다"
		}
		break;

	case 2:
		// 판다 / 수리한다
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5); //5번이 작은창
		GetItemName(m_pItemList[ m_stDialogBoxInfo[20].sV1 ]->m_cName, m_pItemList[ m_stDialogBoxInfo[20].sV1 ]->m_dwAttribute, cStr1, cStr2, cStr3);
#if DEF_LANGUAGE == 4	//언어:English
		wsprintf(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_stDialogBoxInfo[20].sV3, cStr1);
		wsprintf(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_stDialogBoxInfo[20].cStr);
#else
		wsprintf(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, cStr1, m_stDialogBoxInfo[20].sV3);
		wsprintf(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_stDialogBoxInfo[20].cStr);
#endif
		PutString(sX+24, sY+20, cTxt, RGB(45,25,25));
		PutString(sX+24, sY+35, cTxt2, RGB(45,25,25));

		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(255,255,255));//"판다"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(255,255,255));//"판다"
		}
		else {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(4,0,50));//"판다"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(4,0,50));//"판다"
		}
		
		if ((m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			// 수량단위의 아이템은 수리가 불가능하다.
		}
		else {
			if ((msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, RGB(255,255,255));//"수리 한다"
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, RGB(255,255,255));//"수리 한다"
			}
			else {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, RGB(4,0,50));//"수리 한다"
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, RGB(4,0,50));//"수리 한다"
			}
		}
		break;

	case 3:
		// 맡긴다.
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 6); //6번이 큰창
		GetItemName(m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_dwAttribute, cStr1, cStr2, cStr3);
#if DEF_LANGUAGE == 4	//언어:English
		wsprintf(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_stDialogBoxInfo[20].sV3, cStr1);
		wsprintf(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_stDialogBoxInfo[20].cStr);
#else
		wsprintf(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, cStr1, m_stDialogBoxInfo[20].sV3);
		wsprintf(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_stDialogBoxInfo[20].cStr);
#endif
		PutAlignedString(sX, sX+240, sY+20, cTxt, 45,25,25); 
		PutAlignedString(sX, sX+240, sY+35, cTxt2, 45,25,25); 

		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, RGB(255,255,255));//"보관 한다"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, RGB(255,255,255));//"보관 한다"
		}
		else {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, RGB(4,0,50));//"보관 한다"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, RGB(4,0,50));//"보관 한다"
		}
		break;

	case 4:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5); //5번이 작은창
		switch (m_stDialogBoxInfo[20].sV3) {
		
		case 21:
			PutString(sX +35, sY + 25, NPC_NAME_GUARD, RGB(45,25,25));//"경비병"
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_GUARD, RGB(255,255,255));//"경비병"
			break;
		case 32:
			PutString(sX +35, sY + 25, NPC_NAME_UNICORN, RGB(45,25,25));//"유니콘"
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_UNICORN, RGB(255,255,255));//"유니콘"
			break;

		//	NPC 추가... 20021221..
		case 67:
			PutString(sX +35, sY + 25, NPC_NAME_MCGAFFIN, RGB(45,25,25));//"마을청년"
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_MCGAFFIN, RGB(255,255,255));//"마을청년"
			break;
		case 68:
			PutString(sX +35, sY + 25, NPC_NAME_PERRY, RGB(45,25,25));//"마을처녀"
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_PERRY, RGB(255,255,255));//"마을처녀"
			break;
		case 69:
			PutString(sX +35, sY + 25, NPC_NAME_DEVLIN, RGB(45,25,25));//"마을마법사"
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_DEVLIN, RGB(255,255,255));//"마을마법사"
			break;

		}

		if (m_bIsDialogEnabled[21] == FALSE) {
			if ((msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));//"대화 한다"
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));//"대화 한다"
			}
			else {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));//"대화 한다"
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));//"대화 한다"
			}
		}
		break;

	case 5:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 6); //6번이 큰창
		switch (m_stDialogBoxInfo[20].sV3) {
		case 15: 
			PutString(sX +33, sY +23, NPC_NAME_SHOP_KEEPER, RGB(45,25,25));//"상점 주인"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_SHOP_KEEPER, RGB(255,255,255));//"상점 주인"
			break;
		case 24: 
			PutString(sX +33, sY +23, NPC_NAME_BLACKSMITH_KEEPER, RGB(45,25,25));//"대장간 주인"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_BLACKSMITH_KEEPER, RGB(255,255,255));//"대장간 주인"
			break;

		}

		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255));//"거래 한다"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255));//"거래 한다"
		}
		else {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));//"거래 한다"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));//"거래 한다"
		}

		if ((msX > sX + 25 +79) && (msX < sX + 80 +75) && (msY > sY + 55) && (msY < sY + 70)) {
			PutString(sX + 28 +75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(255,255,255));//"판다"
			PutString(sX + 29 +75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(255,255,255));//"판다"
		}
		else {
			PutString(sX + 28 +75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(4,0,50));//"판다"
			PutString(sX + 29 +75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(4,0,50));//"판다"
		}
		
		if (m_bIsDialogEnabled[21] == FALSE) {
			if ((msX > sX + 155) && (msX < sX + 210) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));//"대화 한다"
				PutString(sX + 156, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));//"대화 한다"
			}
			else {
				PutString(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));//"대화 한다"
				PutString(sX + 156, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));//"대화 한다"
			}
		}
		break;
	}
}

void CGame::DrawDialogBox_Party(short msX, short msY)
{
 short sX, sY, szX;
 int  i, iNth;

    // 이 다이얼로그 박스가 마우스 오른쪽 클릭에 의해 닫히지 못하게 해야 한다. 명령을 받고 끝내야만 서버상의 데이터가 정리된다.
	
	sX = m_stDialogBoxInfo[32].sX;
	sY = m_stDialogBoxInfo[32].sY;
	szX = m_stDialogBoxInfo[32].sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 3);
	
	switch (m_stDialogBoxInfo[32].cMode) {
	case 0:
		if (m_iPartyStatus == 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 80) && (msY < sY + 100)) 
				 PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 255,255,255);//"파티에 참가합니다."
			else PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 4,0,50);//"파티에 참가합니다."
		}
		else PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 65,65,65);//"파티에 참가합니다."
		
		if (m_iPartyStatus != 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 100) && (msY < sY + 120))  
				 PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 255,255,255);//"파티에서 탈퇴합니다."
			else PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 4,0,50);//"파티에서 탈퇴합니다."
		}
		else PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 65,65,65);//"파티에서 탈퇴합니다."

	#if DEF_LANGUAGE == 5
		if (m_iPartyStatus != 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 120) && (msY < sY + 145))  
			{
				 PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 255,255,255);//"파티원들의 명단을 봅니다."
			 	 PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY8, 255,255,255);//"파티원들의 명단을 봅니다."
			}
			else 
			{
				PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 4,0,50);//"파티원들의 명단을 봅니다."
				PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY8, 4,0,50);//"파티원들의 명단을 봅니다."
			}
		}
		else 
		{
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 65,65,65);//"파티원들의 명단을 봅니다."
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY8, 65,65,65);//"파티원들의 명단을 봅니다."
		}
	#else
		if (m_iPartyStatus != 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 120) && (msY < sY + 140))  
				 PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 255,255,255);//"파티원들의 명단을 봅니다."
			else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 4,0,50);//"파티원들의 명단을 봅니다."
		}
		else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 65,65,65);//"파티원들의 명단을 봅니다."
	#endif

		switch (m_iPartyStatus) {
		case 0: 
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY10);//"당신은 파티에 참가하지 않은"
			PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY11);//"상태입니다. 다른 플레이어와"
			PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_PARTY12);//"파티를 구성할 수 있습니다." 
			break;

		case 1: 
		case 2: 
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY13);//"당신은 파티에 참가되어 있습니다."
			PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY14);//"파티를 탈퇴하거나 파티원들의"
			PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_PARTY15);//"이름을 조회할 수 있습니다."
			break;
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;
		break;

	case 1: // 파티원이 아니었는데 파티 참가 신청을 받은 경우. 수락하면 파티 마스터가 된다.
		wsprintf(G_cTxt, DRAW_DIALOGBOX_PARTY16,  m_stDialogBoxInfo[32].cStr);
		                //"%s로부터 파티 참가"
		PutAlignedString(sX, sX + szX, sY + 95, G_cTxt);

#if DEF_LANGUAGE == 5
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY17);//"제의가 들어왔습니다. 파티에 참가"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY17_1);//"제의가 들어왔습니다. 파티에 참가"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY18);//"하면 파티 멤버들이 얻은 경험치를"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY19);//"레벨 비례에 따라 나누어 가질 수"
		PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY20);//"있습니다."
#else
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY17);//"제의가 들어왔습니다. 파티에 참가"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY18);//"하면 파티 멤버들이 얻은 경험치를"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY19);//"레벨 비례에 따라 나누어 가질 수"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY20);//"있습니다."
#endif

		PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_PARTY21);//"파티에 참가 하시겠습니까?"
				
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 2:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY22);//"참가할 파티의 캐릭터를 마우스"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY23);//"커서로 지정해 주세요."
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY24);//"파티 참가를 취소하려면 Cancel"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY25);//"버튼을 누릅니다."
				
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16); 
		break;

	case 3:
		wsprintf(G_cTxt, DRAW_DIALOGBOX_PARTY26, m_stDialogBoxInfo[32].cStr);//"%s에게 파티 참가 여부를"
		PutAlignedString(sX, sX + szX, sY + 95, G_cTxt);
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY27);//"물었습니다. 응답이 올 때"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY28);//"까지 기다려 주세요."
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY29);//"파티 참가를 취소하려면 Cancel"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY30);//"버튼을 누릅니다."
		
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16); 
		break;
	
	case 4:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY31);//"당신이 가입한 파티에 소속된"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY32);//"캐릭터들의 이름입니다."
		
		iNth = 0;
		for (i = 0; i <= DEF_MAXPARTYMEMBERS; i++) 
		if (strlen(m_stPartyMemberNameList[i].cName) != 0) {
			wsprintf(G_cTxt, "%s", m_stPartyMemberNameList[i].cName);
			PutAlignedString(sX +17, sX +270, sY + 140 +15*(iNth), G_cTxt);
			iNth++;
		}
		
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 5:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY33);//"파티 탈퇴 처리중입니다."
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY34);//"잠시만 기다려 주세요."
		break;

	case 6:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY35);//"파티를 탈퇴 했습니다."
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 7:
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_PARTY36);//"파티 탈퇴를 하지 못했습니다."
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY37);//"파티 탈퇴가 계속 안된다면 로그"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY38);//"아웃하여 파티를 탈퇴할 수"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY39);//"있습니다."
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 8:
#if DEF_LANGUAGE == 5
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_PARTY40);//"파티에 참가 했습니다."
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY41);//"파티원들이 얻은 경험치를 나누어"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY42);//"얻을 수 있으며 같은 파티원들"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY43);//"끼리는 안전모드를 설정하지 않아도"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY44);//"공격이 되지 않으므로 보다"
		PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY45);//"효율적인 전투가 가능합니다."
		PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_PARTY45_1);//"효율적인 전투가 가능합니다."
#else
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_PARTY40);//"파티에 참가 했습니다."
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY41);//"파티원들이 얻은 경험치를 나누어"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY42);//"얻을 수 있으며 같은 파티원들"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY43);//"끼리는 안전모드를 설정하지 않아도"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY44);//"공격이 되지 않으므로 보다"
		PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY45);//"효율적인 전투가 가능합니다."
#endif
		
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 9:
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_PARTY46);//"파티 참가에 실패했습니다."
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY47);//"파티 참가를 상대가 거부했거나"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY48);//"국적이 다른 플레이어에게 참가"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY49);//"신청을 한 경우, 평화 모드 상태가"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY50);//"아닌 캐릭터에게 참가 신청을 한"
		PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY51);//"경우입니다." 
		
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 10:
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_PARTY52);//"당신의 파티가 해체되었습니다."
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY53);//"파티에 남아있는 인원이 1명 이면"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY54);//"자동적으로 파티가 해체됩니다."
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
		break;

	case 11: // 파티 탈퇴 확인
	
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY55);//"파티를 탈퇴 하시겠습니까?"
				
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;
	}
}

void CGame::DrawDialogBox_QueryDropItemAmount()
{
 short sX, sY;
 char cTxt[120], cStr1[64], cStr2[64], cStr3[64];
	
	sX = m_stDialogBoxInfo[17].sX;
	sY = m_stDialogBoxInfo[17].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5);

	switch (m_stDialogBoxInfo[17].cMode) {
	case 1:
		GetItemName( m_pItemList[m_stDialogBoxInfo[17].sView]->m_cName, m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwAttribute, cStr1, cStr2, cStr3 );
		if (strlen(m_stDialogBoxInfo[17].cStr) == 0) // v1.4
			 wsprintf(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT1, cStr1);//"%s: 버립니다."
		else wsprintf(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT2, cStr1, m_stDialogBoxInfo[17].cStr);//"%s: %s에게 전달."
		
		if (m_stDialogBoxInfo[17].sV3 < 1000) // v1.4
			PutString(sX + 30, sY + 20, cTxt, RGB(55,25,25));
				
		PutString(sX + 30, sY + 35, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT3, RGB(55,25,25));//"수량을 결정하세요."
		if (iGetTopDialogBoxIndex() != 17)
			PutString(sX + 40, sY + 57, m_cAmountString, RGB(255,255,255), FALSE, 2);
#if DEF_LANGUAGE == 5
		wsprintf(cTxt, "__________ (0 - %d)", m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount);
#else
		wsprintf(cTxt, "__________ (0 ~ %d)", m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount);
#endif
		PutString(sX + 38, sY + 62, cTxt, RGB(25,35,25));
		break;

	case 20:
		GetItemName( m_pItemList[m_stDialogBoxInfo[17].sView]->m_cName, m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwAttribute, cStr1, cStr2, cStr3 );
		if (strlen(m_stDialogBoxInfo[17].cStr) == 0) // v1.4
			 wsprintf(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT1, cStr1);//"%s: 버립니다."
		else wsprintf(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT2, cStr1, m_stDialogBoxInfo[17].cStr);//"%s: %s에게 전달." 
		
		if (m_stDialogBoxInfo[17].sV3 < 1000) // v1.4
			PutString(sX + 30, sY + 20, cTxt, RGB(55,25,25));

		PutString(sX + 30, sY + 35, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT3, RGB(55,25,25));//"수량을 결정하세요."
		PutString(sX + 40, sY + 57, m_cAmountString, RGB(255,255,255), FALSE, 2);
#if DEF_LANGUAGE == 5
		wsprintf(cTxt, "__________ (0 - %d)", m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount);
#else
		wsprintf(cTxt, "__________ (0 ~ %d)", m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount);
#endif
		PutString(sX + 38, sY + 62, cTxt, RGB(25,35,25));
		break;
	}
}


void CGame::DrawDialogBox_Quest(int msX, int msY)
{
 short sX, sY, szX;
 char cTxt[120], cTemp[21];

	sX = m_stDialogBoxInfo[28].sX;
	sY = m_stDialogBoxInfo[28].sY;
	szX = m_stDialogBoxInfo[28].sSizeX;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT , sX, sY, 4);

	switch (m_stDialogBoxInfo[28].cMode) {
	case 1:
		switch (m_stQuest.sQuestType) {
		case NULL:
			PutAlignedString(sX, sX + szX, sY + 50 +115 -30, DRAW_DIALOGBOX_QUEST1, 55,25,25);
			                                                     //" 수행중인 퀘스트가 없습니다."
			break;
		
		case 1:
			// 몬스터 Hunt
			if (m_stQuest.bIsQuestCompleted == FALSE)
				 PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST2, 55,25,25);
			                                                  //"몬스터 퇴치 퀘스트를 수행중입니다."
			else PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST3, 55,25,25);
			                                                   //"몬스터 퇴치 퀘스트를 완수했습니다."
			
			ZeroMemory(cTemp, sizeof(cTemp));
			switch (m_stQuest.sWho) {
			case 1:
			case 2:
			case 3: break;
			case 4: strcpy(cTemp, NPC_NAME_CITYHALL_OFFICER); break;
				                  //"시청 행정관"
			case 5:
			case 6:
			case 7: break;
			}
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt,  DRAW_DIALOGBOX_QUEST5, cTemp);
			              //"의뢰인: %s"
			PutAlignedString(sX, sX + szX, sY + 50 +45, cTxt, 55,25,25);

			ZeroMemory(cTemp, sizeof(cTemp));
			GetNpcName(m_stQuest.sTargetType, cTemp);
			ZeroMemory(cTxt, sizeof(cTxt));
#if DEF_LANGUAGE == 4	//언어:English
			wsprintf(cTxt, NPC_TALK_HANDLER16, m_stQuest.sTargetCount, cTemp);
#else
			wsprintf(cTxt, NPC_TALK_HANDLER16, cTemp, m_stQuest.sTargetCount);
#endif
			PutAlignedString(sX, sX + szX, sY + 50 +60, cTxt, 55,25,25);

			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(m_stQuest.cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, DRAW_DIALOGBOX_QUEST31);//"위  치: 상관없음"
				PutAlignedString(sX, sX + szX, sY + 50 +75, cTxt, 55,25,25);
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(m_stQuest.cTargetName, cTemp);
				wsprintf(cTxt,  DRAW_DIALOGBOX_QUEST32, cTemp);//"위  치: %s"
				PutAlignedString(sX, sX + szX, sY + 50 +75, cTxt, 55,25,25);
				
				if (m_stQuest.sX != 0) {
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, DRAW_DIALOGBOX_QUEST33, m_stQuest.sX, m_stQuest.sY, m_stQuest.sRange);//"좌  표: %d,%d 범위: %d 블록 이내"
					PutAlignedString(sX, sX + szX, sY + 50 +90, cTxt, 55,25,25);
				}
			}

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST34, m_stQuest.sContribution);//"공헌도: %dPoint"
			PutAlignedString(sX, sX + szX, sY + 50 +105, cTxt, 55,25,25);
			break;
		
		case 7: // 침투 
			if (m_stQuest.bIsQuestCompleted == FALSE)
				 PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST26, 55,25,25);//"적국 침투 퀘스트를 수행중입니다."
			else PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST27, 55,25,25);//"적국 침투 퀘스트를 완수했습니다."

			ZeroMemory(cTemp, sizeof(cTemp));
			switch (m_stQuest.sWho) {
			case 1:
			case 2:
			case 3: break;
			case 4: strcpy(cTemp, NPC_NAME_CITYHALL_OFFICER); break;//"시청 행정관"  
			case 5:
			case 6:
			case 7: break;
			}
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST29, cTemp);//"의뢰인: %s"
			PutAlignedString(sX, sX + szX, sY + 50 +45, cTxt, 55,25,25);
						
			PutAlignedString(sX, sX + szX, sY + 50 +60, DRAW_DIALOGBOX_QUEST30, 55,25,25);//"목  표: 적국 침투 후 적들의 행동 관찰"

			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(m_stQuest.cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, DRAW_DIALOGBOX_QUEST31);//"위  치: 상관없음"
				PutAlignedString(sX, sX + szX, sY + 50 +75, cTxt, 55,25,25);
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(m_stQuest.cTargetName, cTemp);
				wsprintf(cTxt, DRAW_DIALOGBOX_QUEST32, cTemp);//"위  치: %s"
				PutAlignedString(sX, sX + szX, sY + 50 +75, cTxt, 55,25,25);
				
				if (m_stQuest.sX != 0) {
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, DRAW_DIALOGBOX_QUEST33, m_stQuest.sX, m_stQuest.sY, m_stQuest.sRange);//"좌  표: %d,%d 범위: %d 블록 이내"
					PutAlignedString(sX, sX + szX, sY + 50 +90, cTxt, 55,25,25);
				}
			}

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST34, m_stQuest.sContribution);//"공헌도: %dPoint"
			PutAlignedString(sX, sX + szX, sY + 50 +105, cTxt, 55,25,25);
			break;
		}
		break;

	case 2:
		PutAlignedString(sX, sX + szX, sY + 50 +115 -30, DRAW_DIALOGBOX_QUEST35, 55,25,25);//"당신의 퀘스트가 취소되었습니다."
		break;
	}

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
}

void CGame::DrawDialogBox_SellList(short msX, short msY)
{
 short sX, sY, szX;
 int  i, iItem;
 char cTemp[255], cStr1[64], cStr2[64], cStr3[64]; 
 	
	sX = m_stDialogBoxInfo[31].sX;
	sY = m_stDialogBoxInfo[31].sY;
	szX = m_stDialogBoxInfo[31].sSizeX;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

	iItem = 0;
	for (i = 0; i < DEF_MAXSELLLIST; i++)
	if (m_stSellItemList[i].iIndex != -1)
	{
		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName(m_pItemList[m_stSellItemList[i].iIndex]->m_cName, m_pItemList[m_stSellItemList[i].iIndex]->m_dwAttribute, cStr1, cStr2, cStr3);
		if (m_stSellItemList[i].iAmount > 1 )
		{
#if DEF_LANGUAGE == 4	//언어:English
			wsprintf(cTemp, DRAW_DIALOGBOX_SELL_LIST1, m_stSellItemList[i].iAmount, cStr1);
#else
			wsprintf(cTemp, DRAW_DIALOGBOX_SELL_LIST1, cStr1, m_stSellItemList[i].iAmount);
#endif
			if ((msX > sX + 25) && (msX < sX + 250) && (msY >= sY + 55 + i*15) && (msY <= sY + 55 + 14 + i*15)) 
				 PutAlignedString(sX, sX+szX, sY + 55 + i*15, cTemp, 255,255,255);
			else 
			{
				if(m_bIsSpecial)
					PutAlignedString(sX, sX+szX, sY + 55 + i*15, cTemp, 0,255,50);
				else
					PutAlignedString(sX, sX+szX, sY + 55 + i*15, cTemp, 45,25,25);
			}
		}
		else
		{
			if ((msX > sX + 25) && (msX < sX + 250) && (msY >= sY + 55 + i*15) && (msY <= sY + 55 + 14 + i*15)) 
			{
				if( (strlen(cStr2)==0) && (strlen(cStr3)==0) ) PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 255,255,255);
				else
				{
					ZeroMemory( G_cTxt, sizeof(G_cTxt) );
					if( (strlen(cStr1)+strlen(cStr2)+strlen(cStr3)) < 36 )
					{
						if( (strlen(cStr2)>0) && (strlen(cStr3)>0) ) wsprintf( G_cTxt, "%s(%s, %s)", cStr1, cStr2, cStr3 );
						else wsprintf( G_cTxt, "%s(%s%s)", cStr1, cStr2, cStr3 );
						PutAlignedString(sX, sX+szX, sY + 55 + i*15, G_cTxt, 255,255,255);
						
					}
					else
					{
						if( (strlen(cStr2)>0) && (strlen(cStr3)>0) ) wsprintf( G_cTxt, "(%s, %s)", cStr2, cStr3 );
						else wsprintf( G_cTxt, "(%s%s)", cStr2, cStr3 );
						PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 255,255,255);
						PutAlignedString(sX, sX+szX, sY + 55 + i*15 + 15, G_cTxt, 200,200,200);
						i++;
					}
				}
			}
			else
			{
				if( (strlen(cStr2)==0) && (strlen(cStr3)==0) ) 
				{
					//2003.02.03 정진광 수정 특성치 붙은 아이템의 이름은 연두색
					if(m_bIsSpecial)
						PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 0,255,50);
					else
						PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 45,25,25);
				}
				else
				{
					ZeroMemory( G_cTxt, sizeof(G_cTxt) );
					if( (strlen(cStr1)+strlen(cStr2)+strlen(cStr3)) < 36 )
					{
						if( (strlen(cStr2)>0) && (strlen(cStr3)>0) ) wsprintf( G_cTxt, "%s(%s, %s)", cStr1, cStr2, cStr3 );
						else wsprintf( G_cTxt, "%s(%s%s)", cStr1, cStr2, cStr3 );
						
						if(m_bIsSpecial)
							PutAlignedString(sX, sX+szX, sY + 55 + i*15, G_cTxt, 0,255,50);
						else
							PutAlignedString(sX, sX+szX, sY + 55 + i*15, G_cTxt, 45,25,25);
						
					}
					else 
					{
						//2003.02.03 정진광 수정 특성치 붙은 아이템의 이름은 연두색
						if(m_bIsSpecial)
							PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 0,255,50);
						else
							PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 45,25,25);
					}
				}
			}
		}
	}
	else iItem++;

	if (iItem == DEF_MAXSELLLIST) {
		PutAlignedString(sX, sX+szX, sY + 55 + 30 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST2);//"팔고자 하는 아이템을 인벤토리창에서"		                                       
		PutAlignedString(sX, sX+szX, sY + 55 + 45 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST3);//"끌어와 떨어뜨립니다. 최대 12개까지"
		PutAlignedString(sX, sX+szX, sY + 55 + 60 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST4);//"동시에 팔 수 있으며 무기나 방어구의"
		PutAlignedString(sX, sX+szX, sY + 55 + 75 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST5);//"경우 수명이 0이면 팔아지지 않습니다."
		PutAlignedString(sX, sX+szX, sY + 55 + 95 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST6);//"선택된 아이템을 리스트에서 삭제"
		PutAlignedString(sX, sX+szX, sY + 55 + 110 + 282 -117 -170,DRAW_DIALOGBOX_SELL_LIST7);//"하고자 한다면 아이템 이름을" 
		PutAlignedString(sX, sX+szX, sY + 55 + 125 + 282 -117 -170,DRAW_DIALOGBOX_SELL_LIST8);//"클릭하세요."		

	#if DEF_LANGUAGE == 5
		PutAlignedString(sX, sX+szX, sY + 55 + 155 + 282 -117 -170,DRAW_DIALOGBOX_SELL_LIST9);//"* 팔 아이템을 여기에 떨어뜨리세요! *"
		PutAlignedString(sX, sX+szX, sY + 55 + 170 + 282 -117 -170,DRAW_DIALOGBOX_SELL_LIST10);//"* 팔 아이템을 여기에 떨어뜨리세요! *"
	#else
		PutAlignedString(sX, sX+szX, sY + 55 + 155 + 282 -117 -170,DRAW_DIALOGBOX_SELL_LIST9);//"* 팔 아이템을 여기에 떨어뜨리세요! *"
	#endif
	}
	
	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY) && (iItem < DEF_MAXSELLLIST) )
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 39);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 38);

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
}

void CGame::DrawDialogBox_SellorRepairItem(short msX, short msY)
{
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 char cItemID, cItemColor, cTxt[120], cTemp[120], cStr2[120], cStr3[120]; 
	
	sX = m_stDialogBoxInfo[23].sX;
	sY = m_stDialogBoxInfo[23].sY;

	switch (m_stDialogBoxInfo[23].cMode) {
	case 1:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);
		
		// 먼저 아이템을 그린다.
		cItemID = m_stDialogBoxInfo[23].sV1;
		
		cItemColor = m_pItemList[cItemID]->m_cItemColor; // v1.4
		if (cItemColor == 0)
			 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteFast(sX + 62 + 15, sY + 84 + 30,
	                                                                                                   m_pItemList[cItemID]->m_sSpriteFrame, dwTime);
		else {
			// 무기류 아이템은 색상 세트가 다르다는 점에 주의
			switch (m_pItemList[cItemID]->m_sSprite) {
			case 1:
			case 2:
			case 3:
			case 15: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30, m_pItemList[cItemID]->m_sSpriteFrame,
																									          m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime); break;

			
			default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30, m_pItemList[cItemID]->m_sSpriteFrame,
																									          m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime); break;
			}
		}

		// 아이템 이름 
		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cStr2, sizeof(cStr2));
		ZeroMemory(cStr3, sizeof(cStr3));

		GetItemName(m_pItemList[cItemID]->m_cName, m_pItemList[cItemID]->m_dwAttribute, cTemp, cStr2, cStr3);
		if( m_stDialogBoxInfo[23].sV4 == 1 ) strcpy( cTxt, cTemp );
#if DEF_LANGUAGE == 4	//언어:English
		else wsprintf(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, m_stDialogBoxInfo[23].sV4, cTemp);
#else
		else wsprintf(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, cTemp, m_stDialogBoxInfo[23].sV4);
#endif

		if(m_bIsSpecial)
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 0,255,50);
			PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 0,255,50);
		}
		else
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45,25,25);
			PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 45,25,25);
		}
		
		// 아이템 남은 수명 
		wsprintf(cTxt,  DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM2, m_stDialogBoxInfo[23].sV2);
		              //"수 명: %d"
		PutString(sX + 95 + 15, sY + 53 + 60, cTxt, RGB(45,25,25));
		
		// 아이템 가격  
		wsprintf(cTxt,  DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM3, m_stDialogBoxInfo[23].sV3);
		               //"가 치: %dGold" 
		PutString(sX + 95 + 15, sY + 53 + 75, cTxt, RGB(45,25,25));
		
		PutString(sX + 55, sY + 190, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM4, RGB(45,25,25));
		                            //"이 가격에 팔아버리시겠습니까?"
		
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX +DEF_LBTNPOSX, sY + DEF_BTNPOSY, 39);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX +DEF_LBTNPOSX, sY + DEF_BTNPOSY, 38);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX +DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX +DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 2:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 10);
		
		// 먼저 아이템을 그린다.
		cItemID = m_stDialogBoxInfo[23].sV1;
		cItemColor = m_pItemList[cItemID]->m_cItemColor; // v1.4
		if (cItemColor == 0)
			 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteFast(sX + 62 + 15, sY + 84 + 30,
			                                                                                           m_pItemList[cItemID]->m_sSpriteFrame, dwTime);
		else {
			// 무기류 아이템은 색상 세트가 다르다는 점에 주의
			switch (m_pItemList[cItemID]->m_sSprite) {
			case 1:
			case 2:
			case 3:
			case 15: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30, m_pItemList[cItemID]->m_sSpriteFrame,
																									          m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime); break;

			
			default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30, m_pItemList[cItemID]->m_sSpriteFrame,
																									          m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime); break;
			}
		}
		// 아이템 이름 
		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cStr2, sizeof(cStr2));
		ZeroMemory(cStr3, sizeof(cStr3));

		GetItemName(m_pItemList[cItemID], cTemp, cStr2, cStr3);

		wsprintf(cTxt, "%s", cTemp);

//		PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45,25,25);
//		PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 45,25,25);
				if(m_bIsSpecial)
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 0,255,50);
			PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 0,255,50);
		}
		else
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45,25,25);
			PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 45,25,25);
		}
		
		// 아이템 남은 수명 
		wsprintf(cTxt,  DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM2, m_stDialogBoxInfo[23].sV2);//"수 명: %d"
		PutString(sX + 95 + 15, sY + 53 + 60, cTxt, RGB(45,25,25));
		// 아이템 가격  
		wsprintf(cTxt,  DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM6, m_stDialogBoxInfo[23].sV3);//"수리 비용: %dGold"  
		PutString(sX + 95 + 15, sY + 53 + 75, cTxt, RGB(45,25,25));
		PutString(sX + 55, sY + 190, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM7, RGB(45,25,25));//"아이템을 수리하시겠습니까?"
		
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 43);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 42);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 3:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);
		
		PutString(sX + 55, sY + 100, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM8, RGB(45,25,25));//" 아이템을 팔고 있습니다..."
		PutString(sX + 55, sY + 120, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM9, RGB(45,25,25));//"이 과정이 끝나기 전에는 아이템을 "
		PutString(sX + 55, sY + 135, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM10, RGB(45,25,25));//"버리거나 줄 수 없습니다. "
		break;

	case 4:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 10);
		
		PutString(sX + 55, sY + 100, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM11, RGB(45,25,25));//" 아이템을 수리 중입니다..."
		PutString(sX + 55, sY + 120, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM9, RGB(45,25,25));//"이 과정이 끝나기 전에는 아이템을 "
		PutString(sX + 55, sY + 135, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM10, RGB(45,25,25));//"버리거나 줄 수 없습니다. "
		break;
	}
}

void CGame::DrawDialogBox_Shop(short msX, short msY, short msZ, char cLB)
{
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 int  i, iTemp;
 char cTemp[255], cStr2[255], cStr3[255]; 
 int  iCost, iDiscountCost, iDiscountRatio, iMsgLoc;
 double dTmp1, dTmp2, dTmp3;
 int  iTotalLines, iPointerLoc;
 BOOL bFlag = TRUE;
 double d1, d2, d3;
	
	iMsgLoc = 0;

	sX = m_stDialogBoxInfo[11].sX;
	sY = m_stDialogBoxInfo[11].sY;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);
	
	switch (m_stDialogBoxInfo[11].cMode) {
	case 0:
		iTotalLines = 0;
		for (i = 0; i < DEF_MAXMENUITEMS; i++) 
		if (m_pItemForSaleList[i] != NULL) iTotalLines++; 

		// 스크롤 바 포인터 그린다.
		if (iTotalLines > 13) {
			d1 = (double)m_stDialogBoxInfo[11].sView;
			d2 = (double)(iTotalLines-13);
			d3 = (274.0f * d1)/d2;
			iPointerLoc = (int)(d3);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX+242, sY + iPointerLoc + 35, 7);
		}
		else iPointerLoc = 0;
		
		// 스크롤바 찍기 처리
		if (cLB != 0 && iTotalLines > 13) {
			if ((iGetTopDialogBoxIndex() == 11)) {
				if ((msX >= sX + 235) && (msX <= sX + 260) && (msY >= sY + 10) && (msY <= sY + 330)) { 
					d1 = (double)(msY -(sY+35));
					d2 = (double)(iTotalLines-13);
					d3 = (d1 * d2)/274.0f;
					m_stDialogBoxInfo[11].sView = (int)(d3+0.5);
				}
			}
		}
		else m_stDialogBoxInfo[11].bIsScrollSelected = FALSE;
		if( iGetTopDialogBoxIndex() == 11 && msZ != 0 )
		{
			m_stDialogBoxInfo[11].sView = m_stDialogBoxInfo[11].sView - msZ/60;
			m_DInput.m_sZ = 0;
		}
		if( iTotalLines > 13 && m_stDialogBoxInfo[11].sView > iTotalLines-13 ) m_stDialogBoxInfo[11].sView = iTotalLines-13;
		if( m_stDialogBoxInfo[11].sView < 0 || iTotalLines < 13 ) m_stDialogBoxInfo[11].sView = 0;
		PutAlignedString(sX + 22, sX +165, sY + 45, DRAW_DIALOGBOX_SHOP1);//"아 이 템"
		PutAlignedString(sX + 23, sX +166, sY + 45, DRAW_DIALOGBOX_SHOP1);//"아 이 템"
		PutAlignedString(sX +153, sX +250, sY + 45, DRAW_DIALOGBOX_SHOP3);//"가   격"
		PutAlignedString(sX +154, sX +251, sY + 45, DRAW_DIALOGBOX_SHOP3);//"가   격"

		for (i = 0; i < 13; i++)
		if (((i+ m_stDialogBoxInfo[11].sView) < DEF_MAXMENUITEMS) && (m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView] != NULL)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			GetItemName(m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView], cTemp, cStr2, cStr3);

			if ((msX >= sX + 20) && (msX <= sX + 220) && (msY >= sY + i*18 + 65) && (msY <= sY + i*18 + 79)) {
				PutAlignedString(sX +10, sX +190, sY + i*18 + 65, cTemp, 255, 255, 255);
			}
			else PutAlignedString(sX +10, sX +190, sY + i*18 +65, cTemp, 4,0,50);
		}

		for (i = 0; i < 13; i++)
		if (((i+ m_stDialogBoxInfo[11].sView) < DEF_MAXMENUITEMS) && (m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView] != NULL)) {
			
//			iCost =(int)((float)(m_cDiscount) * 0.9f + 0.5f) ;
			// v2.14 카리스마가 10인경우는 아이템을 할인 하지 않는다.

			iDiscountRatio = ((m_iCharisma - 10)  / 4) ;
			dTmp1 = (double)iDiscountRatio;
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView]->m_wPrice;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;

			iCost = (int)(m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView]->m_wPrice * ((100 + m_cDiscount)/100.) );
			iCost = iCost - iDiscountCost;

			//물건값 최종적으로 계산하는 부분.
			if (iCost < (m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView]->m_wPrice/2))
				iCost = (m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView]->m_wPrice/2) - 1;

			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%6d", iCost);
			if ((msX >= sX+20) && (msX <= sX+220) && (msY >= sY+i*18+65) && (msY <= sY+i*18+79)) 
					PutAlignedString(sX+148, sX+260, sY+i*18+65, cTemp, 255, 255, 255);
			else	PutAlignedString(sX+148, sX+260, sY+i*18+65, cTemp, 4,0,50);
		}
		break;

	default:
		// 먼저 아이템을 그린다.
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sSprite]->PutSpriteFast(sX + 62 + 30 -35, sY + 84 + 30 -10,
		          m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sSpriteFrame, dwTime);
				
		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode-1], cTemp, cStr2, cStr3);

		PutAlignedString(sX +25, sX+240, sY+50, cTemp, 255,255,255);
		PutAlignedString(sX +26, sX+241, sY+50, cTemp, 255,255,255);
		
		strcpy(cTemp, DRAW_DIALOGBOX_SHOP3);//"가  격"
		PutString(sX + 95 + 30 -35, sY + 78 + 30 -10, cTemp, RGB(40,10,10));
		PutString(sX + 96 + 30 -35, sY + 78 + 30 -10, cTemp, RGB(40,10,10));
		strcpy(cTemp, DRAW_DIALOGBOX_SHOP6);
		             //"무  게"
		PutString(sX + 95 + 30 -35, sY + 93 + 30 -10, cTemp, RGB(40,10,10));
		PutString(sX + 96 + 30 -35, sY + 93 + 30 -10, cTemp, RGB(40,10,10));


		// v2.14 카리스마 10인경우는 아이템 할인을 받지 못한다. 
		iDiscountRatio = ((m_iCharisma -10) / 4) ;
		dTmp1 = (double)iDiscountRatio;
		dTmp2 = dTmp1 / 100.0f;
		dTmp1 = (double)m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wPrice;
		dTmp3 = dTmp1 * dTmp2;
		iDiscountCost = (int)dTmp3;

		iCost = (int)(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wPrice * ((100 +m_cDiscount)/100.) );
		iCost = iCost - iDiscountCost;

		//물건값 최종적으로 계산하는 부분.
		if (iCost < (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wPrice/2))
				iCost = (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wPrice/2) - 1;

		wsprintf(cTemp, DRAW_DIALOGBOX_SHOP7, iCost );
		                //": %d Gold"
		PutString(sX + 140, sY + 98, cTemp, RGB(45,25,25));
		
		iTemp = m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100;
		wsprintf(cTemp, DRAW_DIALOGBOX_SHOP8, iTemp);  
		               //": %d Stone"
		PutString(sX + 140, sY + 113, cTemp, RGB(45,25,25));

//	#ifdef _DEBUG
//		// 이론과 실제의 차이가 너무 크므로 무효~!!! 
//		if ((m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cEquipPos == DEF_EQUIPPOS_RHAND) ||
//			(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND) )
//		{
//		    register int iThrow, iRange, iTotalDmg;
//            register int i, iRet;
//			iThrow = m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue1;	
//			iRange = m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue2;	
//			srand( (unsigned)time( NULL ));
//			iRet = 0;
//			iTotalDmg = 0;
//			for (int j = 0 ; j < 10 ; j++)
//			{
//				for (i = 1; i <= iThrow; i++) 
//				{
//					iRet += (rand() % iRange) + 1;
//				}
//				iTotalDmg += iRet;
//			} 
//			wsprintf(cTemp, "평균데미지 : %d", iTotalDmg/10);
//			PutString(sX + 95 + 30 -35, sY + 108 + 30 -10, cTemp, RGB(40,10,10));
//			PutString(sX + 96 + 30 -35, sY + 108 + 30 -10, cTemp, RGB(40,10,10));
//		}
//		// 이론과 실제의 차이가 너무 크므로 무효~!!! 
//	#endif

		switch (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cEquipPos) {
		case DEF_EQUIPPOS_RHAND:
		case DEF_EQUIPPOS_TWOHAND:
			// 무기류이다.
			strcpy(cTemp, DRAW_DIALOGBOX_SHOP9);
			              //"공격력"
			PutString(sX + 40, sY + 145, cTemp, RGB(45,25,25));
			PutString(sX + 41, sY + 145, cTemp, RGB(45,25,25));
			strcpy(cTemp, DRAW_DIALOGBOX_SHOP10);
			             //"속도(최소~최대힘)"
			PutString(sX + 30, sY + 175, cTemp, RGB(45,25,25));
			PutString(sX + 31, sY + 175, cTemp, RGB(45,25,25));

			if (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue3 != 0) {
				wsprintf(cTemp, ": %dD%d+%d (S-M)", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue1,  
					                                m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue2,
								                    m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue3);
				
			}
			else {
				wsprintf(cTemp, ": %dD%d (S-M)", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue1,  
					                             m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue2);
			}
			PutString(sX + 140, sY + 145, cTemp, RGB(45,25,25));

			if (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue6 != 0) {
				wsprintf(cTemp, ": %dD%d+%d (L)", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue4,  
					                              m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5,
								                  m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue6);
			}
			else {
				wsprintf(cTemp, ": %dD%d (L)", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue4,  
					                           m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
			}
			PutString(sX + 140, sY + 160, cTemp, RGB(45,25,25));
//2002.09.26 정진광 수정. 일본어에서 ~ 를 - 로 교체
#if DEF_LANGUAGE == 5			
			if (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cSpeed == 0)   wsprintf(cTemp, ": 0(10-10)");  
			else wsprintf(cTemp, ": %d(%d - %d)",m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cSpeed, iTemp,m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cSpeed*13);  
#else
			if (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cSpeed == 0)   wsprintf(cTemp, ": 0(10~10)");  
			else wsprintf(cTemp, ": %d(%d ~ %d)",m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cSpeed, iTemp,m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cSpeed*13);  
#endif

			PutString(sX + 140, sY + 175, cTemp, RGB(45,25,25));

			// v1.4311 주의 메시지 
			if ((m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100) > m_iStr) {
				wsprintf(cTemp,DRAW_DIALOGBOX_SHOP11, (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100)) ;
							//"* 힘이 %d가 되어야 사용할 수 있습니다."
				PutAlignedString(sX +25, sX+240, sY + 258 +iMsgLoc*15, cTemp, 195,25,25);
				PutAlignedString(sX +26, sX+241, sY + 258 +iMsgLoc*15, cTemp, 195,25,25);
				iMsgLoc++;
			}
			break;

		case DEF_EQUIPPOS_LHAND:
			// 방패류이다.
			strcpy(cTemp, DRAW_DIALOGBOX_SHOP12);//"방어값"
			PutString(sX + 90, sY + 145, cTemp, RGB(45,25,25));
			PutString(sX + 91, sY + 145, cTemp, RGB(45,25,25));

			wsprintf(cTemp, ": +%d%", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue1);  
			PutString(sX + 140, sY + 145, cTemp, RGB(45,25,25));

			// v1.4311 주의 메시지 
			if ((m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100) > m_iStr) {
				wsprintf(cTemp,DRAW_DIALOGBOX_SHOP11, (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100)) ;
				              //"* 힘이 %d가 되어야 사용할 수 있습니다."
				PutAlignedString(sX +25, sX+240, sY + 258, cTemp, 195,25,25);
				PutAlignedString(sX +26, sX+241, sY + 258, cTemp, 195,25,25);
			}
			break;

		case DEF_EQUIPPOS_HEAD:
		case DEF_EQUIPPOS_BODY:
		case DEF_EQUIPPOS_BOOTS:
		case DEF_EQUIPPOS_ARMS:
		case DEF_EQUIPPOS_PANTS:
			strcpy(cTemp, DRAW_DIALOGBOX_SHOP12);//"방어값"
			PutString(sX + 90, sY + 145, cTemp, RGB(45,25,25));
			PutString(sX + 91, sY + 145, cTemp, RGB(45,25,25));

			wsprintf(cTemp, ": +%d%", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue1);  
			PutString(sX + 140, sY + 145, cTemp, RGB(45,25,25));

			bFlag = TRUE;
			switch(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue4) {
			case 10:
				bFlag = FALSE;
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP15, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);  
				               //"Str %d 이상 장착 가능"
				if (m_iStr >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5) {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					bFlag = TRUE;
				}
				else {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
				}
				break;
			case 11:
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP16, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);  
				               //"Dex %d 이상 장착 가능"
				if (m_iDex >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5) {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					bFlag = TRUE;
				}
				else {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
				}
				break;
			case 12:
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP17, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);  
				                 //"Vit %d 이상 장착 가능"
				if (m_iVit >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5) {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					bFlag = TRUE;
				}
				else {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
				}
				break;
			case 13:
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP18, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);  
				                //"Int %d 이상 장착 가능"
				if (m_iInt >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5) {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					bFlag = TRUE;
				}
				else {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
				}
				break;
			case 14:
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP19, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);  
				               //"Mag %d 이상 장착 가능"
				if (m_iMag >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5) {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					bFlag = TRUE;
				}
				else {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(55,25,25));
				}
				break;
			case 15:
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP20, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);  
				               //"Chr %d 이상 장착 가능"
				if (m_iCharisma >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5) {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					bFlag = TRUE;
				}
				else {
					PutString(sX + 95 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
					PutString(sX + 96 +30 -35, sY + 125 + 45 -10, cTemp, RGB(45,25,25));
				}
				break;
			default:
				break;
			}

			// v1.4311 주의 메시지 
			if ((m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100) > m_iStr) {
				wsprintf(cTemp,DRAW_DIALOGBOX_SHOP11, (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100)) ;
				             //"* 힘이 %d가 되어야 사용할 수 있습니다."
				PutAlignedString(sX +25, sX+240, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
				PutAlignedString(sX +25 +1, sX+240 +1, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
				iMsgLoc++;
				bFlag = FALSE;
			}
			else if (bFlag == FALSE) {
				strcpy(cTemp, DRAW_DIALOGBOX_SHOP21);//"* 특성치가 낮아 사용할 수 없습니다."
				PutAlignedString(sX +25, sX+240, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
				PutAlignedString(sX +25 +1, sX+240 +1, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
				iMsgLoc++;
			}

			if (strstr(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cName, "(M)") != NULL) {
				// 남자용 아이템
				if (m_sPlayerType > 3) {	
					strcpy(cTemp, DRAW_DIALOGBOX_SHOP22);//"* 남성용이라 사용할 수 없습니다."
					PutAlignedString(sX +25, sX+240, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
					PutAlignedString(sX +25 +1, sX+240 +1, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
					iMsgLoc++;
					bFlag = FALSE;
				}
			}
			else if (strstr(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cName, "(W)") != NULL) {
				// 여자용 아이템
				if (m_sPlayerType <= 3) {	
					strcpy(cTemp, DRAW_DIALOGBOX_SHOP23);
					              //"* 여성용이라 사용할 수 없습니다."
					PutAlignedString(sX +25, sX+240, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
					PutAlignedString(sX +25 +1, sX+240 +1, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
					iMsgLoc++;
					bFlag = FALSE;
				}
			}
			break;

		case DEF_EQUIPPOS_NONE:
			break;
		}

		// 레벨 제한
		if (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sLevelLimit != 0) {
			strcpy(cTemp, DRAW_DIALOGBOX_SHOP24);
			             //"레벨 제한"
			PutString(sX + 75 -35, sY + 170 + 30 -10, cTemp, RGB(45,25,25));
			PutString(sX + 76 -35, sY + 170 + 30 -10, cTemp, RGB(45,25,25));
			
			wsprintf(cTemp, DRAW_DIALOGBOX_SHOP25, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sLevelLimit);  
			              //": %d이상"
			PutString(sX + 145 + 30 -35, sY + 170 + 30 -10, cTemp, RGB(45,25,25));

			if ((bFlag == TRUE) && (m_iLevel < m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sLevelLimit)) {
				strcpy(cTemp, DRAW_DIALOGBOX_SHOP26);
				             //"* 레벨이 낮아 사용할 수 없습니다."
				PutAlignedString(sX +25, sX+240, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
				PutAlignedString(sX +25 +1, sX+240 +1, sY + 254 -10 +14 +iMsgLoc*15, cTemp, 195,25,25);
				iMsgLoc++;
			}
		}
		
		
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 156, sY + 219, 19, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 170, sY + 219, 19, dwTime);

		PutString(sX + 127 -35, sY + 237 -10, DRAW_DIALOGBOX_SHOP27, RGB(40,10,10));//"구입 갯수:"
		PutString(sX + 128 -35, sY + 237 -10, DRAW_DIALOGBOX_SHOP27, RGB(40,10,10));//"구입 갯수:"
		if( iGetTopDialogBoxIndex() == 11 && msZ != 0 )
		{
			m_stDialogBoxInfo[11].sV3 = m_stDialogBoxInfo[11].sV3 + msZ/60;
			m_DInput.m_sZ = 0;
		}
		if (m_stDialogBoxInfo[11].sV3 > (50 - _iGetTotalItemNum())) m_stDialogBoxInfo[11].sV3 = (50 - _iGetTotalItemNum());
		if (m_stDialogBoxInfo[11].sV3 < 1) m_stDialogBoxInfo[11].sV3 = 1;
		
		if (m_stDialogBoxInfo[11].sV3 >= 10) {
			// 십 자리 출력 
			ZeroMemory(cTemp, sizeof(cTemp));
			_itoa(m_stDialogBoxInfo[11].sV3, cTemp, 10);
			cTemp[1] = NULL;
			PutString(sX -35 + 186, sY -10 + 237, cTemp, RGB(40,10,10));
			PutString(sX -35 + 187, sY -10 + 237, cTemp, RGB(40,10,10));

			// 단자리 출력 
			ZeroMemory(cTemp, sizeof(cTemp));
			_itoa(m_stDialogBoxInfo[11].sV3, cTemp, 10);
			PutString(sX -35 + 200, sY -10 + 237, (cTemp+1), RGB(40,10,10));
			PutString(sX -35 + 201, sY -10 + 237, (cTemp+1), RGB(40,10,10));
		}
		else {
			PutString(sX -35 + 186, sY -10 + 237, "0", RGB(40,10,10));
			PutString(sX -35 + 187, sY -10 + 237, "0", RGB(40,10,10));

			ZeroMemory(cTemp, sizeof(cTemp));
			_itoa(m_stDialogBoxInfo[11].sV3, cTemp, 10);
			PutString(sX -35 + 200, sY -10 + 237, (cTemp), RGB(40,10,10));
			PutString(sX -35 + 201, sY -10 + 237, (cTemp), RGB(40,10,10));
		}

		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX +156, sY + 244, 20, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX +170, sY + 244, 20, dwTime);

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 31);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 30);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;
	}
}

void CGame::DrawDialogBox_Skill(short msX, short msY, short msZ, char cLB)
{
 short sX, sY;
 int  i, iTotalLines, iPointerLoc;
 char cTemp[255], cTemp2[255]; 
 double d1,d2,d3;
	
	sX = m_stDialogBoxInfo[15].sX;
	sY = m_stDialogBoxInfo[15].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0); // Normal Dialog
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 1); // Skill Dialog Title Bar

	switch (m_stDialogBoxInfo[15].cMode) {
	case 0:
		for (i = 0; i < 17; i++)	 									  
		if ((i < DEF_MAXSKILLTYPE) && (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView] != NULL)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%s", m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_cName);
			
			m_Misc.ReplaceString(cTemp, '-', ' ');
			
			ZeroMemory(cTemp2, sizeof(cTemp2));
			wsprintf(cTemp2, "%3d%%", m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_iLevel);
			
			if ((msX >= sX + 25) && (msX <= sX + 166) && (msY >= sY + 45 + i*15) && (msY <= sY + 59 + i*15)) {
				if ((m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_bIsUseable == TRUE) &&
					(m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_iLevel != 0) ) {
					
					PutString(sX + 30,  sY + 45 + i*15, cTemp, RGB(255,255,255));
					PutString(sX + 183, sY + 45 + i*15, cTemp2, RGB(255,255,255));
				}
				else {
					PutString(sX + 30,  sY + 45 + i*15, cTemp, RGB(5,5,5));
					PutString(sX + 183, sY + 45 + i*15, cTemp2, RGB(5,5,5));
				}
			}
			else {
				if ( (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_bIsUseable == TRUE) &&
					 (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_iLevel != 0) ) {
					PutString(sX + 30, sY + 45 + i*15, cTemp, RGB(34,30,120));
					PutString(sX + 183, sY + 45 + i*15, cTemp2, RGB(34,30,120));
			   	}
				else {
					PutString(sX + 30, sY + 45 + i*15, cTemp, RGB(5,5,5));
					PutString(sX + 183, sY + 45 + i*15, cTemp2, RGB(5,5,5));
				}
			}

			if (m_iDownSkillIndex == (i + m_stDialogBoxInfo[15].sView))
				 m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(sX + 215, sY + 47 + i*15, 21, 50,50,50, m_dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + 215, sY + 47 + i*15, 20, m_dwTime);
		}

		iTotalLines = 0;
		for (i = 0; i < DEF_MAXSKILLTYPE; i++) 
		if (m_pSkillCfgList[i] != NULL) iTotalLines++;

		// 스크롤 바 포인터 그린다.
		if (iTotalLines > 17) {
			d1 = (double)m_stDialogBoxInfo[15].sView;
			d2 = (double)(iTotalLines-17);
			d3 = (274.0f * d1)/d2;
			iPointerLoc = (int)d3;
		}
		else iPointerLoc = 0;
		if( iTotalLines > 17 )
		{
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX+242, sY+iPointerLoc + 35, 7);
		}

		// 스크롤바 찍기 처리 
		if (cLB != 0 && iTotalLines > 17) {
			if ((iGetTopDialogBoxIndex() == 15)) {
				if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 30) && (msY <= sY + 320)) {
					d1 = (double)(msY -(sY+35));
					d2 = (double)(iTotalLines-17);
					d3 = (d1 * d2)/274.0f;
					iPointerLoc = (int)(d3+0.5);

					if (iPointerLoc > iTotalLines - 17) iPointerLoc = iTotalLines -17;
					m_stDialogBoxInfo[15].sView = iPointerLoc;
				}
			}
		}
		else m_stDialogBoxInfo[15].bIsScrollSelected = FALSE;
		if( iGetTopDialogBoxIndex() == 15 && msZ != 0 )
		{
			if( msZ > 0 ) m_stDialogBoxInfo[15].sView--;
			if( msZ < 0 ) m_stDialogBoxInfo[15].sView++;
			m_DInput.m_sZ = 0;
		}
		if( m_stDialogBoxInfo[15].sView < 0 ) m_stDialogBoxInfo[15].sView = 0;
		if( iTotalLines > 17 && m_stDialogBoxInfo[15].sView > iTotalLines-17 ) m_stDialogBoxInfo[15].sView = iTotalLines-17;
	   	break;
	}
}

void CGame::DrawDialogBox_SkillDlg(short msX, short msY, short msZ, char cLB)
{
 int i, iLoc ,iAdjX, iAdjY;
 char cTemp[120], cTemp2[120];
 short sX, sY, szX;
 char cStr1[64], cStr2[64], cStr3[64];
 DWORD dwTime = m_dwCurTime;

	iAdjX = 5 ;
	iAdjY = 8 ;
	
	switch (m_stDialogBoxInfo[26].cMode) {
	case 1:
		// 별도의 다이얼로그 박스를 사용하는 아이템을 더블클릭했을 경우.
		if (m_stDialogBoxInfo[26].cStr[0] != 0) {
			sX = m_stDialogBoxInfo[26].sX + iAdjX + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
			sY = m_stDialogBoxInfo[26].sY + iAdjY + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
		}
		else {
			sX = m_stDialogBoxInfo[26].sX;
			sY = m_stDialogBoxInfo[26].sY;
		}
		
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX, sY, 1, dwTime);
		
		if (m_stDialogBoxInfo[26].sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +45*1 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);
		
		if (m_stDialogBoxInfo[26].sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +45*2 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55+45*1 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55+45*2 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);

		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195)) 
#if DEF_LANGUAGE == 1 //Taiwan
			 PutString(sX + iAdjX + 60, sY + iAdjY + 175, "{bN먼먼T", RGB(78, 64, 249));
		else PutString(sX + iAdjX + 60, sY + iAdjY + 175, "{bN먼먼T", RGB(26,11,216));
#else
			 PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 16,16,30);
		else PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 6, 6, 20);
#endif
		break;

	case 2:
		// 별도의 다이얼로그 박스를 사용하는 아이템을 더블클릭했을 경우.
		if (m_stDialogBoxInfo[26].cStr[0] != 0) {
			sX = m_stDialogBoxInfo[26].sX + iAdjX + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
			sY = m_stDialogBoxInfo[26].sY + iAdjY + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
		}
		else {
			sX = m_stDialogBoxInfo[26].sX;
			sY = m_stDialogBoxInfo[26].sY;
		}
		// 작업이 진행중임을 표시 
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX, sY, 1, dwTime);

		if (m_stDialogBoxInfo[26].sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +45*1 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);
		
		if (m_stDialogBoxInfo[26].sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +45*2 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55+45*1 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55+45*2 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)), 
					  m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);

		PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Creating...", 20,6,6);

		
		if ((dwTime - m_stDialogBoxInfo[26].dwT1) > 1000) {
			m_stDialogBoxInfo[26].dwT1 = dwTime;
			m_stDialogBoxInfo[26].cStr[0]++;   //  카운트 	
		}

		if (m_stDialogBoxInfo[26].cStr[0] >= 5) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_CREATEPORTION, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(26);
			PlaySound('E', 42, 0);
		}
		break;

	case 3:
		sX = m_stDialogBoxInfo[26].sX;
		sY = m_stDialogBoxInfo[26].sY;
		szX = m_stDialogBoxInfo[26].sSizeX;
		
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);

		// 제작 가능하다고 판단된 아이템의 리스트를 열거한다. 
		PutString(sX + iAdjX + 44, sY + iAdjY + 38, "Name", RGB(0,0,0));
		PutString(sX + iAdjX +171, sY + iAdjY + 38, "Max.Skill", RGB(0,0,0));
		
		iLoc = 0;
		for (i = 0; i < 13; i++)
		if (m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView] != NULL) { 
			
			ZeroMemory(cTemp, sizeof(cTemp));
			GetItemName( m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView]->m_cName, NULL, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			ZeroMemory(cTemp2, sizeof(cTemp2));
			wsprintf(cTemp2, "%d%%", m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView]->m_iMaxSkill);
			
			if ((msX >= sX + 30) && (msX <= sX + 180) && (msY >= sY + iAdjY + 55 + iLoc*15) && (msY <= sY + iAdjY + 69 + iLoc*15)) {
				// 커서에 의해 선택되어졌다. 하일라이팅한다.
				PutString(sX + 30, sY + iAdjY + 55 + iLoc*15, cTemp, RGB(255,255,255));
				PutString(sX + 190, sY + iAdjY + 55 + iLoc*15, cTemp2, RGB(255,255,255));
			}
			else {
				if (m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView]->m_bBuildEnabled == TRUE) {
					 PutString(sX + 30, sY + iAdjY + 55 + iLoc*15, cTemp, RGB(34,30,120));
					 PutString(sX + 190, sY + iAdjY + 55 + iLoc*15, cTemp2, RGB(34,30,120));
				}
				else {
					PutString(sX + 30, sY + iAdjY + 55 + iLoc*15, cTemp, RGB(45,25,25));
					PutString(sX + 190, sY + iAdjY + 55 + iLoc*15, cTemp2, RGB(45,25,25));
				}
			}
			
			iLoc++;
		}

		// 스크롤 화살표 그린다.
		if ((m_stDialogBoxInfo[26].sView >= 1) && (m_pDispBuildItemList[m_stDialogBoxInfo[26].sView - 1] != NULL)) 
			 m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + iAdjX + 225, sY + iAdjY + 210, 23, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutTransSpriteRGB(sX + iAdjX + 225, sY + iAdjY + 210, 23, 5,5,5, dwTime);

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].sView+13] != NULL) 
			 m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + iAdjX + 225, sY + iAdjY + 230, 24, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutTransSpriteRGB(sX + iAdjX + 225, sY + iAdjY + 230, 24, 5,5,5, dwTime);

		if ((cLB != 0) && (iGetTopDialogBoxIndex() == 26)) {
			if ((msX >= sX + iAdjX + 225) && (msX <= sX + iAdjX + 245) && (msY >= sY + iAdjY + 210) && (msY <= sY + iAdjY + 230)) {
				m_stDialogBoxInfo[26].sView--;
			}

			if ((msX >= sX + iAdjX + 225) && (msX <= sX + iAdjX + 245) && (msY >= sY + iAdjY + 230) && (msY <= sY + iAdjY + 250)) {
				if (m_pDispBuildItemList[m_stDialogBoxInfo[26].sView + 13] != NULL) 
					m_stDialogBoxInfo[26].sView++;
			}
		}
		if (( msZ != 0) && (iGetTopDialogBoxIndex() == 26)) {
			m_stDialogBoxInfo[26].sView = m_stDialogBoxInfo[26].sView - msZ/60;
			m_DInput.m_sZ = 0;
		}
		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].sView + 12] == NULL)
		{
			while(1)
			{
				m_stDialogBoxInfo[26].sView --;
				if( m_stDialogBoxInfo[26].sView < 1 ) break;
				if( m_pDispBuildItemList[m_stDialogBoxInfo[26].sView+12] != NULL ) break;
			}
		}
		if (m_stDialogBoxInfo[26].sView < 0) m_stDialogBoxInfo[26].sView = 0;

		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 265, DRAW_DIALOGBOX_SKILLDLG2, 55,25,25);//" 현재 스킬 수준에서 만들수 있는 아이템"
		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 280, DRAW_DIALOGBOX_SKILLDLG3, 55,25,25);//"입니다. 아이템을 제작하기 위해 필요한  "
		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 295, DRAW_DIALOGBOX_SKILLDLG4, 55,25,25);//"재료가 충분한 아이템은 파란색으로 표시"
		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 310, DRAW_DIALOGBOX_SKILLDLG5, 55,25,25);//"됩니다. "
		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 340, DRAW_DIALOGBOX_SKILLDLG6, 55,25,25);//"제작하고자 하는 아이템을 선택하세요." 
		break;

	case 4:
		sX = m_stDialogBoxInfo[26].sX;
		sY = m_stDialogBoxInfo[26].sY;
		szX = m_stDialogBoxInfo[26].sSizeX;
		iAdjX = -1;
		iAdjY = -7;
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
		// 아이템 그린다.
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
		          m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprFrame, dwTime);

		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3 );
		wsprintf(cTemp, "%s", cStr1);
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55, cTemp, RGB(255,255,255));

		wsprintf(cTemp,  DRAW_DIALOGBOX_SKILLDLG7, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSkillLimit, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iMaxSkill);
		               //"스킬 수준: %d/%d"
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55 +2*15, cTemp, RGB(45,25,25));
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55 +3*15 +5, DRAW_DIALOGBOX_SKILLDLG8, RGB(45,25,25));//"제작에 필요한 재료:"

		iLoc = 4;
		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[1] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName1, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[1] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[2] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName2, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[2] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[3] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName3, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[3] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[4] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName4, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[4] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[5] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName5, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[5] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[6] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName6, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[6] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bBuildEnabled == TRUE) {
			// 만들 수 있는 상태 

			//
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +13, sY + iAdjY +55 +180 , 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*1 +13, sY + iAdjY +55 +180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*2 +13, sY + iAdjY +55 +180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +13, sY + iAdjY +100 +180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*1 +13, sY + iAdjY +100 +180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*2 +13, sY + iAdjY +100 +180, 2, dwTime);
			
			if (m_stDialogBoxInfo[26].sV1 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
				m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +30 +13, sY + iAdjY + 55 +180, 
				m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);
			
			if (m_stDialogBoxInfo[26].sV2 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
				m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +45*1 +30 +13, sY + iAdjY + 55 +180, 
				m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);
			
			if (m_stDialogBoxInfo[26].sV3 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
				m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +45*2 +30 +13, sY + iAdjY + 55 +180, 
				m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);
			
			if (m_stDialogBoxInfo[26].sV4 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
				m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +30 +13, sY + iAdjY + 100 +180, 
				m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);
			
			if (m_stDialogBoxInfo[26].sV5 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
				m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55+45*1 +30 +13, sY + iAdjY + 100 +180, 
				m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);
			
			if (m_stDialogBoxInfo[26].sV6 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
				m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55+45*2 +30 +13, sY + iAdjY + 100 +180, 
				m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);

			//
			PutAlignedString(sX, sX + szX, sY + iAdjY + 230 +75, DRAW_DIALOGBOX_SKILLDLG15, 55,25,25);//" 위 아이템을 제작하고자 하면 재료를"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 245 +75, DRAW_DIALOGBOX_SKILLDLG16, 55,25,25);//"선택해 빈칸에 놓은 다음 Manufacture"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 260 +75, DRAW_DIALOGBOX_SKILLDLG17, 55,25,25);//"버튼을 누릅니다."
						
			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) 
				 PutString_SprFont(sX + iAdjX + 25,  sY + iAdjY + 330 +23, "Back", 6,6,20);
			else PutString_SprFont(sX + iAdjX + 25,  sY + iAdjY + 330 +23, "Back", 0,0,7);

			
			if ((msX >= sX + iAdjX + 160) && (msX <= sX + iAdjX + 255) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
				if (m_stDialogBoxInfo[26].cStr[4] == 1) 
					 PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 +23, "Manufacture", 6,6,20);
				else PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 +23, "Manufacture", 10,10,10);
			}
			else {
				if (m_stDialogBoxInfo[26].cStr[4] == 1) 
					 PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 +23, "Manufacture", 0, 0, 7);
				else PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 +23, "Manufacture", 10,10,10);
			}
		}
		else {
			PutAlignedString(sX, sX + szX, sY + iAdjY + 200 +75, DRAW_DIALOGBOX_SKILLDLG18, 55,25,25);//" 아이템을 제작하기 위해 필요한 재료가"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 215 +75, DRAW_DIALOGBOX_SKILLDLG19, 55,25,25);//"부족합니다. 부족한 아이템은 회색으로"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 230 +75, DRAW_DIALOGBOX_SKILLDLG20, 55,25,25);//"표시됩니다."
			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) 
				 PutString_SprFont(sX + iAdjX + 25,  sY + iAdjY + 330 +23, "Back", 6,6,20);
			else PutString_SprFont(sX + iAdjX + 25,  sY + iAdjY + 330 +23, "Back", 0,0,7);
		}
		break;

	case 5:
		sX = m_stDialogBoxInfo[26].sX;
		sY = m_stDialogBoxInfo[26].sY;
		iAdjX = -1;
		iAdjY = -7;

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
	
		// 아이템 그린다.
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
		          m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprFrame, dwTime);

		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3 );
		wsprintf(cTemp, "%s", cStr1);
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55, cTemp, RGB(255,255,255));

		wsprintf(cTemp,  DRAW_DIALOGBOX_SKILLDLG7, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSkillLimit, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iMaxSkill);//"스킬 수준: %d/%d"
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55 +2*15, cTemp, RGB(45,25,25));
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55 +3*15 +5, DRAW_DIALOGBOX_SKILLDLG8, RGB(45,25,25));//"제작에 필요한 재료:"

		iLoc = 4;
		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[1] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName1, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[1] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[2] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName2, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[2] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[3] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName3, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[3] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[4] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName4, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[4] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[5] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName5, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[5] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[6] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName6, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[6] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		//
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +13, sY + iAdjY +55 +180 , 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*1 +13, sY + iAdjY +55 +180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*2 +13, sY + iAdjY +55 +180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +13, sY + iAdjY +100 +180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*1 +13, sY + iAdjY +100 +180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*2 +13, sY + iAdjY +100 +180, 2, dwTime);
	
		if (m_stDialogBoxInfo[26].sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +30 +13, sY + iAdjY + 55 +180, 
					  m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +45*1 +30 +13, sY + iAdjY + 55 +180, 
					  m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);
		
		if (m_stDialogBoxInfo[26].sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +45*2 +30 +13, sY + iAdjY + 55 +180, 
					  m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +30 +13, sY + iAdjY + 100 +180, 
					  m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55+45*1 +30 +13, sY + iAdjY + 100 +180, 
					  m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + 
			          m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55+45*2 +30 +13, sY + iAdjY + 100 +180, 
					  m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);

		//

		PutString(sX + iAdjX + 33, sY + iAdjY + 230 +75, DRAW_DIALOGBOX_SKILLDLG29, RGB(55,25,25));//" 아이템을 제작 중입니다."
		PutString(sX + iAdjX + 33, sY + iAdjY + 245 +75, DRAW_DIALOGBOX_SKILLDLG30, RGB(55,25,25));//"완료될 때 까지 기다려 주십시오..."
		
		if ((dwTime - m_stDialogBoxInfo[26].dwT1) > 1000) {
			m_stDialogBoxInfo[26].dwT1 = dwTime;
			m_stDialogBoxInfo[26].cStr[1]++;   //  카운트 	
			if (m_stDialogBoxInfo[26].cStr[1] >= 7) m_stDialogBoxInfo[26].cStr[1] = 7;
		}

		if (m_stDialogBoxInfo[26].cStr[1] == 4) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_BUILDITEM, NULL, NULL, NULL, NULL, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cName);
			m_stDialogBoxInfo[26].cStr[1]++;
		}
		break;

	case 6:
		sX = m_stDialogBoxInfo[26].sX;
		sY = m_stDialogBoxInfo[26].sY;
		iAdjX = -1;
		iAdjY = -7;

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);

		// 아이템 그린다.
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
		          m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprFrame, dwTime);

		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3 );

		wsprintf(cTemp, "%s", cStr1);
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55, cTemp, RGB(255,255,255));

		if (m_stDialogBoxInfo[26].cStr[2] == 1) {
			// 아이템 제작에 성공했다.
			PutString(sX + iAdjX + 33 +11, sY + iAdjY + 200 -45, DRAW_DIALOGBOX_SKILLDLG31, RGB(55,25,25));//" 아이템 제작에 성공했습니다!"
			
			if (m_stDialogBoxInfo[26].sV1 == DEF_ITEMTYPE_MATERIAL) {
				wsprintf(G_cTxt, DRAW_DIALOGBOX_SKILLDLG32, m_stDialogBoxInfo[26].cStr[3]);//"만들어진 아이템의 순도는 %d%%입니다."
				PutString(sX + iAdjX + 33 +11, sY + iAdjY + 215 -45, G_cTxt, RGB(55,25,25));
			}
			else {
				wsprintf(G_cTxt, DRAW_DIALOGBOX_SKILLDLG33, (int)m_stDialogBoxInfo[26].cStr[3] +100);//"만들어진 아이템의 완성도는 %d%%입니다."
				PutString(sX + iAdjX + 33, sY + iAdjY + 215 -45, G_cTxt, RGB(55,25,25));
			}
		}
		else {
			// 아이템 제작에 실패했다.
			PutString(sX + iAdjX + 33+11, sY + iAdjY + 200, DRAW_DIALOGBOX_SKILLDLG34, RGB(55,25,25));//"아이템 제작에 실패했습니다!"
		}

		if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) 
			 PutString_SprFont(sX + iAdjX + 35,  sY + iAdjY + 330 +23, "Back", 6,6,20);
		else PutString_SprFont(sX + iAdjX + 35,  sY + iAdjY + 330 +23, "Back", 0,0,7);
		break;
	}
}

void CGame::DrawDialogBox_SysMenu(short msX, short msY, char cLB)
{
 short sX, sY;
	
	sX = m_stDialogBoxInfo[19].sX;
	sY = m_stDialogBoxInfo[19].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 6);

	PutString(sX + 23, sY + 63, DRAW_DIALOGBOX_SYSMENU_DETAILLEVEL, RGB(45,25,25));
	PutString(sX + 24, sY + 63, DRAW_DIALOGBOX_SYSMENU_DETAILLEVEL, RGB(45,25,25));

	if (m_cDetailLevel == 0)
		 PutString(sX + 121, sY + 63, DRAW_DIALOGBOX_SYSMENU_LOW, RGB(255,255,255));
	else PutString(sX + 121, sY + 63, DRAW_DIALOGBOX_SYSMENU_LOW, RGB(45,25,25));
	if (m_cDetailLevel == 1)
		 PutString(sX + 153, sY + 63, DRAW_DIALOGBOX_SYSMENU_NORMAL, RGB(255,255,255));
	else PutString(sX + 153, sY + 63, DRAW_DIALOGBOX_SYSMENU_NORMAL, RGB(45,25,25));
	if (m_cDetailLevel == 2)
		 PutString(sX + 205, sY + 63, DRAW_DIALOGBOX_SYSMENU_HIGH, RGB(255,255,255));
	else PutString(sX + 205, sY + 63, DRAW_DIALOGBOX_SYSMENU_HIGH, RGB(45,25,25));

	PutString(sX + 23, sY + 84, DRAW_DIALOGBOX_SYSMENU_SOUND, RGB(45,25,25));
	PutString(sX + 24, sY + 84, DRAW_DIALOGBOX_SYSMENU_SOUND, RGB(45,25,25));
	if (m_bSoundFlag) {
		if (m_bSoundStat) PutString(sX + 85, sY + 85, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
		else PutString(sX + 83, sY + 85, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));
  	}
	else PutString(sX + 68, sY + 85, DRAW_DIALOGBOX_SYSMENU_DISABLED, RGB(100,100,100));
	
	PutString(sX + 123, sY + 84, DRAW_DIALOGBOX_SYSMENU_MUSIC, RGB(45,25,25));
	PutString(sX + 124, sY + 84, DRAW_DIALOGBOX_SYSMENU_MUSIC, RGB(45,25,25));
	if (m_bSoundFlag) {
		if (m_bMusicStat) PutString(sX + 180, sY + 85, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
		else PutString(sX + 178, sY + 85, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));
  	}
	else PutString(sX + 163, sY + 85, DRAW_DIALOGBOX_SYSMENU_DISABLED, RGB(100,100,100));

	//2002.10 19 정진광 귓속말과 외치기 On Off
	PutString(sX + 23,  sY + 106, DRAW_DIALOGBOX_SYSMENU_WHISPER, RGB(45,25,25));
	PutString(sX + 24, sY + 106, DRAW_DIALOGBOX_SYSMENU_WHISPER, RGB(45,25,25));
	if (m_bWhisper) PutString(sX + 85, sY + 106, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
	else PutString(sX + 82, sY + 106, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));
  			
	PutString(sX + 123, sY + 106, DRAW_DIALOGBOX_SYSMENU_SHOUT, RGB(45,25,25));
	PutString(sX + 124, sY + 106, DRAW_DIALOGBOX_SYSMENU_SHOUT, RGB(45,25,25));
	if (m_bShout) PutString(sX + 180, sY + 106, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
	else PutString(sX + 177, sY + 106, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));
  	
	PutString(sX + 23, sY + 124, DRAW_DIALOGBOX_SYSMENU_SOUNDVOLUME, RGB(45,25,25));
	PutString(sX + 24, sY + 124, DRAW_DIALOGBOX_SYSMENU_SOUNDVOLUME, RGB(45,25,25));
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX + 130 + m_cSoundVolume, sY + 129, 8);

	PutString(sX + 23, sY + 141, DRAW_DIALOGBOX_SYSMENU_MUSICVOLUME, RGB(45,25,25));
	PutString(sX + 24, sY + 141, DRAW_DIALOGBOX_SYSMENU_MUSICVOLUME, RGB(45,25,25));
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX + 130 + m_cMusicVolume, sY + 145, 8);

	PutString(sX + 23, sY + 158, DRAW_DIALOGBOX_SYSMENU_TRANSPARENCY, RGB(45,25,25));
	PutString(sX + 24, sY + 158, DRAW_DIALOGBOX_SYSMENU_TRANSPARENCY, RGB(45,25,25));
	if (m_bDialogTrans) PutString(sX + 208, sY + 158, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
	else PutString(sX + 207, sY + 158, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));

	PutString(sX + 23, sY + 180, DRAW_DIALOGBOX_SYSMENU_GUIDEMAP, RGB(45,25,25));
	PutString(sX + 24, sY + 180, DRAW_DIALOGBOX_SYSMENU_GUIDEMAP, RGB(45,25,25));
	if (m_bIsDialogEnabled[9]) PutString(sX + 208, sY + 180, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
	else PutString(sX + 207, sY + 180, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));

	//v2.17 2002-07-24 by 안상하
	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
#if DEF_LANGUAGE == 3
	wsprintf(G_cTxt, "%d월 %d일 %d시 %d분 %d초", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
#else
	wsprintf(G_cTxt, "%d:%d:%d:%d:%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
#endif
	PutString(sX + 23, sY + 204, G_cTxt, RGB(45,25,25));
	PutString(sX + 24, sY + 204, G_cTxt, RGB(45,25,25));

//v2.172
#ifdef DEF_TESTSERVER
	PutString(sX + 23, sY + 46, UPDATE_SCREEN_ON_SELECT_CHARACTER36, RGB(45,25,25));
	PutString(sX + 24, sY + 46, UPDATE_SCREEN_ON_SELECT_CHARACTER36, RGB(45,25,25));
#else

	#ifndef DEF_FUCK_USA
	if (strcmp(m_cWorldServerName, "WS1") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME1, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME1, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS2") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME2, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME2, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS3") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME3, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME3, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS4") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME4, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME4, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS5") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME5, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME5, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS6") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME6, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME6, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS7") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME7, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME7, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS8") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME8, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME8, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS9") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME9, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME9, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS10") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME10, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME10, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS11") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME11, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME11, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS12") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME12, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME12, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS13") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME13, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME13, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS14") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME14, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME14, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS15") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME15, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME15, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS16") == 0) {
		PutString(sX + 23, sY + 46, MSG_WORLDNAME16, RGB(45,25,25));
		PutString(sX + 24, sY + 46, MSG_WORLDNAME16, RGB(45,25,25));
	}
	#endif

#endif

	if ( (cLB != 0) && (iGetTopDialogBoxIndex() == 19) ) {
		//  (msX >= sX + 120) && (msX <= sX + 242) && (msY >= sY +122) && (msY <= sY +138)
		if ((msX >= sX + 127) && (msX <= sX + 238) && (msY >= sY +122) && (msY <= sY +138)) {
			m_cSoundVolume = msX - (sX + 127);
			if( m_cSoundVolume > 100 ) m_cSoundVolume = 100;
			if( m_cSoundVolume < 0 ) m_cSoundVolume = 0;
		}
		if ((msX >= sX + 127) && (msX <= sX + 238) && (msY >= sY +139) && (msY <= sY +155)) {
			m_cMusicVolume = msX - (sX + 127);
			if( m_cMusicVolume > 100 ) m_cMusicVolume = 100;
			if( m_cMusicVolume < 0 ) m_cMusicVolume = 0;
			if (m_bSoundFlag) {
				int iVol;
				iVol = (m_cMusicVolume - 100)*20;   
				if (iVol > 0) iVol = 0;
				if (iVol < -10000) iVol = -10000;

				if (m_pBGM != NULL) {
					m_pBGM->bStop(TRUE);
					m_pBGM->Play(FALSE, 0, iVol); 
				}
			}
		}
	}
	else m_stDialogBoxInfo[19].bIsScrollSelected = FALSE;

	// Log-Out
	if (m_cLogOutCount == -1) {
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +225, 9);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +225, 8);
	}
	else { //Continue
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +225, 7);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +225, 6);
	}
	// Restart
	if ((m_iHP <= 0) && (m_cRestartCount == -1)) {
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY +225, 37);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY +225, 36);
	}
}

//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

void CGame::bItemDrop_Character()
{
	ItemEquipHandler((char)m_stMCursor.sSelectedObjectID);
}

void CGame::bItemDrop_Inventory(short msX, short msY)
{
 short sX, sY, dX, dY;
 char  cTxt[120];
	
	// 명령이 유효하지 않은 상태라면(죽었다거나) 명령을 수행할 수 없다.
	if (m_cCommand < 0) return;
	if (m_pItemList[m_stMCursor.sSelectedObjectID] == NULL) return;

	if ((m_bSkillUsingStatus == TRUE) && (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == TRUE)) {
		AddEventList(BITEMDROP_INVENTORY1, 10);//"기술 사용중에는 장착된 아이템을 해제할 수 없습니다."
		return;
	}

	// 비활성화 된 아이템은 떨어뜨릴 수 없다. 
	if (m_bIsItemDisabled[m_stMCursor.sSelectedObjectID] == TRUE) return;

	// 인벤토리 내에서의 아이템의 위치를 바꾼다.

	sY = m_stDialogBoxInfo[2].sY;
	sX = m_stDialogBoxInfo[2].sX;

	dX = msX - sX - 32 - m_stMCursor.sDistX;
	dY = msY - sY - 44 - m_stMCursor.sDistY;

	// v1.4
	if (dY < -10) dY = -10;
	if (dX < 0)   dX = 0;
	if (dX > 170) dX = 170;
	if (dY > 95) dY = 95;

	m_pItemList[m_stMCursor.sSelectedObjectID]->m_sX = dX;
	m_pItemList[m_stMCursor.sSelectedObjectID]->m_sY = dY;

	short sTmpSpr, sTmpSprFrm;
	sTmpSpr = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite;
	sTmpSprFrm = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame;
/*	
	//안상하씨 코드.. 가방 정리 하는 부분..
	if( m_bShiftPressed && (sTmpSpr == 6) && (sTmpSprFrm > 0) && (sTmpSprFrm <= 6) && (sTmpSprFrm != 5) )
	{
		for( int i=0 ; i<DEF_MAXITEMS ; i++ )
		{
			if( m_pItemList[i] == NULL ) continue;
			if( (m_pItemList[i]->m_sSprite == sTmpSpr) && (m_pItemList[i]->m_sSpriteFrame == sTmpSprFrm) )
			{
				m_pItemList[i]->m_sX = dX;
				m_pItemList[i]->m_sY = dY;
				bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, i, dX, dY, NULL, NULL);
			}
		}
	}
	else bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, m_stMCursor.sSelectedObjectID, dX, dY, NULL, NULL);//위치를 기억시킨다. 
*/

	//정진광 수정, 가방정리.. 수량개념 없는 모든 아이템에 적용해보기 위해..
	char cItemID; // 정진광 추가...
	if (m_bShiftPressed) // 쉬프트 키가 눌린 상태에서 라면...
	{
        for (int i = 0; i < DEF_MAXITEMS; i++)
		{
		 if (m_cItemOrder[DEF_MAXITEMS - 1 - i] != -1) // White if
		 {
		   cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];
		   //Blue if
		   if (m_pItemList[cItemID] != NULL && memcmp(m_pItemList[cItemID]->m_cName, m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, 20) == 0 )
		   {
			   m_pItemList[cItemID]->m_sX = dX;
			   m_pItemList[cItemID]->m_sY = dY;
			   bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, cItemID, dX, dY, NULL, NULL); 
           } // Close Blue if
		 } // Close White if
		} // Close for loop
    }//Close 쉬프트 눌린 상태 if
	else
	 bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, (char)(m_stMCursor.sSelectedObjectID), dX, dY, NULL, NULL); 
//정진광 수정, 여기까지...

	// 만약 이 아이템이 장착되어 있다면 
	if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == TRUE) {
		
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
		
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"아이템 %s: 장착 해제 되었습니다."
		AddEventList(cTxt, 10);
		
		PlaySound('E', 29, 0);

		// 아이템 장착 해제 메시지를 서버로 전송한다.
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_RELEASEITEM, NULL, m_stMCursor.sSelectedObjectID, NULL, NULL, NULL);
		// 장착위치에서 해제시킨다.
		m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = FALSE;
		m_sItemEquipmentStatus[	m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos ] = -1;
	}
}

void CGame::bItemDrop_SellList(short msX, short msY)
{
 int i;
 char cItemID;

	cItemID = (char)m_stMCursor.sSelectedObjectID;

	if (m_pItemList[cItemID] == NULL) return;
	if (m_bIsItemDisabled[cItemID] == TRUE) return;
	// 명령이 유효하지 않은 상태라면(죽었다거나) 명령을 수행할 수 없다.
	if (m_cCommand < 0) return;
	
	// 이미 팔고자 하는 아이템 리스트에 있음 무시 
	for (i = 0; i < DEF_MAXSELLLIST; i++)
	if (m_stSellItemList[i].iIndex == cItemID) {
		AddEventList(BITEMDROP_SELLLIST1, 10);//"팔고자 하는 아이템이 이미 리스트에 등록되어 있습니다."
		return;
	}
	if (strcmp(m_pItemList[cItemID]->m_cName, "Gold") == 0) {
		AddEventList(BITEMDROP_SELLLIST2, 10);//"Gold는 팔 수 없습니다."
		return;
	}
	if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
	{
		ZeroMemory( G_cTxt, sizeof(G_cTxt) );
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
		wsprintf( G_cTxt, NOTIFYMSG_CANNOT_SELL_ITEM2, cStr1 );
		AddEventList( G_cTxt, 10 );
		return;
	}

	// 만약 소비성 아이템이라면 수량을 묻는다.
	if ( ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) && 
		 (m_pItemList[cItemID]->m_dwCount > 1) ) {
		
		m_stDialogBoxInfo[17].sX  = msX - 140;
		m_stDialogBoxInfo[17].sY  = msY - 70;
		if (m_stDialogBoxInfo[17].sY < 0) m_stDialogBoxInfo[17].sY = 0;
					
		m_stDialogBoxInfo[17].sV1 = m_sPlayerX+1; // !!! 거리가 멀다는 메시지를 뜨지 않게 하기 위함이다.
		m_stDialogBoxInfo[17].sV2 = m_sPlayerY+1;
		// NPC 종류: 1001이면 SellList창 아이템 드롭이다.
		m_stDialogBoxInfo[17].sV3 = 1001;
		m_stDialogBoxInfo[17].sV4 = cItemID;
	
		ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
		EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);

		// 수량 선택 창 뜨는 순간 비활성화
		m_bIsItemDisabled[cItemID] = TRUE;
	}
	else {
		// 팔 아이템을 드래그 해서 놓았다.
		for (i = 0; i < DEF_MAXSELLLIST; i++)
		if (m_stSellItemList[i].iIndex == -1) {
			m_stSellItemList[i].iIndex = cItemID;	// 아이디 설정 
			m_stSellItemList[i].iAmount = 1;		// 갯수 설정
			m_bIsItemDisabled[cItemID] = TRUE;		// 아이템 비활성화
			return;
		}

		// 더이상 놓을 공간이 없다.
		AddEventList(BITEMDROP_SELLLIST3, 10);//"12개 이상의 아이템을 동시에 팔 수는 없습니다."
	}
}

void CGame::bItemDrop_ItemUpgrade()
{
 char cItemID;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_bIsItemDisabled[cItemID] == TRUE) return;
	// 명령이 유효하지 않은 상태라면(죽었다거나) 명령을 수행할 수 없다.
	if (m_cCommand < 0) return;
	if (m_pItemList[cItemID]->m_cEquipPos == DEF_EQUIPPOS_NONE) return;
	
	switch (m_stDialogBoxInfo[34].cMode) {
	case 1:
		m_bIsItemDisabled[m_stDialogBoxInfo[34].sV1] = FALSE;
		m_stDialogBoxInfo[34].sV1 = cItemID;
		m_bIsItemDisabled[cItemID] = TRUE;
		PlaySound('E', 29, 0);
		break;

	case 6:
		m_bIsItemDisabled[m_stDialogBoxInfo[34].sV1] = FALSE;
		m_stDialogBoxInfo[34].sV1 = cItemID;
		m_bIsItemDisabled[cItemID] = TRUE;
		PlaySound('E', 29, 0);
		break;
	}
}

void CGame::bItemDrop_Bank(short msX, short msY)
{
	m_stDialogBoxInfo[39].sV1 = m_stMCursor.sSelectedObjectID;
	// 명령이 유효하지 않은 상태라면(죽었다거나) 명령을 수행할 수 없다.
	if (m_cCommand < 0) return;
	// 존재하지 않는 아이템이라면 리턴.
	if (m_pItemList[m_stDialogBoxInfo[39].sV1] == NULL) return;
	// 비활성화 된 아이템은 창고에 맡길 수 없다. 
	if (m_bIsItemDisabled[m_stDialogBoxInfo[39].sV1] == TRUE) return;
	if ( m_bIsDialogEnabled[17] == TRUE ) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);//"현재 아이템 관련 처리가 끝나지 않았습니다."
		return;
	}
	if ( (m_bIsDialogEnabled[20] == TRUE) && ((m_stDialogBoxInfo[20].cMode == 1) || (m_stDialogBoxInfo[20].cMode == 2)) ) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);//"현재 아이템 관련 처리가 끝나지 않았습니다."
		return;
	}
	if (m_bIsDialogEnabled[23] == TRUE) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);//"현재 아이템 관련 처리가 끝나지 않았습니다."
		return;
	}

	if (m_bIsDialogEnabled[4] == TRUE) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);//"현재 아이템 관련 처리가 끝나지 않았습니다."
		return;
	}


	if ( ((m_pItemList[m_stDialogBoxInfo[39].sV1]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[m_stDialogBoxInfo[39].sV1]->m_cItemType == DEF_ITEMTYPE_ARROW)) && (m_pItemList[m_stDialogBoxInfo[39].sV1]->m_dwCount > 1) )
	{
		// 소비하는 아이템을 다른 캐릭터에게 전달한다. 
		m_stDialogBoxInfo[17].sX  = msX - 140;
		m_stDialogBoxInfo[17].sY  = msY - 70;
		if (m_stDialogBoxInfo[17].sY < 0) m_stDialogBoxInfo[17].sY = 0;
					
		m_stDialogBoxInfo[17].sV1 = m_sPlayerX+1; // !!! 거리가 멀다는 메시지를 뜨지 않게 하기 위함이다.
		m_stDialogBoxInfo[17].sV2 = m_sPlayerY+1;
		m_stDialogBoxInfo[17].sV3 = 1002;// NPC 종류: 1002이면 창고 아이템 드롭이다.
		m_stDialogBoxInfo[17].sV4 = m_stDialogBoxInfo[39].sV1;

		ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
		EnableDialogBox(17, m_stDialogBoxInfo[39].sV1, m_pItemList[m_stDialogBoxInfo[39].sV1]->m_dwCount, NULL);
	}
	else
	{
		if (_iGetBankItemCount() >= (DEF_MAXBANKITEMS-1)) AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);//"아이템을 더 맡길 공간이 없습니다."
		else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_stDialogBoxInfo[39].sV1, 1, m_stDialogBoxInfo[39].sV5, m_stDialogBoxInfo[39].sV6, m_pItemList[m_stDialogBoxInfo[39].sV1]->m_cName, m_stDialogBoxInfo[39].sV4); //v1.4
	}
}

void CGame::bItemDrop_SkillDialog()
{
 int iConsumeNum;	
 char cItemID;

	// 명령이 유효하지 않은 상태라면(죽었다거나) 명령을 수행할 수 없다.
	if (m_cCommand < 0) return;

	// v1.4
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	// 존재하지 않는 아이템이라면 리턴.
	if (m_pItemList[cItemID] == NULL) return;

	// 비활성화 된 아이템은 떨어뜨릴 수 없다. 
	if (m_bIsItemDisabled[cItemID] == TRUE) return;

	// 아이템 판매 다이얼로그 활성화 되어 있다면 버릴 수 없다. 
	if ( m_bIsDialogEnabled[17] == TRUE ) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);//"현재 아이템 관련 처리가 끝나지 않았습니다."
		return;
	}

	if ( (m_bIsDialogEnabled[20] == TRUE) && 
		 ((m_stDialogBoxInfo[20].cMode == 1) || (m_stDialogBoxInfo[20].cMode == 2)) ) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);//"현재 아이템 관련 처리가 끝나지 않았습니다."
		return;
	}

	if (m_bIsDialogEnabled[23] == TRUE) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);//"현재 아이템 관련 처리가 끝나지 않았습니다."
		return;
	}

	switch (m_stDialogBoxInfo[26].cMode) {
	case 1:
		if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) {
			iConsumeNum = 0;
			if (m_stDialogBoxInfo[26].sV1 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV2 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV3 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV4 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV5 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV6 == cItemID) iConsumeNum++;
			if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
		}

		if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) || 
			(m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_NONE)) {

		}
		else return;
		
		// 조건을 만족한다면 빈 자리에 놓는다. 
		if (m_stDialogBoxInfo[26].sV1 == -1) {
			m_stDialogBoxInfo[26].sV1 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV2 == -1) {
			m_stDialogBoxInfo[26].sV2 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV3 == -1) {
			m_stDialogBoxInfo[26].sV3 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV4 == -1) {
			m_stDialogBoxInfo[26].sV4 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV5 == -1) {
			m_stDialogBoxInfo[26].sV5 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV6 == -1) {
			m_stDialogBoxInfo[26].sV6 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		// 빈 슬롯이 없다. 
		AddEventList(BITEMDROP_SKILLDIALOG4, 10);//"더이상 재료를 놓을 공간이 없습니다."
		break;

	case 4:
		// 무기/아이템 제작 창 
		if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) {
			iConsumeNum = 0;
			if (m_stDialogBoxInfo[26].sV1 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV2 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV3 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV4 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV5 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV6 == cItemID) iConsumeNum++;
			if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
		}
		
		// 조건을 만족한다면 빈 자리에 놓는다. 
		if (m_stDialogBoxInfo[26].sV1 == -1) {
			m_stDialogBoxInfo[26].sV1 = cItemID;
			// 아이템 제작 조건이 만족되는지 검사 
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV2 == -1) {
			m_stDialogBoxInfo[26].sV2 = cItemID;
			// 아이템 제작 조건이 만족되는지 검사 
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV3 == -1) {
			m_stDialogBoxInfo[26].sV3 = cItemID;
			// 아이템 제작 조건이 만족되는지 검사 
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV4 == -1) {
			m_stDialogBoxInfo[26].sV4 = cItemID;
			// 아이템 제작 조건이 만족되는지 검사 
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV5 == -1) {
			m_stDialogBoxInfo[26].sV5 = cItemID;
			// 아이템 제작 조건이 만족되는지 검사 
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		else if (m_stDialogBoxInfo[26].sV6 == -1) {
			m_stDialogBoxInfo[26].sV6 = cItemID;
			// 아이템 제작 조건이 만족되는지 검사 
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) {
				// v1.4 소모성 아이템의 경우 1개가 남아있지 않는 한 Disable 시켜서는 안된다.
			}
			else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		// 빈 슬롯이 없다. 
		AddEventList(BITEMDROP_SKILLDIALOG4, 10);//"더이상 재료를 놓을 공간이 없습니다."
		break;

	default:
		break;
	}
}

void CGame::DlgBoxClick_Bank(short msX, short msY)
{
 int i;
 short sX, sY;

 
	sX = m_stDialogBoxInfo[14].sX;
	sY = m_stDialogBoxInfo[14].sY;
		
	switch ( m_stDialogBoxInfo[14].cMode ) {
	case -1:
		// 처리중인 상태. 다이얼로그를 닫을 수 없다.
		break;

	case 0:
		for (i = 0; i < m_stDialogBoxInfo[14].sV1; i++) 
		if ((msX > sX + 30) && (msX < sX + 210) && (msY >= sY + 110 + i*15) && (msY <= sY + 124 + i*15)) {	
			if ((m_pBankList[m_stDialogBoxInfo[14].sView + i] != NULL) && ((m_stDialogBoxInfo[14].sView + i) < DEF_MAXBANKITEMS)) {
				// 클릭되는 순간 아이템을 되찾는다.
				if (_iGetTotalItemNum() >= 50) {
					AddEventList(DLGBOX_CLICK_BANK1, 10);//"현재 소지할 수 있는 아이템 갯수가 남아있지 않아 되찾을 수 없습니다."
					return;
				}
				bSendCommand(MSGID_REQUEST_RETRIEVEITEM, NULL, NULL, (m_stDialogBoxInfo[14].sView + i), NULL, NULL, NULL); 
				m_stDialogBoxInfo[14].cMode = -1;
				PlaySound('E', 14, 5);
			}				
			return;
		}
	
		break;
	}
}

void CGame::DlgBoxClick_Fish(short msX, short msY)
{
 short sX, sY;
	
	sX = m_stDialogBoxInfo[24].sX;
	sY = m_stDialogBoxInfo[24].sY;

	switch (m_stDialogBoxInfo[24].cMode) {
	case 0:
		if ((msX >= sX + 160) && (msX <= sX + 253) && (msY >= sY + 70) && (msY <= sY + 90)) {
			// 낚시 버튼 눌렸다! 
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETFISHTHISTIME, NULL, NULL, NULL, NULL, NULL);
			AddEventList(DLGBOX_CLICK_FISH1, 10);
			             //"낚시를 시도합니다! 과연 잡을수 있을지...??!!!"
			DisableDialogBox(24);

			PlaySound('E', 14, 5);
		}
		break;
	}
}

void CGame::DlgBoxClick_Magic(short msX, short msY)
{
 int i, iCPivot, iYloc;
 short sX, sY;

	sX = m_stDialogBoxInfo[3].sX;   
	sY = m_stDialogBoxInfo[3].sY;   
  
	// 보고있는 마법의 Circle기준점 
	iCPivot = m_stDialogBoxInfo[3].sView*10;
	iYloc = 0;

	for (i = 0; i < 9; i++)
	{
		if ((m_cMagicMastery[iCPivot + i] != NULL) && (m_pMagicCfgList[iCPivot + i] != NULL))
		{			
			if ((msX >= sX + 30) && (msX <= sX + 240) && (msY >= sY + 70 + iYloc) && (msY <= sY + 70 + 18 + iYloc))
			{
				UseMagic(iCPivot + i);
				PlaySound('E', 14, 5);
		 		return;
			}
			iYloc += 18;
		}
	}

	if ((msX >= sX + 16) && (msX <= sX + 38) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 0;
	if ((msX >= sX + 39) && (msX <= sX + 56) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 1;
	if ((msX >= sX + 57) && (msX <= sX + 81) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 2;
	if ((msX >= sX + 82) && (msX <= sX + 101) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 3;
	if ((msX >= sX + 102) && (msX <= sX + 116) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 4;
	if ((msX >= sX + 117) && (msX <= sX + 137) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 5;
	if ((msX >= sX + 138) && (msX <= sX + 165) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 6;
	if ((msX >= sX + 166) && (msX <= sX + 197) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 7;
	if ((msX >= sX + 198) && (msX <= sX + 217) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 8;
	if ((msX >= sX + 218) && (msX <= sX + 239) && (msY >= sY + 240) && (msY <= sY + 268)) 
		m_stDialogBoxInfo[3].sView = 9;

	// v2.15
	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 285) && (msY <= sY + 285 + DEF_BTNSZY)) {
		// 연금술 
		if (m_cSkillMastery[12] == 0) AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY16, 10);//"연금술을 쓰려면 연금술을 배워야 합니다. 상점에서 연금술 교본을 구입해 사용하세요."
		else {
			// 연금술 그릇을 갖고 있는지 검색, 있으면 인터페이스 연다. 
			for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pItemList[i] != NULL) && (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) && 
				(m_pItemList[i]->m_sSpriteFrame == 55)) {
				// 연금술 그릇  아이템 발견 
				EnableDialogBox(26, 1, NULL, NULL, NULL);
				AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY10, 10);//"연금술을 사용합니다..."
				PlaySound('E', 14, 5);
				return;
			}
			AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY15, 10);//"연금술을 쓰려면 연금술 그릇을 소지하고 있어야 합니다. 상점에서 구입하세요."
		}
		PlaySound('E', 14, 5);
	}
}

void CGame::DlgBoxClick_NpcActionQuery(short msX, short msY)
{
 short sX, sY;
 int   absX, absY;

  //2002. 10. 31 정진광 교환창 이용한 사기 방지용..
  if (m_bIsDialogEnabled[27] == TRUE) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);//"현재 아이템 관련 처리가 끝나지 않았습니다."
		return;
  }
 	
	sX = m_stDialogBoxInfo[20].sX;
	sY = m_stDialogBoxInfo[20].sY;

	switch (m_stDialogBoxInfo[20].cMode) {
	case 0:
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			// 거래 한다.
			EnableDialogBox(m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV2, NULL, NULL);
			DisableDialogBox(20);
		}

		if ((m_bIsDialogEnabled[21] == FALSE) && (msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70)) {
			// 대화한다. 서버로 대화 메시지를 요청한다.
			switch (m_stDialogBoxInfo[20].sV1) {
			case 7:
				// Guild
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 1, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_GUILDHALL_OFFICER, 10);//"길드 사무장에게 말을 걸고 있습니다..."
				break;

			case 11:
				// 
				switch (m_stDialogBoxInfo[20].sV2) {
				case 1:
					// 상점
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 2, NULL, NULL, NULL); 
					AddEventList(TALKING_TO_SHOP_KEEPER, 10);//"상점 주인에게 말을 걸고 있습니다..."
					break;
				case 2:
					// 무기상점
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 3, NULL, NULL, NULL); 
					AddEventList(TALKING_TO_BLACKSMITH_KEEPER, 10);//"대장간 주인에게 말을 걸고 있습니다..."
					break;
				}
				break;

			case 13:
				// 시청 
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 4, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_CITYHALL_OFFICER, 10);//"시청 행정관에게 말을 걸고 있습니다..."
				break;

			case 14:
				// 은행 
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 5, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_WAREHOUSE_KEEPER, 10);//"창고 주인에게 말을 걸고 있습니다..."
				break;

			case 16:
				// 마법사 타워  
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 6, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_MAGICIAN, 10);//"마법사에게 말을 걸고 있습니다..."
				break;
			}

			// NPC-Query 창을 닫는다.
			DisableDialogBox(20);
		}
		break;
	
	case 1:
		// 그냥 준다 / 교환한다 
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			// 그냥 준다
			absX = abs(m_stDialogBoxInfo[20].sV5 - m_sPlayerX);
			absY = abs(m_stDialogBoxInfo[20].sV6 - m_sPlayerY);

			if ((absX <= 4) && (absY <= 4))
				 bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV3, m_stDialogBoxInfo[20].sV5, m_stDialogBoxInfo[20].sV6, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); //v1.4
			else AddEventList(DLGBOX_CLICK_NPCACTION_QUERY7, 10);//"아이템을 전달하기에는 거리가 너무 멉니다."
			DisableDialogBox(20);
		}
		else 
		if ((msX > sX + 155) && (msX < sX + 210) && (msY > sY + 55) && (msY < sY + 70)) {
			// 교환 한다 	
			absX = abs(m_stDialogBoxInfo[20].sV5 - m_sPlayerX);
			absY = abs(m_stDialogBoxInfo[20].sV6 - m_sPlayerY);

			if ((absX <= 4) && (absY <= 4))
				 bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_EXCHANGEITEMTOCHAR, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV3, m_stDialogBoxInfo[20].sV5, m_stDialogBoxInfo[20].sV6, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); //v1.4
			else AddEventList(DLGBOX_CLICK_NPCACTION_QUERY8, 10);//"아이템을 교환하기에는 거리가 너무 멉니다."
			DisableDialogBox(20);
		}
		break;

	case 2:
		// 판다 / 수리한다 
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			// 판다
			// m_stDialogBoxInfo[20].sV1 : Item ID 아이디와 아이템 이름을 같이 날린다. 이 아이템과 관련된 
			// 어떠한 액션도 처리도중에는 할 수 없다.
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_SELLITEM, NULL, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV2, m_stDialogBoxInfo[20].sV3, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); // v1.4
			DisableDialogBox(20);
		}
		else 
		if ((msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70)) {
			// 수리한다 	
			// m_stDialogBoxInfo[20].sV1 : Item ID 아이디와 아이템 이름을 같이 날린다. 이 아이템과 관련된 
			// 어떠한 액션도 처리도중에는 할 수 없다.
			if (m_stDialogBoxInfo[20].sV3 == 1) {
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, NULL, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV2, NULL, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); // v1.4
				DisableDialogBox(20);
			}
		}
		break;

	case 3:
		if ((msX > sX + 25) && (msX < sX + 105) && (msY > sY + 55) && (msY < sY + 70)) {
			// 창고 주인에게 보관한다. 준다는 메시지를 전송하면 된다. 
			absX = abs(m_stDialogBoxInfo[20].sV5 - m_sPlayerX);
			absY = abs(m_stDialogBoxInfo[20].sV6 - m_sPlayerY);
			
			// v1.4334 창고 에 맡기는 거리가 늘어 난다. 
			if ((absX <= 8) && (absY <= 8)) {
				// v1.41 클라이언트 상에서 아이템을 더 맡길 수 있는 상태인지 판단한다. 
				if (_iGetBankItemCount() >= (DEF_MAXBANKITEMS-1)) {
					// 더이상 맡길 공간이 없다. 
					AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);//"아이템을 더 맡길 공간이 없습니다."
				}
				else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV3, m_stDialogBoxInfo[20].sV5, m_stDialogBoxInfo[20].sV6, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); //v1.4
			}
			else AddEventList(DLGBOX_CLICK_NPCACTION_QUERY7, 10);//"아이템을 전달하기에는 거리가 너무 멉니다."

			DisableDialogBox(20);
		}
		break;

	case 4: // Unicorn 등 특수 몹과의 대화 
		if ((m_bIsDialogEnabled[21] == FALSE) && (msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70)) {
			// 대화한다. 서버로 대화 메시지를 요청한다.
			switch (m_stDialogBoxInfo[20].sV3) {
			case 21:
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 21, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_GUARD, 10);//"경비병에게 말을 걸고 있습니다..."
				break;
			
			case 32:
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 32, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_UNICORN, 10);//"유니콘에게 말을 걸고 있습니다..."
				break;

				//	NPC 추가...20021221..
			case 67:
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 67, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_MCGAFFIN, 10);//"마을청년에게 말을 걸고 있습니다..."
				break;
			case 68:
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 68, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_PERRY, 10);//"마을처녀에게 말을 걸고 있습니다..."
				break;
			case 69:
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 69, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_DEVLIN, 10);//"마을마법사에게 말을 걸고 있습니다..."
				break;
			}
		}

		// NPC-Query 창을 닫는다.
		DisableDialogBox(20);
		break;


	case 5:
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			// 거래 한다.
			EnableDialogBox(m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV2, NULL, NULL);
			DisableDialogBox(20);
		}

		if ((msX > sX + 25 +75) && (msX < sX + 80 +75) && (msY > sY + 55) && (msY < sY + 70)) {
			// 판다(물량으로)
			EnableDialogBox(31, NULL, NULL, NULL);
			DisableDialogBox(20);
		}

		if ((m_bIsDialogEnabled[21] == FALSE) && (msX > sX + 155) && (msX < sX + 210) && (msY > sY + 55) && (msY < sY + 70)) {
			// 대화한다. 서버로 대화 메시지를 요청한다.
			switch (m_stDialogBoxInfo[20].sV1) {
			case 7:
				// Guild
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 1, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_GUILDHALL_OFFICER, 10);//"길드 사무장에게 말을 걸고 있습니다..."
				break;

			case 11:
				// 
				switch (m_stDialogBoxInfo[20].sV2) {
				case 1:
					// 상점
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 2, NULL, NULL, NULL); 
					AddEventList(TALKING_TO_SHOP_KEEPER, 10);//"상점 주인에게 말을 걸고 있습니다..."
					break;
				case 2:
					// 무기상점
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 3, NULL, NULL, NULL); 
					AddEventList(TALKING_TO_BLACKSMITH_KEEPER, 10);//"대장간 주인에게 말을 걸고 있습니다..."
					break;
				}
				break;

			case 13:
				// 시청 
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 4, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_CITYHALL_OFFICER, 10);//"시청 행정관에게 말을 걸고 있습니다..."
				break;

			case 14:
				// 은행 
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 5, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_WAREHOUSE_KEEPER, 10);//"창고 주인에게 말을 걸고 있습니다..."
				break;

			case 16:
				// 마법사 타워  
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 6, NULL, NULL, NULL); 
				AddEventList(TALKING_TO_MAGICIAN, 10);//"마법사에게 말을 걸고 있습니다..."
				break;
			}

			// NPC-Query 창을 닫는다.
			DisableDialogBox(20);
		}
		break;
	}
}


void CGame::DlgBoxClick_Shop(short msX, short msY)
{
 int i;
 short sX, sY;
 char cTemp[21];


	sX = m_stDialogBoxInfo[11].sX;
	sY = m_stDialogBoxInfo[11].sY;
   	
	switch ( m_stDialogBoxInfo[11].cMode ) {
	case 0:
		for (i = 0; i < 13; i++) 
		if ((msX >= sX + 20) && (msX <= sX + 220) && (msY >= sY + i*18 + 65) && (msY <= sY + i*18 + 79)) {
			if (_iGetTotalItemNum() >= 50) {
				AddEventList(DLGBOX_CLICK_SHOP1, 10);//"현재 소지할 수 있는 아이템 갯수가 남아있지 않아 구입할 수 없습니다."
				return;
			}

			PlaySound('E', 14, 5);
			if (m_pItemForSaleList[m_stDialogBoxInfo[11].sView + i] != NULL) 
				m_stDialogBoxInfo[11].cMode = m_stDialogBoxInfo[11].sView + i + 1;	
			return;
		}
		break;

	default:
		// 아이템 구입 확인 화면
		if ((msX >= sX + 145) && (msX <= sX + 162) && (msY >= sY + 209) && (msY <= sY + 230)) {
			// 십자리 +
			m_stDialogBoxInfo[11].sV3 += 10;
			if (m_stDialogBoxInfo[11].sV3 >= (50 - _iGetTotalItemNum())) 
				m_stDialogBoxInfo[11].sV3 = (50 - _iGetTotalItemNum());
		}
		
		if ((msX >= sX + 145) && (msX <= sX + 162) && (msY >= sY + 234) && (msY <= sY + 251)) {
			// 십자리 -
			m_stDialogBoxInfo[11].sV3 -= 10;
			if (m_stDialogBoxInfo[11].sV3 <= 1) 
				m_stDialogBoxInfo[11].sV3 = 1;
		}

		if ((msX >= sX + 163) && (msX <= sX + 180) && (msY >= sY + 209) && (msY <= sY + 230)) {
			// 단자리 +
			m_stDialogBoxInfo[11].sV3++;
			if (m_stDialogBoxInfo[11].sV3 >= (50 - _iGetTotalItemNum())) 
				m_stDialogBoxInfo[11].sV3 = (50 - _iGetTotalItemNum());
		}
		
		if ((msX >= sX + 163) && (msX <= sX + 180) && (msY >= sY + 234) && (msY <= sY + 251)) {
			// 단자리 -
			m_stDialogBoxInfo[11].sV3--;
			if (m_stDialogBoxInfo[11].sV3 <= 1) 
				m_stDialogBoxInfo[11].sV3 = 1;
		}
			
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Purchase버튼 Click되었다. 아이템 구입명령을 전송한다.
			if ((50 - _iGetTotalItemNum()) < m_stDialogBoxInfo[11].sV3) {
				// 전송하기 전에 현재 소지하고 있는 갯수를 재 확인한다.
				AddEventList(DLGBOX_CLICK_SHOP1, 10);//"현재 소지할 수 있는 아이템 갯수가 남아있지 않아 구입할 수 없습니다."
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				strcpy(cTemp, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cName);
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_PURCHASEITEM, NULL, m_stDialogBoxInfo[11].sV3, NULL, NULL, cTemp); 
			}
			m_stDialogBoxInfo[11].cMode = 0;
			m_stDialogBoxInfo[11].sV3   = 1;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel버튼 Click되었다
			m_stDialogBoxInfo[11].cMode = 0;
			m_stDialogBoxInfo[11].sV3   = 1;
			PlaySound('E', 14, 5);
		}
		break;
	}
}

void CGame::DlgBoxClick_Skill(short msX, short msY)
{
 int i;
 short sX, sY;


	sX = m_stDialogBoxInfo[15].sX;
	sY = m_stDialogBoxInfo[15].sY;

	switch ( m_stDialogBoxInfo[15].cMode ) {
	case -1:
		// 처리중인 상태. 다이얼로그를 닫을 수 없다.
		break;

	case 0:
		for (i = 0; i < 17; i++)	 									  
		if ((i < DEF_MAXSKILLTYPE) && (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView] != NULL)) {
				
			if ((msX >= sX + 44) && (msX <= sX + 135 + 44) && (msY >= sY + 45 + i*15) && (msY <= sY + 59 + i*15)) {
				if ( (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_bIsUseable == TRUE) &&
					 (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_iLevel != 0) ) {
					// 사용 가능한 기술을 사용자가 선택했다. 만약 현재 기술을 사용중이라면 새로 사용할 수는 없다. 
					if (m_bSkillUsingStatus == TRUE) {
						AddEventList(DLGBOX_CLICK_SKILL1, 10);
						             //"이미 다른 기술을 쓰고 있습니다."
						return;
					}

					if ((m_bCommandAvailable == FALSE) || (m_iHP <= 0)) {
						AddEventList(DLGBOX_CLICK_SKILL2, 10); 
						             //"동작중에는 기술을 사용할 수 없습니다."
						return;
					}

					if (m_bIsGetPointingMode == TRUE) {
						return;
					}

					// 이제 기술을 사용한다는 메시지를 보낸다. 
					switch (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_cUseMethod) {
					case 0:
						// 특별한 대상을 지정하지 않고 그냥 사용하는 메시지이다. 
						bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USESKILL, NULL, (i + m_stDialogBoxInfo[15].sView), NULL, NULL, NULL); 
						m_bSkillUsingStatus = TRUE;
						DisableDialogBox(15);
						PlaySound('E', 14, 5);
						break;
					}
				}
			}
			else if ((msX >= sX + 215) && (msX <= sX + 240) && (msY >= sY + 45 + i*15) && (msY <= sY + 59 + i*15)) {
				
				if (m_stDialogBoxInfo[15].bFlag == FALSE) {
					// 스킬 다운 마킹 - 네트웍 트래픽을 막기 위해 플래그를 체크함.
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX, NULL, i + m_stDialogBoxInfo[15].sView, NULL, NULL, NULL);
					PlaySound('E', 14, 5);
					m_stDialogBoxInfo[15].bFlag = TRUE;
				}
			}
		}
		break;
	}
}

void CGame::DlgBoxClick_SkillDlg(short msX, short msY)
{
 int i, iAdjX, iAdjY;
 short sX, sY;
	
	sX = m_stDialogBoxInfo[26].sX;
	sY = m_stDialogBoxInfo[26].sY;

	iAdjX = 5 ;
	iAdjY = 8 ;
	

	switch (m_stDialogBoxInfo[26].cMode) {
	case 1:
		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195)) {
			// 포션 만들기 버튼 눌렸다! 
			m_stDialogBoxInfo[26].cMode = 2;
			m_stDialogBoxInfo[26].cStr[0] = 1;
			m_stDialogBoxInfo[26].dwT1 = m_dwCurTime;
			PlaySound('E', 14, 5);
			AddEventList(DLGBOX_CLICK_SKILLDLG1, 10);
			             //"시약을 제조중입니다..."
			PlaySound('E', 41, 0);
		}
		break;

	case 3:
		for (i = 0; i < 13; i++)
		if (m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView] != NULL) {
			if ((msX >= sX + iAdjX + 44) && (msX <= sX + iAdjX + 135 + 44) && (msY >= sY + iAdjY + 55 + i*15) && (msY <= sY + iAdjY + 55 + 14 + i*15)) {
				// 해당 아이템이 클릭되었다.
				m_stDialogBoxInfo[26].cMode = 4;
				m_stDialogBoxInfo[26].cStr[0] = i + m_stDialogBoxInfo[26].sView;
				PlaySound('E', 14, 5);
			}
		}
		break;

	case 4:
		iAdjX = -1 ;
		iAdjY = -7 ;
		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bBuildEnabled == TRUE) {
			// 만들 수 있는 상태 
			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
				// Back
				m_stDialogBoxInfo[26].cMode = 3;
				PlaySound('E', 14, 5);
				
				if ((m_stDialogBoxInfo[26].sV1 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV1] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV1] = FALSE;
				if ((m_stDialogBoxInfo[26].sV2 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV2] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV2] = FALSE;
				if ((m_stDialogBoxInfo[26].sV3 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV3] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV3] = FALSE;
				if ((m_stDialogBoxInfo[26].sV4 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV4] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV4] = FALSE;
				if ((m_stDialogBoxInfo[26].sV5 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV5] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV5] = FALSE;
				if ((m_stDialogBoxInfo[26].sV6 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV6] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV6] = FALSE;

				m_stDialogBoxInfo[26].sV1   = -1;		
				m_stDialogBoxInfo[26].sV2   = -1;
				m_stDialogBoxInfo[26].sV3   = -1;
				m_stDialogBoxInfo[26].sV4   = -1;
				m_stDialogBoxInfo[26].sV5   = -1;
				m_stDialogBoxInfo[26].sV6   = -1;
				m_stDialogBoxInfo[26].cStr[0] = 0;
				m_stDialogBoxInfo[26].cStr[1] = 0;
				m_stDialogBoxInfo[26].cStr[4] = 0;
			}

			if ((msX >= sX + iAdjX + 160) && (msX <= sX + iAdjX + 255) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
				// Manufacture
				if (m_stDialogBoxInfo[26].cStr[4] == 1) {
					m_stDialogBoxInfo[26].cMode   = 5;
					m_stDialogBoxInfo[26].cStr[1] = 0;
					m_stDialogBoxInfo[26].dwT1    = m_dwCurTime;
					PlaySound('E', 14, 5);
					PlaySound('E', 44, 0);
				}
			}
		}
		else {
			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
				// Back
				m_stDialogBoxInfo[26].cMode = 3;
				PlaySound('E', 14, 5);

				if ((m_stDialogBoxInfo[26].sV1 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV1] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV1] = FALSE;
				if ((m_stDialogBoxInfo[26].sV2 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV2] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV2] = FALSE;
				if ((m_stDialogBoxInfo[26].sV3 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV3] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV3] = FALSE;
				if ((m_stDialogBoxInfo[26].sV4 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV4] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV4] = FALSE;
				if ((m_stDialogBoxInfo[26].sV5 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV5] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV5] = FALSE;
				if ((m_stDialogBoxInfo[26].sV6 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV6] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV6] = FALSE;

				m_stDialogBoxInfo[26].sV1   = -1;		
				m_stDialogBoxInfo[26].sV2   = -1;
				m_stDialogBoxInfo[26].sV3   = -1;
				m_stDialogBoxInfo[26].sV4   = -1;
				m_stDialogBoxInfo[26].sV5   = -1;
				m_stDialogBoxInfo[26].sV6   = -1;
				m_stDialogBoxInfo[26].cStr[0] = 0;
				m_stDialogBoxInfo[26].cStr[1] = 0;
				m_stDialogBoxInfo[26].cStr[4] = 0;
			}
		}
		break;

	case 6:
		iAdjX = -1;
		iAdjY = -7;
		if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
			// Back
			m_stDialogBoxInfo[26].cMode = 3;
			PlaySound('E', 14, 5);

			if ((m_stDialogBoxInfo[26].sV1 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV1] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV1] = FALSE;
			if ((m_stDialogBoxInfo[26].sV2 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV2] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV2] = FALSE;
			if ((m_stDialogBoxInfo[26].sV3 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV3] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV3] = FALSE;
			if ((m_stDialogBoxInfo[26].sV4 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV4] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV4] = FALSE;
			if ((m_stDialogBoxInfo[26].sV5 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV5] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV5] = FALSE;
			if ((m_stDialogBoxInfo[26].sV6 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV6] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV6] = FALSE;

			m_stDialogBoxInfo[26].sV1   = -1;		
			m_stDialogBoxInfo[26].sV2   = -1;
			m_stDialogBoxInfo[26].sV3   = -1;
			m_stDialogBoxInfo[26].sV4   = -1;
			m_stDialogBoxInfo[26].sV5   = -1;
			m_stDialogBoxInfo[26].sV6   = -1;
			m_stDialogBoxInfo[26].cStr[0] = 0;
			m_stDialogBoxInfo[26].cStr[1] = 0;
			m_stDialogBoxInfo[26].cStr[4] = 0;
		}
		break;
	}
}

void CGame::ResponseTeleportList(char *pData)
{
	char *cp;
	int  *ip, i;
	
#ifdef _DEBUG
	AddEventList("텔레포트 하려구 하냐..??", 10);
#endif

	cp = pData + 6;
	ip = (int*) cp;
	m_iTeleportMapCount = *ip; // 텔레포트 할 장소의 개수
	cp += 4;

	for ( i = 0 ; i < m_iTeleportMapCount ; i++)
	{
		ip = (int*)cp;
		m_stTeleportList[i].iIndex = *ip;
		cp += 4;
		ZeroMemory(m_stTeleportList[i].mapname, sizeof(m_stTeleportList[i].mapname) );
		memcpy(m_stTeleportList[i].mapname, cp, 10);
		cp += 10;
		ip = (int*)cp;
		m_stTeleportList[i].iX = *ip;
		cp += 4;
		ip = (int*)cp;
		m_stTeleportList[i].iY = *ip;
		cp += 4;
		ip = (int*)cp;
		m_stTeleportList[i].iCost = *ip;
		cp += 4;
	}
}

void CGame::ResponseChargedTeleport(char *pData)
{
	short *sp;
	char *cp;
	short sRejectReason = 0;

	cp = (char*)pData + DEF_INDEX2_MSGTYPE + 2;
	sp = (short*)cp;
	sRejectReason = *sp;

#ifdef _DEBUG
	AddEventList( "안된데", 10 );
#endif

	switch( sRejectReason )
	{
	case 1:
		AddEventList( RESPONSE_CHARGED_TELEPORT1, 10 );
		break;
	case 2:
		AddEventList( RESPONSE_CHARGED_TELEPORT2, 10 );
		break;
	case 3:
		AddEventList( RESPONSE_CHARGED_TELEPORT3, 10 );
		break;
	case 4:
		AddEventList( RESPONSE_CHARGED_TELEPORT4, 10 );
		break;
	case 5:
		AddEventList( RESPONSE_CHARGED_TELEPORT5, 10 );
		break;
	case 6:
		AddEventList( RESPONSE_CHARGED_TELEPORT6, 10 );
		break;
	default:
		AddEventList( RESPONSE_CHARGED_TELEPORT7, 10 );
	}
}

void CGame::NotifyMsg_CannotGiveItem(char *pData)
{
 char * cp, cName[21], cTxt[256];
 WORD * wp, wItemIndex;
 int  * ip, iAmount;
 
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[wItemIndex], cStr1, cStr2, cStr3);
	if( iAmount == 1 ) wsprintf(cTxt, NOTIFYMSG_CANNOT_GIVE_ITEM2, cStr1, cName);//"아이템 %s : 바닥에 떨어졌습니다. %s에게 전달할 수 없습니다."
#if DEF_LANGUAGE == 4	//언어:English
	else wsprintf( cTxt, NOTIFYMSG_CANNOT_GIVE_ITEM1, iAmount, cStr1, cName);
#else
	else wsprintf(cTxt, NOTIFYMSG_CANNOT_GIVE_ITEM1, cStr1, iAmount, cName);//"아이템 %s %d개 : 바닥에 떨어졌습니다. %s에게 전달할 수 없습니다."
#endif
	              
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_DropItemFin_CountChanged(char *pData)
{
 char * cp, cTxt[256];
 WORD * wp, wItemIndex;
 int  * ip, iAmount;
 
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[wItemIndex]->m_cName, m_pItemList[wItemIndex]->m_dwAttribute, cStr1, cStr2, cStr3);
#if DEF_LANGUAGE == 4	//언어:English
	wsprintf(cTxt, NOTIFYMSG_THROW_ITEM1, iAmount, cStr1);
#else
	wsprintf(cTxt, NOTIFYMSG_THROW_ITEM1, cStr1, iAmount);
#endif
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_CannotJoinMoreGuildsMan(char * pData)
{
 char * cp, cName[12], cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);

	wsprintf(cTxt, NOTIFYMSG_CANNOT_JOIN_MOREGUILDMAN1, cName);//"%s의 길드가입신청요구를 받아들일 수 없습니다."
	AddEventList(cTxt, 10);
	AddEventList(NOTIFYMSG_CANNOT_JOIN_MOREGUILDMAN2, 10);//"길드인원이 이미 다 찼습니다."
}



void CGame::NotifyMsg_DismissGuildsMan(char * pData)
{
 char * cp, cName[12], cTxt[120];
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	              
	if( memcmp( m_cPlayerName, cName, 10 ) != 0 ) {
		wsprintf(cTxt, NOTIFYMSG_DISMISS_GUILDMAN1, cName);//"%s가 당신의 길드를 탈퇴하였습니다."
		AddEventList(cTxt, 10);
	}
	ClearGuildNameList();
}

void CGame::NotifyMsg_CannotRating(char * pData)
{
 char * cp, cTxt[120];
 WORD * wp, wTime;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wTime = *wp;
	cp += 2;

	if (wTime == 0) wsprintf(cTxt, NOTIFYMSG_CANNOT_RATING1, wTime*3);//"다른 캐릭터에 대한 평가명령을 사용할 자격이 없습니다."
	else wsprintf(cTxt, NOTIFYMSG_CANNOT_RATING2, wTime*3);//"다른 캐릭터에 대한 평가명령은 %d초 후에 사용 가능합니다."
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_CannotRepairItem(char * pData)
{
 char * cp, cTxt[120], cStr1[64], cStr2[64], cStr3[64];
 WORD * wp, wV1, wV2;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
  	wV1 = *wp;
	cp += 2;

	wp = (WORD *)cp;
  	wV2 = *wp;
	cp += 2;

	ZeroMemory( cStr1, sizeof(cStr1) );
	ZeroMemory( cStr2, sizeof(cStr2) );
	ZeroMemory( cStr3, sizeof(cStr3) );
	GetItemName( m_pItemList[wV1], cStr1, cStr2, cStr3 );

	switch (wV2) {
	case 1:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_REPAIR_ITEM1, cStr1 );//"아이템 %s: 고칠 필요가 없는 아이템입니다."
		AddEventList(cTxt, 10);
 		break;

	case 2:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_REPAIR_ITEM2, cStr1 );//"아이템 %s: 이곳에서 고칠 수 있는 아이템이 아닙니다."
		AddEventList(cTxt, 10);
 		break;
	}

	// 비 활성화 상태를 해제한다.
	m_bIsItemDisabled[wV1] = FALSE;
}

void CGame::NotifyMsg_CannotSellItem(char * pData)
{
 char * cp, cTxt[120], cStr1[64], cStr2[64], cStr3[64];
 WORD * wp, wV1, wV2;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
  	wV1 = *wp;
	cp += 2;

	wp = (WORD *)cp;
  	wV2 = *wp;
	cp += 2;

	ZeroMemory( cStr1, sizeof(cStr1) );
	ZeroMemory( cStr2, sizeof(cStr2) );
	ZeroMemory( cStr3, sizeof(cStr3) );
	GetItemName( m_pItemList[wV1], cStr1, cStr2, cStr3 );

	switch (wV2) {
	case 1:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_SELL_ITEM1, cStr1);//"아이템 %s: 이 곳에서 팔 수 없는 아이템입니다."
		AddEventList(cTxt, 10);
		break;

	case 2:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_SELL_ITEM2, cStr1);//"아이템 %s: 손상된 아이템은 팔 수 없습니다."
		AddEventList(cTxt, 10);
		break;

	case 3:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_SELL_ITEM3, cStr1);//"아이템 %s: 팔 수 없습니다."
		AddEventList(cTxt, 10);
		AddEventList(NOTIFYMSG_CANNOT_SELL_ITEM4, 10);//"아이템을 팔기 위해서는 시민권을 획득해야 합니다."
		break;

	case 4:
		AddEventList(NOTIFYMSG_CANNOT_SELL_ITEM5, 10); // "소지품 무게 제한에 걸려 아이템을 팔 수 없습니다."
		AddEventList(NOTIFYMSG_CANNOT_SELL_ITEM6, 10); // "소지품을 줄인 다음 다시 시도하세요."
		break;
	}

	// 아이템을 활성화 시킨다.
	m_bIsItemDisabled[wV1] = FALSE;
}

void CGame::NotifyMsg_Charisma(char * pData)
{
 DWORD * dwp;
 int  iPrevChar;
 char cTxt[120];

	iPrevChar = m_iCharisma;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	m_iCharisma = (int)*dwp;

	if (m_iCharisma > iPrevChar) {
		wsprintf(cTxt, NOTIFYMSG_CHARISMA_UP, m_iCharisma - iPrevChar);//"CHR이 %d포인트 증가했습니다."
		AddEventList(cTxt, 10);
		PlaySound('E', 21, 0);
	}
	else {
		wsprintf(cTxt, NOTIFYMSG_CHARISMA_DOWN, iPrevChar - m_iCharisma);//"CHR이 %d포인트 감소했습니다."
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_DropItemFin_EraseItem(char *pData)
{
 char * cp;
 WORD * wp;
 int * ip, iAmount;
 short  sItemIndex;
 char   cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
	sItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);

	ZeroMemory(cTxt, sizeof(cTxt));
	if (m_bIsItemEquipped[sItemIndex] == TRUE) {
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"아이템 %s: 장착 해제 되었습니다."
		AddEventList(cTxt, 10);
		// v1.42
		m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;
		m_bIsItemEquipped[sItemIndex] = FALSE;
	}
	if (m_iHP > 0) {
		wsprintf(cTxt, NOTIFYMSG_THROW_ITEM2, cStr1);
	}
	else {
		if (iAmount < 2) 
			wsprintf(cTxt, NOTIFYMSG_DROPITEMFIN_ERASEITEM3, cStr1);
		else
		{
			#if DEF_LANGUAGE % 2 == 0	// 중국어와 영어
				wsprintf(cTxt, NOTIFYMSG_DROPITEMFIN_ERASEITEM4, iAmount, cStr1);
			#else // 대만어, 일어, 한국어
				wsprintf(cTxt, NOTIFYMSG_DROPITEMFIN_ERASEITEM4, cStr1, iAmount);
			#endif
		}
	}
	AddEventList(cTxt, 10);

	// 아이템을 준 처리가 끝났으므로 리스트에서 삭제한다.
	EraseItem((char)sItemIndex);
	// v1.41 
	_bCheckBuildItemStatus();
}


void CGame::NotifyMsg_EnemyKillReward(char *pData)
{
 DWORD * dwp;
 short * sp, sGuildRank;
 char  * cp, cName[12], cGuildName[24], cTxt[120];
 int   iExp, iEnemyKillCount, iWarContribution;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp  = (DWORD *)cp;
	iExp = *dwp;
	cp += 4;
	dwp  = (DWORD *)cp;
	iEnemyKillCount = *dwp;
	cp += 4;
	memcpy(cName, cp, 10);
	cp += 10;
	memcpy(cGuildName, cp, 20);
	cp += 20;
	sp  = (short *)cp;
	sGuildRank = *sp;
	cp += 2;
	sp  = (short *)cp;
	iWarContribution = *sp;
	cp += 2;

	if (iWarContribution > m_iWarContribution) {
		// 전쟁 공헌도가 올랐다.
		wsprintf(G_cTxt, "%s +%d!", m_pGameMsgList[21]->m_pMsg, iWarContribution - m_iWarContribution);
		SetTopMsg(G_cTxt, 5);
	}
	else if (iWarContribution < m_iWarContribution) {
		// 전쟁 공헌도가 떨어졌다. 적을 죽였는데 이런 일은 없겠지 
	}
	m_iWarContribution = iWarContribution;

	if (sGuildRank == -1) {
		// 시민과의 전투에서 승리했다.
		wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD1, cName);//"%s와의 전투에서 승리했습니다!"
		AddEventList(cTxt, 10);
	}
	else {
		// 적 길드원과의 전투에서 승리했다.
		wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD2,cGuildName, cName);//"적 길드 %s의 길드원 %s와의 전투에서 승리했습니다!"
		AddEventList(cTxt, 10);
	}

	if( m_iExp != iExp )
	{
		if (m_iExp > iExp) wsprintf(cTxt, EXP_DECREASED,m_iExp - iExp);//"Exp가 %d포인트 감소했습니다."
		else wsprintf(cTxt, EXP_INCREASED,iExp - m_iExp);//"Exp가 %d포인트 증가했습니다."
		AddEventList(cTxt, 10);
	}

	if (m_iEnemyKillCount != iEnemyKillCount) {
		if (m_iEnemyKillCount > iEnemyKillCount) {
			wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD5,m_iEnemyKillCount - iEnemyKillCount);//"Enemy-Kill-Count가 %d포인트 감소했습니다."
			AddEventList(cTxt, 10);
		}
		else {
			wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD6, iEnemyKillCount - m_iEnemyKillCount);//"Enemy-Kill-Count가 %d포인트 증가했습니다."
			AddEventList(cTxt, 10);
		}
	}

	if( iExp >= 0 ) m_iExp = iExp;
	if( iEnemyKillCount >= 0 ) m_iEnemyKillCount = iEnemyKillCount;
	PlaySound('E', 23, 0);
}

void CGame::NotifyMsg_EventFishMode(char * pData)
{
 short sSprite, sSpriteFrame;
 char * cp, cName[21];
 WORD * wp, wPrice;
	// 낚시 모드 다이얼로그 박스를 활성화 시킨다. 
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	wp = (WORD *)cp;
	wPrice = *wp;
	cp += 2;

	wp = (WORD *)cp;
	sSprite = (short)*wp;
	cp += 2;

	wp = (WORD *)cp;
	sSpriteFrame = (short)*wp;
	cp += 2;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;
	
	EnableDialogBox(24, 0, NULL, wPrice, cName);
	m_stDialogBoxInfo[24].sV3 = sSprite;
	m_stDialogBoxInfo[24].sV4 = sSpriteFrame;

	AddEventList(NOTIFYMSG_EVENTFISHMODE1, 10);//"낚시가 시작되었습니다..."
}

void CGame::NotifyMsg_Exp(char * pData)
{
 DWORD * dwp;
 int iPrevExp, * ip;
 char * cp, cTxt[120];

	iPrevExp = m_iExp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	m_iExp = (int)*dwp;
	cp += 4;

	ip = (int *)cp;
//	m_iRating = *ip;
	cp += 4;

	if (m_iExp > iPrevExp) {
		wsprintf(cTxt, EXP_INCREASED, m_iExp - iPrevExp);//"Exp가 %d포인트 증가했습니다."
		AddEventList(cTxt, 10);
	}
	else {
		wsprintf(cTxt, EXP_DECREASED, iPrevExp - m_iExp);//"Exp가 %d포인트 감소했습니다."
		AddEventList(cTxt, 10);
	}
}


void CGame::NotifyMsg_ForceDisconn(char *pData)
{
 WORD * wpCount;

	wpCount = (WORD *)(pData + 6);
	
	m_bForceDisconn = TRUE;
	//m_cLogOutCount = (char)*wpCount;
	if( m_bIsProgramActive )
	{
		if( m_cLogOutCount < 0 || m_cLogOutCount > 5 ) m_cLogOutCount = 5;
		AddEventList(NOTIFYMSG_FORCE_DISCONN1, 10);//"강제 접속 종료가 요청되었습니다. 접속 종료를 취소할 수 없습니다."
	}
	else
	{
		delete m_pGSock;
		m_pGSock = NULL;
		m_bEscPressed = FALSE;

		if (m_bSoundFlag) m_pESound[38]->bStop();
		// 배경음악 스톱
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE)) {
			if (m_pBGM != NULL) m_pBGM->bStop();
		}		
		// 과금 서비스의 경우 로그아웃시 무조건 종료
		if (strlen(G_cCmdLineTokenA) != 0) 
			 ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else 
		{
			#ifdef DEF_JAPAN_FOR_TERRA
				ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			#else
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			#endif
		}
	}
}

void CGame::NotifyMsg_GiveItemFin_CountChanged(char *pData)
{
 char * cp, cName[21], cTxt[256];
 WORD * wp, wItemIndex;
 int  * ip, iAmount;
 
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[wItemIndex]->m_cName, m_pItemList[wItemIndex]->m_dwAttribute, cStr1, cStr2, cStr3);
#if DEF_LANGUAGE == 4	//언어:English
	if( iAmount == 1 ) wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_COUNTCHANGED1, cStr1, cName);
	wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_COUNTCHANGED2, iAmount, cStr1, cName);
#else
	wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_COUNTCHANGED1, cStr1, iAmount, cName);
#endif
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_GiveItemFin_EraseItem(char *pData)
{
 char * cp;
 WORD * wp;
 int  * ip, iAmount;
 short  sItemIndex;
 char cName[21], cTxt[250];
	
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
	sItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;
		
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex]->m_cName, m_pItemList[sItemIndex]->m_dwAttribute, cStr1, cStr2, cStr3);

	if (m_bIsItemEquipped[sItemIndex] == TRUE) {
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"아이템 %s: 장착 해제 되었습니다."
		AddEventList(cTxt, 10);

		// v1.42
		m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;
		m_bIsItemEquipped[sItemIndex] = FALSE;
	}
#if DEF_LANGUAGE == 4	//언어:English
	if (strlen(cName) == 0) wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM2, iAmount, cStr1);
	else {
		if (strcmp(cName, "Howard") == 0)
			 wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM3, iAmount, cStr1);
		else if (strcmp(cName, "William") == 0)
			 wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM4, iAmount, cStr1);
		else if (strcmp(cName, "Kennedy") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM5, iAmount, cStr1);
		else if (strcmp(cName, "Tom") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM7, iAmount, cStr1);
		else wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM8, iAmount, cStr1, cName);
	}
#else
	if (strlen(cName) == 0) wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM2, cStr1, iAmount);
	else {
		if (strcmp(cName, "Howard") == 0)
			 wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM3, cStr1, iAmount);
		else if (strcmp(cName, "William") == 0)
			 wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM4, cStr1, iAmount);
		else if (strcmp(cName, "Kennedy") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM5, cStr1, iAmount);
		else if (strcmp(cName, "Tom") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM7, cStr1, iAmount);
		else wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM8, cStr1, iAmount, cName);
	}
#endif
	AddEventList(cTxt, 10);

	// 아이템을 준 처리가 끝났으므로 리스트에서 삭제한다.
	EraseItem((char)sItemIndex);

	// v1.41 
	_bCheckBuildItemStatus();
}

void CGame::NotifyMsg_GlobalAttackMode(char *pData)
{
 char * cp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	switch (*cp) {
	case 0:
		AddEventList(NOTIFYMSG_GLOBAL_ATTACK_MODE1, 10);//"전체 공격 금지 모드가 설정되었습니다!"  
		AddEventList(NOTIFYMSG_GLOBAL_ATTACK_MODE2, 10);//"현재 맵에서 모든 물리공격과 마법캐스팅이 무효화됩니다."
		break;

	case 1:
		AddEventList(NOTIFYMSG_GLOBAL_ATTACK_MODE3, 10);//"전체 공격 금지 모드가 해제되었습니다!"
		break;
	}
	cp++;
}


void CGame::NotifyMsg_HP(char * pData)
{
 DWORD * dwp;
 int iPrevHP;
 char cTxt[120];
 int iPrevMP;

	iPrevHP = m_iHP;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	m_iHP = (int)*dwp;

	iPrevMP = m_iMP;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 6);
	m_iMP = (int)*dwp;

	if (m_iHP > iPrevHP) {
		// 10미만의 변동에 대해서는 무시한다.
		if ((m_iHP - iPrevHP) < 10) return;
		wsprintf(cTxt, NOTIFYMSG_HP_UP, m_iHP - iPrevHP);//"HP가 %d포인트 증가했습니다."
		AddEventList(cTxt, 10);
		PlaySound('E', 21, 0);
	}
	else {
		if ( (m_cLogOutCount > 0) && (m_bForceDisconn==FALSE) ) {
			m_cLogOutCount = -1;
			AddEventList(NOTIFYMSG_HP2, 10);//"접속 종료 카운트 중 HP가 감소하면 카운트가 취소 됩니다."
		}

		// 충격을 먹은 시간을 기록 
		m_dwDamagedTime = timeGetTime();
		if (m_iHP < 20) AddEventList(NOTIFYMSG_HP3, 10);//"경고! HP가 낮아 위험합니다."
		// 10미만의 변동에 대해서는 무시한다.
		if ((iPrevHP - m_iHP) < 10) return;
		wsprintf(cTxt, NOTIFYMSG_HP_DOWN, iPrevHP - m_iHP);
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_Hunger(char * pData)
{
 char * cp, cHLv;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cHLv = *cp;

	if ((cHLv <= 40) && (cHLv > 30)) AddEventList(NOTIFYMSG_HUNGER1, 10);//"허기를 느낍니다..."
	if ((cHLv <= 25) && (cHLv > 20)) AddEventList(NOTIFYMSG_HUNGER2, 10);//"배가 고픕니다..."
	if ((cHLv <= 20) && (cHLv > 15)) AddEventList(NOTIFYMSG_HUNGER3, 10);//"배가 너무 고픕니다..."
	if ((cHLv <= 15) && (cHLv > 10)) AddEventList(NOTIFYMSG_HUNGER4, 10);//"배가 너무 너무 고픕니다..."
	if ((cHLv <= 10) && (cHLv >= 0)) AddEventList(NOTIFYMSG_HUNGER5, 10);//"굶어 죽을 지경입니다!!!"
}

void CGame::NotifyMsg_ItemColorChange(char *pData)
{
 short * sp, sItemIndex, sItemColor;
 char * cp;
 char cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	sp = (short *)cp;
	sItemIndex = *sp;
	cp += 2;

	sp = (short *)cp;
	sItemColor = (short)*sp;
	cp += 2;

	if (m_pItemList[sItemIndex] != NULL) {
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName( m_pItemList[sItemIndex], cStr1, cStr2, cStr3 );
		if (sItemColor != -1) {
			m_pItemList[sItemIndex]->m_cItemColor = (char)sItemColor;
			wsprintf(cTxt, NOTIFYMSG_ITEMCOLOR_CHANGE1, cStr1);//"아이템 %s: 염색 되었습니다."
			AddEventList(cTxt, 10);
		}
		else {
			wsprintf(cTxt, NOTIFYMSG_ITEMCOLOR_CHANGE2, cStr1);//"아이템 %s: 염색할 수 있는 아이템이 아닙니다."
			AddEventList(cTxt, 10);	
		}
	}
}

void CGame::NotifyMsg_ItemDepleted_EraseItem(char * pData)
{
 char * cp;
 WORD * wp;
 short  sItemIndex;
 BOOL   bIsUseItemResult;
 char   cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
	sItemIndex = *wp;
	cp += 2;
	
	bIsUseItemResult = (BOOL)*cp;
	cp += 2;

	ZeroMemory(cTxt, sizeof(cTxt));

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);

	if (m_bIsItemEquipped[sItemIndex] == TRUE) {
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"아이템 %s: 장착 해제 되었습니다."
		AddEventList(cTxt, 10);

		// v1.42
		m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;
		m_bIsItemEquipped[sItemIndex] = FALSE;
	}
   	
	ZeroMemory(cTxt, sizeof(cTxt));
	if ( (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
		 (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
		wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM2, cStr1);//"아이템 %s: 모두 소모되었습니다."
	}
	else {
		if (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) {
			if (bIsUseItemResult == TRUE) {
				wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM3, cStr1);//"아이템 %s: 사용했습니다."
			}
		}
		else if (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) {
			// 음식류를 먹었다면 효과음을 플레이	
			if (bIsUseItemResult == TRUE) {
				wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM4, cStr1);
				               //"아이템 %s: 먹었습니다."
				if ( (m_sPlayerType >= 1) && (m_sPlayerType <= 3) )
					PlaySound('C', 19, 0);
				if ( (m_sPlayerType >= 4) && (m_sPlayerType <= 6) )
					PlaySound('C', 20, 0);
			}
		}
		else if (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
			if (bIsUseItemResult == TRUE) {
				wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM3, cStr1);
				               //"아이템 %s: 사용했습니다."
			}
		}
		else {
			if (bIsUseItemResult == TRUE) {
				wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM6, cStr1);
				              //"아이템 %s: 부서져 없어졌습니다."
				PlaySound('E', 10, 0);
			}
		}
	}

	AddEventList(cTxt, 10);

	if (bIsUseItemResult == TRUE) 
		m_bItemUsingStatus = FALSE;

	// 아이템을 준 처리가 끝났으므로 리스트에서 삭제한다.
	EraseItem((char)sItemIndex);

	// v1.41 
	_bCheckBuildItemStatus();
}

void CGame::NotifyMsg_ItemLifeSpanEnd(char * pData)
{
 char * cp;
 short * sp, sEquipPos, sItemIndex;
 char cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sEquipPos = *sp;
	cp += 2;
	sp = (short *)cp;
	sItemIndex = *sp;
	cp += 2;
	
	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName( m_pItemList[sItemIndex], cStr1, cStr2, cStr3 );
	wsprintf(cTxt, NOTIFYMSG_ITEMLIFE_SPANEND1, cStr1); 
	              //"아이템(%s): 망가졌습니다!"
	AddEventList(cTxt, 10);
	// 장착위치에서 해제시킨다.
	m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;
	m_bIsItemEquipped[sItemIndex] = FALSE;

	// 수명을 0으로 세트.
	m_pItemList[sItemIndex]->m_wCurLifeSpan = 0;

	PlaySound('E', 10, 0);
}

void CGame::NotifyMsg_ItemObtained(char * pData)
{
 char * cp;
 short * sp;
 DWORD * dwp;
 int i, j;

 DWORD dwCount, dwAttribute;
 char  cName[21], cItemType, cEquipPos;
 BOOL  bIsEquipped;
 short sSprite, sSpriteFrame, sLevelLimit, sSpecialEV2; 
 char  cTxt[120], cGenderLimit, cItemColor;
 WORD  * wp, wWeight, wCurLifeSpan;
 
	
	// 플레이어가 아이템을 획득했다. 
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cp++;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	dwp = (DWORD *)cp;
	dwCount = *dwp;
	cp += 4;

	cItemType = *cp;
	cp++;

	cEquipPos = *cp;
	cp++;

	bIsEquipped = (BOOL)*cp;
	cp++;

	sp = (short *)cp;
	sLevelLimit = *sp;
	cp += 2;

	cGenderLimit = *cp;
	cp++;

	wp = (WORD *)cp;
	wCurLifeSpan = *wp;
	cp += 2;

	wp = (WORD *)cp;
	wWeight = *wp;
	cp += 2;

	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;

	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;

	cItemColor = *cp;
	cp++;

	sSpecialEV2 = (short)*cp; // v1.41
	cp++;

	dwp = (DWORD *)cp;
	dwAttribute = *dwp;
	cp += 4;
	/*
	bIsCustomMade = (BOOL)*cp;
	cp++;
	*/

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(cName, dwAttribute, cStr1, cStr2, cStr3);

	ZeroMemory(cTxt, sizeof(cTxt));
	if( dwCount == 1 ) wsprintf(cTxt, NOTIFYMSG_ITEMOBTAINED2, cStr1); 
#if DEF_LANGUAGE == 4	//언어:English
	else wsprintf(cTxt, NOTIFYMSG_ITEMOBTAINED1, dwCount, cStr1); 
#else
	else wsprintf(cTxt, NOTIFYMSG_ITEMOBTAINED1, cStr1, dwCount);
#endif
	AddEventList(cTxt, 10);

	PlaySound('E', 20, 0);

	if ((cItemType == DEF_ITEMTYPE_CONSUME) || (cItemType == DEF_ITEMTYPE_ARROW)) {
		// 소모되는 아이템이라면 먼저 존재하는지 검색하여 존재하면 카운트를 증가시킨다.
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0)) {
			// 같은 이름을 갖는 아이템이 있다. 수량을 증가시키고 복귀한다.
			m_pItemList[i]->m_dwCount += dwCount;
		

			m_bIsItemDisabled[i] = FALSE;
			return;
		}
	}

  //정진광 추가... 이미 갖고 있는 아이템이라면...
  short nX, nY;  // 정진광 추가 변수...이미 있는 아이템의 좌표를 받기위해.
  for (i = 0; i < DEF_MAXITEMS; i++)
  {
	  
	  
	  if ( ( m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0))
	  {
		  nX = m_pItemList[i]->m_sX;
		  nY = m_pItemList[i]->m_sY;
		  break;  // 아이템을 찾았으므로..루프 벗어남
	  }
	  else
	  {
		  nX = 40;
		  nY = 30;
	  }
  }
  // 정진광 추가 여기까지..
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] == NULL) {
		m_pItemList[i] = new class CItem;
		memcpy(m_pItemList[i]->m_cName, cName, 20);
		m_pItemList[i]->m_dwCount = dwCount;
		//m_pItemList[i]->m_sX      =	40;
		//m_pItemList[i]->m_sY      =	30;
		m_pItemList[i]->m_sX      =	nX; //정진광 수정.
		m_pItemList[i]->m_sY      =	nY;
		bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, i, nX, nY, NULL, NULL); 
		m_pItemList[i]->m_cItemType = cItemType;
		m_pItemList[i]->m_cEquipPos = cEquipPos;
		m_bIsItemDisabled[i]        = FALSE;

		// 얻은 아이템은 기본적으로 장착되지 않는 상태이다.
		m_bIsItemEquipped[i] = FALSE;
		m_pItemList[i]->m_sLevelLimit  = sLevelLimit;
		m_pItemList[i]->m_cGenderLimit = cGenderLimit;
		m_pItemList[i]->m_wCurLifeSpan = wCurLifeSpan;
		m_pItemList[i]->m_wWeight      = wWeight;
		m_pItemList[i]->m_sSprite      = sSprite;
		m_pItemList[i]->m_sSpriteFrame = sSpriteFrame;
		m_pItemList[i]->m_cItemColor   = cItemColor;
		m_pItemList[i]->m_sItemSpecEffectValue2 = sSpecialEV2; // v1.41
		m_pItemList[i]->m_dwAttribute = dwAttribute;
		//m_pItemList[i]->m_bIsCustomMade = bIsCustomMade;
		
		// v1.41 
		_bCheckBuildItemStatus();

		// 현재 아이템 갯수중 빈곳에 번호를 할당한다. 
		for (j = 0; j < DEF_MAXITEMS; j++) 
		if (m_cItemOrder[j] == -1) {
			m_cItemOrder[j] = i;
			return;
		}
		return;
	}
}

void CGame::NotifyMsg_ItemPurchased(char * pData)
{
 char  * cp;
 short * sp;
 DWORD * dwp;
 WORD  * wp;
 int i, j;

 DWORD dwCount;
 char  cName[21], cItemType, cEquipPos, cGenderLimit;
 BOOL  bIsEquipped;
 short sSprite, sSpriteFrame, sLevelLimit; 
 WORD  wCost, wWeight, wCurLifeSpan;
 char  cTxt[120], cItemColor;
	
	// 플레이어가 아이템을 구입했다. 
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	cp++;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	dwp = (DWORD *)cp;
	dwCount = *dwp;
	cp += 4;

	cItemType = *cp;
	cp++;

	cEquipPos = *cp;
	cp++;

	bIsEquipped = (BOOL)*cp;
	cp++;

	sp = (short *)cp;
	sLevelLimit = *sp;
	cp += 2;

	cGenderLimit = *cp;
	cp++;

 	wp = (WORD *)cp;
	wCurLifeSpan = *wp;
	cp += 2;

	wp = (WORD *)cp;
	wWeight = *wp;
	cp += 2;

	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;

	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;

	cItemColor = *cp; // v1.4
	cp++;

	wp = (WORD *)cp;
	wCost = *wp;

	// 이벤트 리스트에 입력 
	ZeroMemory(cTxt, sizeof(cTxt));
	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName( cName, NULL, cStr1, cStr2, cStr3 );
	wsprintf(cTxt, NOTIFYMSG_ITEMPURCHASED, cStr1, wCost); 
	AddEventList(cTxt, 10);

	if ( (cItemType == DEF_ITEMTYPE_CONSUME) || (cItemType == DEF_ITEMTYPE_ARROW)) {
		// 소모되는 아이템이라면 먼저 존재하는지 검색하여 존재하면 카운트를 증가시킨다.
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0)) {
			// 같은 이름을 갖는 아이템이 있다. 수량을 증가시키고 복귀한다.
			m_pItemList[i]->m_dwCount += dwCount;
			return;
		}
	}

 //정진광 추가... 이미 갖고 있는 아이템이라면...
 short nX, nY;  // 정진광 추가 변수...이미 있는 아이템의 좌표를 받기위해.
 for (i = 0; i < DEF_MAXITEMS; i++)
  {
	  if ( ( m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0))
	  {
		  nX = m_pItemList[i]->m_sX;
		  nY = m_pItemList[i]->m_sY;
		  break;  // 아이템을 찾았으므로..루프 벗어남
	  }
	  else
	  {
		  nX = 40;
		  nY = 30;
	  }
  }
  // 정진광 추가 여기까지..
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] == NULL) {
		m_pItemList[i] = new class CItem;
		memcpy(m_pItemList[i]->m_cName, cName, 20);
		m_pItemList[i]->m_dwCount      = dwCount;
		//m_pItemList[i]->m_sX           = 40;
		//m_pItemList[i]->m_sY           = 30;
		m_pItemList[i]->m_sX           = nX; //정진광 수정.
		m_pItemList[i]->m_sY           = nY;
		bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, i, nX, nY, NULL, NULL); 
		m_pItemList[i]->m_cItemType    = cItemType;
		m_pItemList[i]->m_cEquipPos    = cEquipPos;
		m_bIsItemDisabled[i]           = FALSE;
		// 얻은 아이템은 기본적으로 장착되지 않는 상태이다.
		m_bIsItemEquipped[i]           = FALSE;
		m_pItemList[i]->m_sLevelLimit  = sLevelLimit;
		m_pItemList[i]->m_cGenderLimit = cGenderLimit;
		m_pItemList[i]->m_wCurLifeSpan = wCurLifeSpan;
		m_pItemList[i]->m_wWeight      = wWeight;
		m_pItemList[i]->m_sSprite      = sSprite;
		m_pItemList[i]->m_sSpriteFrame = sSpriteFrame;
		m_pItemList[i]->m_cItemColor   = cItemColor;    // v1.4

		// fixed v1.11
		for (j = 0; j < DEF_MAXITEMS; j++)
		if (m_cItemOrder[j] == -1) {
			m_cItemOrder[j] = i;
			return;
		}
		
		return;
	}
}

void CGame::NotifyMsg_ItemReleased(char * pData)
{
 char * cp;
 short * sp, sEquipPos, sItemIndex;
 char cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sEquipPos = *sp;
	cp += 2;
	sp = (short *)cp;
	sItemIndex = *sp;
	cp += 2;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);
	
	wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1); 
	               //"아이템(%s): 장착 해제 되었습니다."
	AddEventList(cTxt, 10);
	
	// 장착위치에서 해제시킨다.
	m_bIsItemEquipped[sItemIndex] = FALSE;
	m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;
	
	PlaySound('E', 29, 0);
}

void CGame::NotifyMsg_ItemRepaired(char * pData)
{
 char * cp, cTxt[120];
 DWORD * dwp, dwItemID, dwLife;
	
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	dwp = (DWORD *)cp;
	dwItemID = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	dwLife = *dwp;
	cp += 4;

	m_pItemList[dwItemID]->m_wCurLifeSpan = (WORD)dwLife;

	// 아이템을 활성화 시킨다. 
	m_bIsItemDisabled[dwItemID] = FALSE;
	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName( m_pItemList[dwItemID], cStr1, cStr2, cStr3 );

	wsprintf(cTxt, NOTIFYMSG_ITEMREPAIRED1, cStr1);
	              //"아이템 %s: 수리되었습니다."

	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_ItemToBank(char *pData)
{
 char * cp, cIndex;
 DWORD * dwp, dwCount, dwAttribute;
 char  cName[21], cItemType, cEquipPos, cGenderLimit, cItemColor;
 BOOL  bIsEquipped;
 short * sp, sSprite, sSpriteFrame, sLevelLimit, sItemEffectValue2, sItemSpecEffectValue2;
 WORD  * wp, wWeight, wCurLifeSpan;
 char  cTxt[120];

	cp = (pData + DEF_INDEX2_MSGTYPE + 2);
	
	cIndex = *cp;
	cp++;

	cp++;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	dwp = (DWORD *)cp;
	dwCount = *dwp;
	cp += 4;

	cItemType = *cp;
	cp++;

	cEquipPos = *cp;
	cp++;

	bIsEquipped = (BOOL)*cp;
	cp++;

	sp = (short *)cp;
	sLevelLimit = *sp;
	cp += 2;

	cGenderLimit = *cp;
	cp++;

	wp = (WORD *)cp;
	wCurLifeSpan = *wp;
	cp += 2;

	wp = (WORD *)cp;
	wWeight = *wp;
	cp += 2;

	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;

	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;

	cItemColor = *cp;
	cp++;

	// v1.432 
	sp = (short *)cp;
	sItemEffectValue2 = *sp;
	cp += 2;
		
	dwp = (DWORD *)cp;
	dwAttribute = *dwp;
	cp += 4;

	//v2.14 순도가 잘못 나오는 버그 수정

	sItemSpecEffectValue2 = (short) *cp ;
	cp ++ ;

	// 12-20 성후니 변경 중문화를 위해 변경 
	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(cName, dwAttribute, cStr1, cStr2, cStr3);


	if (m_pBankList[cIndex] == NULL) {
		m_pBankList[cIndex] = new class CItem;
		
		memcpy(m_pBankList[cIndex]->m_cName, cName, 20);
		m_pBankList[cIndex]->m_dwCount = dwCount;
		
		m_pBankList[cIndex]->m_cItemType = cItemType;
		m_pBankList[cIndex]->m_cEquipPos = cEquipPos;
		
		m_pBankList[cIndex]->m_sLevelLimit  = sLevelLimit;
		m_pBankList[cIndex]->m_cGenderLimit = cGenderLimit;
		m_pBankList[cIndex]->m_wCurLifeSpan = wCurLifeSpan;
		m_pBankList[cIndex]->m_wWeight      = wWeight;
		m_pBankList[cIndex]->m_sSprite      = sSprite;
		m_pBankList[cIndex]->m_sSpriteFrame = sSpriteFrame;
		m_pBankList[cIndex]->m_cItemColor   = cItemColor;
		m_pBankList[cIndex]->m_sItemEffectValue2  = sItemEffectValue2;
		m_pBankList[cIndex]->m_dwAttribute        = dwAttribute;
		m_pBankList[cIndex]->m_sItemSpecEffectValue2 = sItemSpecEffectValue2 ;

		ZeroMemory(cTxt, sizeof(cTxt));
		if( dwCount == 1 ) wsprintf(cTxt, NOTIFYMSG_ITEMTOBANK3, cStr1);
#if DEF_LANGUAGE == 4	//언어:English
		else wsprintf(cTxt, NOTIFYMSG_ITEMTOBANK2, dwCount, cStr1);
#else
		else wsprintf(cTxt, NOTIFYMSG_ITEMTOBANK2, cStr1, dwCount);
#endif
		if( m_bIsDialogEnabled[14] == TRUE ) m_stDialogBoxInfo[14].sView = DEF_MAXBANKITEMS-12;
		AddEventList(cTxt, 10);
	}
}


void CGame::NotifyMsg_Killed(char * pData)
{
 char * cp, cAttackerName[21];
	// 플레이어가 사망했다는 메시지가 왔다.
	
	m_bCommandAvailable = FALSE;
	m_cCommand = DEF_OBJECTSTOP;

	m_iHP = 0;
	m_cCommand = -1;

	// Restart를 위해서 변수 클리어
	m_bItemUsingStatus = FALSE;
	
	// 사용중이던 스킬을 클리어 
	ClearSkillUsingStatus();

	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	memcpy(cAttackerName, cp, 20);
	cp += 20;

	AddEventList(NOTIFYMSG_KILLED1, 10);//"당신은 사망했습니다!"

	//괜히 싸움만 하니깐 누가 죽였는지 안보여준다.
/*	if (strlen(cAttackerName) == 0) 
		AddEventList(NOTIFYMSG_KILLED1, 10);
	                 //"당신은 사망했습니다!"
	else {
		wsprintf(G_cTxt, NOTIFYMSG_KILLED2, cAttackerName); 
		              //"당신은 %s의 공격을 받고 사망했습니다!"
		AddEventList(G_cTxt, 10);
	}*/
	AddEventList(NOTIFYMSG_KILLED3, 10);//" 시스템 메뉴의 Restart 버튼을 눌러 다시 게임을 시작하거나"
	AddEventList(NOTIFYMSG_KILLED4, 10);//" Log Out 버튼을 눌러 접속을 종료할 수 있습니다."
}

void CGame::NotifyMsg_LevelUp(char * pData)
{
 char * cp;
 int  * ip;
 int i, iPrevLevel;
 char cTxt[120];

	iPrevLevel = m_iLevel;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	ip  = (int *)cp;
	m_iLevel = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iStr = *ip;		
	cp  += 4;

	ip   = (int *)cp;
	m_iVit = *ip;								
	cp  += 4;

	ip   = (int *)cp;
	m_iDex = *ip;			
	cp  += 4;

	ip   = (int *)cp;
	m_iInt = *ip;					
	cp  += 4;

	ip   = (int *)cp;
	m_iMag = *ip;						
	cp  += 4;

	ip   = (int *)cp;
	m_iCharisma = *ip;
	cp  += 4;
	
	wsprintf(cTxt, NOTIFYMSG_LEVELUP1, m_iLevel);//"Level이 올랐습니다!!! %dLevel"
	AddEventList(cTxt, 10);

	switch (m_sPlayerType) {
	case 1:
	case 2:
	case 3:
		PlaySound('C', 21, 0);
		break;

	case 4:
	case 5:
	case 6:
		PlaySound('C', 22, 0);
		break;
	}
	
	_RemoveChatMsgListByObjectID(m_sPlayerObjectID);
 
	for (i = 1; i < DEF_MAXCHATMSGS; i++) 
	if (m_pChatMsgList[i] == NULL) {
		ZeroMemory(cTxt, sizeof(cTxt));
		strcpy(cTxt, "Level up!");
		m_pChatMsgList[i] = new class CMsg(23, cTxt, m_dwCurTime);
		m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
				
		if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == FALSE) {
			delete m_pChatMsgList[i];
			m_pChatMsgList[i] = NULL;
		}
		return;
	}
}

void CGame::NotifyMsg_MagicEffectOff(char * pData)
{
 char * cp;
 WORD * wp;
 short  sMagicType, sMagicEffect;


	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
	sMagicType = (short)*wp;
	cp += 2;

	wp = (WORD *)cp;
	sMagicEffect = (short)*wp;
	cp += 2;

	switch (sMagicType) {
	case DEF_MAGICTYPE_PROTECT:
		
		switch (sMagicEffect) {
		case 1:
			// 일반 미사일에 대한 방어효과 
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF1, 10);//"활 공격에 대한 보호 효과가 사라졌습니다."
			break;

		case 2:
			// 마법공격에 대한 방어효과
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF2, 10);//"마법 공격에 대한 보호 효과가 사라졌습니다."
			break;

		case 3:
		case 4:
			// 마법공격에 대한 방어효과
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF3, 10);//"근접 전투시의 방어력 증가효과가 사라졌습니다."
			break;
		//v2.16 2002-5-23 고광현
		case 5:
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF14, 10);// "절대 마법 방어 효과가 사라졌습니다."
			break;
		}
		break;

	case DEF_MAGICTYPE_HOLDOBJECT:
		switch (sMagicEffect) {
		case 1:
			m_bParalyze = FALSE;
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF4, 10);//"이동 불가능 마법 효과가 사라졌습니다."
			break;

		case 2:
			m_bParalyze = FALSE;
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF5, 10);//"마비상태(이동 불가능) 마법 효과가 사라졌습니다."
			break;
		}
		break;

	case DEF_MAGICTYPE_INVISIBILITY:
		switch (sMagicEffect) {
		case 1:
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF6, 10);//"투명 마법 효과가 사라졌습니다."
			break;
		}
		break;

	case DEF_MAGICTYPE_CONFUSE:
		switch (sMagicEffect) {
		case 1:
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF7, 10);//"언어 혼란 마법 효과가 사라졌습니다."
			break;

		case 2:
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF8, 10);//"혼란 마법 효과가 사라졌습니다."
			m_bIsConfusion = FALSE;
			break;

		case 3:
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF9, 10);//"환각 마법 효과가 사라졌습니다."
			m_iIlusionOwnerH = NULL;
			break;
		}
		break;

	case DEF_MAGICTYPE_POISON:
		if (m_bIsPoisoned) AddEventList(NOTIFYMSG_MAGICEFFECT_OFF10, 10);//"중독상태가 치료되었습니다!"
		m_bIsPoisoned = FALSE;
		break;

	case DEF_MAGICTYPE_BERSERK:
		switch (sMagicEffect) {
		case 1:
			// 버서커모드
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF11, 10);//"광분상태가 해제되었습니다."
			break;
		}
		break;

	case DEF_MAGICTYPE_POLYMORPH:
		switch (sMagicEffect) {
		case 1:
			// 변신 마법 
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF12, 10);//"변신 마법 효과가 사라졌습니다."
			break;
		}
		break;

	case DEF_MAGICTYPE_ICE:
		AddEventList(NOTIFYMSG_MAGICEFFECT_OFF13, 10);//"얼어붙은 상태가 풀렸습니다."
		break;
	}
}

void CGame::NotifyMsg_MagicEffectOn(char * pData)
{
 char * cp;
 DWORD * dwp;
 WORD * wp;
 short  sMagicType, sMagicEffect, sOwnerH;


	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
	sMagicType = (short)*wp;
	cp += 2;

	dwp = (DWORD *)cp;
	sMagicEffect = (short)*dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	sOwnerH = (short)*dwp;
	cp += 4;

	switch (sMagicType) {
	case DEF_MAGICTYPE_PROTECT:
		
		switch (sMagicEffect) {
		case 1:
			// 일반 미사일에 대한 방어효과 
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON1, 10);//"활 공격에 대한 보호효과가 생겼습니다!"
			break;

		case 2:
			// 마법공격에 대한 방어효과
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON2, 10);//"마법 공격에 대한 보호효과가 생겼습니다!"
			break;

		case 3:
		case 4:
			// 접근전 공격에 대한 방어효과
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON3, 10);//"근접 전투시 방어력이 증가했습니다!"
			break;

		//v2.16 2002-5-23 고광현
		case 5:
			// 절대 마법 방어 효과 
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON14, 10);//"절대 마법 방어 효과가 생겼습니다!"
			break;
		}
		break;

	case DEF_MAGICTYPE_HOLDOBJECT:
		switch (sMagicEffect) {
		case 1:
			// 일반 미사일에 대한 방어효과 
			m_bParalyze = TRUE;
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON4, 10);//"마법에 걸려 이동 불가능 상태가 되었습니다!"
			break;

		case 2:
			m_bParalyze = TRUE;
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON5, 10);//"마법에 걸려 마비상태(이동 불가능)가 되었습니다!"
			break;
		}
		break;

	case DEF_MAGICTYPE_INVISIBILITY:
		switch (sMagicEffect) {
		case 1:
			// 일반 미사일에 대한 방어효과
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON6, 10);//"투명 마법 효과로 보이지 않는 상태가 되었습니다!"
			break;
		}
		break;

	case DEF_MAGICTYPE_CONFUSE:
		switch (sMagicEffect) {
		case 1:
			// Confuse Language
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON7, 10);//"언어 혼란 마법 효과로 당신의 말을 알아들을 수 없게 되었습니다!"
			break;

		case 2:
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON8, 10);//"혼란 마법 효과로 적과 아군을 구분할 수 없게 되었습니다!"
			m_bIsConfusion = TRUE;
			break;

		case 3:
			// Illusion
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON9, 10);//"환각 마법에 걸렸습니다!"  
			_SetIlusionEffect(sOwnerH);
			break;
		}
		break;

	case DEF_MAGICTYPE_POISON:
		AddEventList(NOTIFYMSG_MAGICEFFECT_ON10, 10);//"중독 되었습니다!"
		m_bIsPoisoned = TRUE;
		break;

	case DEF_MAGICTYPE_BERSERK:
		switch (sMagicEffect) {
		case 1:
			// 버서커모드
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON11, 10);//"마법 효과로 광분상태가 되었습니다! 40초동안 공격력이 두배가 됩니다."
			break;
		}
		break;

	case DEF_MAGICTYPE_POLYMORPH:
		switch (sMagicEffect) {
		case 1:
			// 변신 마법 
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON12, 10);//"변신 마법 효과로 몬스터로 변신하였습니다!"
			break;
		}
		break;

	case DEF_MAGICTYPE_ICE:
		AddEventList(NOTIFYMSG_MAGICEFFECT_ON13, 10);//"Ice계열 마법에 얼었습니다! 움직임이 50% 느려집니다."
		break;
	}
}

void CGame::NotifyMsg_MagicStudyFail(char * pData)
{
 char * cp, cMagicNum, cName[31], cFailCode;
 char cTxt[120];
 int  * ip, iCost, iReqInt;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cFailCode = *cp;
	cp++;

	cMagicNum = *cp;
	cp++;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 30);
	cp += 30;

	ip = (int *)cp;
	iCost = *ip;
	cp += 4;

	ip = (int *)cp;
	iReqInt = *ip;
	cp += 4;

	if (iCost > 0) {
		wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL1, cName);//"마법(%s): 배우는데 실패했습니다! Gold나 Int가 모자랍니다."
		AddEventList(cTxt, 10);
	}
	else {
		wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL2,  cName);//"마법(%s): 배우는데 실패했습니다!"
		AddEventList(cTxt, 10);
		wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL3, iReqInt);//" Int가 %d이상 되어야 배울 수 있습니다."
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_MagicStudySuccess(char * pData)
{
 char * cp, cMagicNum, cName[31];
 char cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cMagicNum = *cp;
	cp++;
	m_cMagicMastery[cMagicNum] = 1;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 30);

	wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_SUCCESS1, cName);//"마법(%s): 배웠습니다!"
	AddEventList(cTxt, 10);

	PlaySound('E', 23, 0);
}

void CGame::NotifyMsg_MP(char * pData)
{
 DWORD * dwp;
 int iPrevMP;
 char cTxt[120];

	iPrevMP = m_iMP;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	m_iMP = (int)*dwp;

	// 10미만의 변동에 대해서는 무시한다.
	if (abs(m_iMP - iPrevMP) < 10) return;

	if (m_iMP > iPrevMP) {
		wsprintf(cTxt, NOTIFYMSG_MP_UP, m_iMP - iPrevMP);//"MP가 %d포인트 증가했습니다."
		AddEventList(cTxt, 10);

		PlaySound('E', 21, 0);
	}
	else {
		wsprintf(cTxt, NOTIFYMSG_MP_DOWN, iPrevMP - m_iMP);//"MP가 %d포인트 감소했습니다."
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_NewGuildsMan(char * pData)
{
 char * cp, cName[12], cTxt[120];
	// 새로 길드에 가입했다. 
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	wsprintf(cTxt, NOTIFYMSG_NEW_GUILDMAN1, cName);//"%s가 당신의 길드에 가입하였습니다."
	AddEventList(cTxt, 10);
	ClearGuildNameList();
}

void CGame::NotifyMsg_PKcaptured(char *pData)
{
 char  * cp;
 DWORD * dwp;
 WORD  * wp;
 int     iPKcount, iLevel, iExp, iRewardGold; 
 char cTxt[120], cName[12];

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
	iPKcount = *wp;
	cp += 2;

	wp = (WORD *)cp;
	iLevel = *wp;
	cp += 2;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	dwp = (DWORD *)cp;
	iRewardGold = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	iExp = *dwp;
	cp += 4;

	wsprintf(cTxt, NOTIFYMSG_PK_CAPTURED1, iLevel, cName, iPKcount);

	AddEventList(cTxt, 10);	

	wsprintf(cTxt, EXP_INCREASED, iExp - m_iExp);//"Exp가 %d포인트 증가했습니다."
	AddEventList(cTxt, 10);

	wsprintf(cTxt, NOTIFYMSG_PK_CAPTURED3, iExp - m_iExp);//"포상금 %dGold를 받을 수 있습니다."
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_PKpenalty(char *pData)
{
 char  * cp;
 DWORD * dwp;
 int     iPKcount, iExp, iStr, iVit, iDex, iInt, iMag, iChr;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	
	dwp = (DWORD *)cp;
	iExp = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	iStr = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	iVit = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	iDex = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	iInt = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	iMag = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	iChr = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	iPKcount = *dwp;
	cp += 4;


	wsprintf(G_cTxt, NOTIFYMSG_PK_PENALTY1, iPKcount);//"무고한 플레이어를 살상하여 PK 페널티를 받았습니다. PK-Count(%d)"
	AddEventList(G_cTxt, 10);

	if (m_iExp > iExp) {
		wsprintf(G_cTxt, NOTIFYMSG_PK_PENALTY2, m_iExp - iExp);//"Exp %d포인트 감소!"
		AddEventList(G_cTxt, 10);
	}
	m_iExp = iExp;
	m_iStr = iStr;
	m_iVit = iVit;
	m_iDex = iDex;
	m_iInt = iInt;
	m_iMag = iMag;
	m_iCharisma = iChr;
	m_iPKCount = iPKcount;
}

void CGame::NotifyMsg_PlayerShutUp(char * pData)
{
 char * cp, cName[12];
 WORD * wp, wTime;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wTime = *wp;
	cp += 2;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	if (memcmp(m_cPlayerName, cName, 10) == 0) 
		 wsprintf(G_cTxt, NOTIFYMSG_PLAYER_SHUTUP1, wTime);//"%d초 동안 전체 채팅 메시지를 못하는 페널티를 받았습니다!"
	else wsprintf(G_cTxt, NOTIFYMSG_PLAYER_SHUTUP2, cName, wTime);//"플레이어(%s)를 %d초 동안 전체 채팅 메시지를 못하게 만들었습니다."

	AddEventList(G_cTxt, 10);
}

void CGame::NotifyMsg_PlayerStatus(BOOL bOnGame, char * pData)
{
 char cName[12], cMapName[12], * cp;
 WORD * wp ;
 WORD  dx= 1 ,dy = 1; 

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	ZeroMemory(cMapName, sizeof(cMapName));
	memcpy(cMapName, cp, 10);
	cp += 10;

	wp = (WORD * ) cp ;
	dx = (WORD ) *wp ;
	cp += 2 ;

	wp = (WORD * ) cp ;
	dy = (WORD ) *wp ;
	cp += 2 ;

	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	if (bOnGame == TRUE) {
		if (strlen(cMapName) == 0)
			 wsprintf(G_cTxt, NOTIFYMSG_PLAYER_STATUS1, cName);//"%s님은 현재 접속중입니다."
		else wsprintf(G_cTxt, NOTIFYMSG_PLAYER_STATUS2, cName, cMapName, dx, dy);//"%s님은 현재 맵(%s)(%d %d)에 접속중입니다. "
	}
	else wsprintf(G_cTxt, NOTIFYMSG_PLAYER_STATUS3, cName);//"%s님은 현재 접속하고 있지 않습니다."
	AddEventList(G_cTxt, 10);
}


void CGame::NotifyMsg_QuestReward(char *pData)
{
 short * sp, sWho, sFlag;
 char  * cp, cRewardName[21], cTxt[120];
 int   * ip, iAmount, iIndex, iPreCon;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	sp = (short *)cp;
	sWho = *sp;
	cp += 2;

	sp = (short *)cp;
	sFlag = *sp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	ZeroMemory(cRewardName, sizeof(cRewardName));
	memcpy(cRewardName, cp, 20);
	cp += 20;
	
	// 이전 공헌도 저장.
	iPreCon = m_iContribution;

	ip = (int *)cp;
	m_iContribution = *ip;
	cp += 4;

	if (sFlag == 1) {
		// 퀘스트가 완료되어 포상을 받았다. 퀘스트 상태 초기화.
		m_stQuest.sWho          = NULL;
		m_stQuest.sQuestType    = NULL;
		m_stQuest.sContribution = NULL;
		m_stQuest.sTargetType   = NULL;
		m_stQuest.sTargetCount  = NULL;
		m_stQuest.sX     = NULL;
		m_stQuest.sY     = NULL;
		m_stQuest.sRange = NULL;
		m_stQuest.bIsQuestCompleted = FALSE;
		
		ZeroMemory(m_stQuest.cTargetName, sizeof(m_stQuest.cTargetName));
		
		EnableDialogBox(21, 0, sWho+110, 0);

		// 퀘스트의 포상 내용을 덛붙여 작성한다. 	
		iIndex = m_stDialogBoxInfo[21].sV1;
		m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
		iIndex++;

		ZeroMemory(cTxt, sizeof(cTxt));
		if (memcmp(cRewardName, "경험치", 6) == 0) {
			if (iAmount > 0) wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD1, iAmount);//"포상: 경험치 %d포인트"
		}
		else {
#if DEF_LANGUAGE == 4	//언어:English
			wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD2, iAmount, cRewardName);
#else
			wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD2, cRewardName, iAmount);
#endif
		}

		m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
		iIndex++;

		m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
		iIndex++;

		ZeroMemory(cTxt, sizeof(cTxt));
		if (iPreCon < m_iContribution) 
			 wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD3, m_iContribution - iPreCon);//"공헌도가 %d포인트 상승했습니다."
		else wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD4, iPreCon - m_iContribution);//"공헌도가 %d포인트 하락했습니다." 
		
		m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
		iIndex++;
	}
	else EnableDialogBox(21, 0, sWho+120, 0);// 퀘스트는 완료되었으나 포상을 받을 수 없는 조건이라서 클리어 되지 못하는 상태
}

void CGame::NotifyMsg_RatingPlayer(char * pData)
{
// int * ip;
 char * cp, cName[12];
 WORD  cValue;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	cValue = *cp;
	cp++;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

//	ip = (int *)cp;
//	m_iRating = *ip;
	cp += 4;

	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	if (memcmp(m_cPlayerName, cName, 10) == 0) {
		if (cValue == 1) {
			 strcpy(G_cTxt, NOTIFYMSG_RATING_PLAYER1);//"다른 플레이어로부터 좋은 평가를 받았습니다."
			 PlaySound('E', 23, 0);
 		}
	}
	else {
		if (cValue == 1)
			 wsprintf(G_cTxt, NOTIFYMSG_RATING_PLAYER2, cName);//"캐릭터(%s)에게 좋은 평가를 내렸습니다."
		else wsprintf(G_cTxt, NOTIFYMSG_RATING_PLAYER3, cName);//"캐릭터(%s)에게 나쁜 평가를 내렸습니다."
	}
	AddEventList(G_cTxt, 10); 
}


void CGame::NotifyMsg_ServerChange(char * pData)
{
 char * cp, cGameServerAddr[16];
 int * ip, iGameServerPort;

	ZeroMemory(m_cMapName, sizeof(m_cMapName));
	ZeroMemory(m_cMapMessage, sizeof(m_cMapMessage));
	ZeroMemory(cGameServerAddr, sizeof(cGameServerAddr));

	// v1.43
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
    memcpy(m_cMapName, cp, 10);
	
//	m_cMapIndex = GetOfficialMapName(m_cMapName, m_cMapMessage);
	cp += 10;

	memcpy(cGameServerAddr, cp, 15);
	cp += 15;

	ip = (int *)cp;
	iGameServerPort = *ip;
	cp += 4;

	// 현재의 접속을 끊고 새로 접속을 한다. 
	if (m_pGSock != NULL) {
		delete m_pGSock;
		m_pGSock = NULL;	
	}

	if (m_pLSock != NULL) {
		delete m_pLSock;
		m_pLSock = NULL;	
	}
 
	m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
#ifdef DEF_USING_GATEWAY
	m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT); // v2.04 Gateway 사용시
#else
	m_pLSock->bConnect(cGameServerAddr, iGameServerPort, WM_USER_LOGSOCKETEVENT); // v2.04 Gateway
#endif
	m_pLSock->bInitBufferSize(30000);
	
	m_bIsPoisoned = FALSE;

	// 게임모드 변환 
	ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
	m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
	//m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW; //Gateway
	m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW_TOWLSBUTMLS;
	ZeroMemory(m_cMsg, sizeof(m_cMsg));
	strcpy(m_cMsg,"55");
}

void CGame::NotifyMsg_SetItemCount(char * pData)
{
 char  * cp;
 WORD  * wp;
 DWORD * dwp;
 short  sItemIndex;
 DWORD  dwCount;
 BOOL   bIsItemUseResponse;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
	sItemIndex = *wp;
	cp += 2;

	dwp = (DWORD *)cp;
	dwCount = *dwp;
	cp += 4;

	bIsItemUseResponse = (BOOL)*cp;
	cp++;

	if (m_pItemList[sItemIndex] != NULL) {
		m_pItemList[sItemIndex]->m_dwCount = dwCount;
		if (bIsItemUseResponse == TRUE) m_bIsItemDisabled[sItemIndex] = FALSE;
	}
}

void CGame::NotifyMsg_ShowMap(char * pData)
{
 char * cp;
 WORD * wp, w1, w2;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	w1 = *wp;
	cp += 2;

	wp = (WORD *)cp;
	w2 = *wp;
	cp += 2;

	if (w2 == 0) AddEventList(NOTIFYMSG_SHOW_MAP1, 10);//"현재 위치에 해당하는 지도가 없습니다." 
	else EnableDialogBox(22, NULL, w1, w2 -1);
}

void CGame::NotifyMsg_Skill(char *pData)
{
 WORD * wp;
 short sSkillIndex, sValue;
 char * cp;
 char cTxt[120];
 int i;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	wp = (WORD *)cp;
	sSkillIndex = (short)*wp;
	cp += 2;

	wp = (WORD *)cp;
	sValue = (short)*wp;
	cp += 2;

	_RemoveChatMsgListByObjectID(m_sPlayerObjectID);

	if (m_pSkillCfgList[sSkillIndex]->m_iLevel < sValue) {
		wsprintf(cTxt, NOTIFYMSG_SKILL1, m_pSkillCfgList[sSkillIndex]->m_cName, sValue - m_pSkillCfgList[sSkillIndex]->m_iLevel);
		               //"Skill %s: %d%% 증가했습니다."
		AddEventList(cTxt, 10);

		PlaySound('E', 23, 0);

		for (i = 1; i < DEF_MAXCHATMSGS; i++) 
		if (m_pChatMsgList[i] == NULL) {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%s +%d%%", m_pSkillCfgList[sSkillIndex]->m_cName, sValue - m_pSkillCfgList[sSkillIndex]->m_iLevel);
			m_pChatMsgList[i] = new class CMsg(20, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
			
			if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == FALSE) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			break;
		}
	}
	else if (m_pSkillCfgList[sSkillIndex]->m_iLevel > sValue) {
		wsprintf(cTxt, NOTIFYMSG_SKILL2, m_pSkillCfgList[sSkillIndex]->m_cName, m_pSkillCfgList[sSkillIndex]->m_iLevel - sValue);
		               //"Skill %s: %d%% 감소했습니다." 
		AddEventList(cTxt, 10);
		
		PlaySound('E', 24, 0);

		for (i = 1; i < DEF_MAXCHATMSGS; i++) 
		if (m_pChatMsgList[i] == NULL) {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%s -%d%%", m_pSkillCfgList[sSkillIndex]->m_cName, sValue - m_pSkillCfgList[sSkillIndex]->m_iLevel);
			m_pChatMsgList[i] = new class CMsg(20, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
			
			if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == FALSE) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			break;
		}
	}
	m_pSkillCfgList[sSkillIndex]->m_iLevel = sValue;
	m_cSkillMastery[sSkillIndex] = (unsigned char)sValue;
}


void CGame::NotifyMsg_SkillTrainSuccess(char * pData)
{
 char * cp, cSkillNum, cSkillLevel;
 char cTemp[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cSkillNum = *cp;
	cp++;

	cSkillLevel = *cp;
	cp++;
   	
	ZeroMemory(cTemp, sizeof(cTemp));
	wsprintf(cTemp, NOTIFYMSG_SKILL_TRAIN_SUCCESS1, m_pSkillCfgList[cSkillNum]->m_cName, cSkillLevel);
	              //"기술(%s): 새로 배웠습니다! 기술 수준은 %d%%입니다."
	AddEventList(cTemp, 10);

	m_pSkillCfgList[cSkillNum]->m_iLevel = cSkillLevel;
	m_cSkillMastery[cSkillNum] = (unsigned char)cSkillLevel;

	PlaySound('E', 23, 0);
}

void CGame::NotifyMsg_SkillUsingEnd(char * pData)
{
 char * cp;
 WORD * wp, wResult;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	wp = (WORD *)cp;
	wResult = * wp;

	switch (wResult) {
	case NULL:
		AddEventList(NOTIFYMSG_SKILL_USINGEND1, 10);
		              //"기술 사용 실패!" 
		break;

	case 1:
		AddEventList(NOTIFYMSG_SKILL_USINGEND2, 10);
		              //"기술 사용 성공!"
		break;
	}

	m_bSkillUsingStatus = FALSE;
}

void CGame::NotifyMsg_SP(char * pData)
{
 DWORD * dwp;
 int iPrevSP;

	iPrevSP = m_iSP;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	m_iSP = (int)*dwp;

	// 10미만의 변동에 대해서는 무시한다.
	if (abs(m_iSP - iPrevSP) < 10) return;

	if (m_iSP > iPrevSP) {
		wsprintf(G_cTxt, NOTIFYMSG_SP_UP, m_iSP - iPrevSP);//"SP가 %d포인트 증가했습니다."
		AddEventList(G_cTxt, 10);
		PlaySound('E', 21, 0);
	}
	else {
		wsprintf(G_cTxt, NOTIFYMSG_SP_DOWN, iPrevSP - m_iSP);//"SP가 %d포인트 감소했습니다."
		AddEventList(G_cTxt, 10);
	}
}

void CGame::NotifyMsg_TotalUsers(char * pData)
{
	WORD *wp;
	int iTotal;
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iTotal = (int)*wp;
	wsprintf(G_cTxt, NOTIFYMSG_TOTAL_USER1, iTotal);//"현재 총 사용자 수는 %d명입니다."
	AddEventList(G_cTxt, 10);
}

void CGame::NotifyMsg_WhisperMode(BOOL bActive, char * pData)
{
	char cName[12], *cp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	if (bActive == TRUE) 
	{
		wsprintf(G_cTxt, NOTIFYMSG_WHISPERMODE1, cName);//"%s님과의 귓속말 상태가 설정되었습니다."
		if (m_pWhisperMsg[DEF_MAXWHISPERMSG - 1] != NULL) {
			delete m_pWhisperMsg[DEF_MAXWHISPERMSG - 1];
			m_pWhisperMsg[DEF_MAXWHISPERMSG - 1] = NULL;
		}
		for (int i = DEF_MAXWHISPERMSG - 2; i >= 0; i--) {
			m_pWhisperMsg[i+1] = m_pWhisperMsg[i];
			m_pWhisperMsg[i] = NULL;
		}
		m_pWhisperMsg[0] = new class CMsg(NULL, cName, NULL);
		m_cWhisperIndex = 0;
	}
	else wsprintf(G_cTxt, NOTIFYMSG_WHISPERMODE2, cName);//"귓속말 상태가 해제되었습니다."

	AddEventList(G_cTxt, 10);
}

void CGame::DrawDialogBox_CrusadeJob(short msX, short msY)
{
 short sX, sY;
 	
	sX = m_stDialogBoxInfo[33].sX;
	sY = m_stDialogBoxInfo[33].sY;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);

	switch (m_stDialogBoxInfo[33].cMode) {
	case 1:
		PutAlignedString(sX +24, sX +246, sY +45+20, DRAWDIALOGBOX_CRUSADEJOB1);//"전면전 기간 동안 당신이 맡을 역할을"
		PutAlignedString(sX +24, sX +246, sY +60+20, DRAWDIALOGBOX_CRUSADEJOB2);//"결정합니다. 당신의 현재 상태에서"
		PutAlignedString(sX +24, sX +246, sY +75+20, DRAWDIALOGBOX_CRUSADEJOB3);//"맡을 수 있는 역할이 아래에 표시됩니다."
		PutAlignedString(sX +24, sX +246, sY +90+20, DRAWDIALOGBOX_CRUSADEJOB4);//"원하는 역할을 클릭하세요."

		if( m_bCitizen == TRUE )
		{
			if( m_bAresden )
			{
				// 아레스덴 소속 
				if (m_iGuildRank == 0) {
					// 무조건 지휘관
					if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))  
						 PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB5, 255,255,255);//"지휘관(Commander)"
 					else PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB5, 4,0,50);//"지휘관(Commander)"
				}
				else {
					// 군인 아니면 공병 
					if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))  
						 PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB7, 255,255,255);//"군인(Soldier)"
 					else PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB7, 4,0,50);//"군인(Soldier)"
					
					// 길드 소속이면 건축가 가능 
					if (m_iGuildRank != -1) {
						if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 175) && (msY < sY + 190))  
							 PutAlignedString(sX +24, sX +246, sY+175, DRAWDIALOGBOX_CRUSADEJOB9, 255,255,255);//"건축가(Constructor)"
 						else PutAlignedString(sX +24, sX +246, sY+175, DRAWDIALOGBOX_CRUSADEJOB9, 4,0,50);//"건축가(Constructor)"
					}
				}
			}
			else if( m_bAresden == FALSE )
			{
				// 엘바인 소속 
				if (m_iGuildRank == 0) {
					// 무조건 지휘관
					if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))  
						 PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB5, 255,255,255);//"지휘관(Commander)"
 					else PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB5, 4,0,50);//"지휘관(Commander)"
				}
				else {
					// 군인 아니면 공병 
					if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))  
						 PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB7, 255,255,255);//"군인(Soldier)"
 					else PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB7, 4,0,50);//"군인(Soldier)"

					// 길드 소속이면 건축가 가능 
					if (m_iGuildRank != -1) {
						if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 175) && (msY < sY + 190))  
							 PutAlignedString(sX +24, sX +246, sY+175, DRAWDIALOGBOX_CRUSADEJOB9, 255,255,255);//"건축가(Constructor)"
 						else PutAlignedString(sX +24, sX +246, sY+175, DRAWDIALOGBOX_CRUSADEJOB9, 4,0,50);//"건축가(Constructor)"
					}
				}
			}
		}

		PutAlignedString(sX +24, sX +246, sY +290 -40,   DRAWDIALOGBOX_CRUSADEJOB10);//"각각의 역할에 대해 보다 자세하게 알고"
		PutAlignedString(sX +24, sX +246, sY +305 -40,   DRAWDIALOGBOX_CRUSADEJOB17);//"싶으면 아래의 Help 버튼을 누르십시오."

		if ((msX > sX + 210) && (msX < sX + 260) && (msY >= sY + 296) && (msY <= sY + 316)) 
			 PutString_SprFont(sX +50+160, sY +296, "Help", 6,6,20);
		else PutString_SprFont(sX +50+160, sY +296, "Help", 0, 0, 7);
		break;

	case 2:
		PutAlignedString(sX +24, sX +246, sY +90+20, DRAWDIALOGBOX_CRUSADEJOB18);
		                                            //"전면전 기간 동안 당신이 맡은 역할은"
		switch (m_iCrusadeDuty) {
		case 1: PutAlignedString(sX +24, sX +246, sY+125, DRAWDIALOGBOX_CRUSADEJOB19); break;//"군인(Soldier) 입니다."
		case 2: PutAlignedString(sX +24, sX +246, sY+125, DRAWDIALOGBOX_CRUSADEJOB20); break;//"건축가(Constructor) 입니다."
		case 3: PutAlignedString(sX +24, sX +246, sY+125, DRAWDIALOGBOX_CRUSADEJOB21); break;//"지휘관(Commander) 입니다."
		}
		
		PutAlignedString(sX +24, sX +246, sY +145, DRAWDIALOGBOX_CRUSADEJOB22);//"맡은 역할에 대한 자세한 내용을 알려면"
		if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 160) && (msY < sY + 175))  
			 PutAlignedString(sX +24, sX +246, sY+160, DRAWDIALOGBOX_CRUSADEJOB23, 255,255,255);//"여기를 클릭 하십시오."
 		else PutAlignedString(sX +24, sX +246, sY+160, DRAWDIALOGBOX_CRUSADEJOB23, 4,0,50);//"여기를 클릭 하십시오."

		PutAlignedString(sX +24, sX +246, sY +175, DRAWDIALOGBOX_CRUSADEJOB25);//"다른 역할을 맡고 싶다면 시청에 있는"
		PutAlignedString(sX +24, sX +246, sY +190, DRAWDIALOGBOX_CRUSADEJOB26);//"행정관을 찾아 가십시오." 

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	}
}

void CGame::_Draw_OnLogin(char *pAccount, char *pPassword, int msX, int msY, int iFrame)
{
 BOOL bFlag = TRUE;
 DWORD dwTime = timeGetTime();

    m_DDraw.ClearBackB4();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0,0,0, TRUE);
	DrawVersion();
	
	if ((iFrame >= 15) && (iFrame <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->PutTransSprite25(39,121, 2, TRUE);
	else if (iFrame > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 39,121, 2, TRUE);
	
	if (m_cCurFocus != 1) { 
		if (m_Misc.bCheckValidName(pAccount) != FALSE)
			 PutString2(180, 162, pAccount, 200,200,200);
		else PutString2(180, 162, pAccount, 200,100,100);
	}
	if ((m_Misc.bCheckValidName(pAccount) == FALSE) || (strlen(pAccount) == 0)) bFlag = FALSE;

	if (m_cCurFocus != 2) {
		if ((m_Misc.bCheckValidString(pPassword) != FALSE))
			 PutString(180, 185, pPassword, RGB(200,200,200), TRUE, 1);
		else PutString(180, 185, pPassword, RGB(200,100,100), TRUE, 1);
	}
	if ((m_Misc.bCheckValidString(pPassword) == FALSE) || (strlen(pPassword) == 0)) bFlag = FALSE;

	if (m_cCurFocus == 1)
		ShowReceivedString(); 
	else 
	if (m_cCurFocus == 2) 
		ShowReceivedString(TRUE); 
	
#if DEF_LANGUAGE == 2	//언어:Chinese
	if (bFlag == TRUE) {
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 95,270, 3, TRUE);
	}
	if (m_cCurFocus == 4) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 268,272,4, TRUE);
#else
	if (bFlag == TRUE) {
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 80,282, 3, TRUE);
	}
	#ifndef DEF_JAPAN_FOR_TERRA
		if (m_cCurFocus == 4) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256,282,4, TRUE);
	#else
		if (m_cCurFocus == 4) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256,282,7, TRUE);
	#endif
#endif
	

	// 마우스 커서 그린다.
	if ((m_bIsHideLocalCursor != TRUE) && (msX != 0) && (msY != 0)) {
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	}
}


void CGame::ShowEventList(DWORD dwTime)
{
 int i;

	m_DDraw._GetBackBufferDC();

	for (i = 0; i < 6; i++) 
	if ((dwTime - m_stEventHistory[i].dwTime) < 5000) {
		switch (m_stEventHistory[i].cColor) {
		case 0:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(225,225,225), FALSE, 1, TRUE);
			break;
		case 1:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(130,255,130), FALSE, 1, TRUE);
			break;
		case 2:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(255,130,130), FALSE, 1, TRUE);
			break;
		case 3:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(130,130,255), FALSE, 1, TRUE);
			break;
		case 4:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(230, 230, 130), FALSE, 1, TRUE);
			break;
		case 10:
			// 공지사항 메시지
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(180,255,180), FALSE, 1, TRUE);
			break;
		case 20:
			// 귓속말 
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(150,150,170), FALSE, 1, TRUE);
			break;
		}
	}

	for (i = 0; i < 6; i++) 
	if ((dwTime - m_stEventHistory2[i].dwTime) < 5000) {
		
		switch (m_stEventHistory2[i].cColor) {
		case 0:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(225,225,225), FALSE, 1, TRUE);
			break;
		case 1:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(130,255,130), FALSE, 1, TRUE);
			break;
		case 2:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(255,130,130), FALSE, 1, TRUE);
			break;
		case 3:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(130,130,255), FALSE, 1, TRUE);
			break;
		case 4:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(230, 230, 130), FALSE, 1, TRUE);
			break;
		case 10:
			// 공지사항 메시지
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(180,255,180), FALSE, 1, TRUE);
			break;
		case 20:
			// 귓속말 
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(150,150,170), FALSE, 1, TRUE);
			break;
		}
	}

	if (m_bSkillUsingStatus	== TRUE) {		
		PutString(280 -29, 280 -52, SHOW_EVENT_LIST1, RGB(235,235,235), FALSE, 1, TRUE);
		                            //"기술을 사용하고 있습니다..."
	}

	m_DDraw._ReleaseBackBufferDC();
}

void CGame::RequestTeleportAndWaitData()
{
   	// v1.4311 만약 아레스덴 초보 던전 입구라면 레벨 검사후에 81이상이면 클라이언트에서 못들어가게 한다.
	if (strcmp(m_cMapName, "aresden") == 0) {
		if ( ((m_sPlayerX == 188) && (m_sPlayerY == 105))  || 
			 ((m_sPlayerX == 187) && (m_sPlayerY == 105))  ||
			 ((m_sPlayerX == 187) && (m_sPlayerY == 106))  || 
			 ((m_sPlayerX == 186) && (m_sPlayerY == 106))  ||
			 ((m_sPlayerX == 186) && (m_sPlayerY == 107))  ) {
			if ( (m_iLevel < 30) || (m_iLevel>80) ) {
				AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA1, 10);//"당신은 초보 던젼에 들어갈 수 없습니다. 레벨 30~80 사이의 플레이어만 가능합니다."
				return;
			}
		}
	}
	// v1.4311 만약 엘바인 초보 던전 입구라면 레벨 검사후에 81이상이면 클라이언트에서 못들어가게 한다.
	if (strcmp(m_cMapName, "elvine") == 0) {
		if ( ((m_sPlayerX == 218) && (m_sPlayerY == 109))  || 
			 ((m_sPlayerX == 217) && (m_sPlayerY == 109))  ||
			 ((m_sPlayerX == 217) && (m_sPlayerY == 110))  || 
			 ((m_sPlayerX == 216) && (m_sPlayerY == 110))  ||
			 ((m_sPlayerX == 216) && (m_sPlayerY == 111))  ) 
		{
			if ( (m_iLevel < 30) || (m_iLevel>80) ) {
				AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA1, 10);//"당신은 초보 던젼에 들어갈 수 없습니다. 레벨 30~80 사이의 플레이어만 가능합니다."
				return;
			}
		}
	}

	//정진광 수정.
	//v2.18 적 마을에서는 건물들을 이용할 수 없다. 단, 전면전시는 제외
#if DEF_LANGUAGE == 3
	if(!m_bIsCrusadeMode) // m_bIsCrusadeMode 가 TRUE 면 전면전.
	{
	   if (strcmp(m_cLocation, "elvine") == 0 && strcmp(m_cMapName, "aresden") == 0)
	   { // 엘바인유저가 아레스덴의 상점으로 들어가려 한다.
	    	if( (m_sPlayerX == 180) && (m_sPlayerY == 206) ||
		    	(m_sPlayerX == 180) && (m_sPlayerY == 207) ||
			    (m_sPlayerX == 181) && (m_sPlayerY == 207) ||
			    (m_sPlayerX == 184) && (m_sPlayerY == 207) ||
			    (m_sPlayerX == 185) && (m_sPlayerY == 206) )// 여까지는 텔레포트 타일..
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 엘바인 유저가 아레스덴 상점에 들어가려는 처리...

	   if (strcmp(m_cLocation, "elvine") == 0 && strcmp(m_cMapName, "aresden") == 0)
	   { // 엘바인유저가 아레스덴의 길드홀로 들어가려 한다.
	    	if( (m_sPlayerX == 167) && (m_sPlayerY == 136) ||
		    	(m_sPlayerX == 166) && (m_sPlayerY == 137) ||
			    (m_sPlayerX == 167) && (m_sPlayerY == 137) ||
			    (m_sPlayerX == 168) && (m_sPlayerY == 137) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 엘바인 유저가 아레스덴 길드홀에 들어가려는 처리...

	   if (strcmp(m_cLocation, "elvine") == 0 && strcmp(m_cMapName, "aresden") == 0)
	   { // 엘바인유저가 아레스덴의 구창고로 들어가려 한다.
	    	if( (m_sPlayerX == 136) && (m_sPlayerY == 210) ||
		    	(m_sPlayerX == 137) && (m_sPlayerY == 211) ||
			    (m_sPlayerX == 138) && (m_sPlayerY == 212) ||
			    (m_sPlayerX == 142) && (m_sPlayerY == 212) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 엘바인 유저가 아레스덴 구창고에 들어가려는 처리...

	   if (strcmp(m_cLocation, "elvine") == 0 && strcmp(m_cMapName, "aresden") == 0)
	   { // 엘바인유저가 아레스덴의 신창고로 들어가려 한다.
	    	if( (m_sPlayerX == 271) && (m_sPlayerY == 172) ||
		    	(m_sPlayerX == 272) && (m_sPlayerY == 173) ||
			    (m_sPlayerX == 273) && (m_sPlayerY == 174) ||
			    (m_sPlayerX == 277) && (m_sPlayerY == 174) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 엘바인 유저가 아레스덴 신창고에 들어가려는 처리...

	   if (strcmp(m_cLocation, "elvine") == 0 && strcmp(m_cMapName, "aresden") == 0)
	   { // 엘바인유저가 아레스덴의 성당으로 들어가려 한다.
	    	if( (m_sPlayerX == 239) && (m_sPlayerY == 133) ||
		    	(m_sPlayerX == 240) && (m_sPlayerY == 133) ||
			    (m_sPlayerX == 240) && (m_sPlayerY == 132) ||
			    (m_sPlayerX == 241) && (m_sPlayerY == 132) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 엘바인 유저가 아레스덴 성당에 들어가려는 처리...

	   if (strcmp(m_cLocation, "elvine") == 0 && strcmp(m_cMapName, "aresden") == 0)
	   { // 엘바인유저가 아레스덴의 시청으로 들어가려 한다.
	    	if( (m_sPlayerX == 200) && (m_sPlayerY == 162) ||
		    	(m_sPlayerX == 200) && (m_sPlayerY == 163) ||
			    (m_sPlayerX == 199) && (m_sPlayerY == 163) ||
			    (m_sPlayerX == 198) && (m_sPlayerY == 163) ||
				(m_sPlayerX == 189) && (m_sPlayerY == 169) ||
		    	(m_sPlayerX == 190) && (m_sPlayerY == 169) ||
			    (m_sPlayerX == 191) && (m_sPlayerY == 169) ||
			    (m_sPlayerX == 191) && (m_sPlayerY == 168) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 엘바인 유저가 아레스덴 시청에 들어가려는 처리...

	   if (strcmp(m_cLocation, "elvine") == 0 && strcmp(m_cMapName, "aresden") == 0)
	   { // 엘바인유저가 아레스덴의 마법타워로 들어가려 한다.
	    	if( (m_sPlayerX == 67) && (m_sPlayerY == 160) ||
		    	(m_sPlayerX == 68) && (m_sPlayerY == 160) ||
			    (m_sPlayerX == 69) && (m_sPlayerY == 159) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 엘바인 유저가 아레스덴 마법타워에 들어가려는 처리...

	   if (strcmp(m_cLocation, "elvine") == 0 && strcmp(m_cMapName, "aresden") == 0)
	   { // 엘바인유저가 아레스덴의 대장간으로 들어가려 한다.
	    	if( (m_sPlayerX == 211) && (m_sPlayerY == 240) ||
		    	(m_sPlayerX == 211) && (m_sPlayerY == 241) ||
			    (m_sPlayerX == 212) && (m_sPlayerY == 241) ||
			    (m_sPlayerX == 223) && (m_sPlayerY == 234) ||
			    (m_sPlayerX == 223) && (m_sPlayerY == 235) ||
				(m_sPlayerX == 222) && (m_sPlayerY == 235) ||
			    (m_sPlayerX == 221) && (m_sPlayerY == 235) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 엘바인 유저가 아레스덴 대장간에 들어가려는 처리...


	   if (strcmp(m_cLocation, "aresden") == 0 && strcmp(m_cMapName, "elvine") == 0)
	   { // 아레스덴유저가 엘바인의 상점으로 들어가려 한다.
	    	if( (m_sPlayerX == 273) && (m_sPlayerY == 131) ||
		    	(m_sPlayerX == 273) && (m_sPlayerY == 132) ||
			    (m_sPlayerX == 274) && (m_sPlayerY == 132) ||
			    (m_sPlayerX == 277) && (m_sPlayerY == 132) ||
			    (m_sPlayerX == 278) && (m_sPlayerY == 131) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 아레스덴 유저가 엘바인 상점에 들어가려는 처리...

	   if (strcmp(m_cLocation, "aresden") == 0 && strcmp(m_cMapName, "elvine") == 0)
	   { // 아레스덴유저가 엘바인의 길드홀로 들어가려 한다.
	    	if( (m_sPlayerX == 101) && (m_sPlayerY == 176) ||
		    	(m_sPlayerX == 100) && (m_sPlayerY == 177) ||
			    (m_sPlayerX == 101) && (m_sPlayerY == 177) ||
			    (m_sPlayerX == 102) && (m_sPlayerY == 177) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 아레스덴 유저가 엘바인 길드홀에 들어가려는 처리...

	   if (strcmp(m_cLocation, "aresden") == 0 && strcmp(m_cMapName, "elvine") == 0)
	   { // 아레스덴유저가 엘바인의 훈련소로 들어가려 한다.
	    	if( (m_sPlayerX == 199) && (m_sPlayerY == 104) ||
		    	(m_sPlayerX == 198) && (m_sPlayerY == 104) ||
			    (m_sPlayerX == 198) && (m_sPlayerY == 105) ||
			    (m_sPlayerX == 197) && (m_sPlayerY == 105) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 아레스덴 유저가 엘바인 훈련소에 들어가려는 처리...
	   
	   if (strcmp(m_cLocation, "aresden") == 0 && strcmp(m_cMapName, "elvine") == 0)
	   { // 아레스덴유저가 엘바인의 구창고로 들어가려 한다.
	    	if( (m_sPlayerX == 257) && (m_sPlayerY == 163) ||
		    	(m_sPlayerX == 258) && (m_sPlayerY == 164) ||
			    (m_sPlayerX == 259) && (m_sPlayerY == 165) ||
			    (m_sPlayerX == 263) && (m_sPlayerY == 165) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 아레스덴 유저가 엘바인 구창고에 들어가려는 처리...

	   if (strcmp(m_cLocation, "aresden") == 0 && strcmp(m_cMapName, "elvine") == 0)
	   { // 아레스덴유저가 엘바인의 신창고로 들어가려 한다.
	    	if( (m_sPlayerX == 249) && (m_sPlayerY == 250) ||
		    	(m_sPlayerX == 250) && (m_sPlayerY == 251) ||
			    (m_sPlayerX == 251) && (m_sPlayerY == 252) ||
			    (m_sPlayerX == 255) && (m_sPlayerY == 252) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 아레스덴 유저가 엘바인 신창고에 들어가려는 처리...
	   
	   if (strcmp(m_cLocation, "aresden") == 0 && strcmp(m_cMapName, "elvine") == 0)
	   { // 아레스덴유저가 엘바인의 성당으로 들어가려 한다.
	    	if( (m_sPlayerX == 163) && (m_sPlayerY == 132) ||
		    	(m_sPlayerX == 162) && (m_sPlayerY == 132) ||
			    (m_sPlayerX == 162) && (m_sPlayerY == 133) ||
			    (m_sPlayerX == 161) && (m_sPlayerY == 133) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 아레스덴 유저가 엘바인 성당에 들어가려는 처리...

	   if (strcmp(m_cLocation, "aresden") == 0 && strcmp(m_cMapName, "elvine") == 0)
	   { // 아레스덴유저가 엘바인의 시청으로 들어가려 한다.
	    	if( (m_sPlayerX == 182) && (m_sPlayerY == 178) ||
		    	(m_sPlayerX == 181) && (m_sPlayerY == 178) ||
			    (m_sPlayerX == 181) && (m_sPlayerY == 179) ||
			    (m_sPlayerX == 180) && (m_sPlayerY == 179) ||
				(m_sPlayerX == 173) && (m_sPlayerY == 184) ||
		    	(m_sPlayerX == 173) && (m_sPlayerY == 185) ||
			    (m_sPlayerX == 172) && (m_sPlayerY == 185) ||
			    (m_sPlayerX == 171) && (m_sPlayerY == 185) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 아레스덴 유저가 엘바인 시청에 들어가려는 처리...

	   if (strcmp(m_cLocation, "aresden") == 0 && strcmp(m_cMapName, "elvine") == 0)
	   { // 아레스덴유저가 엘바인의 마탑으로 들어가려 한다.
	    	if( (m_sPlayerX == 98) && (m_sPlayerY == 108) ||
		    	(m_sPlayerX == 99) && (m_sPlayerY == 108) ||
			    (m_sPlayerX == 100) && (m_sPlayerY == 107) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 아레스덴 유저가 엘바인 마탑에 들어가려는 처리...

	   if (strcmp(m_cLocation, "aresden") == 0 && strcmp(m_cMapName, "elvine") == 0)
	   { // 아레스덴유저가 엘바인의 대장간으로 들어가려 한다.
	    	if( (m_sPlayerX == 313) && (m_sPlayerY == 168) ||
		    	(m_sPlayerX == 313) && (m_sPlayerY == 169) ||
			    (m_sPlayerX == 314) && (m_sPlayerY == 169) ||
				(m_sPlayerX == 325) && (m_sPlayerY == 162) ||
			    (m_sPlayerX == 325) && (m_sPlayerY == 163) ||
				(m_sPlayerX == 324) && (m_sPlayerY == 163) ||
			    (m_sPlayerX == 323) && (m_sPlayerY == 163) )
			{
			    AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA2, 10);//"적 마을의 건물은 이용할 수 없습니다."
			    return;
			}
	   } // 아레스덴 유저가 엘바인 대장간에 들어가려는 처리...
	}//Close 전면전인지 아닌지의 여부..
#endif	
	//정진광 수정, 여기까지...

	bSendCommand(MSGID_REQUEST_TELEPORT, NULL, NULL, NULL, NULL, NULL, NULL);
	ChangeGameMode(DEF_GAMEMODE_ONWAITINGINITDATA);
}

void CGame::InitDataResponseHandler(char * pData)
{
 int * ip, i;
 short * sp, sX, sY;
 char  * cp, cMapFileName[32], cTxt[120], cPreCurLocation[12];
 BOOL  bIsObserverMode;
 HANDLE hFile;
 DWORD  dwFileSize;

	ZeroMemory( cPreCurLocation, sizeof(cPreCurLocation) );
	// 맵이 변경되었으므로 해당되는 데이터를 초기화한다.
	m_bParalyze = FALSE;
	m_pMapData->Init();

	m_sMonsterID = 0;
	m_dwMonsterEventTime = 0;

	// 닫혀야 하는 다이얼로그 박스들 
	DisableDialogBox(7);
	DisableDialogBox(11);
	DisableDialogBox(13);
	DisableDialogBox(14);
	DisableDialogBox(16);
	DisableDialogBox(22);
	DisableDialogBox(20);
	DisableDialogBox(21);
	DisableDialogBox(23);//아이템 팔거나 수리하는 Dialog

	m_cCommand = DEF_OBJECTSTOP;
	
	//m_bCommandAvailable = TRUE;
	m_cCommandCount = 0;

	m_bIsGetPointingMode = FALSE;
	m_iPointCommandType  = -1; //v2.15 NULL -> -1

	// v2.05 환각 효과 초기화
	m_iIlusionOwnerH = NULL;
	m_cIlusionOwnerType = NULL;

	// v1.433
	m_bIsTeleportRequested = FALSE;

	// v2.173 2002-7-11 혼란 효과 초기화 
	m_bIsConfusion = FALSE;
	// v2.173 2002-7-18 스킬 사용중 초기화 
	m_bSkillUsingStatus = FALSE;
	// v2.17 2002-7-15 서버 이동후 약 않먹어 지는 버그 수정 
	m_bItemUsingStatus = FALSE ;

	m_cRestartCount = -1;
	m_dwRestartCountTime = NULL;
	
	for (i = 0; i < DEF_MAXEFFECTS; i++) {
		if (m_pEffectList[i] != NULL) delete m_pEffectList[i];
		m_pEffectList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXWHETHEROBJECTS; i++) {
		m_stWhetherObject[i].sX    = 0;
		m_stWhetherObject[i].sY    = 0;
		m_stWhetherObject[i].cStep = 0;
	}

	for (i = 0; i < DEF_MAXGUILDNAMES; i++) {
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		ZeroMemory(m_stGuildName[i].cCharName, sizeof(m_stGuildName[i].cCharName));
		ZeroMemory(m_stGuildName[i].cGuildName, sizeof(m_stGuildName[i].cGuildName));
	} 

	// v1.411 채팅 메시지 다 삭제 
	for (i = 0; i < DEF_MAXCHATMSGS; i++) {
		if (m_pChatMsgList[i] != NULL) delete m_pChatMsgList[i];
		m_pChatMsgList[i] = NULL;
	}
	//

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	
	// Player의 ObjectID 
	sp = (short *)cp;
	m_sPlayerObjectID = *sp;
	cp += 2;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerType = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr1 = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr2 = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr3 = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr4 = *sp;
	cp += 2;

	ip = (int *)cp; // v1.4
	m_iPlayerApprColor = *ip;
	cp += 4;

	sp = (short *)cp;
	m_sPlayerStatus = *sp;
	cp += 2;

	// (!) 맵을 할당한다.
	ZeroMemory(m_cMapName, sizeof(m_cMapName));
	ZeroMemory(m_cMapMessage, sizeof(m_cMapMessage));
	memcpy(m_cMapName, cp, 10);
	m_cMapIndex = GetOfficialMapName(m_cMapName, m_cMapMessage);
	if( m_cMapIndex < 0 )
	{
		m_stDialogBoxInfo[9].sSizeX = -1;
		m_stDialogBoxInfo[9].sSizeY = -1;
	}
	else
	{
		m_stDialogBoxInfo[9].sSizeX = 128;
		m_stDialogBoxInfo[9].sSizeY = 128;
	}
	cp += 10;

	strcpy( cPreCurLocation, m_cCurLocation );
	ZeroMemory(m_cCurLocation, sizeof(m_cCurLocation));
	memcpy(m_cCurLocation, cp, 10);
	cp += 10;

	// 주야간 모드를 가져온다. 
	G_cSpriteAlphaDegree = *cp;
	cp++;

	// 날씨 모드를 가져온다. 0이면 무의미, 1이상이면 기상 상태 작동 
	m_cWhetherStatus = *cp;
	cp++;

	// v1.4 
	ip = (int *)cp;
	m_iContribution = *ip;
	cp += 4;

	// v1.41 
	bIsObserverMode = (BOOL)*cp;
	cp++;

	ip = (int *)cp;
//	m_iRating = *ip;
	cp += 4;

	// v1.431
	ip = (int *)cp;
	m_iHP = *ip;
	cp += 4;

	//testcode
    m_cDiscount = (char )*cp;
    cp++;

	if (m_cWhetherStatus != NULL) 
		 SetWhetherStatus(TRUE, m_cWhetherStatus);
	else SetWhetherStatus(FALSE, m_cWhetherStatus);

	ZeroMemory(cMapFileName, sizeof(cMapFileName));
	strcat(cMapFileName, "mapdata\\");
	strcat(cMapFileName, m_cMapName);
	strcat(cMapFileName, ".amd");
	m_pMapData->OpenMapDataFile(cMapFileName);

	m_pMapData->m_sPivotX = sX;
	m_pMapData->m_sPivotY = sY;
	// 기준점을 정함과 동시에 맵데이터가 로딩된다.
 
	m_sPlayerX   = sX + 14 + 5;
	m_sPlayerY   = sY + 12 + 5;

	m_cPlayerDir = 5;
	
	// 관람 모드라면 설정하지 않는다. 
	if (bIsObserverMode == FALSE) {
		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, 
							                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
											  m_sPlayerStatus, m_cPlayerName, 
											  DEF_OBJECTSTOP, NULL, NULL, NULL);
	}
	
	// 뷰포트 설정
	m_sViewDstX = m_sViewPointX = (sX+4+5)*32;
	m_sViewDstY = m_sViewPointY = (sY+5+5)*32;

	// 맵데이터를 읽어 초기화한다.
	_ReadMapData(sX + 4 + 5, sY + 5 + 5, cp);

	m_bIsRedrawPDBGS = TRUE;

	// -------- 이곳에서 현재 맵의 이름에 따른 메시지를 보여준다 --------------+ 
	wsprintf(cTxt, INITDATA_RESPONSE_HANDLER1, m_cMapMessage);//"이곳은 %s입니다."
	AddEventList(cTxt, 10);

#if DEF_LANGUAGE > 2
	m_stDialogBoxInfo[6].sX  =  150;
    m_stDialogBoxInfo[6].sY  =  130;

	//	정진광 .. 20021209 프리PK지역 경고 메시지..
	if(	( memcmp( m_cCurLocation, "middleland"	,10 ) == 0 ) ||
		( memcmp( m_cCurLocation, "dglv2"		, 5 ) == 0 ) ||
		( memcmp( m_cCurLocation, "middled1n"	, 9 ) == 0 )	)
    	EnableDialogBox(6, NULL,NULL, NULL);
	
	BOOL bPrevSafe, bNowSafe;
	if( memcmp( cPreCurLocation, m_cLocation, 3 ) == 0 )
		bPrevSafe = TRUE;
	else bPrevSafe = FALSE;

	if( memcmp( m_cCurLocation, m_cLocation, 3 ) == 0 )
		bNowSafe = TRUE;
	else bNowSafe = FALSE;

	if( memcmp( m_cCurLocation, "2nd", 3 ) == 0 ) bNowSafe = TRUE;//약속의땅은 안전하다.
	if( m_iPKCount != 0 ) bNowSafe = FALSE;//PK는 어디가든 불안하지...

	if( bPrevSafe )
	{
		if( bNowSafe == FALSE ) SetTopMsg(DEF_MSG_DANGERZONE, 5);//"이곳은 다른 플레이어의 공격으로부터 보호받을 수 없습니다."
	}
	else
	{
		if( bNowSafe ) SetTopMsg(DEF_MSG_SAFEZONE, 5);//"이곳은 안전한 곳입니다."
	}

#endif
	
    // ------------------------------------------------------------------------+
   
	// 메인 게임모드로 변환.
	ChangeGameMode(DEF_GAMEMODE_ONMAINGAME);
	m_DDraw.ClearBackB4();
	
	//v1.41
	if ((m_sPlayerAppr2 & 0xF000) != 0) 
		 m_bIsCombatMode = TRUE;
	else m_bIsCombatMode = FALSE;

	//v1.42
	if (m_bIsFirstConn == TRUE) {
		m_bIsFirstConn = FALSE;
	
		// 공지사항 파일 사이즈를 읽는다.
		hFile = CreateFile("contents\\contents1000.txt", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
		if (hFile == INVALID_HANDLE_VALUE) 
			dwFileSize = 0;
		else {
			dwFileSize = GetFileSize(hFile, NULL);
			CloseHandle(hFile);
		}

		bSendCommand(MSGID_REQUEST_NOTICEMENT, NULL, NULL, (int)dwFileSize, NULL, NULL, NULL);
	}


	//cp += 2;
}

void CGame::MotionEventHandler(char * pData)
{
 WORD  * wp, wEventType, wObjectID;
 short * sp, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sStatus, sV1, sV2, sV3, sPrevAppr2;
 char  * cp, cDir, cName[12];
 int   * ip, iApprColor, iLoc;
 char    cTxt[120];
 int i;

	ZeroMemory(cName, sizeof(cName));
	sV1 = sV2 = sV3 = NULL;
	
	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wEventType = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	wp = (WORD *)cp;
	wObjectID = *wp;
	cp += 2;
	
	iLoc = 0; // v1.4

	if (wObjectID < 30000) {
		// 모든 데이터가 들어가 있는 형식이다.
		if (wObjectID < 10000) {
			// Player의 데이터이다.
			sp  = (short *)cp;
			sX = *sp;
			cp += 2;
		
			sp  = (short *)cp;
			sY = *sp;
			cp += 2;
		
			sp  = (short *)cp;
			sType = *sp;
			cp += 2;
		
			cDir = *cp;
			cp++;

			memcpy(cName, cp, 10);
			cp += 10;

			sp  = (short *)cp;
			sAppr1 = *sp;
			cp += 2;

			sp  = (short *)cp;
			sAppr2 = *sp;
			cp += 2;

			sp  = (short *)cp;
			sAppr3 = *sp;
			cp += 2;

			sp  = (short *)cp;
			sAppr4 = *sp;
			cp += 2;

			ip = (int *)cp; // v1.4
			iApprColor = *ip;
			cp += 4;

			sp  = (short *)cp;
			sStatus = *sp;
			cp += 2;

			iLoc = *cp;
			cp++;
		}
		else {
			// Npc의 데이터이다.
			sp  = (short *)cp;
			sX = *sp;
			cp += 2;
		
			sp  = (short *)cp;
			sY = *sp;
			cp += 2;
		
			sp  = (short *)cp;
			sType = *sp;
			cp += 2;
		
			cDir = *cp;
			cp++;

			memcpy(cName, cp, 5);
			cp += 5;
						
			sAppr1 = sAppr3 = sAppr4 = 0;
			
			sp  = (short *)cp;
			sAppr2 = *sp;
			cp += 2;
			
			sp  = (short *)cp;
			sStatus = *sp;
			cp += 2;

			iLoc = *cp;
			cp++;
		}
	}
	else {
		// 일부 데이터만을 가진 형식이다. 
		switch (wEventType) {
		case DEF_OBJECTMAGIC:
		case DEF_OBJECTDAMAGEMOVE:
		case DEF_OBJECTDAMAGE:
			cDir = *cp;
			cp++;

			sV1 = (short)*cp; // 받은 Damage의 크기, 혹은 마법 번호  
			cp++;
			sV2 = (short)*cp; // 공격받은 무기 인덱스, 혹은 마법 시전자 수준  
			cp++;
  			break;

		case DEF_OBJECTDYING:
			cDir = *cp;
			cp++;

			sV1 = (short)*cp; // 받은 Damage의 크기, 혹은 마법 번호  
			cp++;
			sV2 = (short)*cp; // 공격받은 무기 인덱스 
			cp++;

			sp  = (short *)cp;	// 죽은 좌표 
			sX = *sp;
			cp += 2;
		
			sp  = (short *)cp;
			sY = *sp;
			cp += 2;
			break;
		
		case DEF_OBJECTATTACK:
			// 추가 정보가 붙는다. 
			cDir = *cp;
			cp++;

			sV1 = *cp;
			cp++;

			sV2 = *cp;
			cp++;

			sp = (short *)cp;
			sV3 = *sp;
			cp += 2;
			break;
		
		default:
			cDir = *cp;
			cp++;
			break;
		}
	}
	
	if ((wEventType == DEF_OBJECTNULLACTION) && (memcmp(cName, m_cPlayerName, 10) == 0))
	{				
		// 플레이어 자신의 외형이 변화했다.
		m_sPlayerType   = sType;
		m_sPlayerAppr1  = sAppr1;
		sPrevAppr2      = m_sPlayerAppr2;
		m_sPlayerAppr2  = sAppr2;
		m_sPlayerAppr3  = sAppr3;
		m_sPlayerAppr4  = sAppr4;
		m_iPlayerApprColor = iApprColor;
		m_sPlayerStatus    = sStatus;
	
		if ((sPrevAppr2 & 0xF000) == 0) {
			if ((sAppr2 & 0xF000) != 0) {
				AddEventList(MOTION_EVENT_HANDLER1, 10); //"전투모드로 전환했습니다."
				m_bIsCombatMode = TRUE;
			}
		}
		else {
			if ((sAppr2 & 0xF000) == 0) {
				AddEventList(MOTION_EVENT_HANDLER2, 10); //"평화모드로 전환했습니다."
				m_bIsCombatMode = FALSE;
			}
		}

		// v2.17 2002-7-24 탭키를 이용한 속도 방지 
		if (m_cCommand != DEF_OBJECTRUN) m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, sStatus, cName, (char)wEventType, sV1, sV2, sV3, iLoc);
	}
	else m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, sStatus, cName, (char)wEventType, sV1, sV2, sV3, iLoc);

	switch (wEventType) {
	case DEF_OBJECTMAGIC:
		// Casting 하는 마법 이름을 보여준다. 
		_RemoveChatMsgListByObjectID(wObjectID - 30000);

		for (i = 1; i < DEF_MAXCHATMSGS; i++) 
		if (m_pChatMsgList[i] == NULL) {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%s!", m_pMagicCfgList[sV1]->m_cName);
			m_pChatMsgList[i] = new class CMsg(41, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
			if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == FALSE) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			return;
		}
		break;

	case DEF_OBJECTDYING:
		_RemoveChatMsgListByObjectID(wObjectID - 30000);

		for (i = 1; i < DEF_MAXCHATMSGS; i++) 
		if (m_pChatMsgList[i] == NULL) {
			ZeroMemory(cTxt, sizeof(cTxt));
			if (sV1 > 0)
				wsprintf(cTxt, "-%dPts!", sV1); //pts
			else strcpy(cTxt, "Critical!");
			
			int iFontType;
			if ((sV1 >= 0) && (sV1 < 12))		iFontType = 21;
			else if ((sV1 >= 12) && (sV1 < 40)) iFontType = 22;
			else if ((sV1 >= 40) || (sV1 < 0))	iFontType = 23;

			m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
			
			if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == FALSE) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			return;
		}
		break;

	case DEF_OBJECTDAMAGEMOVE:
	case DEF_OBJECTDAMAGE:	
		// 플레이어가 캐스팅 중에 맞았다면 취소다. 
		if (memcmp(cName, m_cPlayerName, 10) == 0) {
			m_bIsGetPointingMode = FALSE;
			m_iPointCommandType	 = -1;  // v2.15 NULL -> -1
			// v1.41 커서 모양 변경 
			m_stMCursor.sCursorFrame = 0;
			
			// 사용중이었던 스킬을 제거 
			ClearSkillUsingStatus();
		}
		
		// 타격 받은 메시지를 
		_RemoveChatMsgListByObjectID(wObjectID - 30000);
		
		for (i = 1; i < DEF_MAXCHATMSGS; i++) 
		if (m_pChatMsgList[i] == NULL) {
			ZeroMemory(cTxt, sizeof(cTxt));
			
			if (sV1 != 0) {
				if (sV1 > 0)
					wsprintf(cTxt, "-%dPts", sV1); //pts
				else strcpy(cTxt, "Critical!");
				
				int iFontType;
				if ((sV1 >= 0) && (sV1 < 12))		iFontType = 21;
				else if ((sV1 >= 12) && (sV1 < 40)) iFontType = 22;
				else if ((sV1 >= 40) || (sV1 < 0))	iFontType = 23;

				m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
			}
			else {
				strcpy(cTxt, " * Failed! *");
				m_pChatMsgList[i] = new class CMsg(22, cTxt, m_dwCurTime);
				PlaySound('C', 17, 0);
			}
			m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;

			if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == FALSE) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			return;
		}
		break;
	}
}

void CGame::DrawDialogBox_Commander(int msX, int msY)
{
 short sX, sY, szX, szY, MapSzX, MapSzY;	
 DWORD dwTime = G_dwGlobalTime;
 double dV1, dV2, dV3;
 int i, tX, tY;
 
	sX = m_stDialogBoxInfo[36].sX;
	sY = m_stDialogBoxInfo[36].sY;
	szX = m_stDialogBoxInfo[36].sSizeX;

	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000*10) {
		// 10초에 한번씩 미들랜드 맵 상황을 요청한다.
		_RequestMapStatus("middleland", 3);
		_RequestMapStatus("middleland", 1);
		m_dwCommanderCommandRequestedTime = dwTime; 
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 0, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 15, FALSE, m_bDialogTrans);

	switch (m_stDialogBoxInfo[36].cMode) {
	case 0: // 일반 모드
		// 일반 아이콘 배열 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20,          sY + 322, 3, dwTime); // 텔레포트 설정 아이콘 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,      sY + 322, 1, dwTime); // 텔레포트 아이콘 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100,     sY + 322, 2, dwTime); // 소환 아이콘 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150,     sY + 322, 30,dwTime); // 건설 위치 지정 아이콘 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 
		PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER1);//"미들랜드 전쟁용 구조물 배치 상황"
		
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 텔레포트 위치 지정 
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20,          sY + 322, 17, dwTime); // 텔레포트 설정 아이콘 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER2, 255,255,255);//"미들랜드 텔레포트 위치 설정"
		}
		else if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 텔레포트 확인 화면으로 
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,  sY + 322, 15, dwTime); // 텔레포트 아이콘 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER3, 255,255,255);//"설정된 위치로 텔레포트 이동"
		}
		else if ((msX >= sX +20 +100) && (msX <= sX +20 +46 +100) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 소환 
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100,     sY + 322, 16, dwTime); // 소환 아이콘 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER4, 255,255,255);//"전쟁 유니트 소환"
		}
		else if ((msX >= sX +20 +150) && (msX <= sX +20 +46 +150) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 건설 위치 지정
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150,     sY + 322, 24,dwTime); // 건설 위치 지정 아이콘 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER5, 255,255,255);//"미들랜드 건설 위치 설정"
		}
		else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER6, 255,255,255);//"지휘관 역할에 대한 도움말"
		}
		
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);
		break;

	case 1: // 텔레포트 위치 선정 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 20, dwTime); // 뒤로 가기 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_COMMANDER7);//"텔레포트 위치로 설정할 곳에 클릭하세요."

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 뒤로가기
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 19, dwTime); // 뒤로 가기 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER8, 255,255,255);//"지휘관 메뉴 처음으로 돌아감"
		}
		else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER9, 255,255,255);//"텔레포트 위치 설정에 대한 도움말"
		}
		
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);
		
		if ((msX >= sX + 15) && (msX <= sX + 15 + 280) && (msY >= sY + 60) && (msY <= sY + 60 + 253)) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, msX, msY, 42, FALSE, TRUE); 
		}
		break; 

	case 2: // 텔레포트 확인
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,  sY + 322, 1, dwTime); // 텔레포트 아이콘 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 20, dwTime); // 뒤로 가기 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 

		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_COMMANDER10);//"설정한 위치로 텔레포트 이동"
		
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,  sY + 322, 15, dwTime); // 텔레포트 아이콘 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER11, 255,255,255);//"텔레포트 이동 확인(한번 더 클릭)"
		}
		else if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 뒤로가기
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 19, dwTime); // 뒤로 가기 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER12, 255,255,255);//"지휘관 메뉴 처음으로 돌아감"
		}
		else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER13, 255,255,255);//"텔레포트 이동 기능에 대한 도움말"
		}
		
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);
		break;

	case 3: // 소환 모드 
		if( (m_bCitizen == TRUE) && (m_bAresden == TRUE) ) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 6, dwTime); // 배틀골렘
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 5, dwTime); // 템플나이트
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 7, dwTime); // 라이트 워 비틀
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 35, dwTime); // 2.04 캐터팔트
		}
		else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) ) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 9, dwTime); // 고즈핸드 & 배틀 스티드
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 8, dwTime); // 고즈핸드
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 7, dwTime); // 라이트 워 비틀
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 35, dwTime); // 2.04 캐터팔트
		}
		
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 20, dwTime); // 뒤로 가기 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 
		
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_COMMANDER14);//"전쟁용 유니트 소환"

		wsprintf(G_cTxt, "%s %d",DRAW_DIALOGBOX_COMMANDER15, m_iConstructionPoint);//"현재 소환 포인트: %d"
		PutAlignedString(sX, sX +323, sY +190,  G_cTxt);

		if( (m_bCitizen == TRUE) && (m_bAresden == TRUE) ) {
			// 아레스덴 유니트
			if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				
				if (m_iConstructionPoint >= 3000) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 11, dwTime); // 배틀골렘
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER16, 255,255,255);//"배틀 골렘(Battle Golem)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER17, 255,255,255);//"소환 포인트 3000"
				
			}
			else if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				
				if (m_iConstructionPoint >= 2000) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 10, dwTime); // 템플나이트
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER18, 255,255,255);//"템플 나이트(Temple Knight)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER19, 255,255,255);//"소환 포인트 2000"

			}
			else if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				
				if (m_iConstructionPoint >= 1000) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 12, dwTime); // 라이트 워 비틀
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER20, 255,255,255);//"라이트 워 비틀(Light War Beetle)"   
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER21, 255,255,255);//"소환 포인트 1000"
			}
			else if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) { 
				
				if (m_iConstructionPoint >= 5000) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 29, dwTime); // v2.04 캐터팔트
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER22, 255,255,255);//"캐터팔트(Catapult)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER23, 255,255,255);//"소환 포인트 1500"
			}
			else if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +140) && (msY < sY +160)) {
				// 가드 모드
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER24, 255,255,255);//"주인을 따라다니며 보호하는 모드"
			}
			else if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +160) && (msY < sY +175)) {
				// 홀드 모드
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER25, 255,255,255);//"자기 위치를 지키는 모드"
			}
			else if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
				// 뒤로가기
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 19, dwTime); // 뒤로 가기 
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER26, 255,255,255);//"지휘관 메뉴 처음으로 돌아감"
				
			}
			else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
				// 헬프
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘		
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER27, 255,255,255);//"전쟁용 유니트 소환과 관련된 도움말"				
			}
		}
		else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) ) {
			// 엘바인 유니트
			if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 고즈 핸드 & 배틀 스티드 
				
				if (m_iConstructionPoint >= 3000) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 14, dwTime); // 고즈핸드 & 배틀 스티드
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER28, 255,255,255);//"고즈 핸드 나이트 기병(God's Hand Knight Cavalry)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER29, 255,255,255);//"소환 포인트 3000"
			}
			else if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 고즈 핸드
				
				if (m_iConstructionPoint >= 2000) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 13, dwTime); // 고즈핸드
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER30, 255,255,255);//"고즈 핸드 나이트(God's Hand Knight)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER31, 255,255,255);//"소환 포인트 2000"
			}
			else if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				// 라이트 워 비틀 
				
				if (m_iConstructionPoint >= 1000) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 12, dwTime); // 라이트 워 비틀
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER32, 255,255,255);//"라이트 워 비틀(Light War Beetle)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER33, 255,255,255);//"소환 포인트 1000"
			}
			else if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
				
				if (m_iConstructionPoint >= 5000) {
					m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 29, dwTime); // v2.04 캐터팔트
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER34, 255,255,255);//"캐터팔트(Catapult)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER35, 255,255,255);//"소환 포인트 1500"
			}
			else if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +140) && (msY < sY +160)) {
				// 가드 모드
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER36, 255,255,255);//"주인을 따라다니며 보호하는 행동 방식"
			}
			else if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +160) && (msY < sY +175)) {
				// 홀드 모드
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER37, 255,255,255);//"자기 위치를 지키는 행동 방식"
			}	
			else if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
				// 뒤로가기
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 19, dwTime); // 뒤로 가기 
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER38, 255,255,255);//"지휘관 메뉴 처음으로 돌아감"
				
			}
			else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
				// 헬프
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘		
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER39, 255,255,255);//"전쟁용 유니트 소환과 관련된 도움말"
			}
		}
	
		PutAlignedString(sX, sX +323, sY +80,  DRAW_DIALOGBOX_COMMANDER40);//"소환할 유니트의 행동 모드를 선택한 다음"
		PutAlignedString(sX, sX +323, sY +95,  DRAW_DIALOGBOX_COMMANDER41);//"유니트의 아이콘을 클릭합니다. 보다 자세한"
		PutAlignedString(sX, sX +323, sY +110, DRAW_DIALOGBOX_COMMANDER42);//"내용을 보실려면 헬프 버튼을 누르세요." 

		switch (m_stDialogBoxInfo[36].sV1) {
		case 0:
			// 호위 모드 선택됨
			PutAlignedString(sX, sX +323, sY +140,  DRAW_DIALOGBOX_COMMANDER43, 255, 255, 255);//"Guard Mode"
			PutAlignedString(sX, sX +323, sY +160,  DRAW_DIALOGBOX_COMMANDER44, 4,0,50);//"Hold Mode"
			break;
		case 1:
			// 지역 방어 모드 선택됨
			PutAlignedString(sX, sX +323, sY +140,  DRAW_DIALOGBOX_COMMANDER43, 4,0,50);//"Guard Mode"
			PutAlignedString(sX, sX +323, sY +160,  DRAW_DIALOGBOX_COMMANDER44, 255, 255, 255);//"Hold Mode"
			break;
		} 
		break;

	case 4: // 건설 위치 지정 모드
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 20, dwTime); // 뒤로 가기 
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 

		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_COMMANDER47);//"건설 위치로 설정할 곳을 클릭하세요."

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 뒤로
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 19, dwTime); // 뒤로 가기 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER48, 255,255,255);//"지휘관 메뉴 처음으로 돌아가기"
			
		}
		else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			// 헬프
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘 
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER49, 255,255,255);//"건설 위치 설정 기능과 관련된 도움말"
		}
				
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21);
		if ((msX >= sX + 15) && (msX <= sX + 15 + 280) && (msY >= sY + 60) && (msY <= sY + 60 + 253)) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, msX, msY, 41, FALSE, TRUE); 
		}
		break;
	}	

	// 특정 모드에서 전쟁용 유니트 배치 상황을 그려준다.
	switch (m_stDialogBoxInfo[36].cMode) {
	case 0:
	case 1:
	case 2:
	case 4:
		szX = NULL;
		szY = NULL;
		MapSzX = NULL;
		MapSzY = NULL;

		if (strcmp(m_cStatusMapName, "aresden") == 0) {
			szX = 250;
			szY = 250;	
		}
		else if (strcmp(m_cStatusMapName, "elvine") == 0) {
			szX = 250;
			szY = 250;
		}
		else if (strcmp(m_cStatusMapName, "middleland") == 0) {
			szX = 280;
			szY = 253;
			MapSzX = 752;
			MapSzY = 680;
		}

		if (szX != NULL) {
			// 미들랜드 전쟁용 건축물들 위치를 그린다.
			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
			if (m_stCrusadeStructureInfo[i].cType != NULL) {
				dV1 = (double)MapSzX;
				dV2 = (double)m_stCrusadeStructureInfo[i].sX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;

				dV1 = (double)MapSzY;
				dV2 = (double)m_stCrusadeStructureInfo[i].sY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;

				switch (m_stCrusadeStructureInfo[i].cType) {
				case 38:
					if (m_stCrusadeStructureInfo[i].cSide == 1)
						 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 39, FALSE, TRUE); 
					else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 37, FALSE, TRUE); 
					break;
				
				case 36:
				case 37:
				case 39:
					if (m_stCrusadeStructureInfo[i].cSide == 1)
						 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 38, FALSE, TRUE); 
					else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 36, FALSE, TRUE); 
					break;	
				case 42:
					DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 40); 
					break;
				}
			}

			// 텔레포트 위치 출력 
			if (m_iTeleportLocX != -1) {
				dV1 = (double)MapSzX;
				dV2 = (double)m_iTeleportLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
 
				dV1 = (double)MapSzY;
				dV2 = (double)m_iTeleportLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;

				if ((m_stDialogBoxInfo[36].cMode == 1) && (tY >= 100) && (tY <= 724)) {
					DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 42, FALSE, TRUE); 
				}
				else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 42, FALSE, TRUE); 
			}
			
			// 건설 위치 출력 
			if ((m_stDialogBoxInfo[36].cMode != 2) && (m_iConstructLocX != -1)) {
				dV1 = (double)MapSzX;
				dV2 = (double)m_iConstructLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;

				dV1 = (double)MapSzY;
				dV2 = (double)m_iConstructLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;

				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 41, FALSE, TRUE); 
			}

			// 플레이어의 위치: 미들랜드일때만 그려준다.
			if (strcmp(m_cMapName, "middleland") == 0) {
				dV1 = (double)m_pMapData->m_sMapSizeX;
				dV2 = (double)m_sPlayerX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;

				dV1 = (double)m_pMapData->m_sMapSizeY;
				if( dV1 == 752 ) dV1 = 680;
				dV2 = (double)m_sPlayerY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;

				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 43); 
			}
		}
		break;
	}

	switch (m_stDialogBoxInfo[36].cMode) {
	case 0:
	case 1:
	case 4:
		// 커서의 좌표 보여줌.
		if ((msX >= sX + 15) && (msX <= sX + 15 +280) && (msY >= sY + 60) && (msY <= sY + 60 +253)) {
			dV1 = (double)(msX - (sX + 15));
			dV2 = (double)(752.0f); // 미들랜드 맵 사이즈
			dV3 = (dV2*dV1)/280.0f;
			tX = (int)dV3;

			dV1 = (double)(msY - (sY + 60));
			dV2 = (double)(680.0f); // 미들랜드 맵 사이즈
			dV3 = (dV2*dV1)/253.0f;
			tY = (int)dV3;

			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > 722) tX = 722;
			if (tY > 650) tY = 650;
		
			wsprintf(G_cTxt, "%d,%d", tX, tY);
			PutString_SprFont3(msX + 10, msY -10, G_cTxt, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
		}
		break;
	}
}

void CGame::DrawDialogBox_Constructor(int msX, int msY)
{
 short sX, sY, szX, szY, MapSzX, MapSzY;	
 DWORD dwTime = G_dwGlobalTime;
 double dV1, dV2, dV3;
 int tX, tY;
 char cMapName[12];
 
	sX = m_stDialogBoxInfo[37].sX;
	sY = m_stDialogBoxInfo[37].sY;
	szX = m_stDialogBoxInfo[37].sSizeX;

	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000*10) {
		// 10초에 한번씩 텔레포트 좌표와 건설 포인트를 요청한다.
		_RequestMapStatus("middleland", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 0, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 16, FALSE, m_bDialogTrans);
	
	switch (m_stDialogBoxInfo[37].cMode) {
	case 0: // 일반 모드
		if (m_iConstructLocX != -1) {
			ZeroMemory(cMapName, sizeof(cMapName));
			GetOfficialMapName(m_cConstructMapName, cMapName);
			wsprintf(G_cTxt, DRAW_DIALOGBOX_CONSTRUCTOR1, cMapName, m_iConstructLocX, m_iConstructLocY);//"건설 위치: %s %d,%d 근처"
			PutAlignedString(sX, sX + szX, sY + 40, G_cTxt);
		}
		else PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_CONSTRUCTOR2);//"건설 위치 지정 안됨: 현재 건설 불가능"
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 322, 24, dwTime); // 건설 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 322, 30, dwTime); // 건설 아이콘 

		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,      sY + 322, 15, dwTime); // 텔레포트 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,      sY + 322, 1, dwTime); // 텔레포트 아이콘 
		
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 

		// 일반 아이콘 배열 
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR3, 255,255,255);//"건설할 전쟁 건축물 선택"
		}
		else if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR4, 255,255,255);//"지휘관이 설정한 좌표로 텔레포트 이동"
		}
		else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR5, 255,255,255);//"건설자 역할에 대한 도움말"
		}
		break;

	case 1: // 건설 메뉴 
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_CONSTRUCTOR6);//"건설할 전쟁 건축물 선택"
		PutAlignedString(sX, sX +323, sY +80,  DRAW_DIALOGBOX_CONSTRUCTOR7);//"현재 위치에 전쟁 건축물을 건설합니다."
		PutAlignedString(sX, sX +323, sY +95,  DRAW_DIALOGBOX_CONSTRUCTOR8);//"건설할 건축물 아이콘을 누르면 선택된"
		PutAlignedString(sX, sX +323, sY +110, DRAW_DIALOGBOX_CONSTRUCTOR9);//"건축물 베이스가 생성되며 건설을 완료"
		PutAlignedString(sX, sX +323, sY +125, DRAW_DIALOGBOX_CONSTRUCTOR10);//"하려면 픽액스로 건축물을 공격합니다."
		PutAlignedString(sX, sX +323, sY +140, DRAW_DIALOGBOX_CONSTRUCTOR11);//"건설이 완료되기 전까지 전쟁용 건축물은"
		PutAlignedString(sX, sX +323, sY +155, DRAW_DIALOGBOX_CONSTRUCTOR12);//"작동하지 않습니다."
		
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 27, dwTime);		// 마나 콜렉터
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 33, dwTime);		// 마나 콜렉터

		if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 28, dwTime);	// 디텍터
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 34, dwTime);	// 디텍터

		if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 26, dwTime);	// 애로우 가드 타워
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 32, dwTime);	// 애로우 가드 타워

		if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 25, dwTime);	// 캐논 가드 타워
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 31, dwTime);	// 캐논 가드 타워

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 19, dwTime); // 뒤로 가기 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 20, dwTime); // 뒤로 가기 

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 

		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR13, 255,255,255);//"마나 콜렉터(Mana Collector)"
		}
		else if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR14, 255,255,255);//"디텍터(Detector)"
		}
		else if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR15, 255,255,255);//"애로우 가드 타워(Arrow Guard Tower)"
		}
		else if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR16, 255,255,255);//"캐논 가드 타워(Cannon Guard Tower)"
		}
		else if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR17, 255,255,255);//"건설자 메뉴 처음으로 돌아감"
		}
		else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR18, 255,255,255);//"전쟁 건축물들에 대한 도움말" 
		}
		break;

	case 2: // 텔레포트 확인
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_CONSTRUCTOR19);//"지휘관이 설정한 위치로 텔레포트 이동"

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);
		
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,      sY + 322, 15, dwTime); // 텔레포트 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,      sY + 322, 1, dwTime); // 텔레포트 아이콘 
		
		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 19, dwTime); // 뒤로 가기 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 20, dwTime); // 뒤로 가기 

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 

		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR20, 255,255,255);//"텔레포트 이동 확인(한번 더 클릭)"
		}
		else if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR21, 255,255,255);//"건설자 메뉴 처음으로 돌아감"
		}
		else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR22, 255,255,255);//"텔레포트 이동 기능에 대한 도움말"
		}
		break;
	}
	
	// 텔레포트, 건설 위치 좌표 출력
	switch (m_stDialogBoxInfo[37].cMode) {
	case 0: 
	case 2:
		szX = NULL;
		szY = NULL;
		MapSzX = NULL;
		MapSzY = NULL;

		if (strcmp(m_cStatusMapName, "aresden") == 0) {
			szX = 250;
			szY = 250;	
		}
		else if (strcmp(m_cStatusMapName, "elvine") == 0) {
			szX = 250;
			szY = 250;
		}
		else if (strcmp(m_cStatusMapName, "middleland") == 0) {
			szX = 280;
			szY = 253;
			MapSzX = 752;
			MapSzY = 680;
		}

		if (szX != 0) {
			for (int i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
				if (m_stCrusadeStructureInfo[i].cType == 42) {
					dV1 = (double)MapSzX;
					dV2 = (double)m_stCrusadeStructureInfo[i].sX;
					dV3 = (dV2*(double)szX)/dV1;
					tX  = (int)dV3;

					dV1 = (double)MapSzY;
					dV2 = (double)m_stCrusadeStructureInfo[i].sY;
					dV3 = (dV2*(double)szY)/dV1;
					tY  = (int)dV3;

					switch (m_stCrusadeStructureInfo[i].cType) {
					case 42:
						DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 40); 
						break;
				}
			}
		}

		// 텔레포트 위치 출력 
		if (m_iTeleportLocX != -1) {
								
			if (szX != NULL) {
				dV1 = (double)MapSzX;
				dV2 = (double)m_iTeleportLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;

				dV1 = (double)MapSzY;
				dV2 = (double)m_iTeleportLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;

				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 42, FALSE, TRUE); 
			}
		}

		// 건설 위치 출력 
		if ((m_stDialogBoxInfo[37].cMode != 2) && (m_iConstructLocX != -1)) {

			if (szX != 0) {
				dV1 = (double)MapSzX;
				dV2 = (double)m_iConstructLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;

				dV1 = (double)MapSzY;
				dV2 = (double)m_iConstructLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
 
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 41, FALSE, TRUE); 
			}
		} 

		// 플레이어의 위치: 미들랜드일때만 그려준다.
		if (strcmp(m_cMapName, "middleland") == 0) {
			dV1 = (double)m_pMapData->m_sMapSizeX;
			dV2 = (double)m_sPlayerX;
			dV3 = (dV2*(double)280.0f)/dV1;
			tX  = (int)dV3;

			dV1 = (double)m_pMapData->m_sMapSizeY;
			if( dV1 == 752 ) dV1 = 680;
			dV2 = (double)m_sPlayerY;
			dV3 = (dV2*(double)253.0f)/dV1;
			tY  = (int)dV3;

			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 43); 
		}

		if ((msX >= sX + 15) && (msX <= sX + 15 +280) && (msY >= sY + 60) && (msY <= sY + 60 +253)) {
			dV1 = (double)(msX - (sX + 15));
			dV2 = (double)(752.0f); // 미들랜드 맵 사이즈
			dV3 = (dV2*dV1)/280.0f;
			tX = (int)dV3;

			dV1 = (double)(msY - (sY + 60));
			dV2 = (double)(680.0f); // 미들랜드 맵 사이즈
			dV3 = (dV2*dV1)/253.0f;
			tY = (int)dV3;

			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > 722) tX = 722;
			if (tY > 650) tY = 650;
		
			wsprintf(G_cTxt, "%d,%d", tX, tY);
			PutString_SprFont3(msX + 10, msY -10, G_cTxt, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
		}
		break;
	}
}

void CGame::DrawDialogBox_Soldier(int msX, int msY)
{
 short sX, sY, szX, szY, MapSzX, MapSzY;	
 DWORD dwTime = G_dwGlobalTime;
 char cMapName[120];
 double dV1, dV2, dV3;
 int tX, tY;

	sX = m_stDialogBoxInfo[38].sX;
	sY = m_stDialogBoxInfo[38].sY;	
	szX = m_stDialogBoxInfo[38].sSizeX;
	
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000*10) {
		// 10초에 한번씩 텔레포트 좌표와 건설 포인트를 요청한다.
		_RequestMapStatus("middleland", 1);
		m_dwCommanderCommandRequestedTime = dwTime;		
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 0, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 17, FALSE, m_bDialogTrans); // Crusade Soldier Menu Text
	
	switch (m_stDialogBoxInfo[38].cMode) {
	case 0: // 일반 모드
		// 일반 아이콘 배열 
				
		if (m_iTeleportLocX != -1) {
			ZeroMemory(cMapName, sizeof(cMapName));
			GetOfficialMapName(m_cTeleportMapName, cMapName);
			wsprintf(G_cTxt, DRAW_DIALOGBOX_SOLDIER1, cMapName, m_iTeleportLocX, m_iTeleportLocY);//"텔레포트 위치: %s %d,%d 근처"
			PutAlignedString(sX, sX + szX, sY + 40, G_cTxt);
		}
		else PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_SOLDIER2);//"텔레포트 위치 지정 안됨"

		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			 m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 322, 15, dwTime); // 텔레포트 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 322, 1, dwTime); // 텔레포트 아이콘 
				
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 

		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER3, 255,255,255);//"지휘관이 설정한 위치로 텔레포트 이동"
		}
		else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER4, 255,255,255);//"군인 역할에 대한 도움말"
		}
		break;
	
	case 1: // 텔레포트 확인
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_SOLDIER5);//"지휘관이 설정한 위치로 텔레포트 이동"
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			 m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20,          sY + 322, 15, dwTime); // 텔레포트 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20,          sY + 322, 1, dwTime); // 텔레포트 아이콘 
		
		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74 -50, sY + 322, 19, dwTime); // 뒤로 가기
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74 -50, sY + 322, 20, dwTime); // 뒤로 가기 

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime); // 헬프 아이콘 
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime); // 헬프 아이콘 

		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			 PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER6, 255,255,255);//"텔레포트 이동 확인(한번 더 클릭)"
		}
		else if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER7, 255,255,255);//"군인 메뉴 처음으로 돌아감"
		}
		else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52)) {
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER8, 255,255,255);//"텔레포트 이동 기능에 대한 도움말"
		}
		break;
	}
		
	// 특정 모드에서 전쟁용 유니트 배치 상황을 그려준다.
	switch (m_stDialogBoxInfo[38].cMode) {
	case 0:
	case 1:
		szX = NULL;
		szY = NULL;
		MapSzX = NULL;
		MapSzY = NULL;

		// v2.15 군인도 건물의 위치를 본다. 
		// 미들랜드 전쟁용 건축물들 위치를 그린다.
		if (strcmp(m_cStatusMapName, "aresden") == 0) {
			szX = 250;
			szY = 250;	
		}
		else if (strcmp(m_cStatusMapName, "elvine") == 0) {
			szX = 250;
			szY = 250;
		}
		else if (strcmp(m_cStatusMapName, "middleland") == 0) {
			szX = 280;
			szY = 253;
			MapSzX = 752;
			MapSzY = 680;
		}

		if (szX != 0) {
			for (int i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
				if (m_stCrusadeStructureInfo[i].cType == 42) {
					dV1 = (double)MapSzX;
					dV2 = (double)m_stCrusadeStructureInfo[i].sX;
					dV3 = (dV2*(double)szX)/dV1;
					tX  = (int)dV3;

					dV1 = (double)MapSzY;
					dV2 = (double)m_stCrusadeStructureInfo[i].sY;
					dV3 = (dV2*(double)szY)/dV1;
					tY  = (int)dV3;

					switch (m_stCrusadeStructureInfo[i].cType) {
					case 42:
						DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 40); 
						break;
				}
			}
		}
			
		// 텔레포트 위치 출력 
		if (m_iTeleportLocX != -1) {

			if (szX != NULL) {
				dV1 = (double)MapSzX;
				dV2 = (double)m_iTeleportLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;

				dV1 = (double)MapSzY;
				dV2 = (double)m_iTeleportLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;

				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 42, FALSE, TRUE);
			}
		}
	

		
		// 플레이어의 위치: 미들랜드일때만 그려준다.
		if (strcmp(m_cMapName, "middleland") == 0) {
			dV1 = (double)m_pMapData->m_sMapSizeX;
			dV2 = (double)m_sPlayerX;
			dV3 = (dV2*(double)280.0f)/dV1;
			tX  = (int)dV3;

			dV1 = (double)m_pMapData->m_sMapSizeY;
			if( dV1 == 752 ) dV1 = 680;
			dV2 = (double)m_sPlayerY;
			dV3 = (dV2*(double)253.0f)/dV1;
			tY  = (int)dV3;

			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 43); 
		}

		if ((msX >= sX + 15) && (msX <= sX + 15 +280) && (msY >= sY + 60) && (msY <= sY + 60 + 253)) {
			dV1 = (double)(msX - (sX + 15));
			dV2 = (double)(752.0f); // 미들랜드 맵 사이즈
			dV3 = (dV2*dV1)/280.0f;
			tX = (int)dV3;

			dV1 = (double)(msY - (sY + 60));
			dV2 = (double)(680.0f); // 미들랜드 맵 사이즈
			dV3 = (dV2*dV1)/253.0f;
			tY = (int)dV3;

			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > 722) tX = 722;
			if (tY > 650) tY = 650;
		
			wsprintf(G_cTxt, "%d,%d", tX, tY);
			PutString_SprFont3(msX + 10, msY -10, G_cTxt, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
		}
		break;
	}
}

// v2.15 건물의 HP를 보여주기 위해 수정함 
void CGame::GrandMagicResult(char *pMapName, int iV1, int iV2, int iV3, int iV4, int iHP1, int iHP2, int iHP3, int iHP4) 
{
 int i, iTxtIdx=0; 
 char cTemp[120];

	// 텍스트 내용을 작성한다.
	// 내용 클리어.
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != NULL) 
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;
	} 
	
	// 에러 체크용
	for (i = 0; i < 92; i++)
	if (m_pGameMsgList[i] == NULL) return;

	if (strcmp(pMapName, "aresden") == 0) {
		
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[2]->m_pMsg, NULL); // 엘바인의 마법공격에 의해  
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[3]->m_pMsg, NULL); // 아레스덴이 입은 피해 내용입니다.
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL); 
		
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[4]->m_pMsg, iV1); // 파괴된 적 건물 개수:
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL); 
		
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[5]->m_pMsg, iV2); // 적 건물에 입힌 대미지:
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL); 
		
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[6]->m_pMsg, iV3); // 사망자 수: 
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL); 
		
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[58]->m_pMsg, iV4); // 남은 적 건물 개수:
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL); 
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL); 
		
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1,iHP2,iHP3,iHP4); // "건물의 내구력 :"
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL); 
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL); 
		
		if (iV2 == 0) {
			if( (m_bCitizen == TRUE) && (m_bAresden == FALSE) ) {
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[59]->m_pMsg, NULL); // 마법 공격으로 적 건물에 대미지를
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[60]->m_pMsg, NULL); // 주지 못했습니다. 적국에 침투하여
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[61]->m_pMsg, NULL); // 적 건물앞에 설치된 '매직 실드
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[62]->m_pMsg, NULL); // 제네레이터'를 파괴해야만 합니다.
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
			}
			else if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) ) {
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[69]->m_pMsg, NULL); // 적국의 마법 공격이 아군 건물에
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[70]->m_pMsg, NULL); // 대미지를 주지 못했습니다. 적들의 
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[71]->m_pMsg, NULL); // 마법 공격을 멈추려면 미들랜드
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[72]->m_pMsg, NULL); // 마나스톤 주위에 건설되어 있는 
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[73]->m_pMsg, NULL); // 적국의 '마나 콜렉터'를 모두 
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[74]->m_pMsg, NULL); // 파괴해야만 합니다.
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
			}
			else PlaySound('E', 25, 0, 0);
		}
		else {
			if (iV1 != 0) {
				if( (m_bCitizen == TRUE) && (m_bAresden == FALSE) ) {
					PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[63]->m_pMsg, NULL); // 마법 공격으로 적 건물을 파괴하였 
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[64]->m_pMsg, NULL); // 습니다! 모든 적 건물을 파괴하면
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[65]->m_pMsg, NULL); // 전면전에서 승리할 수 있습니다.
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
				}
				else if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) ) {
					PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[75]->m_pMsg, NULL); // 적의 마법 공격으로 아군 건물이
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[76]->m_pMsg, NULL); // 파괴 되었습니다! 모든 아군 건물이
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[77]->m_pMsg, NULL); // 파괴되면 전면전에서 패배하게 
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[78]->m_pMsg, NULL); // 됩니다. 적들의 마법 공격을 
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[79]->m_pMsg, NULL); // 멈추려면 미들랜드 마나스톤
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[80]->m_pMsg, NULL); // 주위에 건설되어 있는 적국의 모든
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[81]->m_pMsg, NULL); // '마나 콜렉터'를 파괴해야만
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[82]->m_pMsg, NULL); // 합니다.
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
				}
				else PlaySound('E', 25, 0, 0);
			}
			else {
				if( (m_bCitizen == TRUE) && (m_bAresden == FALSE) ) {
					PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[66]->m_pMsg, NULL); // 마법 공격으로 적 건물에 대미지를
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[67]->m_pMsg, NULL); // 입혔습니다. 마법 공격이 계속되면
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[68]->m_pMsg, NULL); // 적 건물은 파괴될 것입니다.
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
				}
				else if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) ) {
					PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[83]->m_pMsg, NULL); // 적의 마법 공격으로 아군 건물이
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[84]->m_pMsg, NULL); // 대미지를 입었습니다! 모든 아군
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[85]->m_pMsg, NULL); // 건물이 파괴되면 전면전에서
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[86]->m_pMsg, NULL); // 패배하게 됩니다. 적들의 마법
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[87]->m_pMsg, NULL); // 공격을 멈추려면 미들랜드 마나스톤
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[88]->m_pMsg, NULL); // 주위에 건설되어 있는 적국의 모든
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[89]->m_pMsg, NULL); // '마나 콜렉터'를 파괴해야만
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[90]->m_pMsg, NULL); // 합니다.
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
				}
				else PlaySound('E', 25, 0, 0);
			}
		}
	}
	else if (strcmp(pMapName, "elvine") == 0) {
				
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[7]->m_pMsg, NULL); // 아레스덴의 마법공격에 의해  
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[8]->m_pMsg, NULL); // 엘바인이 입은 피해 내용입니다.
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL); 
		
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[4]->m_pMsg, iV1); // 파괴된 주요 건물 개수:
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL); 

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[5]->m_pMsg, iV2); // 주요 건물에 입힌 대미지:
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL); 

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[6]->m_pMsg, iV3); // 사망자 수: 
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);
		
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[58]->m_pMsg, iV4); // 남은 적 건물 개수:
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL); 
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL); 

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1,iHP2,iHP3,iHP4); // "건물의 내구력 :"
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL); 
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL); 

		if (iV2 == 0) {
			if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) ) {
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[59]->m_pMsg, NULL); // 마법 공격으로 적 건물에 대미지를
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[60]->m_pMsg, NULL); // 주지 못했습니다. 적국에 침투하여
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[61]->m_pMsg, NULL); // 적 건물앞에 설치된 '매직 실드
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[62]->m_pMsg, NULL); // 제네레이터'를 파괴해야만 합니다.
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
			}
			else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) ) {
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[69]->m_pMsg, NULL); // 적국의 마법 공격이 아군 건물에
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[70]->m_pMsg, NULL); // 대미지를 주지 못했습니다. 적들의 
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[71]->m_pMsg, NULL); // 마법 공격을 멈추려면 미들랜드
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[72]->m_pMsg, NULL); // 마나스톤 주위에 건설되어 있는 
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[73]->m_pMsg, NULL); // 적국의 '마나 콜렉터'를 모두 
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[74]->m_pMsg, NULL); // 파괴해야만 합니다.
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
			}
			else PlaySound('E', 25, 0, 0);
		}
		else {
			if (iV1 != 0) {
				if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) ) {
					PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[63]->m_pMsg, NULL); // 마법 공격으로 적 건물을 파괴하였 
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[64]->m_pMsg, NULL); // 습니다! 모든 적 건물을 파괴하면
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[65]->m_pMsg, NULL); // 전면전에서 승리할 수 있습니다.
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
				}
				else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) ) {
					PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[75]->m_pMsg, NULL); // 적의 마법 공격으로 아군 건물이
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[76]->m_pMsg, NULL); // 파괴 되었습니다! 모든 아군 건물이
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[77]->m_pMsg, NULL); // 파괴되면 전면전에서 패배하게 
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[78]->m_pMsg, NULL); // 됩니다. 적들의 마법 공격을 
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[79]->m_pMsg, NULL); // 멈추려면 미들랜드 마나스톤
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[80]->m_pMsg, NULL); // 주위에 건설되어 있는 적국의 모든
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[81]->m_pMsg, NULL); // '마나 콜렉터'를 파괴해야만
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[82]->m_pMsg, NULL); // 합니다.
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
				}
				else PlaySound('E', 25, 0, 0);
			}
			else {
				if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) ) {
					PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[66]->m_pMsg, NULL); // 마법 공격으로 적 건물에 대미지를
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[67]->m_pMsg, NULL); // 입혔습니다. 마법 공격이 계속되면
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[68]->m_pMsg, NULL); // 적 건물은 파괴될 것입니다.
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
				}
				else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) ) {
					PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[83]->m_pMsg, NULL); // 적의 마법 공격으로 아군 건물이
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[84]->m_pMsg, NULL); // 대미지를 입었습니다! 모든 아군
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[85]->m_pMsg, NULL); // 건물이 파괴되면 전면전에서
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[86]->m_pMsg, NULL); // 패배하게 됩니다. 적들의 마법
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[87]->m_pMsg, NULL); // 공격을 멈추려면 미들랜드 마나스톤
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[88]->m_pMsg, NULL); // 주위에 건설되어 있는 적국의 모든
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[89]->m_pMsg, NULL); // '마나 콜렉터'를 파괴해야만 
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[90]->m_pMsg, NULL); // 합니다.
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL); 
				}
				else PlaySound('E', 25, 0, 0);
			}
		}
	}

	// 다이얼로그 박스를 오픈한다.
	EnableDialogBox(18, NULL, NULL, NULL);
}

void CGame::DrawDialogBox_Help(int msX, int msY)
{
 short sX, sY, szX;

	sX = m_stDialogBoxInfo[35].sX;
	sY = m_stDialogBoxInfo[35].sY;
	szX = m_stDialogBoxInfo[35].sSizeX;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*0) && (msY < sY +50+15*1)) 
		 PutAlignedString(sX, sX+szX, sY + 50 +15*0, DRAW_DIALOGBOX_HELP1, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*0, DRAW_DIALOGBOX_HELP1, 4, 0, 50);//"헬브레스 크루세이드의 세계관"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*1) && (msY < sY +50+15*2)) 
		 PutAlignedString(sX, sX+szX, sY + 50 +15*1, DRAW_DIALOGBOX_HELP2, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*1, DRAW_DIALOGBOX_HELP2, 4, 0, 50);//"공지 사항" 
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*2) && (msY < sY +50+15*3)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*2, DRAW_DIALOGBOX_HELP3, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*2, DRAW_DIALOGBOX_HELP3, 4, 0, 50);//"캐릭터 이동 방법"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*3) && (msY < sY +50+15*4)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*3, DRAW_DIALOGBOX_HELP4, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*3, DRAW_DIALOGBOX_HELP4, 4, 0, 50);//"공격과 방어, 적과 아군, 중립"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*4) && (msY < sY +50+15*5)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*4, DRAW_DIALOGBOX_HELP5, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*4, DRAW_DIALOGBOX_HELP5, 4, 0, 50);//"인터페이스"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*5) && (msY < sY +50+15*6)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*5, DRAW_DIALOGBOX_HELP6, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*5, DRAW_DIALOGBOX_HELP6, 4, 0, 50);//"마    법"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*6) && (msY < sY +50+15*7)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*6, DRAW_DIALOGBOX_HELP7, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*6, DRAW_DIALOGBOX_HELP7, 4, 0, 50);//"캐릭터 특성치, 스킬 시스템"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*7) && (msY < sY +50+15*8)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*7, DRAW_DIALOGBOX_HELP8, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*7, DRAW_DIALOGBOX_HELP8, 4, 0, 50);//"길드 조직, 가입, 탈퇴, 해체"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*8) && (msY < sY +50+15*9)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*8, DRAW_DIALOGBOX_HELP9, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*8, DRAW_DIALOGBOX_HELP9, 4, 0, 50);//"아이템 장착, 거래, 교환, 보관"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*9) && (msY < sY +50+15*10)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*9, DRAW_DIALOGBOX_HELP10, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*9, DRAW_DIALOGBOX_HELP10, 4, 0, 50);//"플레이어간 의사소통"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*10) && (msY < sY +50+15*11)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*10, DRAW_DIALOGBOX_HELP11, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*10, DRAW_DIALOGBOX_HELP11, 4, 0, 50);//"크루세이드 전면전이란?"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*11) && (msY < sY +50+15*12)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*11,DRAW_DIALOGBOX_HELP12, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*11,DRAW_DIALOGBOX_HELP12, 4, 0, 50);//"고급 명령어"  
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*12) && (msY < sY +50+15*13)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*12,"F.A.Q.", 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*12,"F.A.Q.", 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*13) && (msY < sY +50+15*14)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*13,DRAW_DIALOGBOX_HELP13, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*13,DRAW_DIALOGBOX_HELP13, 4, 0, 50);//"초보 사용자 도움말"
	
#if DEF_LANGUAGE == 3
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*14) && (msY < sY +50+15*15)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*14,DRAW_DIALOGBOX_HELP14, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*14,DRAW_DIALOGBOX_HELP14, 4, 0, 50);//"헬브레스에서 살아가기 1"
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*15) && (msY < sY +50+15*16)) 
		PutAlignedString(sX, sX+szX, sY + 50 +15*15,DRAW_DIALOGBOX_HELP15, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*15,DRAW_DIALOGBOX_HELP15, 4, 0, 50);//"헬브레스에서 살아가기 2"
#endif



	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) 
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1); 
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0); 
}

// v2.16 2002-5-22 고광현수정 함수 전체
void CGame::DrawDialogBox_ItemUpgrade(int msX, int msY)
{
 int i, sX, sY, iValue;
 char cItemColor, cStr1[120], cStr2[120], cStr3[120];
 DWORD dwTime = timeGetTime();
 
	sX = m_stDialogBoxInfo[34].sX;
	sY = m_stDialogBoxInfo[34].sY;
	
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT , sX, sY, 5); //Item Upgrade Text

	switch (m_stDialogBoxInfo[34].cMode) {
	case 1://지존 아이템 업그레이드 준비창..
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 30, DRAW_DIALOGBOX_ITEMUPGRADE1);//"업그레이드 하고자 하는 아이템을"
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE2);//"인벤토리 창에서 끌어와 놓은 다음"
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 60, DRAW_DIALOGBOX_ITEMUPGRADE3);//"Upgrade 버튼을 누르세요."
		wsprintf(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE11, m_iGizonItemUpgradeLeft);
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, G_cTxt);

		// v2.16 2002-5-21 고광현 수정
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);

		// 올려진 아이템을 그린다.
		if (m_stDialogBoxInfo[34].sV1 != -1) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			iValue = (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_dwAttribute & 0xF0000000) >> 28;
			iValue = iValue*(iValue+6)/8 + 2;
			wsprintf( G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE12, iValue );
			if( m_iGizonItemUpgradeLeft < iValue ) PutAlignedString(sX + 24, sX + 248, sY + 55 + 95 + 282 -117 -170 -30, G_cTxt, 195,25,25);
			else PutAlignedString(sX + 24, sX + 248, sY + 55 + 95 + 282 -117 -170 -30, G_cTxt);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if ((m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
				// 무기, 방패등은 컬러 세트가 다르다. 갑옷은 이 색상 세트를 써서는 안된다.
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}
			else {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}
			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
			if( m_iGizonItemUpgradeLeft < iValue ) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);
			else
			{
				if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
					DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +DEF_BTNPOSY, 47);
				else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +DEF_BTNPOSY, 46);
			}
		}
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 2:
		// 지존 아이템 업그레이드 중
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 30 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE5);//"아이템을 업그레이드 하고 있습니다."		                                       
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 45 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE6);//"잠시만 기다려 주세요"
		
		// 올려진 아이템을 그린다.
		if (m_stDialogBoxInfo[34].sV1 != -1) {
			// 제작 과정 중간을 깜빡이게 만든다.
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if ((m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
				// 무기, 방패등은 컬러 세트가 다르다. 갑옷은 이 색상 세트를 써서는 안된다.
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, 
																	                                             m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}
			else {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, 
																	                                             m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}
			if ((rand() % 5) == 0) m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutTransSprite25(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, dwTime);
			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
		}

		if (((dwTime - m_stDialogBoxInfo[34].dwV1)/1000 > 4) && (m_stDialogBoxInfo[34].dwV1 != NULL)) {
			m_stDialogBoxInfo[34].dwV1 = NULL;
			// 서버로 메시지 전송
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_UPGRADEITEM, NULL, m_stDialogBoxInfo[34].sV1, NULL, NULL, NULL); 
		}
		break;

	case 3:
		// 지존 아이템 업그레이드 완료
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 30 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE7);
			                                                             //"축하합니다! 아이템 업그레이드에"		                                       
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 45 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE8);
		                                                                 //"성공 하였습니다!"
		// 올려진 아이템을 그린다.
		if (m_stDialogBoxInfo[34].sV1 != -1) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if ((m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
				// 무기, 방패등은 컬러 세트가 다르다. 갑옷은 이 색상 세트를 써서는 안된다.
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, 
																	                                             m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}
			else {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, 
																	                                             m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}
		
			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
		}

		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 4:
		// 지존 아이템 업그레이드 실패
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 30 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE9);//"아이템 업그레이드에 실패하였습니다."		                                       
		if ((m_stDialogBoxInfo[34].sV1 != -1) && (m_pItemList[m_stDialogBoxInfo[34].sV1] == NULL)) {
			// 업그레이드가 실패해서 아이템이 사라졌다.
			PlaySound('E', 24, 0, 0);
			m_stDialogBoxInfo[34].cMode = 7;
			return;
		}

		// 올려진 아이템을 그린다.
		if (m_stDialogBoxInfo[34].sV1 != -1) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if ((m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
				// 무기, 방패등은 컬러 세트가 다르다. 갑옷은 이 색상 세트를 써서는 안된다.
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, 
																	                                             m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}
			else {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, 
																	                                             m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}
		
			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
		}

		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	// v2.16 2002-5-20 고광현수정 
	case 5: // 일반 아이템 업그레이드 / 지존 아이템 업그레이드 구분 창 
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE13);//"업그레이드 종류를 선택하세요."
		
		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +100) && (msY < sY +115)) {
			PutAlignedString(sX + 24, sX + 248, sY + 100, DRAW_DIALOGBOX_ITEMUPGRADE14, 255,255,255);

			PutAlignedString(sX + 24, sX + 248, sY + 150, DRAW_DIALOGBOX_ITEMUPGRADE16);
			PutAlignedString(sX + 24, sX + 248, sY + 165, DRAW_DIALOGBOX_ITEMUPGRADE17);
			PutAlignedString(sX + 24, sX + 248, sY + 180, DRAW_DIALOGBOX_ITEMUPGRADE18);
			PutAlignedString(sX + 24, sX + 248, sY + 195, DRAW_DIALOGBOX_ITEMUPGRADE19);
			PutAlignedString(sX + 24, sX + 248, sY + 210, DRAW_DIALOGBOX_ITEMUPGRADE20);
			PutAlignedString(sX + 24, sX + 248, sY + 225, DRAW_DIALOGBOX_ITEMUPGRADE21);
			PutAlignedString(sX + 24, sX + 248, sY + 255, DRAW_DIALOGBOX_ITEMUPGRADE26);
			PutAlignedString(sX + 24, sX + 248, sY + 270, DRAW_DIALOGBOX_ITEMUPGRADE27);
		}
		else PutAlignedString(sX + 24, sX + 248, sY + 100, DRAW_DIALOGBOX_ITEMUPGRADE14, 4,0,50);
		
		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +120) && (msY < sY +135)) {
			PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_ITEMUPGRADE15, 255,255,255);

			PutAlignedString(sX + 24, sX + 248, sY + 150, DRAW_DIALOGBOX_ITEMUPGRADE22);
			PutAlignedString(sX + 24, sX + 248, sY + 165, DRAW_DIALOGBOX_ITEMUPGRADE23);
			PutAlignedString(sX + 24, sX + 248, sY + 180, DRAW_DIALOGBOX_ITEMUPGRADE24);
			PutAlignedString(sX + 24, sX + 248, sY + 195, DRAW_DIALOGBOX_ITEMUPGRADE25);
			PutAlignedString(sX + 24, sX + 248, sY + 225, DRAW_DIALOGBOX_ITEMUPGRADE28);
			PutAlignedString(sX + 24, sX + 248, sY + 240, DRAW_DIALOGBOX_ITEMUPGRADE29);
		}
		else PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_ITEMUPGRADE15, 4,0,50);

		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 6:
		// 일반 아이템 업그레이드 준비창
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 30, DRAW_DIALOGBOX_ITEMUPGRADE31);//"업그레이드 하고자 하는 일반 아이템을"
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE32);//"인벤토리 창에서 끌어와 놓은 다음"
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 60, DRAW_DIALOGBOX_ITEMUPGRADE33);//"Upgrade 버튼을 누르세요."
		if( m_stDialogBoxInfo[34].sV2 == 0 )
		{
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, DRAW_DIALOGBOX_ITEMUPGRADE41, 195,25,25);
		}
		else
		{
			wsprintf(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE34, m_stDialogBoxInfo[34].sV2);
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, G_cTxt);
		}
		if( m_stDialogBoxInfo[34].sV3 == 0 )
		{
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 95, DRAW_DIALOGBOX_ITEMUPGRADE42, 195,25,25);
		}
		else
		{
			wsprintf(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE35, m_stDialogBoxInfo[34].sV3);
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 95, G_cTxt);
		}

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);

		// 올려진 아이템을 그린다.
		if (m_stDialogBoxInfo[34].sV1 != -1) {
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if ((m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND) || (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND)) {
				// 무기, 방패등은 컬러 세트가 다르다. 갑옷은 이 색상 세트를 써서는 안된다.
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, 
																	                                             m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}
			else {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, 
																	                                             m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}
		
			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
						
			if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
				 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 47);
			else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);
		}
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) 
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 7: // 일반 아이템 업그레이드 실패로 아이템 사라짐
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE36);//"아이템 업그레이드에 실패하여"
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 145, DRAW_DIALOGBOX_ITEMUPGRADE37);//"아이템이 사라졌습니다. 아쉽군요!"
		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 8: // 일반 아이템 업그레이드 실패
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE38);//"더 이상 아이템 업그레이드가 불가능 합니다."
		
		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 9: // 업그레이드 실패
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE39);//"아이템 업그레이드가 불가능한 아이템입니다."
		
		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 10: // 업그레이드 실패
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE40);//"더 이상 아이템 업그레이드가 불가능 합니다."
		
		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	}
}

LONG CGame::GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata)
{
    HKEY hkey;
    LONG retval = RegOpenKeyEx(key, subkey, 0, KEY_QUERY_VALUE, &hkey);

    if (retval == ERROR_SUCCESS) {
        long datasize = MAX_PATH;
        TCHAR data[MAX_PATH];
        RegQueryValue(hkey, NULL, data, &datasize);
        lstrcpy(retdata,data);
        RegCloseKey(hkey);
    }

    return retval;
}

void CGame::GoHomepage() 
{
	LPCTSTR	url;
#ifdef DEF_TESTSERVER
	url = "http://www.helbreath.com/zb/add_ts_setup.php";
#else

#if DEF_LANGUAGE == 3
	url = "http://www.helbreath.com/zb/member_join.php?c=1/";
#endif

#if DEF_LANGUAGE == 4
	#ifdef DEF_FUCK_USA
		//미국
		url = "http://www.helbreathusa.com/zb/NewAccount.php";
	#else
		//인터네셔널..
		url = "http://inter.helbreath.com/zb/member_join.php?c=1/";
	#endif
#endif

#if DEF_LANGUAGE == 5
  #ifdef DEF_JAPAN_FOR_TERRA
    // 테라....
	url = "http://www.netgame.co.jp/main/account.asp?da=ag";
  #else
    //인터네셔널..
	url = "http://inter.helbreath.com/zb/member_join.php?c=1/";
  #endif
#endif

#endif

#ifdef _DEBUG
	//return;
#endif
	int		showcmd = SW_SHOW;
	char	key[MAX_PATH + MAX_PATH];

	SendMessage( G_hWnd, WM_ACTIVATEAPP, 0, 0 );
	
    // First try ShellExecute()
    HINSTANCE result = ShellExecute(NULL, "open", url, NULL,NULL, showcmd);

    // If it failed, get the .htm regkey and lookup the program
    if ((UINT)result <= HINSTANCE_ERROR) {

        if (GetRegKey(HKEY_CLASSES_ROOT, ".htm", key) == ERROR_SUCCESS) {
            lstrcat(key, "\\shell\\open\\command");

            if (GetRegKey(HKEY_CLASSES_ROOT,key,key) == ERROR_SUCCESS) {
                char *pos;
                pos = strstr(key, "\"%1\"");
                if (pos == NULL) {                     // No quotes found
                    pos = strstr(key, "%1");      // Check for %1, without quotes 
                    if (pos == NULL)                   // No parameter at all...
                        pos = key+lstrlen(key)-1;
                    else
                        *pos = '\0';                   // Remove the parameter
                }
                else
                    *pos = '\0';                       // Remove the parameter

                lstrcat(pos, " ");
                lstrcat(pos, url);

                result = (HINSTANCE) WinExec(key,showcmd);
            }
        }
    }
}

// num : 0 - F1, 1 - F2, 2 - F3, 3 - F5, 4 - F6
void CGame::UseShortCut( int num )
{
	int index;
	if( num < 3 ) index = num+1;
	else index = num+2;
	if(m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
	if (m_bCtrlPressed == TRUE) {
		// 가장 최근에 사용했던 마법 혹은 무기 아이템을 기억 
		if (m_sRecentShortCut == -1)
		{
			AddEventList(MSG_SHORTCUT1, 10);//"단축키에 할당할 아이템 혹은 마법이 선택되지 않았습니다."
			wsprintf( G_cTxt, MSG_SHORTCUT2, index );//"[F%d] 키에 할당하고자 하는 무기 혹은 방어구, 마법을 장착"
			AddEventList(G_cTxt, 10);
			wsprintf( G_cTxt, MSG_SHORTCUT3, index );//"혹은 캐스팅한 후 [Control]-[F%d] 키를 누르면 할당 됩니다."
			AddEventList(G_cTxt, 10);
		}
		else
		{
			m_sShortCut[num] = m_sRecentShortCut;
			if (m_sShortCut[num] < 100)
			{
				// 아이템이다.
				if (m_pItemList[m_sShortCut[num]] == NULL)
				{
					m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				char cStr1[64], cStr2[64], cStr3[64];
				ZeroMemory(cStr1, sizeof(cStr1));
				ZeroMemory(cStr2, sizeof(cStr2));
				ZeroMemory(cStr3, sizeof(cStr3));

				GetItemName(m_pItemList[m_sShortCut[num]], cStr1, cStr2, cStr3);
				wsprintf(G_cTxt, MSG_SHORTCUT4, cStr1, cStr2, cStr3, index);//"아이템(%s %s %s): [F%d] 키에 할당되었습니다."
				AddEventList(G_cTxt, 10);
			}
			else if (m_sShortCut[num] >= 100)
			{
				// 마법이다.
				if (m_pMagicCfgList[m_sShortCut[num]-100] == NULL)
				{
					m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				wsprintf(G_cTxt, MSG_SHORTCUT5, m_pMagicCfgList[m_sShortCut[num]-100]->m_cName, index);//"마법(%s): [F%d] 키에 할당되었습니다."
				AddEventList(G_cTxt, 10);
			}
		}
	}
	else {
		// 단축키 사용
		if (m_sShortCut[num] == -1)
		{
			// 할당된 항목이 없다.
			AddEventList(MSG_SHORTCUT1, 10);//"단축키에 할당된 아이템 혹은 마법이 없습니다."
			wsprintf( G_cTxt, MSG_SHORTCUT2, index );//"[F%d] 키에 할당하고자 하는 무기 혹은 방어구, 마법을 장착"
			AddEventList(G_cTxt, 10);
			wsprintf( G_cTxt, MSG_SHORTCUT3, index );//"혹은 캐스팅한 후 [Control]-[F%d] 키를 누르면 할당 됩니다."
			AddEventList(G_cTxt, 10);
		}
		else if (m_sShortCut[num] < 100)
		{
			// 아이템이다. 장착한다.
			ItemEquipHandler((char)m_sShortCut[num]);
		}
		else if (m_sShortCut[num] >= 100) UseMagic(m_sShortCut[num]-100);
	}
}

int CGame::iGetManaCost(int iMagicNo)
{
	int i, iManaSave, iManaCost;
	iManaSave = 0;

	if( iMagicNo < 0 || iMagicNo >= 100 ) return 1;

	for( i=0; i<DEF_MAXITEMS ; i++ )
	{
		if( m_pItemList[i] == NULL ) continue;
		if( m_bIsItemEquipped[i] == TRUE )
		{
#ifdef DEF_ENGLISHITEM
			if(      strcmp( m_pItemList[i]->m_cName, "MagicWand(MS10)" ) == 0) iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "MagicWand(MS20)" ) == 0) iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "MagicWand(MS30-LLF)" ) == 0) iManaSave += 30;
			else if( strcmp( m_pItemList[i]->m_cName, "WizMagicWand(MS10)" ) == 0) iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "WizMagicWand(MS20)" ) == 0) iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "MagicNecklace(MS10)" ) == 0) iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "DarkMageMagicStaff" ) == 0) iManaSave += 25;
			else if( strcmp( m_pItemList[i]->m_cName, "DarkMageMagicStaffW" ) == 0) iManaSave += 25;
			else if( strcmp( m_pItemList[i]->m_cName, "DarkMageMagicWand" ) == 0) iManaSave += 28;
			else if( strcmp( m_pItemList[i]->m_cName, "NecklaceOfLiche") ==0) iManaSave += 15;	//	15퍼센트..
#else
			if(      strcmp( m_pItemList[i]->m_cName, "매직스탭(MS10)" ) == 0) iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "매직스탭(MS20)" ) == 0) iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "매직원드(MS30-LLF)" ) == 0) iManaSave += 30;
			else if( strcmp( m_pItemList[i]->m_cName, "위저드매직스탭(MS10)" ) == 0) iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "위저드매직스탭(MS20)" ) == 0) iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "마법목걸이(MS10)" ) == 0) iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "흑마법사의매직스탭" ) == 0) iManaSave += 25;
			else if( strcmp( m_pItemList[i]->m_cName, "흑여마법사매직스탭" ) == 0) iManaSave += 25;
			else if( strcmp( m_pItemList[i]->m_cName, "흑마법사의매직원드" ) == 0) iManaSave += 28;
			else if( strcmp( m_pItemList[i]->m_cName, "넥클리스오브리치") ==0) iManaSave += 15;	//	15퍼센트..
#endif
		}
	}
	iManaCost = m_pMagicCfgList[iMagicNo]->m_sValue1;
	if (m_bIsSafeAttackMode) iManaCost += (iManaCost/2) - (iManaCost / 10);//안전모드는 1.4배
	if (iManaSave > 0)
	{
		double dV1 = (double)iManaSave;
		double dV2 = (double)(dV1 / 100.0f);
		double dV3 = (double)iManaCost;
		dV1 = dV2 * dV3; // 이 값이 절약되는 값 
		dV2 = dV3 - dV1; 
		iManaCost = (int)dV2;
	}
	if( iManaCost < 1 ) iManaCost = 1; // v2.173
	return iManaCost;
}

void CGame::UseMagic(int iMagicNo)
{
	if( iMagicNo < 0 || iMagicNo >= 100 ) return;
	if ((m_cMagicMastery[iMagicNo] == NULL) || (m_pMagicCfgList[iMagicNo] == NULL)) return;

	// 죽어있어도 Casting할 수 없다.
	if (m_iHP <= 0) return;
	// 포인팅 입력을 기다리던 중이었다면 무효.
	if (m_bIsGetPointingMode == TRUE) return;
	// 마나가 부족해도 리턴 
	if (iGetManaCost(iMagicNo) > m_iMP) return;
	// 두손에 무언가를 들고 있어도 리턴 
	if (_bIsItemOnHand() == TRUE) {
		AddEventList(DLGBOX_CLICK_MAGIC1, 10);//"마법을 캐스팅하기 위해서는 두손이 자유로와야 합니다."
		return;
	}
	// 스킬을 사용중이라고 해도 리턴 
	if (m_bSkillUsingStatus == TRUE) {
		AddEventList(DLGBOX_CLICK_MAGIC2, 10);//"기술 사용 중에 마법을 캐스팅할 수는 없습니다."
		return;
	}
	if ((m_sPlayerAppr2 & 0xF000) == 0) bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, NULL, NULL, NULL, NULL, NULL); 

	m_cCommand = DEF_OBJECTMAGIC;

	m_iCastingMagicType = iMagicNo; // 캐스팅하는 마법 종류	저장 
	m_sMagicShortCut    = iMagicNo;
	m_sRecentShortCut   = iMagicNo + 100;
	m_iPointCommandType = iMagicNo + 100; // 0~99 까지는 마법외의 Effect, 100~199까지는 마법 Effect 때문에 100을 머법 번호에 더한다.
	//m_bIsGetPointingMode = TRUE;
	
	DisableDialogBox(3);
}

#if DEF_LANGUAGE == 2
void CGame::UpdateScreen_OnInputKeyCode()
{
 short msX, msY, msZ, sX, sY;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI; 
 static char  cName[12], cPassword[12], cKeyCode[20], cPrevFocus;
 static DWORD dwCTime;
 DWORD dwTime = timeGetTime();	
 BOOL bFlag = TRUE;

	sX = 146; 
	sY = 114;
	if (m_cGameModeCount == 0) {
		EndInputString();
		
		pMI = new class CMouseInterface;
		pMI->AddRect(285, 142, 445, 163);
		pMI->AddRect(285, 165, 445, 185);
		pMI->AddRect(285, 188, 445, 208);

		pMI->AddRect(197, 298, 256, 317);
		pMI->AddRect(383, 298, 442, 317);

		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 5;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cPassword, sizeof(cPassword));
		ZeroMemory(cKeyCode, sizeof(cKeyCode));

		StartInputString(sX + 154 -2, sY + 50 -20, 11, cName);
		ClearInputString();
		dwCTime = dwTime;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	if (m_cArrowPressed != 0) {
		// 화살표키가 눌렸다.
		switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		
		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// 엔터키가 눌렸다. 	
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
		case 2:
		case 3:
			m_cCurFocus++;
			if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		
		case 4:
			if ( (m_Misc.bCheckValidString(cKeyCode) == FALSE) || (strlen(cKeyCode) != 17) ) break;

			// Connect 버튼이 선택된 상태에서 Enter키가 눌렸다.
			// 이름을 초기화한다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			ZeroMemory(m_cKeyCode, sizeof(m_cKeyCode));
			
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			strcpy(m_cKeyCode, cKeyCode);

			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_INPUTKEYCODE;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "61");
			delete pMI;
			return;
		
		case 5:
			// Cancel 버튼이 선택된 상태에서 Enter키가 눌렸다.
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			//m_dwLoginMode = MSGID_REQUEST_LOGIN;
			delete pMI;
			return;
		}
		// (!)
		m_bEnterPressed = FALSE;
	}

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (cPrevFocus != m_cCurFocus) {
		// 마우스나 엔터, 탭키등에 의해서 입력 포커스가 변경되었다.
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(sX + 154 -2, sY + 50 -20, 11, cName);
			break;
		case 2:
			StartInputString(sX + 154 -2, sY + 65 -11, 11, cPassword);
			break;
		case 3:
			StartInputString(sX + 154 -2, sY + 89 -11, 18, cKeyCode);
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, -1, -1, 0, TRUE);

	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6)) {
		m_DDraw.DrawShadowBox(0,0,639,479);
	}
	else if (m_cGameModeCount >= 6) {
		m_DDraw.DrawShadowBox(0,0,639,479);
		m_DDraw.DrawShadowBox(0,0,639,479);
	}

	if (m_cCurFocus != 1) {
		if (m_Misc.bCheckValidString(cName) != FALSE)
			 PutString(sX + 154 -2, sY + 50 -20, cName, RGB(25,35,25));
		else PutString(sX + 154 -2, sY + 50 -20, cName, RGB(0,0,0));
	}
	if ((m_Misc.bCheckValidString(cName) == FALSE) || (strlen(cName) == 0)) bFlag = FALSE;

	if (m_cCurFocus != 2) {
		if (m_Misc.bCheckValidString(cPassword) != FALSE)
			 PutString(sX + 154 -2, sY + 65 -11, cPassword, RGB(25,35,25), 12, TRUE, 3);
		else PutString(sX + 154 -2, sY + 65 -11, cPassword, RGB(55,18,13), 12, TRUE, 3);
	}
	if ( m_Misc.bCheckValidString(cPassword) == FALSE ) bFlag = FALSE;

	if (m_cCurFocus != 3)
	{
		BOOL bTempFlag = TRUE;
		for( int i=0 ; i<strlen(cKeyCode) ; i++ )
		{
			if( cKeyCode[i] < 48 ) bTempFlag = FALSE;
			if( (cKeyCode[i]>57) && (cKeyCode[i]<65) )  bTempFlag = FALSE;
			if( (cKeyCode[i]>90) && (cKeyCode[i]<97) )  bTempFlag = FALSE;
			if( cKeyCode[i] > 122 ) bTempFlag = FALSE;
		}
		if(bTempFlag)
		{
			for( i=0 ; i<strlen(cKeyCode) ; i++ )
			{
				char temp = cKeyCode[i];
				if( (temp>96) && (temp<123) ) cKeyCode[i] = temp-32;
			}
			PutString(sX + 154 -2, sY + 89 -11, cKeyCode, RGB(25,35,25));
		}
		else PutString2(sX + 154 -2, sY + 89 -11, cKeyCode, 200,100,100);
	}
	if ( (m_Misc.bCheckValidString(cKeyCode) == FALSE) || (strlen(cKeyCode) != 17)  ) bFlag = FALSE;
	for( int i=0 ; i<strlen(cKeyCode) ; i++ )
	{
		if( cKeyCode[i] < 48 ) {
			bFlag = FALSE;
			break;
		}
		if( (cKeyCode[i]>57) && (cKeyCode[i]<65) ) {
			bFlag = FALSE;
			break;
		}
		if( cKeyCode[i]>90 ) {
			bFlag = FALSE;
			break;
		}
	}

	if ((m_cCurFocus == 1) || (m_cCurFocus == 3)) ShowReceivedString();
	else if (m_cCurFocus == 2) ShowReceivedString(TRUE);

	if( (bFlag == TRUE) || (m_cCurFocus != 4) ) {
		PutAlignedString(140, 500, sY + 90  +30, "헝渴흙콱돨瑯뵀，쵱쯤뵨엥뵀");
	}
	
	if (bFlag == TRUE) {
		if (m_cCurFocus == 4) 
			 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 297, 21, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 297, 20, dwTime);
	}
	else {
		if (m_cCurFocus == 4) {
			 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 297, 20, dwTime);
			 PutAlignedString(140, 500, sY + 90  +30, "엥뵀극伎角亶匡俚캡뵨鑒俚돨莉북");
		}
		else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 297, 20, dwTime);
	}
	
	if (m_cCurFocus == 5) 
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(383, 297, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(383, 297, 16, dwTime);

	DrawVersion();
	// 마우스 커서 그린다.
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		// 마우스클릭. 
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
			m_cCurFocus = iMIbuttonNum;
			break;
		
		case 4:
			if ( (m_Misc.bCheckValidString(cKeyCode) == FALSE) || (strlen(cKeyCode) == 0) || (strlen(cName)<1) ||
				 (m_Misc.bCheckValidName(cKeyCode) == FALSE) || (m_Misc.bCheckValidName(cKeyCode) == FALSE) || (strlen(cKeyCode) != 17) ) break;

			EndInputString();
			
			// 이름을 초기화한다. 
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			ZeroMemory(m_cKeyCode, sizeof(m_cKeyCode));
			
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			strcpy(m_cKeyCode, cKeyCode);
			
			// 접속을 시도요구가 있으면 로그서버로 소켓을 생성하고 연결을 기다린다. 
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			// 게임모드 변환 
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_INPUTKEYCODE;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "61");
			delete pMI;
			return;

		case 5:
			// Cancel 버튼이 눌렸다.
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	if ((msX >= 197) && (msX <= 256) && (msY >= 296) && (msY <= 321)) m_cCurFocus = 4;
	if ((msX >= 383) && (msX <= 442) && (msY >= 296) && (msY <= 321)) m_cCurFocus = 5;

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}
#endif

void CGame::ReleaseEquipHandler(char cEquipPos)
{
	char cStr1[64], cStr2[64], cStr3[64];
	if( m_sItemEquipmentStatus[cEquipPos] < 0 ) return;
	GetItemName(m_pItemList[m_sItemEquipmentStatus[cEquipPos]], cStr1, cStr2, cStr3);
	wsprintf(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"아이템 %s: 장착 해제 되었습니다."
	AddEventList(G_cTxt, 10);
	m_bIsItemEquipped[m_sItemEquipmentStatus[cEquipPos]] = FALSE;
	m_sItemEquipmentStatus[cEquipPos] = -1;
}

void CGame::ItemEquipHandler(char cItemID)
{
	// 아이템 관련 연산이 가능한 상태인지 판별
	if (bCheckItemOperationEnabled(cItemID) == FALSE) return;
	// 이미 장착하고 있으면 장착할 필요 없다.
	if (m_bIsItemEquipped[cItemID] == TRUE) return;
	// 장착이 불가능한 아이템이라면 무시
	if (m_pItemList[cItemID]->m_cEquipPos == DEF_EQUIPPOS_NONE) {
		AddEventList(BITEMDROP_CHARACTER3, 10);//"장착할 수 없는 아이템입니다." 
		return;
	}
	if ( m_pItemList[cItemID]->m_wCurLifeSpan == 0 ) {
		AddEventList(BITEMDROP_CHARACTER1, 10);//"손상된 아이템입니다. 아이템을 고친 후 사용하십시오."
		return;
	}
	if (m_pItemList[cItemID]->m_wWeight / 100 > m_iStr) {
		AddEventList(BITEMDROP_CHARACTER2, 10);//"너무 무거워서 장착할 수 없습니다."
		return;
	}
	//v1.4334 커스텀아이템 레벨 제한 폐지 // 중문추가 
	if (((m_pItemList[cItemID]->m_dwAttribute & 0x00000001) == 0) && (m_pItemList[cItemID]->m_sLevelLimit > m_iLevel)   ) {
		AddEventList(BITEMDROP_CHARACTER4, 10);//"레벨이 낮아 장착, 사용할 수 없습니다."
		return;
	}
	if (m_bSkillUsingStatus == TRUE) {
		AddEventList(BITEMDROP_CHARACTER5, 10);//"기술 사용중에는 아이템을 장착할 수 없습니다."
		return;
	}
	if (m_pItemList[cItemID]->m_cGenderLimit != 0) {
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			// 남자 캐릭터 이다.
			if (m_pItemList[cItemID]->m_cGenderLimit != 1) {
				AddEventList(BITEMDROP_CHARACTER6, 10);//"남성이 사용할 수 없는 아이템입니다."
				return;
			}
			break;
		case 4:
		case 5:
		case 6:
			// 여자 캐릭터이다.
			if (m_pItemList[cItemID]->m_cGenderLimit != 2) {
				AddEventList(BITEMDROP_CHARACTER7, 10);//"여성이 사용할 수 없는 아이템입니다."
				return;
			}
			break;
		}
	}

	// 서버로 아이템 장착 메시지를 전송한다.
	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_EQUIPITEM, NULL, cItemID, NULL, NULL, NULL); 
	// 숏컷 저장
	m_sRecentShortCut = cItemID;

	//일단 자신의 위치에 있는 아이템은 벗긴다.
	ReleaseEquipHandler(m_pItemList[cItemID]->m_cEquipPos);
	//그밖에도 겹쳐서 벗겨져야 할 아이템을 벗긴다.
	switch( m_pItemList[cItemID]->m_cEquipPos )
	{
	case DEF_EQUIPPOS_HEAD:
	case DEF_EQUIPPOS_BODY:
	case DEF_EQUIPPOS_ARMS:
	case DEF_EQUIPPOS_PANTS:
	case DEF_EQUIPPOS_BOOTS:
	case DEF_EQUIPPOS_BACK:
		ReleaseEquipHandler(DEF_EQUIPPOS_FULLBODY);
		break;
	case DEF_EQUIPPOS_FULLBODY:
		ReleaseEquipHandler(DEF_EQUIPPOS_HEAD);
		ReleaseEquipHandler(DEF_EQUIPPOS_BODY);
		ReleaseEquipHandler(DEF_EQUIPPOS_ARMS);
		ReleaseEquipHandler(DEF_EQUIPPOS_PANTS);
		ReleaseEquipHandler(DEF_EQUIPPOS_BOOTS);
		ReleaseEquipHandler(DEF_EQUIPPOS_BACK);
		break;
	case DEF_EQUIPPOS_LHAND:
	case DEF_EQUIPPOS_RHAND:
		ReleaseEquipHandler(DEF_EQUIPPOS_TWOHAND);
		break;
	case DEF_EQUIPPOS_TWOHAND:
		ReleaseEquipHandler(DEF_EQUIPPOS_RHAND);
		ReleaseEquipHandler(DEF_EQUIPPOS_LHAND);
		break;
	}
	
	// 해당 위치에 할당한다.
	m_sItemEquipmentStatus[ m_pItemList[cItemID]->m_cEquipPos ] = cItemID;
	m_bIsItemEquipped[cItemID] = TRUE;
	
	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
	// 이벤트 리스트에 입력 
	wsprintf(G_cTxt, BITEMDROP_CHARACTER9, cStr1);//"아이템 %s : 장착했습니다."
	AddEventList(G_cTxt, 10);
	PlaySound('E', 28, 0);
}


